# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepBasic')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepBasic')
    _StepBasic = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepBasic', [dirname(__file__)])
        except ImportError:
            import _StepBasic
            return _StepBasic
        try:
            _mod = imp.load_module('_StepBasic', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepBasic = swig_import_helper()
    del swig_import_helper
else:
    import _StepBasic
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepBasic.delete_SwigPyIterator

    def value(self):
        return _StepBasic.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepBasic.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepBasic.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepBasic.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepBasic.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepBasic.SwigPyIterator_copy(self)

    def next(self):
        return _StepBasic.SwigPyIterator_next(self)

    def __next__(self):
        return _StepBasic.SwigPyIterator___next__(self)

    def previous(self):
        return _StepBasic.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepBasic.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepBasic.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepBasic.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepBasic.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepBasic.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepBasic.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepBasic.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepBasic.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepBasic.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepBasic.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepBasic.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepBasic.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepBasic.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepBasic.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepBasic.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepBasic.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepBasic.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepBasic.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepBasic.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepBasic.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepBasic.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepBasic.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepBasic.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepBasic.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepBasic.ptr_to_number(item)
ptr_to_number = _StepBasic.ptr_to_number

def HashCode(*args):
    return _StepBasic.HashCode(*args)
HashCode = _StepBasic.HashCode

def ptr_equal(a, b):
    return _StepBasic.ptr_equal(a, b)
ptr_equal = _StepBasic.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
StepBasic_aobAhead = _StepBasic.StepBasic_aobAhead
StepBasic_aobExact = _StepBasic.StepBasic_aobExact
StepBasic_aobBehind = _StepBasic.StepBasic_aobBehind
StepBasic_sMade = _StepBasic.StepBasic_sMade
StepBasic_sBought = _StepBasic.StepBasic_sBought
StepBasic_sNotKnown = _StepBasic.StepBasic_sNotKnown
StepBasic_spExa = _StepBasic.StepBasic_spExa
StepBasic_spPeta = _StepBasic.StepBasic_spPeta
StepBasic_spTera = _StepBasic.StepBasic_spTera
StepBasic_spGiga = _StepBasic.StepBasic_spGiga
StepBasic_spMega = _StepBasic.StepBasic_spMega
StepBasic_spKilo = _StepBasic.StepBasic_spKilo
StepBasic_spHecto = _StepBasic.StepBasic_spHecto
StepBasic_spDeca = _StepBasic.StepBasic_spDeca
StepBasic_spDeci = _StepBasic.StepBasic_spDeci
StepBasic_spCenti = _StepBasic.StepBasic_spCenti
StepBasic_spMilli = _StepBasic.StepBasic_spMilli
StepBasic_spMicro = _StepBasic.StepBasic_spMicro
StepBasic_spNano = _StepBasic.StepBasic_spNano
StepBasic_spPico = _StepBasic.StepBasic_spPico
StepBasic_spFemto = _StepBasic.StepBasic_spFemto
StepBasic_spAtto = _StepBasic.StepBasic_spAtto
StepBasic_sunMetre = _StepBasic.StepBasic_sunMetre
StepBasic_sunGram = _StepBasic.StepBasic_sunGram
StepBasic_sunSecond = _StepBasic.StepBasic_sunSecond
StepBasic_sunAmpere = _StepBasic.StepBasic_sunAmpere
StepBasic_sunKelvin = _StepBasic.StepBasic_sunKelvin
StepBasic_sunMole = _StepBasic.StepBasic_sunMole
StepBasic_sunCandela = _StepBasic.StepBasic_sunCandela
StepBasic_sunRadian = _StepBasic.StepBasic_sunRadian
StepBasic_sunSteradian = _StepBasic.StepBasic_sunSteradian
StepBasic_sunHertz = _StepBasic.StepBasic_sunHertz
StepBasic_sunNewton = _StepBasic.StepBasic_sunNewton
StepBasic_sunPascal = _StepBasic.StepBasic_sunPascal
StepBasic_sunJoule = _StepBasic.StepBasic_sunJoule
StepBasic_sunWatt = _StepBasic.StepBasic_sunWatt
StepBasic_sunCoulomb = _StepBasic.StepBasic_sunCoulomb
StepBasic_sunVolt = _StepBasic.StepBasic_sunVolt
StepBasic_sunFarad = _StepBasic.StepBasic_sunFarad
StepBasic_sunOhm = _StepBasic.StepBasic_sunOhm
StepBasic_sunSiemens = _StepBasic.StepBasic_sunSiemens
StepBasic_sunWeber = _StepBasic.StepBasic_sunWeber
StepBasic_sunTesla = _StepBasic.StepBasic_sunTesla
StepBasic_sunHenry = _StepBasic.StepBasic_sunHenry
StepBasic_sunDegreeCelsius = _StepBasic.StepBasic_sunDegreeCelsius
StepBasic_sunLumen = _StepBasic.StepBasic_sunLumen
StepBasic_sunLux = _StepBasic.StepBasic_sunLux
StepBasic_sunBecquerel = _StepBasic.StepBasic_sunBecquerel
StepBasic_sunGray = _StepBasic.StepBasic_sunGray
StepBasic_sunSievert = _StepBasic.StepBasic_sunSievert
class StepBasic_NamedUnit(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_NamedUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_NamedUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_NamedUnit self) -> StepBasic_NamedUnit

        Returns a NamedUnit


        """
        this = _StepBasic.new_StepBasic_NamedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_NamedUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.StepBasic_NamedUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(StepBasic_NamedUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.StepBasic_NamedUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(StepBasic_NamedUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.StepBasic_NamedUnit_Dimensions(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_NamedUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_NamedUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_NamedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_NamedUnit
StepBasic_NamedUnit_swigregister = _StepBasic.StepBasic_NamedUnit_swigregister
StepBasic_NamedUnit_swigregister(StepBasic_NamedUnit)

def StepBasic_NamedUnit_get_type_name(*args):
    """
    StepBasic_NamedUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_NamedUnit_get_type_name(*args)

def StepBasic_NamedUnit_get_type_descriptor(*args):
    """
    StepBasic_NamedUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_NamedUnit_get_type_descriptor(*args)

class StepBasic_SiUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnit self) -> StepBasic_SiUnit

        Returns a SiUnit


        """
        this = _StepBasic.new_StepBasic_SiUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnit_Init(self, *args)


    def SetPrefix(self, *args):
        """
        SetPrefix(StepBasic_SiUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.StepBasic_SiUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(StepBasic_SiUnit self)"""
        return _StepBasic.StepBasic_SiUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(StepBasic_SiUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.StepBasic_SiUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(StepBasic_SiUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_SiUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_SiUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_SiUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(StepBasic_SiUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.StepBasic_SiUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(StepBasic_SiUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.StepBasic_SiUnit_Dimensions(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnit
StepBasic_SiUnit_swigregister = _StepBasic.StepBasic_SiUnit_swigregister
StepBasic_SiUnit_swigregister(StepBasic_SiUnit)

def StepBasic_SiUnit_get_type_name(*args):
    """
    StepBasic_SiUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnit_get_type_name(*args)

def StepBasic_SiUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnit_get_type_descriptor(*args)

class StepBasic_ApplicationContextElement(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApplicationContextElement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApplicationContextElement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApplicationContextElement self) -> StepBasic_ApplicationContextElement

        Returns a ApplicationContextElement


        """
        this = _StepBasic.new_StepBasic_ApplicationContextElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApplicationContextElement self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.StepBasic_ApplicationContextElement_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ApplicationContextElement self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationContextElement_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ApplicationContextElement self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationContextElement_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(StepBasic_ApplicationContextElement self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.StepBasic_ApplicationContextElement_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(StepBasic_ApplicationContextElement self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.StepBasic_ApplicationContextElement_FrameOfReference(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApplicationContextElement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApplicationContextElement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApplicationContextElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApplicationContextElement
StepBasic_ApplicationContextElement_swigregister = _StepBasic.StepBasic_ApplicationContextElement_swigregister
StepBasic_ApplicationContextElement_swigregister(StepBasic_ApplicationContextElement)

def StepBasic_ApplicationContextElement_get_type_name(*args):
    """
    StepBasic_ApplicationContextElement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApplicationContextElement_get_type_name(*args)

def StepBasic_ApplicationContextElement_get_type_descriptor(*args):
    """
    StepBasic_ApplicationContextElement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApplicationContextElement_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnit self) -> StepBasic_ConversionBasedUnit

        Returns a ConversionBasedUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ConversionBasedUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ConversionBasedUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(StepBasic_ConversionBasedUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(StepBasic_ConversionBasedUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_ConversionFactor(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnit
StepBasic_ConversionBasedUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnit_swigregister
StepBasic_ConversionBasedUnit_swigregister(StepBasic_ConversionBasedUnit)

def StepBasic_ConversionBasedUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnit_get_type_descriptor(*args)

class StepBasic_MeasureWithUnit(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_MeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_MeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_MeasureWithUnit self) -> StepBasic_MeasureWithUnit

        Returns a MeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_MeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_MeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.StepBasic_MeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(StepBasic_MeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.StepBasic_MeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(StepBasic_MeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_MeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(StepBasic_MeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.StepBasic_MeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(StepBasic_MeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.StepBasic_MeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(StepBasic_MeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.StepBasic_MeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(StepBasic_MeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.StepBasic_MeasureWithUnit_UnitComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_MeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_MeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_MeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_MeasureWithUnit
StepBasic_MeasureWithUnit_swigregister = _StepBasic.StepBasic_MeasureWithUnit_swigregister
StepBasic_MeasureWithUnit_swigregister(StepBasic_MeasureWithUnit)

def StepBasic_MeasureWithUnit_get_type_name(*args):
    """
    StepBasic_MeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_MeasureWithUnit_get_type_name(*args)

def StepBasic_MeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_MeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_MeasureWithUnit_get_type_descriptor(*args)

class StepBasic_ProductDefinitionFormation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionFormation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionFormation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionFormation self) -> StepBasic_ProductDefinitionFormation

        Returns a ProductDefinitionFormation


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionFormation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionFormation self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Product aOfProduct)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_ProductDefinitionFormation self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_SetId(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_ProductDefinitionFormation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ProductDefinitionFormation self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ProductDefinitionFormation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_Description(self, *args)


    def SetOfProduct(self, *args):
        """
        SetOfProduct(StepBasic_ProductDefinitionFormation self, Handle_StepBasic_Product aOfProduct)

        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_SetOfProduct(self, *args)


    def OfProduct(self, *args):
        """
        OfProduct(StepBasic_ProductDefinitionFormation self) -> Handle_StepBasic_Product

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_OfProduct(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionFormation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionFormation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionFormation
StepBasic_ProductDefinitionFormation_swigregister = _StepBasic.StepBasic_ProductDefinitionFormation_swigregister
StepBasic_ProductDefinitionFormation_swigregister(StepBasic_ProductDefinitionFormation)

def StepBasic_ProductDefinitionFormation_get_type_name(*args):
    """
    StepBasic_ProductDefinitionFormation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionFormation_get_type_name(*args)

def StepBasic_ProductDefinitionFormation_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionFormation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionFormation_get_type_descriptor(*args)

class StepBasic_ProductCategory(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductCategory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductCategory(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductCategory self) -> StepBasic_ProductCategory

        Returns a ProductCategory


        """
        this = _StepBasic.new_StepBasic_ProductCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductCategory self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasAdescription, Handle_TCollection_HAsciiString aDescription)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAdescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategory_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ProductCategory self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategory_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ProductCategory self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategory_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ProductCategory self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategory_SetDescription(self, *args)


    def UnSetDescription(self, *args):
        """UnSetDescription(StepBasic_ProductCategory self)"""
        return _StepBasic.StepBasic_ProductCategory_UnSetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ProductCategory self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategory_Description(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_ProductCategory self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_ProductCategory_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductCategory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductCategory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductCategory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductCategory
StepBasic_ProductCategory_swigregister = _StepBasic.StepBasic_ProductCategory_swigregister
StepBasic_ProductCategory_swigregister(StepBasic_ProductCategory)

def StepBasic_ProductCategory_get_type_name(*args):
    """
    StepBasic_ProductCategory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductCategory_get_type_name(*args)

def StepBasic_ProductCategory_get_type_descriptor(*args):
    """
    StepBasic_ProductCategory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductCategory_get_type_descriptor(*args)

class StepBasic_Date(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Date
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Date(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Date self) -> StepBasic_Date

        Returns a Date


        """
        this = _StepBasic.new_StepBasic_Date(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Date self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.StepBasic_Date_Init(self, *args)


    def SetYearComponent(self, *args):
        """
        SetYearComponent(StepBasic_Date self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.StepBasic_Date_SetYearComponent(self, *args)


    def YearComponent(self, *args):
        """
        YearComponent(StepBasic_Date self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_Date_YearComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Date_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Date_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Date_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Date
StepBasic_Date_swigregister = _StepBasic.StepBasic_Date_swigregister
StepBasic_Date_swigregister(StepBasic_Date)

def StepBasic_Date_get_type_name(*args):
    """
    StepBasic_Date_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Date_get_type_name(*args)

def StepBasic_Date_get_type_descriptor(*args):
    """
    StepBasic_Date_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Date_get_type_descriptor(*args)

class StepBasic_ProductDefinition(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinition self) -> StepBasic_ProductDefinition

        Returns a ProductDefinition


        """
        this = _StepBasic.new_StepBasic_ProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinition self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aFormation, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.StepBasic_ProductDefinition_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_ProductDefinition self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinition_SetId(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_ProductDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinition_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ProductDefinition self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinition_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ProductDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinition_Description(self, *args)


    def SetFormation(self, *args):
        """
        SetFormation(StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinitionFormation aFormation)

        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinition_SetFormation(self, *args)


    def Formation(self, *args):
        """
        Formation(StepBasic_ProductDefinition self) -> Handle_StepBasic_ProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinition_Formation(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.StepBasic_ProductDefinition_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(StepBasic_ProductDefinition self) -> Handle_StepBasic_ProductDefinitionContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.StepBasic_ProductDefinition_FrameOfReference(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinition
StepBasic_ProductDefinition_swigregister = _StepBasic.StepBasic_ProductDefinition_swigregister
StepBasic_ProductDefinition_swigregister(StepBasic_ProductDefinition)

def StepBasic_ProductDefinition_get_type_name(*args):
    """
    StepBasic_ProductDefinition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinition_get_type_name(*args)

def StepBasic_ProductDefinition_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinition_get_type_descriptor(*args)

class StepBasic_SiUnitAndLengthUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndLengthUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndLengthUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndLengthUnit self) -> StepBasic_SiUnitAndLengthUnit

        Returns a SiUnitAndLengthUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndLengthUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndLengthUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndLengthUnit_Init(self, *args)


    def SetLengthUnit(self, *args):
        """
        SetLengthUnit(StepBasic_SiUnitAndLengthUnit self, Handle_StepBasic_LengthUnit aLengthUnit)

        :type aLengthUnit: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.StepBasic_SiUnitAndLengthUnit_SetLengthUnit(self, *args)


    def LengthUnit(self, *args):
        """
        LengthUnit(StepBasic_SiUnitAndLengthUnit self) -> Handle_StepBasic_LengthUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.StepBasic_SiUnitAndLengthUnit_LengthUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndLengthUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndLengthUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndLengthUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndLengthUnit
StepBasic_SiUnitAndLengthUnit_swigregister = _StepBasic.StepBasic_SiUnitAndLengthUnit_swigregister
StepBasic_SiUnitAndLengthUnit_swigregister(StepBasic_SiUnitAndLengthUnit)

def StepBasic_SiUnitAndLengthUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndLengthUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndLengthUnit_get_type_name(*args)

def StepBasic_SiUnitAndLengthUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndLengthUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndLengthUnit_get_type_descriptor(*args)

class StepBasic_SecurityClassificationLevel(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SecurityClassificationLevel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SecurityClassificationLevel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SecurityClassificationLevel self) -> StepBasic_SecurityClassificationLevel

        Returns a SecurityClassificationLevel


        """
        this = _StepBasic.new_StepBasic_SecurityClassificationLevel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SecurityClassificationLevel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassificationLevel_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_SecurityClassificationLevel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassificationLevel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_SecurityClassificationLevel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassificationLevel_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SecurityClassificationLevel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SecurityClassificationLevel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SecurityClassificationLevel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SecurityClassificationLevel
StepBasic_SecurityClassificationLevel_swigregister = _StepBasic.StepBasic_SecurityClassificationLevel_swigregister
StepBasic_SecurityClassificationLevel_swigregister(StepBasic_SecurityClassificationLevel)

def StepBasic_SecurityClassificationLevel_get_type_name(*args):
    """
    StepBasic_SecurityClassificationLevel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SecurityClassificationLevel_get_type_name(*args)

def StepBasic_SecurityClassificationLevel_get_type_descriptor(*args):
    """
    StepBasic_SecurityClassificationLevel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SecurityClassificationLevel_get_type_descriptor(*args)

class StepBasic_ProductRelatedProductCategory(StepBasic_ProductCategory):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductRelatedProductCategory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductRelatedProductCategory(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductRelatedProductCategory self) -> StepBasic_ProductRelatedProductCategory

        Returns a ProductRelatedProductCategory


        """
        this = _StepBasic.new_StepBasic_ProductRelatedProductCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductRelatedProductCategory self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasAdescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_HArray1OfProduct aProducts)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAdescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aProducts: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_Init(self, *args)


    def SetProducts(self, *args):
        """
        SetProducts(StepBasic_ProductRelatedProductCategory self, Handle_StepBasic_HArray1OfProduct aProducts)

        :type aProducts: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_SetProducts(self, *args)


    def Products(self, *args):
        """
        Products(StepBasic_ProductRelatedProductCategory self) -> Handle_StepBasic_HArray1OfProduct

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_Products(self, *args)


    def ProductsValue(self, *args):
        """
        ProductsValue(StepBasic_ProductRelatedProductCategory self, Standard_Integer const num) -> Handle_StepBasic_Product

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_ProductsValue(self, *args)


    def NbProducts(self, *args):
        """
        NbProducts(StepBasic_ProductRelatedProductCategory self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_NbProducts(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductRelatedProductCategory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductRelatedProductCategory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductRelatedProductCategory
StepBasic_ProductRelatedProductCategory_swigregister = _StepBasic.StepBasic_ProductRelatedProductCategory_swigregister
StepBasic_ProductRelatedProductCategory_swigregister(StepBasic_ProductRelatedProductCategory)

def StepBasic_ProductRelatedProductCategory_get_type_name(*args):
    """
    StepBasic_ProductRelatedProductCategory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductRelatedProductCategory_get_type_name(*args)

def StepBasic_ProductRelatedProductCategory_get_type_descriptor(*args):
    """
    StepBasic_ProductRelatedProductCategory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductRelatedProductCategory_get_type_descriptor(*args)

class StepBasic_DocumentProductAssociation(Standard.Standard_Transient):
    """Representation of STEP entity DocumentProductAssociation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentProductAssociation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentProductAssociation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DocumentProductAssociation self) -> StepBasic_DocumentProductAssociation

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_DocumentProductAssociation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DocumentProductAssociation self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Document aRelatingDocument, StepBasic_ProductOrFormationOrDefinition aRelatedProduct)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aRelatedProduct: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_DocumentProductAssociation self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_DocumentProductAssociation self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_DocumentProductAssociation self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_DocumentProductAssociation self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_DocumentProductAssociation self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_HasDescription(self, *args)


    def RelatingDocument(self, *args):
        """
        RelatingDocument(StepBasic_DocumentProductAssociation self) -> Handle_StepBasic_Document

        Returns field RelatingDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_RelatingDocument(self, *args)


    def SetRelatingDocument(self, *args):
        """
        SetRelatingDocument(StepBasic_DocumentProductAssociation self, Handle_StepBasic_Document RelatingDocument)

        Set field RelatingDocument

        :type RelatingDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_SetRelatingDocument(self, *args)


    def RelatedProduct(self, *args):
        """
        RelatedProduct(StepBasic_DocumentProductAssociation self) -> StepBasic_ProductOrFormationOrDefinition

        Returns field RelatedProduct

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_RelatedProduct(self, *args)


    def SetRelatedProduct(self, *args):
        """
        SetRelatedProduct(StepBasic_DocumentProductAssociation self, StepBasic_ProductOrFormationOrDefinition RelatedProduct)

        Set field RelatedProduct

        :type RelatedProduct: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_SetRelatedProduct(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentProductAssociation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentProductAssociation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentProductAssociation
StepBasic_DocumentProductAssociation_swigregister = _StepBasic.StepBasic_DocumentProductAssociation_swigregister
StepBasic_DocumentProductAssociation_swigregister(StepBasic_DocumentProductAssociation)

def StepBasic_DocumentProductAssociation_get_type_name(*args):
    """
    StepBasic_DocumentProductAssociation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentProductAssociation_get_type_name(*args)

def StepBasic_DocumentProductAssociation_get_type_descriptor(*args):
    """
    StepBasic_DocumentProductAssociation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentProductAssociation_get_type_descriptor(*args)

class StepBasic_Address(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Address
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Address(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Address self) -> StepBasic_Address

        Returns a Address


        """
        this = _StepBasic.new_StepBasic_Address(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Address self, Standard_Boolean const hasAinternalLocation, Handle_TCollection_HAsciiString aInternalLocation, Standard_Boolean const hasAstreetNumber, Handle_TCollection_HAsciiString aStreetNumber, Standard_Boolean const hasAstreet, Handle_TCollection_HAsciiString aStreet, Standard_Boolean const hasApostalBox, Handle_TCollection_HAsciiString aPostalBox, Standard_Boolean const hasAtown, Handle_TCollection_HAsciiString aTown, Standard_Boolean const hasAregion, Handle_TCollection_HAsciiString aRegion, Standard_Boolean const hasApostalCode, Handle_TCollection_HAsciiString aPostalCode, Standard_Boolean const hasAcountry, Handle_TCollection_HAsciiString aCountry, Standard_Boolean const hasAfacsimileNumber, Handle_TCollection_HAsciiString aFacsimileNumber, Standard_Boolean const hasAtelephoneNumber, Handle_TCollection_HAsciiString aTelephoneNumber, Standard_Boolean const hasAelectronicMailAddress, Handle_TCollection_HAsciiString aElectronicMailAddress, Standard_Boolean const hasAtelexNumber, Handle_TCollection_HAsciiString aTelexNumber)

        :type hasAinternalLocation: bool
        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreetNumber: bool
        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreet: bool
        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalBox: bool
        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtown: bool
        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAregion: bool
        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalCode: bool
        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAcountry: bool
        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfacsimileNumber: bool
        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelephoneNumber: bool
        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAelectronicMailAddress: bool
        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelexNumber: bool
        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_Init(self, *args)


    def SetInternalLocation(self, *args):
        """
        SetInternalLocation(StepBasic_Address self, Handle_TCollection_HAsciiString aInternalLocation)

        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetInternalLocation(self, *args)


    def UnSetInternalLocation(self, *args):
        """UnSetInternalLocation(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetInternalLocation(self, *args)


    def InternalLocation(self, *args):
        """
        InternalLocation(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_InternalLocation(self, *args)


    def HasInternalLocation(self, *args):
        """
        HasInternalLocation(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasInternalLocation(self, *args)


    def SetStreetNumber(self, *args):
        """
        SetStreetNumber(StepBasic_Address self, Handle_TCollection_HAsciiString aStreetNumber)

        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetStreetNumber(self, *args)


    def UnSetStreetNumber(self, *args):
        """UnSetStreetNumber(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetStreetNumber(self, *args)


    def StreetNumber(self, *args):
        """
        StreetNumber(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_StreetNumber(self, *args)


    def HasStreetNumber(self, *args):
        """
        HasStreetNumber(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasStreetNumber(self, *args)


    def SetStreet(self, *args):
        """
        SetStreet(StepBasic_Address self, Handle_TCollection_HAsciiString aStreet)

        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetStreet(self, *args)


    def UnSetStreet(self, *args):
        """UnSetStreet(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetStreet(self, *args)


    def Street(self, *args):
        """
        Street(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_Street(self, *args)


    def HasStreet(self, *args):
        """
        HasStreet(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasStreet(self, *args)


    def SetPostalBox(self, *args):
        """
        SetPostalBox(StepBasic_Address self, Handle_TCollection_HAsciiString aPostalBox)

        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetPostalBox(self, *args)


    def UnSetPostalBox(self, *args):
        """UnSetPostalBox(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetPostalBox(self, *args)


    def PostalBox(self, *args):
        """
        PostalBox(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_PostalBox(self, *args)


    def HasPostalBox(self, *args):
        """
        HasPostalBox(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasPostalBox(self, *args)


    def SetTown(self, *args):
        """
        SetTown(StepBasic_Address self, Handle_TCollection_HAsciiString aTown)

        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetTown(self, *args)


    def UnSetTown(self, *args):
        """UnSetTown(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetTown(self, *args)


    def Town(self, *args):
        """
        Town(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_Town(self, *args)


    def HasTown(self, *args):
        """
        HasTown(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasTown(self, *args)


    def SetRegion(self, *args):
        """
        SetRegion(StepBasic_Address self, Handle_TCollection_HAsciiString aRegion)

        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetRegion(self, *args)


    def UnSetRegion(self, *args):
        """UnSetRegion(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetRegion(self, *args)


    def Region(self, *args):
        """
        Region(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_Region(self, *args)


    def HasRegion(self, *args):
        """
        HasRegion(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasRegion(self, *args)


    def SetPostalCode(self, *args):
        """
        SetPostalCode(StepBasic_Address self, Handle_TCollection_HAsciiString aPostalCode)

        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetPostalCode(self, *args)


    def UnSetPostalCode(self, *args):
        """UnSetPostalCode(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetPostalCode(self, *args)


    def PostalCode(self, *args):
        """
        PostalCode(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_PostalCode(self, *args)


    def HasPostalCode(self, *args):
        """
        HasPostalCode(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasPostalCode(self, *args)


    def SetCountry(self, *args):
        """
        SetCountry(StepBasic_Address self, Handle_TCollection_HAsciiString aCountry)

        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetCountry(self, *args)


    def UnSetCountry(self, *args):
        """UnSetCountry(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetCountry(self, *args)


    def Country(self, *args):
        """
        Country(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_Country(self, *args)


    def HasCountry(self, *args):
        """
        HasCountry(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasCountry(self, *args)


    def SetFacsimileNumber(self, *args):
        """
        SetFacsimileNumber(StepBasic_Address self, Handle_TCollection_HAsciiString aFacsimileNumber)

        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetFacsimileNumber(self, *args)


    def UnSetFacsimileNumber(self, *args):
        """UnSetFacsimileNumber(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetFacsimileNumber(self, *args)


    def FacsimileNumber(self, *args):
        """
        FacsimileNumber(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_FacsimileNumber(self, *args)


    def HasFacsimileNumber(self, *args):
        """
        HasFacsimileNumber(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasFacsimileNumber(self, *args)


    def SetTelephoneNumber(self, *args):
        """
        SetTelephoneNumber(StepBasic_Address self, Handle_TCollection_HAsciiString aTelephoneNumber)

        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetTelephoneNumber(self, *args)


    def UnSetTelephoneNumber(self, *args):
        """UnSetTelephoneNumber(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetTelephoneNumber(self, *args)


    def TelephoneNumber(self, *args):
        """
        TelephoneNumber(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_TelephoneNumber(self, *args)


    def HasTelephoneNumber(self, *args):
        """
        HasTelephoneNumber(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasTelephoneNumber(self, *args)


    def SetElectronicMailAddress(self, *args):
        """
        SetElectronicMailAddress(StepBasic_Address self, Handle_TCollection_HAsciiString aElectronicMailAddress)

        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetElectronicMailAddress(self, *args)


    def UnSetElectronicMailAddress(self, *args):
        """UnSetElectronicMailAddress(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetElectronicMailAddress(self, *args)


    def ElectronicMailAddress(self, *args):
        """
        ElectronicMailAddress(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_ElectronicMailAddress(self, *args)


    def HasElectronicMailAddress(self, *args):
        """
        HasElectronicMailAddress(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasElectronicMailAddress(self, *args)


    def SetTelexNumber(self, *args):
        """
        SetTelexNumber(StepBasic_Address self, Handle_TCollection_HAsciiString aTelexNumber)

        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_SetTelexNumber(self, *args)


    def UnSetTelexNumber(self, *args):
        """UnSetTelexNumber(StepBasic_Address self)"""
        return _StepBasic.StepBasic_Address_UnSetTelexNumber(self, *args)


    def TelexNumber(self, *args):
        """
        TelexNumber(StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Address_TelexNumber(self, *args)


    def HasTelexNumber(self, *args):
        """
        HasTelexNumber(StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Address_HasTelexNumber(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Address_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Address_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Address_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Address
StepBasic_Address_swigregister = _StepBasic.StepBasic_Address_swigregister
StepBasic_Address_swigregister(StepBasic_Address)

def StepBasic_Address_get_type_name(*args):
    """
    StepBasic_Address_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Address_get_type_name(*args)

def StepBasic_Address_get_type_descriptor(*args):
    """
    StepBasic_Address_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Address_get_type_descriptor(*args)

class StepBasic_PlaneAngleUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PlaneAngleUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PlaneAngleUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_PlaneAngleUnit self) -> StepBasic_PlaneAngleUnit

        Returns a PlaneAngleUnit


        """
        this = _StepBasic.new_StepBasic_PlaneAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PlaneAngleUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PlaneAngleUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PlaneAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_PlaneAngleUnit
StepBasic_PlaneAngleUnit_swigregister = _StepBasic.StepBasic_PlaneAngleUnit_swigregister
StepBasic_PlaneAngleUnit_swigregister(StepBasic_PlaneAngleUnit)

def StepBasic_PlaneAngleUnit_get_type_name(*args):
    """
    StepBasic_PlaneAngleUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PlaneAngleUnit_get_type_name(*args)

def StepBasic_PlaneAngleUnit_get_type_descriptor(*args):
    """
    StepBasic_PlaneAngleUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PlaneAngleUnit_get_type_descriptor(*args)

class StepBasic_ProductContext(StepBasic_ApplicationContextElement):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductContext self) -> StepBasic_ProductContext

        Returns a ProductContext


        """
        this = _StepBasic.new_StepBasic_ProductContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductContext self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference, Handle_TCollection_HAsciiString aDisciplineType)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aDisciplineType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductContext_Init(self, *args)


    def SetDisciplineType(self, *args):
        """
        SetDisciplineType(StepBasic_ProductContext self, Handle_TCollection_HAsciiString aDisciplineType)

        :type aDisciplineType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductContext_SetDisciplineType(self, *args)


    def DisciplineType(self, *args):
        """
        DisciplineType(StepBasic_ProductContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductContext_DisciplineType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductContext
StepBasic_ProductContext_swigregister = _StepBasic.StepBasic_ProductContext_swigregister
StepBasic_ProductContext_swigregister(StepBasic_ProductContext)

def StepBasic_ProductContext_get_type_name(*args):
    """
    StepBasic_ProductContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductContext_get_type_name(*args)

def StepBasic_ProductContext_get_type_descriptor(*args):
    """
    StepBasic_ProductContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductContext_get_type_descriptor(*args)

class StepBasic_ExternalSource(Standard.Standard_Transient):
    """Representation of STEP entity ExternalSource"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ExternalSource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ExternalSource(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ExternalSource self) -> StepBasic_ExternalSource

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ExternalSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ExternalSource self, StepBasic_SourceItem aSourceId)

        Initialize all fields (own and inherited)

        :type aSourceId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.StepBasic_ExternalSource_Init(self, *args)


    def SourceId(self, *args):
        """
        SourceId(StepBasic_ExternalSource self) -> StepBasic_SourceItem

        Returns field SourceId

        :rtype: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.StepBasic_ExternalSource_SourceId(self, *args)


    def SetSourceId(self, *args):
        """
        SetSourceId(StepBasic_ExternalSource self, StepBasic_SourceItem SourceId)

        Set field SourceId

        :type SourceId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.StepBasic_ExternalSource_SetSourceId(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ExternalSource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ExternalSource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ExternalSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ExternalSource
StepBasic_ExternalSource_swigregister = _StepBasic.StepBasic_ExternalSource_swigregister
StepBasic_ExternalSource_swigregister(StepBasic_ExternalSource)

def StepBasic_ExternalSource_get_type_name(*args):
    """
    StepBasic_ExternalSource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ExternalSource_get_type_name(*args)

def StepBasic_ExternalSource_get_type_descriptor(*args):
    """
    StepBasic_ExternalSource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ExternalSource_get_type_descriptor(*args)

class StepBasic_ActionRequestSolution(Standard.Standard_Transient):
    """Representation of STEP entity ActionRequestSolution"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ActionRequestSolution
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ActionRequestSolution(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ActionRequestSolution self) -> StepBasic_ActionRequestSolution

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ActionRequestSolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ActionRequestSolution self, Handle_StepBasic_ActionMethod aMethod, Handle_StepBasic_VersionedActionRequest aRequest)

        Initialize all fields (own and inherited)

        :type aMethod: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod
        :type aRequest: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.StepBasic_ActionRequestSolution_Init(self, *args)


    def Method(self, *args):
        """
        Method(StepBasic_ActionRequestSolution self) -> Handle_StepBasic_ActionMethod

        Returns field Method

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.StepBasic_ActionRequestSolution_Method(self, *args)


    def SetMethod(self, *args):
        """
        SetMethod(StepBasic_ActionRequestSolution self, Handle_StepBasic_ActionMethod Method)

        Set field Method

        :type Method: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.StepBasic_ActionRequestSolution_SetMethod(self, *args)


    def Request(self, *args):
        """
        Request(StepBasic_ActionRequestSolution self) -> Handle_StepBasic_VersionedActionRequest

        Returns field Request

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.StepBasic_ActionRequestSolution_Request(self, *args)


    def SetRequest(self, *args):
        """
        SetRequest(StepBasic_ActionRequestSolution self, Handle_StepBasic_VersionedActionRequest Request)

        Set field Request

        :type Request: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.StepBasic_ActionRequestSolution_SetRequest(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ActionRequestSolution_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ActionRequestSolution_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ActionRequestSolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ActionRequestSolution
StepBasic_ActionRequestSolution_swigregister = _StepBasic.StepBasic_ActionRequestSolution_swigregister
StepBasic_ActionRequestSolution_swigregister(StepBasic_ActionRequestSolution)

def StepBasic_ActionRequestSolution_get_type_name(*args):
    """
    StepBasic_ActionRequestSolution_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ActionRequestSolution_get_type_name(*args)

def StepBasic_ActionRequestSolution_get_type_descriptor(*args):
    """
    StepBasic_ActionRequestSolution_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ActionRequestSolution_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnitAndTimeUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndTimeUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndTimeUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndTimeUnit self) -> StepBasic_ConversionBasedUnitAndTimeUnit

        Returns a ConversionBasedUnitAndTimeUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndTimeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_Init(self, *args)


    def SetTimeUnit(self, *args):
        """
        SetTimeUnit(StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_TimeUnit aTimeUnit)

        :type aTimeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_SetTimeUnit(self, *args)


    def TimeUnit(self, *args):
        """
        TimeUnit(StepBasic_ConversionBasedUnitAndTimeUnit self) -> Handle_StepBasic_TimeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_TimeUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndTimeUnit
StepBasic_ConversionBasedUnitAndTimeUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_swigregister
StepBasic_ConversionBasedUnitAndTimeUnit_swigregister(StepBasic_ConversionBasedUnitAndTimeUnit)

def StepBasic_ConversionBasedUnitAndTimeUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndTimeUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndTimeUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndTimeUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndTimeUnit_get_type_descriptor(*args)

class StepBasic_Product(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Product
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Product(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Product self) -> StepBasic_Product

        Returns a Product


        """
        this = _StepBasic.new_StepBasic_Product(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Product self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_HArray1OfProductContext aFrameOfReference)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProductContext

        """
        return _StepBasic.StepBasic_Product_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_Product self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Product_SetId(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_Product self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Product_Id(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Product self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Product_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Product self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Product_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_Product self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Product_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_Product self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Product_Description(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(StepBasic_Product self, Handle_StepBasic_HArray1OfProductContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProductContext

        """
        return _StepBasic.StepBasic_Product_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(StepBasic_Product self) -> Handle_StepBasic_HArray1OfProductContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProductContext

        """
        return _StepBasic.StepBasic_Product_FrameOfReference(self, *args)


    def FrameOfReferenceValue(self, *args):
        """
        FrameOfReferenceValue(StepBasic_Product self, Standard_Integer const num) -> Handle_StepBasic_ProductContext

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductContext

        """
        return _StepBasic.StepBasic_Product_FrameOfReferenceValue(self, *args)


    def NbFrameOfReference(self, *args):
        """
        NbFrameOfReference(StepBasic_Product self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_Product_NbFrameOfReference(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Product_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Product_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Product_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Product
StepBasic_Product_swigregister = _StepBasic.StepBasic_Product_swigregister
StepBasic_Product_swigregister(StepBasic_Product)

def StepBasic_Product_get_type_name(*args):
    """
    StepBasic_Product_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Product_get_type_name(*args)

def StepBasic_Product_get_type_descriptor(*args):
    """
    StepBasic_Product_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Product_get_type_descriptor(*args)

class StepBasic_ObjectRole(Standard.Standard_Transient):
    """Representation of STEP entity ObjectRole"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ObjectRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ObjectRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ObjectRole self) -> StepBasic_ObjectRole

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ObjectRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ObjectRole self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ObjectRole_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ObjectRole self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ObjectRole_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ObjectRole self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ObjectRole_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ObjectRole self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ObjectRole_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ObjectRole self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ObjectRole_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_ObjectRole self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_ObjectRole_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ObjectRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ObjectRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ObjectRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ObjectRole
StepBasic_ObjectRole_swigregister = _StepBasic.StepBasic_ObjectRole_swigregister
StepBasic_ObjectRole_swigregister(StepBasic_ObjectRole)

def StepBasic_ObjectRole_get_type_name(*args):
    """
    StepBasic_ObjectRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ObjectRole_get_type_name(*args)

def StepBasic_ObjectRole_get_type_descriptor(*args):
    """
    StepBasic_ObjectRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ObjectRole_get_type_descriptor(*args)

class StepBasic_RoleAssociation(Standard.Standard_Transient):
    """Representation of STEP entity RoleAssociation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_RoleAssociation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_RoleAssociation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_RoleAssociation self) -> StepBasic_RoleAssociation

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_RoleAssociation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_RoleAssociation self, Handle_StepBasic_ObjectRole aRole, StepBasic_RoleSelect aItemWithRole)

        Initialize all fields (own and inherited)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_ObjectRole
        :type aItemWithRole: OCC.wrapper.StepBasic.StepBasic_RoleSelect

        """
        return _StepBasic.StepBasic_RoleAssociation_Init(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_RoleAssociation self) -> Handle_StepBasic_ObjectRole

        Returns field Role

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ObjectRole

        """
        return _StepBasic.StepBasic_RoleAssociation_Role(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_RoleAssociation self, Handle_StepBasic_ObjectRole Role)

        Set field Role

        :type Role: OCC.wrapper.StepBasic.Handle_StepBasic_ObjectRole

        """
        return _StepBasic.StepBasic_RoleAssociation_SetRole(self, *args)


    def ItemWithRole(self, *args):
        """
        ItemWithRole(StepBasic_RoleAssociation self) -> StepBasic_RoleSelect

        Returns field ItemWithRole

        :rtype: OCC.wrapper.StepBasic.StepBasic_RoleSelect

        """
        return _StepBasic.StepBasic_RoleAssociation_ItemWithRole(self, *args)


    def SetItemWithRole(self, *args):
        """
        SetItemWithRole(StepBasic_RoleAssociation self, StepBasic_RoleSelect ItemWithRole)

        Set field ItemWithRole

        :type ItemWithRole: OCC.wrapper.StepBasic.StepBasic_RoleSelect

        """
        return _StepBasic.StepBasic_RoleAssociation_SetItemWithRole(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_RoleAssociation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_RoleAssociation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_RoleAssociation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_RoleAssociation
StepBasic_RoleAssociation_swigregister = _StepBasic.StepBasic_RoleAssociation_swigregister
StepBasic_RoleAssociation_swigregister(StepBasic_RoleAssociation)

def StepBasic_RoleAssociation_get_type_name(*args):
    """
    StepBasic_RoleAssociation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_RoleAssociation_get_type_name(*args)

def StepBasic_RoleAssociation_get_type_descriptor(*args):
    """
    StepBasic_RoleAssociation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_RoleAssociation_get_type_descriptor(*args)

class StepBasic_ApprovalDateTime(Standard.Standard_Transient):
    """Added from StepBasic Rev2 to Rev4"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApprovalDateTime
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApprovalDateTime(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApprovalDateTime self) -> StepBasic_ApprovalDateTime

        Added from StepBasic Rev2 to Rev4
        """
        this = _StepBasic.new_StepBasic_ApprovalDateTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApprovalDateTime self, StepBasic_DateTimeSelect aDateTime, Handle_StepBasic_Approval aDatedApproval)

        :type aDateTime: OCC.wrapper.StepBasic.StepBasic_DateTimeSelect
        :type aDatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalDateTime_Init(self, *args)


    def SetDateTime(self, *args):
        """
        SetDateTime(StepBasic_ApprovalDateTime self, StepBasic_DateTimeSelect aDateTime)

        :type aDateTime: OCC.wrapper.StepBasic.StepBasic_DateTimeSelect

        """
        return _StepBasic.StepBasic_ApprovalDateTime_SetDateTime(self, *args)


    def DateTime(self, *args):
        """
        DateTime(StepBasic_ApprovalDateTime self) -> StepBasic_DateTimeSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_DateTimeSelect

        """
        return _StepBasic.StepBasic_ApprovalDateTime_DateTime(self, *args)


    def SetDatedApproval(self, *args):
        """
        SetDatedApproval(StepBasic_ApprovalDateTime self, Handle_StepBasic_Approval aDatedApproval)

        :type aDatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalDateTime_SetDatedApproval(self, *args)


    def DatedApproval(self, *args):
        """
        DatedApproval(StepBasic_ApprovalDateTime self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalDateTime_DatedApproval(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApprovalDateTime_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApprovalDateTime_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApprovalDateTime_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApprovalDateTime
StepBasic_ApprovalDateTime_swigregister = _StepBasic.StepBasic_ApprovalDateTime_swigregister
StepBasic_ApprovalDateTime_swigregister(StepBasic_ApprovalDateTime)

def StepBasic_ApprovalDateTime_get_type_name(*args):
    """
    StepBasic_ApprovalDateTime_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApprovalDateTime_get_type_name(*args)

def StepBasic_ApprovalDateTime_get_type_descriptor(*args):
    """
    StepBasic_ApprovalDateTime_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApprovalDateTime_get_type_descriptor(*args)

class StepBasic_LengthUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_LengthUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_LengthUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_LengthUnit self) -> StepBasic_LengthUnit

        Returns a LengthUnit


        """
        this = _StepBasic.new_StepBasic_LengthUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_LengthUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_LengthUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_LengthUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_LengthUnit
StepBasic_LengthUnit_swigregister = _StepBasic.StepBasic_LengthUnit_swigregister
StepBasic_LengthUnit_swigregister(StepBasic_LengthUnit)

def StepBasic_LengthUnit_get_type_name(*args):
    """
    StepBasic_LengthUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_LengthUnit_get_type_name(*args)

def StepBasic_LengthUnit_get_type_descriptor(*args):
    """
    StepBasic_LengthUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_LengthUnit_get_type_descriptor(*args)

class StepBasic_DocumentType(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentType(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_DocumentType self) -> StepBasic_DocumentType"""
        this = _StepBasic.new_StepBasic_DocumentType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DocumentType self, Handle_TCollection_HAsciiString apdt)

        :type apdt: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentType_Init(self, *args)


    def ProductDataType(self, *args):
        """
        ProductDataType(StepBasic_DocumentType self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentType_ProductDataType(self, *args)


    def SetProductDataType(self, *args):
        """
        SetProductDataType(StepBasic_DocumentType self, Handle_TCollection_HAsciiString apdt)

        :type apdt: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentType_SetProductDataType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentType
StepBasic_DocumentType_swigregister = _StepBasic.StepBasic_DocumentType_swigregister
StepBasic_DocumentType_swigregister(StepBasic_DocumentType)

def StepBasic_DocumentType_get_type_name(*args):
    """
    StepBasic_DocumentType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentType_get_type_name(*args)

def StepBasic_DocumentType_get_type_descriptor(*args):
    """
    StepBasic_DocumentType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentType_get_type_descriptor(*args)

class StepBasic_ProductDefinitionFormationWithSpecifiedSource(StepBasic_ProductDefinitionFormation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> StepBasic_ProductDefinitionFormationWithSpecifiedSource

        Returns a ProductDefinitionFormationWithSpecifiedSource


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionFormationWithSpecifiedSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Product aOfProduct, StepBasic_Source const aMakeOrBuy)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product
        :type aMakeOrBuy: OCC.wrapper.StepBasic.StepBasic_Source

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_Init(self, *args)


    def SetMakeOrBuy(self, *args):
        """
        SetMakeOrBuy(StepBasic_ProductDefinitionFormationWithSpecifiedSource self, StepBasic_Source const aMakeOrBuy)

        :type aMakeOrBuy: OCC.wrapper.StepBasic.StepBasic_Source

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_SetMakeOrBuy(self, *args)


    def MakeOrBuy(self, *args):
        """
        MakeOrBuy(StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> StepBasic_Source

        :rtype: OCC.wrapper.StepBasic.StepBasic_Source

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_MakeOrBuy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionFormationWithSpecifiedSource
StepBasic_ProductDefinitionFormationWithSpecifiedSource_swigregister = _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_swigregister
StepBasic_ProductDefinitionFormationWithSpecifiedSource_swigregister(StepBasic_ProductDefinitionFormationWithSpecifiedSource)

def StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_name(*args):
    """
    StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_name(*args)

def StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_descriptor(*args)

class StepBasic_ProductDefinitionReference(Standard.Standard_Transient):
    """Representation of STEP entity Product_Definition_Reference"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionReference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionReference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionReference self) -> StepBasic_ProductDefinitionReference

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionReference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionReference self, Handle_StepBasic_ExternalSource theSource, Handle_TCollection_HAsciiString theProductId, Handle_TCollection_HAsciiString theProductDefinitionFormationId, Handle_TCollection_HAsciiString theProductDefinitionId, Handle_TCollection_HAsciiString theIdOwningOrganizationName)
        Init(StepBasic_ProductDefinitionReference self, Handle_StepBasic_ExternalSource theSource, Handle_TCollection_HAsciiString theProductId, Handle_TCollection_HAsciiString theProductDefinitionFormationId, Handle_TCollection_HAsciiString theProductDefinitionId)

        Initialize all fields (own and inherited)

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource
        :type theProductId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theProductDefinitionFormationId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theProductDefinitionId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_Init(self, *args)


    def Source(self, *args):
        """
        Source(StepBasic_ProductDefinitionReference self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepBasic_ProductDefinitionReference self, Handle_StepBasic_ExternalSource theSource)

        Set field Source

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_SetSource(self, *args)


    def ProductId(self, *args):
        """
        ProductId(StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field ProductId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_ProductId(self, *args)


    def SetProductId(self, *args):
        """
        SetProductId(StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theProductId)

        Set field ProductId

        :type theProductId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_SetProductId(self, *args)


    def ProductDefinitionFormationId(self, *args):
        """
        ProductDefinitionFormationId(StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field ProductDefinitionFormationId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_ProductDefinitionFormationId(self, *args)


    def SetProductDefinitionFormationId(self, *args):
        """
        SetProductDefinitionFormationId(StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theProductDefinitionFormationId)

        Set field ProductDefinitionFormationId

        :type theProductDefinitionFormationId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_SetProductDefinitionFormationId(self, *args)


    def ProductDefinitionId(self, *args):
        """
        ProductDefinitionId(StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field ProductDefinitionId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_ProductDefinitionId(self, *args)


    def SetProductDefinitionId(self, *args):
        """
        SetProductDefinitionId(StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theProductDefinitionId)

        Set field ProductDefinitionId

        :type theProductDefinitionId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_SetProductDefinitionId(self, *args)


    def IdOwningOrganizationName(self, *args):
        """
        IdOwningOrganizationName(StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field IdOwningOrganizationName

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_IdOwningOrganizationName(self, *args)


    def SetIdOwningOrganizationName(self, *args):
        """
        SetIdOwningOrganizationName(StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theIdOwningOrganizationName)

        Set field IdOwningOrganizationName

        :type theIdOwningOrganizationName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_SetIdOwningOrganizationName(self, *args)


    def HasIdOwningOrganizationName(self, *args):
        """
        HasIdOwningOrganizationName(StepBasic_ProductDefinitionReference self) -> Standard_Boolean

        Returns true if IdOwningOrganizationName exists

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_HasIdOwningOrganizationName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionReference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionReference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionReference
StepBasic_ProductDefinitionReference_swigregister = _StepBasic.StepBasic_ProductDefinitionReference_swigregister
StepBasic_ProductDefinitionReference_swigregister(StepBasic_ProductDefinitionReference)

def StepBasic_ProductDefinitionReference_get_type_name(*args):
    """
    StepBasic_ProductDefinitionReference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionReference_get_type_name(*args)

def StepBasic_ProductDefinitionReference_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionReference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionReference_get_type_descriptor(*args)

class StepBasic_GroupRelationship(Standard.Standard_Transient):
    """Representation of STEP entity GroupRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_GroupRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_GroupRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_GroupRelationship self) -> StepBasic_GroupRelationship

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_GroupRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_GroupRelationship self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Group aRelatingGroup, Handle_StepBasic_Group aRelatedGroup)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group
        :type aRelatedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupRelationship_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_GroupRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GroupRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_GroupRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GroupRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_GroupRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GroupRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_GroupRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GroupRelationship_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_GroupRelationship self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_GroupRelationship_HasDescription(self, *args)


    def RelatingGroup(self, *args):
        """
        RelatingGroup(StepBasic_GroupRelationship self) -> Handle_StepBasic_Group

        Returns field RelatingGroup

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupRelationship_RelatingGroup(self, *args)


    def SetRelatingGroup(self, *args):
        """
        SetRelatingGroup(StepBasic_GroupRelationship self, Handle_StepBasic_Group RelatingGroup)

        Set field RelatingGroup

        :type RelatingGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupRelationship_SetRelatingGroup(self, *args)


    def RelatedGroup(self, *args):
        """
        RelatedGroup(StepBasic_GroupRelationship self) -> Handle_StepBasic_Group

        Returns field RelatedGroup

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupRelationship_RelatedGroup(self, *args)


    def SetRelatedGroup(self, *args):
        """
        SetRelatedGroup(StepBasic_GroupRelationship self, Handle_StepBasic_Group RelatedGroup)

        Set field RelatedGroup

        :type RelatedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupRelationship_SetRelatedGroup(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_GroupRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_GroupRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_GroupRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_GroupRelationship
StepBasic_GroupRelationship_swigregister = _StepBasic.StepBasic_GroupRelationship_swigregister
StepBasic_GroupRelationship_swigregister(StepBasic_GroupRelationship)

def StepBasic_GroupRelationship_get_type_name(*args):
    """
    StepBasic_GroupRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_GroupRelationship_get_type_name(*args)

def StepBasic_GroupRelationship_get_type_descriptor(*args):
    """
    StepBasic_GroupRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_GroupRelationship_get_type_descriptor(*args)

class StepBasic_VolumeUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_VolumeUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_VolumeUnit(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_VolumeUnit self) -> StepBasic_VolumeUnit"""
        this = _StepBasic.new_StepBasic_VolumeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_VolumeUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_VolumeUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_VolumeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_VolumeUnit
StepBasic_VolumeUnit_swigregister = _StepBasic.StepBasic_VolumeUnit_swigregister
StepBasic_VolumeUnit_swigregister(StepBasic_VolumeUnit)

def StepBasic_VolumeUnit_get_type_name(*args):
    """
    StepBasic_VolumeUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_VolumeUnit_get_type_name(*args)

def StepBasic_VolumeUnit_get_type_descriptor(*args):
    """
    StepBasic_VolumeUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_VolumeUnit_get_type_descriptor(*args)

class StepBasic_GroupAssignment(Standard.Standard_Transient):
    """Representation of STEP entity GroupAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_GroupAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_GroupAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_GroupAssignment self) -> StepBasic_GroupAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_GroupAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_GroupAssignment self, Handle_StepBasic_Group aAssignedGroup)

        Initialize all fields (own and inherited)

        :type aAssignedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupAssignment_Init(self, *args)


    def AssignedGroup(self, *args):
        """
        AssignedGroup(StepBasic_GroupAssignment self) -> Handle_StepBasic_Group

        Returns field AssignedGroup

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupAssignment_AssignedGroup(self, *args)


    def SetAssignedGroup(self, *args):
        """
        SetAssignedGroup(StepBasic_GroupAssignment self, Handle_StepBasic_Group AssignedGroup)

        Set field AssignedGroup

        :type AssignedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.StepBasic_GroupAssignment_SetAssignedGroup(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_GroupAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_GroupAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_GroupAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_GroupAssignment
StepBasic_GroupAssignment_swigregister = _StepBasic.StepBasic_GroupAssignment_swigregister
StepBasic_GroupAssignment_swigregister(StepBasic_GroupAssignment)

def StepBasic_GroupAssignment_get_type_name(*args):
    """
    StepBasic_GroupAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_GroupAssignment_get_type_name(*args)

def StepBasic_GroupAssignment_get_type_descriptor(*args):
    """
    StepBasic_GroupAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_GroupAssignment_get_type_descriptor(*args)

class StepBasic_PlaneAngleMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PlaneAngleMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PlaneAngleMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_PlaneAngleMeasureWithUnit self) -> StepBasic_PlaneAngleMeasureWithUnit

        Returns a PlaneAngleMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_PlaneAngleMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PlaneAngleMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PlaneAngleMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PlaneAngleMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_PlaneAngleMeasureWithUnit
StepBasic_PlaneAngleMeasureWithUnit_swigregister = _StepBasic.StepBasic_PlaneAngleMeasureWithUnit_swigregister
StepBasic_PlaneAngleMeasureWithUnit_swigregister(StepBasic_PlaneAngleMeasureWithUnit)

def StepBasic_PlaneAngleMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_PlaneAngleMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PlaneAngleMeasureWithUnit_get_type_name(*args)

def StepBasic_PlaneAngleMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_PlaneAngleMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PlaneAngleMeasureWithUnit_get_type_descriptor(*args)

class StepBasic_SiUnitAndTimeUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndTimeUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndTimeUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndTimeUnit self) -> StepBasic_SiUnitAndTimeUnit

        Returns a SiUnitAndTimeUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndTimeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndTimeUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndTimeUnit_Init(self, *args)


    def SetTimeUnit(self, *args):
        """
        SetTimeUnit(StepBasic_SiUnitAndTimeUnit self, Handle_StepBasic_TimeUnit aTimeUnit)

        :type aTimeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.StepBasic_SiUnitAndTimeUnit_SetTimeUnit(self, *args)


    def TimeUnit(self, *args):
        """
        TimeUnit(StepBasic_SiUnitAndTimeUnit self) -> Handle_StepBasic_TimeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.StepBasic_SiUnitAndTimeUnit_TimeUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndTimeUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndTimeUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndTimeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndTimeUnit
StepBasic_SiUnitAndTimeUnit_swigregister = _StepBasic.StepBasic_SiUnitAndTimeUnit_swigregister
StepBasic_SiUnitAndTimeUnit_swigregister(StepBasic_SiUnitAndTimeUnit)

def StepBasic_SiUnitAndTimeUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndTimeUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndTimeUnit_get_type_name(*args)

def StepBasic_SiUnitAndTimeUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndTimeUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndTimeUnit_get_type_descriptor(*args)

class StepBasic_SolidAngleMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SolidAngleMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SolidAngleMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SolidAngleMeasureWithUnit self) -> StepBasic_SolidAngleMeasureWithUnit

        Returns a SolidAngleMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_SolidAngleMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SolidAngleMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SolidAngleMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SolidAngleMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SolidAngleMeasureWithUnit
StepBasic_SolidAngleMeasureWithUnit_swigregister = _StepBasic.StepBasic_SolidAngleMeasureWithUnit_swigregister
StepBasic_SolidAngleMeasureWithUnit_swigregister(StepBasic_SolidAngleMeasureWithUnit)

def StepBasic_SolidAngleMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_SolidAngleMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SolidAngleMeasureWithUnit_get_type_name(*args)

def StepBasic_SolidAngleMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_SolidAngleMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SolidAngleMeasureWithUnit_get_type_descriptor(*args)

class StepBasic_HArray1OfDocument(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfDocument
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfDocument(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfDocument self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfDocument
        __init__(StepBasic_HArray1OfDocument self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_Document theValue) -> StepBasic_HArray1OfDocument
        __init__(StepBasic_HArray1OfDocument self, NCollection_Array1_Handle_StepBasic_Document theOther) -> StepBasic_HArray1OfDocument

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfDocument

        """
        this = _StepBasic.new_StepBasic_HArray1OfDocument(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDocument

        """
        res = _StepBasic.StepBasic_HArray1OfDocument_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfDocument self) -> NCollection_Array1_Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDocument

        """
        return _StepBasic.StepBasic_HArray1OfDocument_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfDocument_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfDocument_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfDocument_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfDocument
StepBasic_HArray1OfDocument_swigregister = _StepBasic.StepBasic_HArray1OfDocument_swigregister
StepBasic_HArray1OfDocument_swigregister(StepBasic_HArray1OfDocument)

def StepBasic_HArray1OfDocument_get_type_name(*args):
    """
    StepBasic_HArray1OfDocument_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfDocument_get_type_name(*args)

def StepBasic_HArray1OfDocument_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfDocument_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfDocument_get_type_descriptor(*args)

class StepBasic_VersionedActionRequest(Standard.Standard_Transient):
    """Representation of STEP entity VersionedActionRequest"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_VersionedActionRequest
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_VersionedActionRequest(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_VersionedActionRequest self) -> StepBasic_VersionedActionRequest

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_VersionedActionRequest(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aVersion, Handle_TCollection_HAsciiString aPurpose, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aVersion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_Init(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_SetId(self, *args)


    def Version(self, *args):
        """
        Version(StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Version

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_Version(self, *args)


    def SetVersion(self, *args):
        """
        SetVersion(StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Version)

        Set field Version

        :type Version: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_SetVersion(self, *args)


    def Purpose(self, *args):
        """
        Purpose(StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_SetPurpose(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_VersionedActionRequest_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_VersionedActionRequest self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_VersionedActionRequest_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_VersionedActionRequest_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_VersionedActionRequest_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_VersionedActionRequest_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_VersionedActionRequest
StepBasic_VersionedActionRequest_swigregister = _StepBasic.StepBasic_VersionedActionRequest_swigregister
StepBasic_VersionedActionRequest_swigregister(StepBasic_VersionedActionRequest)

def StepBasic_VersionedActionRequest_get_type_name(*args):
    """
    StepBasic_VersionedActionRequest_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_VersionedActionRequest_get_type_name(*args)

def StepBasic_VersionedActionRequest_get_type_descriptor(*args):
    """
    StepBasic_VersionedActionRequest_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_VersionedActionRequest_get_type_descriptor(*args)

class StepBasic_SiUnitAndPlaneAngleUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndPlaneAngleUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndPlaneAngleUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndPlaneAngleUnit self) -> StepBasic_SiUnitAndPlaneAngleUnit

        Returns a SiUnitAndPlaneAngleUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndPlaneAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndPlaneAngleUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_Init(self, *args)


    def SetPlaneAngleUnit(self, *args):
        """
        SetPlaneAngleUnit(StepBasic_SiUnitAndPlaneAngleUnit self, Handle_StepBasic_PlaneAngleUnit aPlaneAngleUnit)

        :type aPlaneAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_SetPlaneAngleUnit(self, *args)


    def PlaneAngleUnit(self, *args):
        """
        PlaneAngleUnit(StepBasic_SiUnitAndPlaneAngleUnit self) -> Handle_StepBasic_PlaneAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_PlaneAngleUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndPlaneAngleUnit
StepBasic_SiUnitAndPlaneAngleUnit_swigregister = _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_swigregister
StepBasic_SiUnitAndPlaneAngleUnit_swigregister(StepBasic_SiUnitAndPlaneAngleUnit)

def StepBasic_SiUnitAndPlaneAngleUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndPlaneAngleUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_get_type_name(*args)

def StepBasic_SiUnitAndPlaneAngleUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndPlaneAngleUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndPlaneAngleUnit_get_type_descriptor(*args)

class StepBasic_DateRole(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DateRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DateRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DateRole self) -> StepBasic_DateRole

        Returns a DateRole


        """
        this = _StepBasic.new_StepBasic_DateRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DateRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DateRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_DateRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DateRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_DateRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DateRole_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DateRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DateRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DateRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DateRole
StepBasic_DateRole_swigregister = _StepBasic.StepBasic_DateRole_swigregister
StepBasic_DateRole_swigregister(StepBasic_DateRole)

def StepBasic_DateRole_get_type_name(*args):
    """
    StepBasic_DateRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DateRole_get_type_name(*args)

def StepBasic_DateRole_get_type_descriptor(*args):
    """
    StepBasic_DateRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DateRole_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnitAndMassUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndMassUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndMassUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndMassUnit self) -> StepBasic_ConversionBasedUnitAndMassUnit

        Returns a ConversionBasedUnitAndLengthUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndMassUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_Init(self, *args)


    def SetMassUnit(self, *args):
        """
        SetMassUnit(StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_MassUnit aMassUnit)

        :type aMassUnit: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_SetMassUnit(self, *args)


    def MassUnit(self, *args):
        """
        MassUnit(StepBasic_ConversionBasedUnitAndMassUnit self) -> Handle_StepBasic_MassUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_MassUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndMassUnit
StepBasic_ConversionBasedUnitAndMassUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_swigregister
StepBasic_ConversionBasedUnitAndMassUnit_swigregister(StepBasic_ConversionBasedUnitAndMassUnit)

def StepBasic_ConversionBasedUnitAndMassUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndMassUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndMassUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndMassUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndMassUnit_get_type_descriptor(*args)

class StepBasic_PersonAndOrganizationRole(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PersonAndOrganizationRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PersonAndOrganizationRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_PersonAndOrganizationRole self) -> StepBasic_PersonAndOrganizationRole

        Returns a PersonAndOrganizationRole


        """
        this = _StepBasic.new_StepBasic_PersonAndOrganizationRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_PersonAndOrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_PersonAndOrganizationRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_PersonAndOrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_PersonAndOrganizationRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_PersonAndOrganizationRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_PersonAndOrganizationRole_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PersonAndOrganizationRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PersonAndOrganizationRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PersonAndOrganizationRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_PersonAndOrganizationRole
StepBasic_PersonAndOrganizationRole_swigregister = _StepBasic.StepBasic_PersonAndOrganizationRole_swigregister
StepBasic_PersonAndOrganizationRole_swigregister(StepBasic_PersonAndOrganizationRole)

def StepBasic_PersonAndOrganizationRole_get_type_name(*args):
    """
    StepBasic_PersonAndOrganizationRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PersonAndOrganizationRole_get_type_name(*args)

def StepBasic_PersonAndOrganizationRole_get_type_descriptor(*args):
    """
    StepBasic_PersonAndOrganizationRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PersonAndOrganizationRole_get_type_descriptor(*args)

class StepBasic_ProductDefinitionContext(StepBasic_ApplicationContextElement):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionContext self) -> StepBasic_ProductDefinitionContext

        Returns a ProductDefinitionContext


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionContext self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference, Handle_TCollection_HAsciiString aLifeCycleStage)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aLifeCycleStage: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionContext_Init(self, *args)


    def SetLifeCycleStage(self, *args):
        """
        SetLifeCycleStage(StepBasic_ProductDefinitionContext self, Handle_TCollection_HAsciiString aLifeCycleStage)

        :type aLifeCycleStage: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionContext_SetLifeCycleStage(self, *args)


    def LifeCycleStage(self, *args):
        """
        LifeCycleStage(StepBasic_ProductDefinitionContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionContext_LifeCycleStage(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionContext
StepBasic_ProductDefinitionContext_swigregister = _StepBasic.StepBasic_ProductDefinitionContext_swigregister
StepBasic_ProductDefinitionContext_swigregister(StepBasic_ProductDefinitionContext)

def StepBasic_ProductDefinitionContext_get_type_name(*args):
    """
    StepBasic_ProductDefinitionContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionContext_get_type_name(*args)

def StepBasic_ProductDefinitionContext_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionContext_get_type_descriptor(*args)

class StepBasic_AreaUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_AreaUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_AreaUnit(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_AreaUnit self) -> StepBasic_AreaUnit"""
        this = _StepBasic.new_StepBasic_AreaUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_AreaUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_AreaUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_AreaUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_AreaUnit
StepBasic_AreaUnit_swigregister = _StepBasic.StepBasic_AreaUnit_swigregister
StepBasic_AreaUnit_swigregister(StepBasic_AreaUnit)

def StepBasic_AreaUnit_get_type_name(*args):
    """
    StepBasic_AreaUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_AreaUnit_get_type_name(*args)

def StepBasic_AreaUnit_get_type_descriptor(*args):
    """
    StepBasic_AreaUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_AreaUnit_get_type_descriptor(*args)

class StepBasic_SiUnitAndAreaUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndAreaUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndAreaUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndAreaUnit self) -> StepBasic_SiUnitAndAreaUnit

        Returns a SiUnitAndAreaUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndAreaUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetAreaUnit(self, *args):
        """
        SetAreaUnit(StepBasic_SiUnitAndAreaUnit self, Handle_StepBasic_AreaUnit anAreaUnit)

        :type anAreaUnit: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.StepBasic_SiUnitAndAreaUnit_SetAreaUnit(self, *args)


    def AreaUnit(self, *args):
        """
        AreaUnit(StepBasic_SiUnitAndAreaUnit self) -> Handle_StepBasic_AreaUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.StepBasic_SiUnitAndAreaUnit_AreaUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndAreaUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndAreaUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndAreaUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndAreaUnit
StepBasic_SiUnitAndAreaUnit_swigregister = _StepBasic.StepBasic_SiUnitAndAreaUnit_swigregister
StepBasic_SiUnitAndAreaUnit_swigregister(StepBasic_SiUnitAndAreaUnit)

def StepBasic_SiUnitAndAreaUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndAreaUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndAreaUnit_get_type_name(*args)

def StepBasic_SiUnitAndAreaUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndAreaUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndAreaUnit_get_type_descriptor(*args)

class StepBasic_SiUnitAndMassUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndMassUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndMassUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndMassUnit self) -> StepBasic_SiUnitAndMassUnit

        Returns a SiUnitAndMassUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndMassUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndMassUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndMassUnit_Init(self, *args)


    def SetMassUnit(self, *args):
        """
        SetMassUnit(StepBasic_SiUnitAndMassUnit self, Handle_StepBasic_MassUnit aMassUnit)

        :type aMassUnit: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.StepBasic_SiUnitAndMassUnit_SetMassUnit(self, *args)


    def MassUnit(self, *args):
        """
        MassUnit(StepBasic_SiUnitAndMassUnit self) -> Handle_StepBasic_MassUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.StepBasic_SiUnitAndMassUnit_MassUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndMassUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndMassUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndMassUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndMassUnit
StepBasic_SiUnitAndMassUnit_swigregister = _StepBasic.StepBasic_SiUnitAndMassUnit_swigregister
StepBasic_SiUnitAndMassUnit_swigregister(StepBasic_SiUnitAndMassUnit)

def StepBasic_SiUnitAndMassUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndMassUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndMassUnit_get_type_name(*args)

def StepBasic_SiUnitAndMassUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndMassUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndMassUnit_get_type_descriptor(*args)

class StepBasic_SiUnitAndThermodynamicTemperatureUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> StepBasic_SiUnitAndThermodynamicTemperatureUnit

        Returns a SiUnitAndThermodynamicTemperatureUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndThermodynamicTemperatureUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_Init(self, *args)


    def SetThermodynamicTemperatureUnit(self, *args):
        """
        SetThermodynamicTemperatureUnit(StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_StepBasic_ThermodynamicTemperatureUnit aThermodynamicTemperatureUnit)

        :type aThermodynamicTemperatureUnit: OCC.wrapper.StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit

        """
        return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_SetThermodynamicTemperatureUnit(self, *args)


    def ThermodynamicTemperatureUnit(self, *args):
        """
        ThermodynamicTemperatureUnit(StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Handle_StepBasic_ThermodynamicTemperatureUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit

        """
        return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_ThermodynamicTemperatureUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndThermodynamicTemperatureUnit
StepBasic_SiUnitAndThermodynamicTemperatureUnit_swigregister = _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_swigregister
StepBasic_SiUnitAndThermodynamicTemperatureUnit_swigregister(StepBasic_SiUnitAndThermodynamicTemperatureUnit)

def StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_name(*args)

def StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_descriptor(*args)

class StepBasic_IdentificationRole(Standard.Standard_Transient):
    """Representation of STEP entity IdentificationRole"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_IdentificationRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_IdentificationRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_IdentificationRole self) -> StepBasic_IdentificationRole

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_IdentificationRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_IdentificationRole self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationRole_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_IdentificationRole self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationRole_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_IdentificationRole self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationRole_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_IdentificationRole self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationRole_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_IdentificationRole self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationRole_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_IdentificationRole self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_IdentificationRole_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_IdentificationRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_IdentificationRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_IdentificationRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_IdentificationRole
StepBasic_IdentificationRole_swigregister = _StepBasic.StepBasic_IdentificationRole_swigregister
StepBasic_IdentificationRole_swigregister(StepBasic_IdentificationRole)

def StepBasic_IdentificationRole_get_type_name(*args):
    """
    StepBasic_IdentificationRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_IdentificationRole_get_type_name(*args)

def StepBasic_IdentificationRole_get_type_descriptor(*args):
    """
    StepBasic_IdentificationRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_IdentificationRole_get_type_descriptor(*args)

class StepBasic_ProductDefinitionReferenceWithLocalRepresentation(StepBasic_ProductDefinition):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        Returns a ProductDefinitionReferenceWithLocalRepresentation


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionReferenceWithLocalRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ExternalSource theSource, Handle_TCollection_HAsciiString theId, Handle_TCollection_HAsciiString theDescription, Handle_StepBasic_ProductDefinitionFormation theFormation, Handle_StepBasic_ProductDefinitionContext theFrameOfReference)

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource
        :type theId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type theFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Init(self, *args)


    def Source(self, *args):
        """
        Source(StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ExternalSource theSource)

        Set field Source

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_SetSource(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionReferenceWithLocalRepresentation
StepBasic_ProductDefinitionReferenceWithLocalRepresentation_swigregister = _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_swigregister
StepBasic_ProductDefinitionReferenceWithLocalRepresentation_swigregister(StepBasic_ProductDefinitionReferenceWithLocalRepresentation)

def StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_name(*args):
    """
    StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_name(*args)

def StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnitAndPlaneAngleUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> StepBasic_ConversionBasedUnitAndPlaneAngleUnit

        Returns a ConversionBasedUnitAndPlaneAngleUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndPlaneAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_Init(self, *args)


    def SetPlaneAngleUnit(self, *args):
        """
        SetPlaneAngleUnit(StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_PlaneAngleUnit aPlaneAngleUnit)

        :type aPlaneAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_SetPlaneAngleUnit(self, *args)


    def PlaneAngleUnit(self, *args):
        """
        PlaneAngleUnit(StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Handle_StepBasic_PlaneAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_PlaneAngleUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndPlaneAngleUnit
StepBasic_ConversionBasedUnitAndPlaneAngleUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_swigregister
StepBasic_ConversionBasedUnitAndPlaneAngleUnit_swigregister(StepBasic_ConversionBasedUnitAndPlaneAngleUnit)

def StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnitAndVolumeUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndVolumeUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndVolumeUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndVolumeUnit self) -> StepBasic_ConversionBasedUnitAndVolumeUnit

        Returns a ConversionBasedUnitAndVolumeUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndVolumeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetVolumeUnit(self, *args):
        """
        SetVolumeUnit(StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_VolumeUnit aVolumeUnit)

        :type aVolumeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_SetVolumeUnit(self, *args)


    def VolumeUnit(self, *args):
        """
        VolumeUnit(StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Handle_StepBasic_VolumeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_VolumeUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndVolumeUnit
StepBasic_ConversionBasedUnitAndVolumeUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_swigregister
StepBasic_ConversionBasedUnitAndVolumeUnit_swigregister(StepBasic_ConversionBasedUnitAndVolumeUnit)

def StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_descriptor(*args)

class StepBasic_TimeUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_TimeUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_TimeUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_TimeUnit self) -> StepBasic_TimeUnit

        Returns a TimeUnit


        """
        this = _StepBasic.new_StepBasic_TimeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_TimeUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_TimeUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_TimeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_TimeUnit
StepBasic_TimeUnit_swigregister = _StepBasic.StepBasic_TimeUnit_swigregister
StepBasic_TimeUnit_swigregister(StepBasic_TimeUnit)

def StepBasic_TimeUnit_get_type_name(*args):
    """
    StepBasic_TimeUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_TimeUnit_get_type_name(*args)

def StepBasic_TimeUnit_get_type_descriptor(*args):
    """
    StepBasic_TimeUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_TimeUnit_get_type_descriptor(*args)

class StepBasic_Document(Standard.Standard_Transient):
    """Representation of STEP entity Document"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Document
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Document(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Document self) -> StepBasic_Document

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Document self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_DocumentType aKind)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.StepBasic_Document_Init(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_Document self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Document_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_Document self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Document_SetId(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Document self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Document_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Document self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Document_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_Document self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Document_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_Document self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Document_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_Document self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Document_HasDescription(self, *args)


    def Kind(self, *args):
        """
        Kind(StepBasic_Document self) -> Handle_StepBasic_DocumentType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.StepBasic_Document_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(StepBasic_Document self, Handle_StepBasic_DocumentType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.StepBasic_Document_SetKind(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Document_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Document_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Document_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Document
StepBasic_Document_swigregister = _StepBasic.StepBasic_Document_swigregister
StepBasic_Document_swigregister(StepBasic_Document)

def StepBasic_Document_get_type_name(*args):
    """
    StepBasic_Document_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Document_get_type_name(*args)

def StepBasic_Document_get_type_descriptor(*args):
    """
    StepBasic_Document_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Document_get_type_descriptor(*args)

class StepBasic_WeekOfYearAndDayDate(StepBasic_Date):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_WeekOfYearAndDayDate
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_WeekOfYearAndDayDate(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_WeekOfYearAndDayDate self) -> StepBasic_WeekOfYearAndDayDate

        Returns a WeekOfYearAndDayDate


        """
        this = _StepBasic.new_StepBasic_WeekOfYearAndDayDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aYearComponent, Standard_Integer const aWeekComponent, Standard_Boolean const hasAdayComponent, Standard_Integer const aDayComponent)

        :type aYearComponent: int
        :type aWeekComponent: int
        :type hasAdayComponent: bool
        :type aDayComponent: int

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_Init(self, *args)


    def SetWeekComponent(self, *args):
        """
        SetWeekComponent(StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aWeekComponent)

        :type aWeekComponent: int

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_SetWeekComponent(self, *args)


    def WeekComponent(self, *args):
        """
        WeekComponent(StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_WeekComponent(self, *args)


    def SetDayComponent(self, *args):
        """
        SetDayComponent(StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aDayComponent)

        :type aDayComponent: int

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_SetDayComponent(self, *args)


    def UnSetDayComponent(self, *args):
        """UnSetDayComponent(StepBasic_WeekOfYearAndDayDate self)"""
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_UnSetDayComponent(self, *args)


    def DayComponent(self, *args):
        """
        DayComponent(StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_DayComponent(self, *args)


    def HasDayComponent(self, *args):
        """
        HasDayComponent(StepBasic_WeekOfYearAndDayDate self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_HasDayComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_WeekOfYearAndDayDate_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_WeekOfYearAndDayDate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_WeekOfYearAndDayDate
StepBasic_WeekOfYearAndDayDate_swigregister = _StepBasic.StepBasic_WeekOfYearAndDayDate_swigregister
StepBasic_WeekOfYearAndDayDate_swigregister(StepBasic_WeekOfYearAndDayDate)

def StepBasic_WeekOfYearAndDayDate_get_type_name(*args):
    """
    StepBasic_WeekOfYearAndDayDate_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_WeekOfYearAndDayDate_get_type_name(*args)

def StepBasic_WeekOfYearAndDayDate_get_type_descriptor(*args):
    """
    StepBasic_WeekOfYearAndDayDate_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_WeekOfYearAndDayDate_get_type_descriptor(*args)

class StepBasic_SiUnitAndSolidAngleUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndSolidAngleUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndSolidAngleUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndSolidAngleUnit self) -> StepBasic_SiUnitAndSolidAngleUnit

        Returns a SiUnitAndSolidAngleUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndSolidAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndSolidAngleUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_Init(self, *args)


    def SetSolidAngleUnit(self, *args):
        """
        SetSolidAngleUnit(StepBasic_SiUnitAndSolidAngleUnit self, Handle_StepBasic_SolidAngleUnit aSolidAngleUnit)

        :type aSolidAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_SetSolidAngleUnit(self, *args)


    def SolidAngleUnit(self, *args):
        """
        SolidAngleUnit(StepBasic_SiUnitAndSolidAngleUnit self) -> Handle_StepBasic_SolidAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_SolidAngleUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndSolidAngleUnit
StepBasic_SiUnitAndSolidAngleUnit_swigregister = _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_swigregister
StepBasic_SiUnitAndSolidAngleUnit_swigregister(StepBasic_SiUnitAndSolidAngleUnit)

def StepBasic_SiUnitAndSolidAngleUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndSolidAngleUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_get_type_name(*args)

def StepBasic_SiUnitAndSolidAngleUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndSolidAngleUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndSolidAngleUnit_get_type_descriptor(*args)

class StepBasic_RatioMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_RatioMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_RatioMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_RatioMeasureWithUnit self) -> StepBasic_RatioMeasureWithUnit

        Returns a RatioMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_RatioMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_RatioMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_RatioMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_RatioMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_RatioMeasureWithUnit
StepBasic_RatioMeasureWithUnit_swigregister = _StepBasic.StepBasic_RatioMeasureWithUnit_swigregister
StepBasic_RatioMeasureWithUnit_swigregister(StepBasic_RatioMeasureWithUnit)

def StepBasic_RatioMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_RatioMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_RatioMeasureWithUnit_get_type_name(*args)

def StepBasic_RatioMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_RatioMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_RatioMeasureWithUnit_get_type_descriptor(*args)

class StepBasic_Certification(Standard.Standard_Transient):
    """Representation of STEP entity Certification"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Certification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Certification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Certification self) -> StepBasic_Certification

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_Certification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Certification self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aPurpose, Handle_StepBasic_CertificationType aKind)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationType

        """
        return _StepBasic.StepBasic_Certification_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Certification self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Certification_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Certification self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Certification_SetName(self, *args)


    def Purpose(self, *args):
        """
        Purpose(StepBasic_Certification self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Certification_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(StepBasic_Certification self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Certification_SetPurpose(self, *args)


    def Kind(self, *args):
        """
        Kind(StepBasic_Certification self) -> Handle_StepBasic_CertificationType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationType

        """
        return _StepBasic.StepBasic_Certification_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(StepBasic_Certification self, Handle_StepBasic_CertificationType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationType

        """
        return _StepBasic.StepBasic_Certification_SetKind(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Certification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Certification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Certification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Certification
StepBasic_Certification_swigregister = _StepBasic.StepBasic_Certification_swigregister
StepBasic_Certification_swigregister(StepBasic_Certification)

def StepBasic_Certification_get_type_name(*args):
    """
    StepBasic_Certification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Certification_get_type_name(*args)

def StepBasic_Certification_get_type_descriptor(*args):
    """
    StepBasic_Certification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Certification_get_type_descriptor(*args)

class StepBasic_ActionRequestAssignment(Standard.Standard_Transient):
    """Representation of STEP entity ActionRequestAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ActionRequestAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ActionRequestAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ActionRequestAssignment self) -> StepBasic_ActionRequestAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ActionRequestAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ActionRequestAssignment self, Handle_StepBasic_VersionedActionRequest aAssignedActionRequest)

        Initialize all fields (own and inherited)

        :type aAssignedActionRequest: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.StepBasic_ActionRequestAssignment_Init(self, *args)


    def AssignedActionRequest(self, *args):
        """
        AssignedActionRequest(StepBasic_ActionRequestAssignment self) -> Handle_StepBasic_VersionedActionRequest

        Returns field AssignedActionRequest

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.StepBasic_ActionRequestAssignment_AssignedActionRequest(self, *args)


    def SetAssignedActionRequest(self, *args):
        """
        SetAssignedActionRequest(StepBasic_ActionRequestAssignment self, Handle_StepBasic_VersionedActionRequest AssignedActionRequest)

        Set field AssignedActionRequest

        :type AssignedActionRequest: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.StepBasic_ActionRequestAssignment_SetAssignedActionRequest(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ActionRequestAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ActionRequestAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ActionRequestAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ActionRequestAssignment
StepBasic_ActionRequestAssignment_swigregister = _StepBasic.StepBasic_ActionRequestAssignment_swigregister
StepBasic_ActionRequestAssignment_swigregister(StepBasic_ActionRequestAssignment)

def StepBasic_ActionRequestAssignment_get_type_name(*args):
    """
    StepBasic_ActionRequestAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ActionRequestAssignment_get_type_name(*args)

def StepBasic_ActionRequestAssignment_get_type_descriptor(*args):
    """
    StepBasic_ActionRequestAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ActionRequestAssignment_get_type_descriptor(*args)

class StepBasic_ContractAssignment(Standard.Standard_Transient):
    """Representation of STEP entity ContractAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ContractAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ContractAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ContractAssignment self) -> StepBasic_ContractAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ContractAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ContractAssignment self, Handle_StepBasic_Contract aAssignedContract)

        Initialize all fields (own and inherited)

        :type aAssignedContract: OCC.wrapper.StepBasic.Handle_StepBasic_Contract

        """
        return _StepBasic.StepBasic_ContractAssignment_Init(self, *args)


    def AssignedContract(self, *args):
        """
        AssignedContract(StepBasic_ContractAssignment self) -> Handle_StepBasic_Contract

        Returns field AssignedContract

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Contract

        """
        return _StepBasic.StepBasic_ContractAssignment_AssignedContract(self, *args)


    def SetAssignedContract(self, *args):
        """
        SetAssignedContract(StepBasic_ContractAssignment self, Handle_StepBasic_Contract AssignedContract)

        Set field AssignedContract

        :type AssignedContract: OCC.wrapper.StepBasic.Handle_StepBasic_Contract

        """
        return _StepBasic.StepBasic_ContractAssignment_SetAssignedContract(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ContractAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ContractAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ContractAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ContractAssignment
StepBasic_ContractAssignment_swigregister = _StepBasic.StepBasic_ContractAssignment_swigregister
StepBasic_ContractAssignment_swigregister(StepBasic_ContractAssignment)

def StepBasic_ContractAssignment_get_type_name(*args):
    """
    StepBasic_ContractAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ContractAssignment_get_type_name(*args)

def StepBasic_ContractAssignment_get_type_descriptor(*args):
    """
    StepBasic_ContractAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ContractAssignment_get_type_descriptor(*args)

class StepBasic_HArray1OfProductDefinition(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfProductDefinition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfProductDefinition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfProductDefinition self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfProductDefinition
        __init__(StepBasic_HArray1OfProductDefinition self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_ProductDefinition theValue) -> StepBasic_HArray1OfProductDefinition
        __init__(StepBasic_HArray1OfProductDefinition self, NCollection_Array1_Handle_StepBasic_ProductDefinition theOther) -> StepBasic_HArray1OfProductDefinition

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfProductDefinition

        """
        this = _StepBasic.new_StepBasic_HArray1OfProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductDefinition

        """
        res = _StepBasic.StepBasic_HArray1OfProductDefinition_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfProductDefinition self) -> NCollection_Array1_Handle_StepBasic_ProductDefinition

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductDefinition

        """
        return _StepBasic.StepBasic_HArray1OfProductDefinition_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfProductDefinition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfProductDefinition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfProductDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfProductDefinition
StepBasic_HArray1OfProductDefinition_swigregister = _StepBasic.StepBasic_HArray1OfProductDefinition_swigregister
StepBasic_HArray1OfProductDefinition_swigregister(StepBasic_HArray1OfProductDefinition)

def StepBasic_HArray1OfProductDefinition_get_type_name(*args):
    """
    StepBasic_HArray1OfProductDefinition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfProductDefinition_get_type_name(*args)

def StepBasic_HArray1OfProductDefinition_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfProductDefinition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfProductDefinition_get_type_descriptor(*args)

class StepBasic_ProductConceptContext(StepBasic_ApplicationContextElement):
    """Representation of STEP entity ProductConceptContext"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductConceptContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductConceptContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductConceptContext self) -> StepBasic_ProductConceptContext

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ProductConceptContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductConceptContext self, Handle_TCollection_HAsciiString aApplicationContextElement_Name, Handle_StepBasic_ApplicationContext aApplicationContextElement_FrameOfReference, Handle_TCollection_HAsciiString aMarketSegmentType)

        Initialize all fields (own and inherited)

        :type aApplicationContextElement_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aApplicationContextElement_FrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aMarketSegmentType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductConceptContext_Init(self, *args)


    def MarketSegmentType(self, *args):
        """
        MarketSegmentType(StepBasic_ProductConceptContext self) -> Handle_TCollection_HAsciiString

        Returns field MarketSegmentType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductConceptContext_MarketSegmentType(self, *args)


    def SetMarketSegmentType(self, *args):
        """
        SetMarketSegmentType(StepBasic_ProductConceptContext self, Handle_TCollection_HAsciiString MarketSegmentType)

        Set field MarketSegmentType

        :type MarketSegmentType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductConceptContext_SetMarketSegmentType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductConceptContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductConceptContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductConceptContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductConceptContext
StepBasic_ProductConceptContext_swigregister = _StepBasic.StepBasic_ProductConceptContext_swigregister
StepBasic_ProductConceptContext_swigregister(StepBasic_ProductConceptContext)

def StepBasic_ProductConceptContext_get_type_name(*args):
    """
    StepBasic_ProductConceptContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductConceptContext_get_type_name(*args)

def StepBasic_ProductConceptContext_get_type_descriptor(*args):
    """
    StepBasic_ProductConceptContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductConceptContext_get_type_descriptor(*args)

class StepBasic_ApprovalAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApprovalAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApprovalAssignment(self) 
            return h


    def Init(self, *args):
        """
        Init(StepBasic_ApprovalAssignment self, Handle_StepBasic_Approval aAssignedApproval)

        :type aAssignedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalAssignment_Init(self, *args)


    def SetAssignedApproval(self, *args):
        """
        SetAssignedApproval(StepBasic_ApprovalAssignment self, Handle_StepBasic_Approval aAssignedApproval)

        :type aAssignedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalAssignment_SetAssignedApproval(self, *args)


    def AssignedApproval(self, *args):
        """
        AssignedApproval(StepBasic_ApprovalAssignment self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalAssignment_AssignedApproval(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApprovalAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApprovalAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApprovalAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_ApprovalAssignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_ApprovalAssignment
StepBasic_ApprovalAssignment_swigregister = _StepBasic.StepBasic_ApprovalAssignment_swigregister
StepBasic_ApprovalAssignment_swigregister(StepBasic_ApprovalAssignment)

def StepBasic_ApprovalAssignment_get_type_name(*args):
    """
    StepBasic_ApprovalAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApprovalAssignment_get_type_name(*args)

def StepBasic_ApprovalAssignment_get_type_descriptor(*args):
    """
    StepBasic_ApprovalAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApprovalAssignment_get_type_descriptor(*args)

class StepBasic_LocalTime(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_LocalTime
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_LocalTime(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_LocalTime self) -> StepBasic_LocalTime

        Returns a LocalTime


        """
        this = _StepBasic.new_StepBasic_LocalTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_LocalTime self, Standard_Integer const aHourComponent, Standard_Boolean const hasAminuteComponent, Standard_Integer const aMinuteComponent, Standard_Boolean const hasAsecondComponent, Standard_Real const aSecondComponent, Handle_StepBasic_CoordinatedUniversalTimeOffset aZone)

        :type aHourComponent: int
        :type hasAminuteComponent: bool
        :type aMinuteComponent: int
        :type hasAsecondComponent: bool
        :type aSecondComponent: float
        :type aZone: OCC.wrapper.StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset

        """
        return _StepBasic.StepBasic_LocalTime_Init(self, *args)


    def SetHourComponent(self, *args):
        """
        SetHourComponent(StepBasic_LocalTime self, Standard_Integer const aHourComponent)

        :type aHourComponent: int

        """
        return _StepBasic.StepBasic_LocalTime_SetHourComponent(self, *args)


    def HourComponent(self, *args):
        """
        HourComponent(StepBasic_LocalTime self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_LocalTime_HourComponent(self, *args)


    def SetMinuteComponent(self, *args):
        """
        SetMinuteComponent(StepBasic_LocalTime self, Standard_Integer const aMinuteComponent)

        :type aMinuteComponent: int

        """
        return _StepBasic.StepBasic_LocalTime_SetMinuteComponent(self, *args)


    def UnSetMinuteComponent(self, *args):
        """UnSetMinuteComponent(StepBasic_LocalTime self)"""
        return _StepBasic.StepBasic_LocalTime_UnSetMinuteComponent(self, *args)


    def MinuteComponent(self, *args):
        """
        MinuteComponent(StepBasic_LocalTime self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_LocalTime_MinuteComponent(self, *args)


    def HasMinuteComponent(self, *args):
        """
        HasMinuteComponent(StepBasic_LocalTime self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_LocalTime_HasMinuteComponent(self, *args)


    def SetSecondComponent(self, *args):
        """
        SetSecondComponent(StepBasic_LocalTime self, Standard_Real const aSecondComponent)

        :type aSecondComponent: float

        """
        return _StepBasic.StepBasic_LocalTime_SetSecondComponent(self, *args)


    def UnSetSecondComponent(self, *args):
        """UnSetSecondComponent(StepBasic_LocalTime self)"""
        return _StepBasic.StepBasic_LocalTime_UnSetSecondComponent(self, *args)


    def SecondComponent(self, *args):
        """
        SecondComponent(StepBasic_LocalTime self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_LocalTime_SecondComponent(self, *args)


    def HasSecondComponent(self, *args):
        """
        HasSecondComponent(StepBasic_LocalTime self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_LocalTime_HasSecondComponent(self, *args)


    def SetZone(self, *args):
        """
        SetZone(StepBasic_LocalTime self, Handle_StepBasic_CoordinatedUniversalTimeOffset aZone)

        :type aZone: OCC.wrapper.StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset

        """
        return _StepBasic.StepBasic_LocalTime_SetZone(self, *args)


    def Zone(self, *args):
        """
        Zone(StepBasic_LocalTime self) -> Handle_StepBasic_CoordinatedUniversalTimeOffset

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset

        """
        return _StepBasic.StepBasic_LocalTime_Zone(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_LocalTime_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_LocalTime_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_LocalTime_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_LocalTime
StepBasic_LocalTime_swigregister = _StepBasic.StepBasic_LocalTime_swigregister
StepBasic_LocalTime_swigregister(StepBasic_LocalTime)

def StepBasic_LocalTime_get_type_name(*args):
    """
    StepBasic_LocalTime_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_LocalTime_get_type_name(*args)

def StepBasic_LocalTime_get_type_descriptor(*args):
    """
    StepBasic_LocalTime_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_LocalTime_get_type_descriptor(*args)

class StepBasic_ApprovalStatus(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApprovalStatus
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApprovalStatus(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApprovalStatus self) -> StepBasic_ApprovalStatus

        Returns a ApprovalStatus


        """
        this = _StepBasic.new_StepBasic_ApprovalStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApprovalStatus self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalStatus_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ApprovalStatus self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalStatus_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ApprovalStatus self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalStatus_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApprovalStatus_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApprovalStatus_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApprovalStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApprovalStatus
StepBasic_ApprovalStatus_swigregister = _StepBasic.StepBasic_ApprovalStatus_swigregister
StepBasic_ApprovalStatus_swigregister(StepBasic_ApprovalStatus)

def StepBasic_ApprovalStatus_get_type_name(*args):
    """
    StepBasic_ApprovalStatus_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApprovalStatus_get_type_name(*args)

def StepBasic_ApprovalStatus_get_type_descriptor(*args):
    """
    StepBasic_ApprovalStatus_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApprovalStatus_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnitAndAreaUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndAreaUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndAreaUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndAreaUnit self) -> StepBasic_ConversionBasedUnitAndAreaUnit

        Returns a ConversionBasedUnitAndAreaUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndAreaUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetAreaUnit(self, *args):
        """
        SetAreaUnit(StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_AreaUnit anAreaUnit)

        :type anAreaUnit: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_SetAreaUnit(self, *args)


    def AreaUnit(self, *args):
        """
        AreaUnit(StepBasic_ConversionBasedUnitAndAreaUnit self) -> Handle_StepBasic_AreaUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_AreaUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndAreaUnit
StepBasic_ConversionBasedUnitAndAreaUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_swigregister
StepBasic_ConversionBasedUnitAndAreaUnit_swigregister(StepBasic_ConversionBasedUnitAndAreaUnit)

def StepBasic_ConversionBasedUnitAndAreaUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndAreaUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndAreaUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndAreaUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndAreaUnit_get_type_descriptor(*args)

class StepBasic_NameAssignment(Standard.Standard_Transient):
    """Representation of STEP entity NameAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_NameAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_NameAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_NameAssignment self) -> StepBasic_NameAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_NameAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_NameAssignment self, Handle_TCollection_HAsciiString aAssignedName)

        Initialize all fields (own and inherited)

        :type aAssignedName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_NameAssignment_Init(self, *args)


    def AssignedName(self, *args):
        """
        AssignedName(StepBasic_NameAssignment self) -> Handle_TCollection_HAsciiString

        Returns field AssignedName

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_NameAssignment_AssignedName(self, *args)


    def SetAssignedName(self, *args):
        """
        SetAssignedName(StepBasic_NameAssignment self, Handle_TCollection_HAsciiString AssignedName)

        Set field AssignedName

        :type AssignedName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_NameAssignment_SetAssignedName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_NameAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_NameAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_NameAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_NameAssignment
StepBasic_NameAssignment_swigregister = _StepBasic.StepBasic_NameAssignment_swigregister
StepBasic_NameAssignment_swigregister(StepBasic_NameAssignment)

def StepBasic_NameAssignment_get_type_name(*args):
    """
    StepBasic_NameAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_NameAssignment_get_type_name(*args)

def StepBasic_NameAssignment_get_type_descriptor(*args):
    """
    StepBasic_NameAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_NameAssignment_get_type_descriptor(*args)

class StepBasic_SecurityClassification(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SecurityClassification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SecurityClassification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SecurityClassification self) -> StepBasic_SecurityClassification

        Returns a SecurityClassification


        """
        this = _StepBasic.new_StepBasic_SecurityClassification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SecurityClassification self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aPurpose, Handle_StepBasic_SecurityClassificationLevel aSecurityLevel)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSecurityLevel: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _StepBasic.StepBasic_SecurityClassification_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_SecurityClassification self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassification_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_SecurityClassification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassification_Name(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(StepBasic_SecurityClassification self, Handle_TCollection_HAsciiString aPurpose)

        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassification_SetPurpose(self, *args)


    def Purpose(self, *args):
        """
        Purpose(StepBasic_SecurityClassification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SecurityClassification_Purpose(self, *args)


    def SetSecurityLevel(self, *args):
        """
        SetSecurityLevel(StepBasic_SecurityClassification self, Handle_StepBasic_SecurityClassificationLevel aSecurityLevel)

        :type aSecurityLevel: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _StepBasic.StepBasic_SecurityClassification_SetSecurityLevel(self, *args)


    def SecurityLevel(self, *args):
        """
        SecurityLevel(StepBasic_SecurityClassification self) -> Handle_StepBasic_SecurityClassificationLevel

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _StepBasic.StepBasic_SecurityClassification_SecurityLevel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SecurityClassification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SecurityClassification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SecurityClassification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SecurityClassification
StepBasic_SecurityClassification_swigregister = _StepBasic.StepBasic_SecurityClassification_swigregister
StepBasic_SecurityClassification_swigregister(StepBasic_SecurityClassification)

def StepBasic_SecurityClassification_get_type_name(*args):
    """
    StepBasic_SecurityClassification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SecurityClassification_get_type_name(*args)

def StepBasic_SecurityClassification_get_type_descriptor(*args):
    """
    StepBasic_SecurityClassification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SecurityClassification_get_type_descriptor(*args)

class StepBasic_OrganizationRole(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_OrganizationRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_OrganizationRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_OrganizationRole self) -> StepBasic_OrganizationRole

        Returns a OrganizationRole


        """
        this = _StepBasic.new_StepBasic_OrganizationRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_OrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_OrganizationRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_OrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_OrganizationRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_OrganizationRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_OrganizationRole_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_OrganizationRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_OrganizationRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_OrganizationRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_OrganizationRole
StepBasic_OrganizationRole_swigregister = _StepBasic.StepBasic_OrganizationRole_swigregister
StepBasic_OrganizationRole_swigregister(StepBasic_OrganizationRole)

def StepBasic_OrganizationRole_get_type_name(*args):
    """
    StepBasic_OrganizationRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_OrganizationRole_get_type_name(*args)

def StepBasic_OrganizationRole_get_type_descriptor(*args):
    """
    StepBasic_OrganizationRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_OrganizationRole_get_type_descriptor(*args)

class StepBasic_MassUnit(StepBasic_NamedUnit):
    """Representation of STEP entity MassUnit"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_MassUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_MassUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_MassUnit self) -> StepBasic_MassUnit

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_MassUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_MassUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_MassUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_MassUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_MassUnit
StepBasic_MassUnit_swigregister = _StepBasic.StepBasic_MassUnit_swigregister
StepBasic_MassUnit_swigregister(StepBasic_MassUnit)

def StepBasic_MassUnit_get_type_name(*args):
    """
    StepBasic_MassUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_MassUnit_get_type_name(*args)

def StepBasic_MassUnit_get_type_descriptor(*args):
    """
    StepBasic_MassUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_MassUnit_get_type_descriptor(*args)

class StepBasic_Action(Standard.Standard_Transient):
    """Representation of STEP entity Action"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Action
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Action(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Action self) -> StepBasic_Action

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_Action(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Action self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ActionMethod aChosenMethod)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aChosenMethod: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.StepBasic_Action_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Action self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Action_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Action self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Action_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_Action self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Action_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_Action self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Action_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_Action self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Action_HasDescription(self, *args)


    def ChosenMethod(self, *args):
        """
        ChosenMethod(StepBasic_Action self) -> Handle_StepBasic_ActionMethod

        Returns field ChosenMethod

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.StepBasic_Action_ChosenMethod(self, *args)


    def SetChosenMethod(self, *args):
        """
        SetChosenMethod(StepBasic_Action self, Handle_StepBasic_ActionMethod ChosenMethod)

        Set field ChosenMethod

        :type ChosenMethod: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.StepBasic_Action_SetChosenMethod(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Action_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Action_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Action_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Action
StepBasic_Action_swigregister = _StepBasic.StepBasic_Action_swigregister
StepBasic_Action_swigregister(StepBasic_Action)

def StepBasic_Action_get_type_name(*args):
    """
    StepBasic_Action_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Action_get_type_name(*args)

def StepBasic_Action_get_type_descriptor(*args):
    """
    StepBasic_Action_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Action_get_type_descriptor(*args)

class StepBasic_OrdinalDate(StepBasic_Date):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_OrdinalDate
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_OrdinalDate(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_OrdinalDate self) -> StepBasic_OrdinalDate

        Returns a OrdinalDate


        """
        this = _StepBasic.new_StepBasic_OrdinalDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_OrdinalDate self, Standard_Integer const aYearComponent, Standard_Integer const aDayComponent)

        :type aYearComponent: int
        :type aDayComponent: int

        """
        return _StepBasic.StepBasic_OrdinalDate_Init(self, *args)


    def SetDayComponent(self, *args):
        """
        SetDayComponent(StepBasic_OrdinalDate self, Standard_Integer const aDayComponent)

        :type aDayComponent: int

        """
        return _StepBasic.StepBasic_OrdinalDate_SetDayComponent(self, *args)


    def DayComponent(self, *args):
        """
        DayComponent(StepBasic_OrdinalDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_OrdinalDate_DayComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_OrdinalDate_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_OrdinalDate_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_OrdinalDate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_OrdinalDate
StepBasic_OrdinalDate_swigregister = _StepBasic.StepBasic_OrdinalDate_swigregister
StepBasic_OrdinalDate_swigregister(StepBasic_OrdinalDate)

def StepBasic_OrdinalDate_get_type_name(*args):
    """
    StepBasic_OrdinalDate_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_OrdinalDate_get_type_name(*args)

def StepBasic_OrdinalDate_get_type_descriptor(*args):
    """
    StepBasic_OrdinalDate_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_OrdinalDate_get_type_descriptor(*args)

class StepBasic_CertificationType(Standard.Standard_Transient):
    """Representation of STEP entity CertificationType"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_CertificationType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_CertificationType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_CertificationType self) -> StepBasic_CertificationType

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_CertificationType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_CertificationType self, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CertificationType_Init(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_CertificationType self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CertificationType_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_CertificationType self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CertificationType_SetDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_CertificationType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_CertificationType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_CertificationType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_CertificationType
StepBasic_CertificationType_swigregister = _StepBasic.StepBasic_CertificationType_swigregister
StepBasic_CertificationType_swigregister(StepBasic_CertificationType)

def StepBasic_CertificationType_get_type_name(*args):
    """
    StepBasic_CertificationType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_CertificationType_get_type_name(*args)

def StepBasic_CertificationType_get_type_descriptor(*args):
    """
    StepBasic_CertificationType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_CertificationType_get_type_descriptor(*args)

class StepBasic_DateAndTimeAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DateAndTimeAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DateAndTimeAssignment(self) 
            return h


    def Init(self, *args):
        """
        Init(StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateAndTime aAssignedDateAndTime, Handle_StepBasic_DateTimeRole aRole)

        :type aAssignedDateAndTime: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_Init(self, *args)


    def SetAssignedDateAndTime(self, *args):
        """
        SetAssignedDateAndTime(StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateAndTime aAssignedDateAndTime)

        :type aAssignedDateAndTime: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_SetAssignedDateAndTime(self, *args)


    def AssignedDateAndTime(self, *args):
        """
        AssignedDateAndTime(StepBasic_DateAndTimeAssignment self) -> Handle_StepBasic_DateAndTime

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_AssignedDateAndTime(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateTimeRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_DateAndTimeAssignment self) -> Handle_StepBasic_DateTimeRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_Role(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DateAndTimeAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DateAndTimeAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_DateAndTimeAssignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_DateAndTimeAssignment
StepBasic_DateAndTimeAssignment_swigregister = _StepBasic.StepBasic_DateAndTimeAssignment_swigregister
StepBasic_DateAndTimeAssignment_swigregister(StepBasic_DateAndTimeAssignment)

def StepBasic_DateAndTimeAssignment_get_type_name(*args):
    """
    StepBasic_DateAndTimeAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DateAndTimeAssignment_get_type_name(*args)

def StepBasic_DateAndTimeAssignment_get_type_descriptor(*args):
    """
    StepBasic_DateAndTimeAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DateAndTimeAssignment_get_type_descriptor(*args)

class StepBasic_PersonalAddress(StepBasic_Address):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PersonalAddress
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PersonalAddress(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_PersonalAddress self) -> StepBasic_PersonalAddress

        Returns a PersonalAddress


        """
        this = _StepBasic.new_StepBasic_PersonalAddress(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_PersonalAddress self, Standard_Boolean const hasAinternalLocation, Handle_TCollection_HAsciiString aInternalLocation, Standard_Boolean const hasAstreetNumber, Handle_TCollection_HAsciiString aStreetNumber, Standard_Boolean const hasAstreet, Handle_TCollection_HAsciiString aStreet, Standard_Boolean const hasApostalBox, Handle_TCollection_HAsciiString aPostalBox, Standard_Boolean const hasAtown, Handle_TCollection_HAsciiString aTown, Standard_Boolean const hasAregion, Handle_TCollection_HAsciiString aRegion, Standard_Boolean const hasApostalCode, Handle_TCollection_HAsciiString aPostalCode, Standard_Boolean const hasAcountry, Handle_TCollection_HAsciiString aCountry, Standard_Boolean const hasAfacsimileNumber, Handle_TCollection_HAsciiString aFacsimileNumber, Standard_Boolean const hasAtelephoneNumber, Handle_TCollection_HAsciiString aTelephoneNumber, Standard_Boolean const hasAelectronicMailAddress, Handle_TCollection_HAsciiString aElectronicMailAddress, Standard_Boolean const hasAtelexNumber, Handle_TCollection_HAsciiString aTelexNumber, Handle_StepBasic_HArray1OfPerson aPeople, Handle_TCollection_HAsciiString aDescription)

        :type hasAinternalLocation: bool
        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreetNumber: bool
        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreet: bool
        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalBox: bool
        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtown: bool
        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAregion: bool
        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalCode: bool
        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAcountry: bool
        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfacsimileNumber: bool
        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelephoneNumber: bool
        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAelectronicMailAddress: bool
        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelexNumber: bool
        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPeople: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfPerson
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_PersonalAddress_Init(self, *args)


    def SetPeople(self, *args):
        """
        SetPeople(StepBasic_PersonalAddress self, Handle_StepBasic_HArray1OfPerson aPeople)

        :type aPeople: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfPerson

        """
        return _StepBasic.StepBasic_PersonalAddress_SetPeople(self, *args)


    def People(self, *args):
        """
        People(StepBasic_PersonalAddress self) -> Handle_StepBasic_HArray1OfPerson

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfPerson

        """
        return _StepBasic.StepBasic_PersonalAddress_People(self, *args)


    def PeopleValue(self, *args):
        """
        PeopleValue(StepBasic_PersonalAddress self, Standard_Integer const num) -> Handle_StepBasic_Person

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.StepBasic_PersonalAddress_PeopleValue(self, *args)


    def NbPeople(self, *args):
        """
        NbPeople(StepBasic_PersonalAddress self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_PersonalAddress_NbPeople(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_PersonalAddress_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_PersonalAddress_Description(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PersonalAddress_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PersonalAddress_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PersonalAddress_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_PersonalAddress
StepBasic_PersonalAddress_swigregister = _StepBasic.StepBasic_PersonalAddress_swigregister
StepBasic_PersonalAddress_swigregister(StepBasic_PersonalAddress)

def StepBasic_PersonalAddress_get_type_name(*args):
    """
    StepBasic_PersonalAddress_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PersonalAddress_get_type_name(*args)

def StepBasic_PersonalAddress_get_type_descriptor(*args):
    """
    StepBasic_PersonalAddress_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PersonalAddress_get_type_descriptor(*args)

class StepBasic_CoordinatedUniversalTimeOffset(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_CoordinatedUniversalTimeOffset
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_CoordinatedUniversalTimeOffset(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_CoordinatedUniversalTimeOffset self) -> StepBasic_CoordinatedUniversalTimeOffset

        Returns a CoordinatedUniversalTimeOffset


        """
        this = _StepBasic.new_StepBasic_CoordinatedUniversalTimeOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_CoordinatedUniversalTimeOffset self, Standard_Integer const aHourOffset, Standard_Boolean const hasAminuteOffset, Standard_Integer const aMinuteOffset, StepBasic_AheadOrBehind const aSense)

        :type aHourOffset: int
        :type hasAminuteOffset: bool
        :type aMinuteOffset: int
        :type aSense: OCC.wrapper.StepBasic.StepBasic_AheadOrBehind

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_Init(self, *args)


    def SetHourOffset(self, *args):
        """
        SetHourOffset(StepBasic_CoordinatedUniversalTimeOffset self, Standard_Integer const aHourOffset)

        :type aHourOffset: int

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_SetHourOffset(self, *args)


    def HourOffset(self, *args):
        """
        HourOffset(StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_HourOffset(self, *args)


    def SetMinuteOffset(self, *args):
        """
        SetMinuteOffset(StepBasic_CoordinatedUniversalTimeOffset self, Standard_Integer const aMinuteOffset)

        :type aMinuteOffset: int

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_SetMinuteOffset(self, *args)


    def UnSetMinuteOffset(self, *args):
        """UnSetMinuteOffset(StepBasic_CoordinatedUniversalTimeOffset self)"""
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_UnSetMinuteOffset(self, *args)


    def MinuteOffset(self, *args):
        """
        MinuteOffset(StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_MinuteOffset(self, *args)


    def HasMinuteOffset(self, *args):
        """
        HasMinuteOffset(StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_HasMinuteOffset(self, *args)


    def SetSense(self, *args):
        """
        SetSense(StepBasic_CoordinatedUniversalTimeOffset self, StepBasic_AheadOrBehind const aSense)

        :type aSense: OCC.wrapper.StepBasic.StepBasic_AheadOrBehind

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_SetSense(self, *args)


    def Sense(self, *args):
        """
        Sense(StepBasic_CoordinatedUniversalTimeOffset self) -> StepBasic_AheadOrBehind

        :rtype: OCC.wrapper.StepBasic.StepBasic_AheadOrBehind

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_Sense(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_CoordinatedUniversalTimeOffset
StepBasic_CoordinatedUniversalTimeOffset_swigregister = _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_swigregister
StepBasic_CoordinatedUniversalTimeOffset_swigregister(StepBasic_CoordinatedUniversalTimeOffset)

def StepBasic_CoordinatedUniversalTimeOffset_get_type_name(*args):
    """
    StepBasic_CoordinatedUniversalTimeOffset_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_get_type_name(*args)

def StepBasic_CoordinatedUniversalTimeOffset_get_type_descriptor(*args):
    """
    StepBasic_CoordinatedUniversalTimeOffset_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_CoordinatedUniversalTimeOffset_get_type_descriptor(*args)

class StepBasic_PersonAndOrganizationAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PersonAndOrganizationAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PersonAndOrganizationAssignment(self) 
            return h


    def Init(self, *args):
        """
        Init(StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganization aAssignedPersonAndOrganization, Handle_StepBasic_PersonAndOrganizationRole aRole)

        :type aAssignedPersonAndOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_Init(self, *args)


    def SetAssignedPersonAndOrganization(self, *args):
        """
        SetAssignedPersonAndOrganization(StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganization aAssignedPersonAndOrganization)

        :type aAssignedPersonAndOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_SetAssignedPersonAndOrganization(self, *args)


    def AssignedPersonAndOrganization(self, *args):
        """
        AssignedPersonAndOrganization(StepBasic_PersonAndOrganizationAssignment self) -> Handle_StepBasic_PersonAndOrganization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_AssignedPersonAndOrganization(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganizationRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_PersonAndOrganizationAssignment self) -> Handle_StepBasic_PersonAndOrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_Role(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PersonAndOrganizationAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PersonAndOrganizationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_PersonAndOrganizationAssignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_PersonAndOrganizationAssignment
StepBasic_PersonAndOrganizationAssignment_swigregister = _StepBasic.StepBasic_PersonAndOrganizationAssignment_swigregister
StepBasic_PersonAndOrganizationAssignment_swigregister(StepBasic_PersonAndOrganizationAssignment)

def StepBasic_PersonAndOrganizationAssignment_get_type_name(*args):
    """
    StepBasic_PersonAndOrganizationAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PersonAndOrganizationAssignment_get_type_name(*args)

def StepBasic_PersonAndOrganizationAssignment_get_type_descriptor(*args):
    """
    StepBasic_PersonAndOrganizationAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PersonAndOrganizationAssignment_get_type_descriptor(*args)

class StepBasic_ActionMethod(Standard.Standard_Transient):
    """Representation of STEP entity ActionMethod"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ActionMethod
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ActionMethod(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ActionMethod self) -> StepBasic_ActionMethod

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ActionMethod(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ActionMethod self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_TCollection_HAsciiString aConsequence, Handle_TCollection_HAsciiString aPurpose)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConsequence: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_ActionMethod self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_ActionMethod_HasDescription(self, *args)


    def Consequence(self, *args):
        """
        Consequence(StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Consequence

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_Consequence(self, *args)


    def SetConsequence(self, *args):
        """
        SetConsequence(StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Consequence)

        Set field Consequence

        :type Consequence: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_SetConsequence(self, *args)


    def Purpose(self, *args):
        """
        Purpose(StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ActionMethod_SetPurpose(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ActionMethod_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ActionMethod_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ActionMethod_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ActionMethod
StepBasic_ActionMethod_swigregister = _StepBasic.StepBasic_ActionMethod_swigregister
StepBasic_ActionMethod_swigregister(StepBasic_ActionMethod)

def StepBasic_ActionMethod_get_type_name(*args):
    """
    StepBasic_ActionMethod_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ActionMethod_get_type_name(*args)

def StepBasic_ActionMethod_get_type_descriptor(*args):
    """
    StepBasic_ActionMethod_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ActionMethod_get_type_descriptor(*args)

class StepBasic_DerivedUnitElement(Standard.Standard_Transient):
    """Added from StepBasic Rev2 to Rev4"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DerivedUnitElement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DerivedUnitElement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DerivedUnitElement self) -> StepBasic_DerivedUnitElement

        Added from StepBasic Rev2 to Rev4
        """
        this = _StepBasic.new_StepBasic_DerivedUnitElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DerivedUnitElement self, Handle_StepBasic_NamedUnit aUnit, Standard_Real const aExponent)

        :type aUnit: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit
        :type aExponent: float

        """
        return _StepBasic.StepBasic_DerivedUnitElement_Init(self, *args)


    def SetUnit(self, *args):
        """
        SetUnit(StepBasic_DerivedUnitElement self, Handle_StepBasic_NamedUnit aUnit)

        :type aUnit: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit

        """
        return _StepBasic.StepBasic_DerivedUnitElement_SetUnit(self, *args)


    def Unit(self, *args):
        """
        Unit(StepBasic_DerivedUnitElement self) -> Handle_StepBasic_NamedUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit

        """
        return _StepBasic.StepBasic_DerivedUnitElement_Unit(self, *args)


    def SetExponent(self, *args):
        """
        SetExponent(StepBasic_DerivedUnitElement self, Standard_Real const aExponent)

        :type aExponent: float

        """
        return _StepBasic.StepBasic_DerivedUnitElement_SetExponent(self, *args)


    def Exponent(self, *args):
        """
        Exponent(StepBasic_DerivedUnitElement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DerivedUnitElement_Exponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DerivedUnitElement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DerivedUnitElement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DerivedUnitElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DerivedUnitElement
StepBasic_DerivedUnitElement_swigregister = _StepBasic.StepBasic_DerivedUnitElement_swigregister
StepBasic_DerivedUnitElement_swigregister(StepBasic_DerivedUnitElement)

def StepBasic_DerivedUnitElement_get_type_name(*args):
    """
    StepBasic_DerivedUnitElement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DerivedUnitElement_get_type_name(*args)

def StepBasic_DerivedUnitElement_get_type_descriptor(*args):
    """
    StepBasic_DerivedUnitElement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DerivedUnitElement_get_type_descriptor(*args)

class StepBasic_HArray1OfOrganization(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfOrganization
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfOrganization(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfOrganization self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfOrganization
        __init__(StepBasic_HArray1OfOrganization self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_Organization theValue) -> StepBasic_HArray1OfOrganization
        __init__(StepBasic_HArray1OfOrganization self, NCollection_Array1_Handle_StepBasic_Organization theOther) -> StepBasic_HArray1OfOrganization

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfOrganization

        """
        this = _StepBasic.new_StepBasic_HArray1OfOrganization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfOrganization

        """
        res = _StepBasic.StepBasic_HArray1OfOrganization_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfOrganization self) -> NCollection_Array1_Handle_StepBasic_Organization

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfOrganization

        """
        return _StepBasic.StepBasic_HArray1OfOrganization_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfOrganization_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfOrganization_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfOrganization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfOrganization
StepBasic_HArray1OfOrganization_swigregister = _StepBasic.StepBasic_HArray1OfOrganization_swigregister
StepBasic_HArray1OfOrganization_swigregister(StepBasic_HArray1OfOrganization)

def StepBasic_HArray1OfOrganization_get_type_name(*args):
    """
    StepBasic_HArray1OfOrganization_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfOrganization_get_type_name(*args)

def StepBasic_HArray1OfOrganization_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfOrganization_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfOrganization_get_type_descriptor(*args)

class StepBasic_HArray1OfUncertaintyMeasureWithUnit(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfUncertaintyMeasureWithUnit
        __init__(StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_UncertaintyMeasureWithUnit theValue) -> StepBasic_HArray1OfUncertaintyMeasureWithUnit
        __init__(StepBasic_HArray1OfUncertaintyMeasureWithUnit self, NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit theOther) -> StepBasic_HArray1OfUncertaintyMeasureWithUnit

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfUncertaintyMeasureWithUnit

        """
        this = _StepBasic.new_StepBasic_HArray1OfUncertaintyMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfUncertaintyMeasureWithUnit

        """
        res = _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfUncertaintyMeasureWithUnit

        """
        return _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfUncertaintyMeasureWithUnit
StepBasic_HArray1OfUncertaintyMeasureWithUnit_swigregister = _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_swigregister
StepBasic_HArray1OfUncertaintyMeasureWithUnit_swigregister(StepBasic_HArray1OfUncertaintyMeasureWithUnit)

def StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_name(*args)

def StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_descriptor(*args)

class StepBasic_DimensionalExponents(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DimensionalExponents
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DimensionalExponents(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DimensionalExponents self) -> StepBasic_DimensionalExponents

        Returns a DimensionalExponents


        """
        this = _StepBasic.new_StepBasic_DimensionalExponents(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DimensionalExponents self, Standard_Real const aLengthExponent, Standard_Real const aMassExponent, Standard_Real const aTimeExponent, Standard_Real const aElectricCurrentExponent, Standard_Real const aThermodynamicTemperatureExponent, Standard_Real const aAmountOfSubstanceExponent, Standard_Real const aLuminousIntensityExponent)

        :type aLengthExponent: float
        :type aMassExponent: float
        :type aTimeExponent: float
        :type aElectricCurrentExponent: float
        :type aThermodynamicTemperatureExponent: float
        :type aAmountOfSubstanceExponent: float
        :type aLuminousIntensityExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_Init(self, *args)


    def SetLengthExponent(self, *args):
        """
        SetLengthExponent(StepBasic_DimensionalExponents self, Standard_Real const aLengthExponent)

        :type aLengthExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetLengthExponent(self, *args)


    def LengthExponent(self, *args):
        """
        LengthExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_LengthExponent(self, *args)


    def SetMassExponent(self, *args):
        """
        SetMassExponent(StepBasic_DimensionalExponents self, Standard_Real const aMassExponent)

        :type aMassExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetMassExponent(self, *args)


    def MassExponent(self, *args):
        """
        MassExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_MassExponent(self, *args)


    def SetTimeExponent(self, *args):
        """
        SetTimeExponent(StepBasic_DimensionalExponents self, Standard_Real const aTimeExponent)

        :type aTimeExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetTimeExponent(self, *args)


    def TimeExponent(self, *args):
        """
        TimeExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_TimeExponent(self, *args)


    def SetElectricCurrentExponent(self, *args):
        """
        SetElectricCurrentExponent(StepBasic_DimensionalExponents self, Standard_Real const aElectricCurrentExponent)

        :type aElectricCurrentExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetElectricCurrentExponent(self, *args)


    def ElectricCurrentExponent(self, *args):
        """
        ElectricCurrentExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_ElectricCurrentExponent(self, *args)


    def SetThermodynamicTemperatureExponent(self, *args):
        """
        SetThermodynamicTemperatureExponent(StepBasic_DimensionalExponents self, Standard_Real const aThermodynamicTemperatureExponent)

        :type aThermodynamicTemperatureExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetThermodynamicTemperatureExponent(self, *args)


    def ThermodynamicTemperatureExponent(self, *args):
        """
        ThermodynamicTemperatureExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_ThermodynamicTemperatureExponent(self, *args)


    def SetAmountOfSubstanceExponent(self, *args):
        """
        SetAmountOfSubstanceExponent(StepBasic_DimensionalExponents self, Standard_Real const aAmountOfSubstanceExponent)

        :type aAmountOfSubstanceExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetAmountOfSubstanceExponent(self, *args)


    def AmountOfSubstanceExponent(self, *args):
        """
        AmountOfSubstanceExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_AmountOfSubstanceExponent(self, *args)


    def SetLuminousIntensityExponent(self, *args):
        """
        SetLuminousIntensityExponent(StepBasic_DimensionalExponents self, Standard_Real const aLuminousIntensityExponent)

        :type aLuminousIntensityExponent: float

        """
        return _StepBasic.StepBasic_DimensionalExponents_SetLuminousIntensityExponent(self, *args)


    def LuminousIntensityExponent(self, *args):
        """
        LuminousIntensityExponent(StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_DimensionalExponents_LuminousIntensityExponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DimensionalExponents_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DimensionalExponents_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DimensionalExponents_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DimensionalExponents
StepBasic_DimensionalExponents_swigregister = _StepBasic.StepBasic_DimensionalExponents_swigregister
StepBasic_DimensionalExponents_swigregister(StepBasic_DimensionalExponents)

def StepBasic_DimensionalExponents_get_type_name(*args):
    """
    StepBasic_DimensionalExponents_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DimensionalExponents_get_type_name(*args)

def StepBasic_DimensionalExponents_get_type_descriptor(*args):
    """
    StepBasic_DimensionalExponents_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DimensionalExponents_get_type_descriptor(*args)

class StepBasic_ConversionBasedUnitAndSolidAngleUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> StepBasic_ConversionBasedUnitAndSolidAngleUnit

        Returns a ConversionBasedUnitAndSolidAngleUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndSolidAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_Init(self, *args)


    def SetSolidAngleUnit(self, *args):
        """
        SetSolidAngleUnit(StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_SolidAngleUnit aSolidAngleUnit)

        :type aSolidAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_SetSolidAngleUnit(self, *args)


    def SolidAngleUnit(self, *args):
        """
        SolidAngleUnit(StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Handle_StepBasic_SolidAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_SolidAngleUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndSolidAngleUnit
StepBasic_ConversionBasedUnitAndSolidAngleUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_swigregister
StepBasic_ConversionBasedUnitAndSolidAngleUnit_swigregister(StepBasic_ConversionBasedUnitAndSolidAngleUnit)

def StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_descriptor(*args)

class StepBasic_DocumentReference(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentReference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentReference(self) 
            return h


    def Init0(self, *args):
        """
        Init0(StepBasic_DocumentReference self, Handle_StepBasic_Document aAssignedDocument, Handle_TCollection_HAsciiString aSource)

        :type aAssignedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aSource: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentReference_Init0(self, *args)


    def AssignedDocument(self, *args):
        """
        AssignedDocument(StepBasic_DocumentReference self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentReference_AssignedDocument(self, *args)


    def SetAssignedDocument(self, *args):
        """
        SetAssignedDocument(StepBasic_DocumentReference self, Handle_StepBasic_Document aAssignedDocument)

        :type aAssignedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentReference_SetAssignedDocument(self, *args)


    def Source(self, *args):
        """
        Source(StepBasic_DocumentReference self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentReference_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepBasic_DocumentReference self, Handle_TCollection_HAsciiString aSource)

        :type aSource: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentReference_SetSource(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentReference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentReference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentReference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_DocumentReference()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentReference
StepBasic_DocumentReference_swigregister = _StepBasic.StepBasic_DocumentReference_swigregister
StepBasic_DocumentReference_swigregister(StepBasic_DocumentReference)

def StepBasic_DocumentReference_get_type_name(*args):
    """
    StepBasic_DocumentReference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentReference_get_type_name(*args)

def StepBasic_DocumentReference_get_type_descriptor(*args):
    """
    StepBasic_DocumentReference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentReference_get_type_descriptor(*args)

class StepBasic_ContractType(Standard.Standard_Transient):
    """Representation of STEP entity ContractType"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ContractType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ContractType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ContractType self) -> StepBasic_ContractType

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ContractType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ContractType self, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ContractType_Init(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ContractType self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ContractType_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ContractType self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ContractType_SetDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ContractType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ContractType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ContractType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ContractType
StepBasic_ContractType_swigregister = _StepBasic.StepBasic_ContractType_swigregister
StepBasic_ContractType_swigregister(StepBasic_ContractType)

def StepBasic_ContractType_get_type_name(*args):
    """
    StepBasic_ContractType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ContractType_get_type_name(*args)

def StepBasic_ContractType_get_type_descriptor(*args):
    """
    StepBasic_ContractType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ContractType_get_type_descriptor(*args)

class StepBasic_EulerAngles(Standard.Standard_Transient):
    """Representation of STEP entity EulerAngles"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_EulerAngles
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_EulerAngles(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_EulerAngles self) -> StepBasic_EulerAngles

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_EulerAngles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_EulerAngles self, Handle_TColStd_HArray1OfReal aAngles)

        Initialize all fields (own and inherited)

        :type aAngles: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepBasic.StepBasic_EulerAngles_Init(self, *args)


    def Angles(self, *args):
        """
        Angles(StepBasic_EulerAngles self) -> Handle_TColStd_HArray1OfReal

        Returns field Angles

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepBasic.StepBasic_EulerAngles_Angles(self, *args)


    def SetAngles(self, *args):
        """
        SetAngles(StepBasic_EulerAngles self, Handle_TColStd_HArray1OfReal Angles)

        Set field Angles

        :type Angles: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepBasic.StepBasic_EulerAngles_SetAngles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_EulerAngles_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_EulerAngles_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_EulerAngles_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_EulerAngles
StepBasic_EulerAngles_swigregister = _StepBasic.StepBasic_EulerAngles_swigregister
StepBasic_EulerAngles_swigregister(StepBasic_EulerAngles)

def StepBasic_EulerAngles_get_type_name(*args):
    """
    StepBasic_EulerAngles_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_EulerAngles_get_type_name(*args)

def StepBasic_EulerAngles_get_type_descriptor(*args):
    """
    StepBasic_EulerAngles_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_EulerAngles_get_type_descriptor(*args)

class StepBasic_DateAndTime(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DateAndTime
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DateAndTime(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DateAndTime self) -> StepBasic_DateAndTime

        Returns a DateAndTime


        """
        this = _StepBasic.new_StepBasic_DateAndTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DateAndTime self, Handle_StepBasic_Date aDateComponent, Handle_StepBasic_LocalTime aTimeComponent)

        :type aDateComponent: OCC.wrapper.StepBasic.Handle_StepBasic_Date
        :type aTimeComponent: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.StepBasic_DateAndTime_Init(self, *args)


    def SetDateComponent(self, *args):
        """
        SetDateComponent(StepBasic_DateAndTime self, Handle_StepBasic_Date aDateComponent)

        :type aDateComponent: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.StepBasic_DateAndTime_SetDateComponent(self, *args)


    def DateComponent(self, *args):
        """
        DateComponent(StepBasic_DateAndTime self) -> Handle_StepBasic_Date

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.StepBasic_DateAndTime_DateComponent(self, *args)


    def SetTimeComponent(self, *args):
        """
        SetTimeComponent(StepBasic_DateAndTime self, Handle_StepBasic_LocalTime aTimeComponent)

        :type aTimeComponent: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.StepBasic_DateAndTime_SetTimeComponent(self, *args)


    def TimeComponent(self, *args):
        """
        TimeComponent(StepBasic_DateAndTime self) -> Handle_StepBasic_LocalTime

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.StepBasic_DateAndTime_TimeComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DateAndTime_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DateAndTime_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DateAndTime_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DateAndTime
StepBasic_DateAndTime_swigregister = _StepBasic.StepBasic_DateAndTime_swigregister
StepBasic_DateAndTime_swigregister(StepBasic_DateAndTime)

def StepBasic_DateAndTime_get_type_name(*args):
    """
    StepBasic_DateAndTime_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DateAndTime_get_type_name(*args)

def StepBasic_DateAndTime_get_type_descriptor(*args):
    """
    StepBasic_DateAndTime_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DateAndTime_get_type_descriptor(*args)

class StepBasic_IdentificationAssignment(Standard.Standard_Transient):
    """Representation of STEP entity IdentificationAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_IdentificationAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_IdentificationAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_IdentificationAssignment self) -> StepBasic_IdentificationAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_IdentificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_IdentificationAssignment self, Handle_TCollection_HAsciiString aAssignedId, Handle_StepBasic_IdentificationRole aRole)

        Initialize all fields (own and inherited)

        :type aAssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.StepBasic_IdentificationAssignment_Init(self, *args)


    def AssignedId(self, *args):
        """
        AssignedId(StepBasic_IdentificationAssignment self) -> Handle_TCollection_HAsciiString

        Returns field AssignedId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationAssignment_AssignedId(self, *args)


    def SetAssignedId(self, *args):
        """
        SetAssignedId(StepBasic_IdentificationAssignment self, Handle_TCollection_HAsciiString AssignedId)

        Set field AssignedId

        :type AssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_IdentificationAssignment_SetAssignedId(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_IdentificationAssignment self) -> Handle_StepBasic_IdentificationRole

        Returns field Role

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.StepBasic_IdentificationAssignment_Role(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_IdentificationAssignment self, Handle_StepBasic_IdentificationRole Role)

        Set field Role

        :type Role: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.StepBasic_IdentificationAssignment_SetRole(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_IdentificationAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_IdentificationAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_IdentificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_IdentificationAssignment
StepBasic_IdentificationAssignment_swigregister = _StepBasic.StepBasic_IdentificationAssignment_swigregister
StepBasic_IdentificationAssignment_swigregister(StepBasic_IdentificationAssignment)

def StepBasic_IdentificationAssignment_get_type_name(*args):
    """
    StepBasic_IdentificationAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_IdentificationAssignment_get_type_name(*args)

def StepBasic_IdentificationAssignment_get_type_descriptor(*args):
    """
    StepBasic_IdentificationAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_IdentificationAssignment_get_type_descriptor(*args)

class StepBasic_TimeMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_TimeMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_TimeMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_TimeMeasureWithUnit self) -> StepBasic_TimeMeasureWithUnit

        Returns a TimeMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_TimeMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_TimeMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_TimeMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_TimeMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_TimeMeasureWithUnit
StepBasic_TimeMeasureWithUnit_swigregister = _StepBasic.StepBasic_TimeMeasureWithUnit_swigregister
StepBasic_TimeMeasureWithUnit_swigregister(StepBasic_TimeMeasureWithUnit)

def StepBasic_TimeMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_TimeMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_TimeMeasureWithUnit_get_type_name(*args)

def StepBasic_TimeMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_TimeMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_TimeMeasureWithUnit_get_type_descriptor(*args)

class StepBasic_SiUnitAndVolumeUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndVolumeUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndVolumeUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndVolumeUnit self) -> StepBasic_SiUnitAndVolumeUnit

        Returns a SiUnitAndVolumeUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndVolumeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetVolumeUnit(self, *args):
        """
        SetVolumeUnit(StepBasic_SiUnitAndVolumeUnit self, Handle_StepBasic_VolumeUnit aVolumeUnit)

        :type aVolumeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.StepBasic_SiUnitAndVolumeUnit_SetVolumeUnit(self, *args)


    def VolumeUnit(self, *args):
        """
        VolumeUnit(StepBasic_SiUnitAndVolumeUnit self) -> Handle_StepBasic_VolumeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.StepBasic_SiUnitAndVolumeUnit_VolumeUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndVolumeUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndVolumeUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndVolumeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndVolumeUnit
StepBasic_SiUnitAndVolumeUnit_swigregister = _StepBasic.StepBasic_SiUnitAndVolumeUnit_swigregister
StepBasic_SiUnitAndVolumeUnit_swigregister(StepBasic_SiUnitAndVolumeUnit)

def StepBasic_SiUnitAndVolumeUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndVolumeUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndVolumeUnit_get_type_name(*args)

def StepBasic_SiUnitAndVolumeUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndVolumeUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndVolumeUnit_get_type_descriptor(*args)

class StepBasic_SolidAngleUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SolidAngleUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SolidAngleUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SolidAngleUnit self) -> StepBasic_SolidAngleUnit

        Returns a SolidAngleUnit


        """
        this = _StepBasic.new_StepBasic_SolidAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SolidAngleUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SolidAngleUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SolidAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SolidAngleUnit
StepBasic_SolidAngleUnit_swigregister = _StepBasic.StepBasic_SolidAngleUnit_swigregister
StepBasic_SolidAngleUnit_swigregister(StepBasic_SolidAngleUnit)

def StepBasic_SolidAngleUnit_get_type_name(*args):
    """
    StepBasic_SolidAngleUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SolidAngleUnit_get_type_name(*args)

def StepBasic_SolidAngleUnit_get_type_descriptor(*args):
    """
    StepBasic_SolidAngleUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SolidAngleUnit_get_type_descriptor(*args)

class StepBasic_ApplicationContext(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApplicationContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApplicationContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApplicationContext self) -> StepBasic_ApplicationContext

        Returns a ApplicationContext


        """
        this = _StepBasic.new_StepBasic_ApplicationContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApplicationContext self, Handle_TCollection_HAsciiString aApplication)

        :type aApplication: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationContext_Init(self, *args)


    def SetApplication(self, *args):
        """
        SetApplication(StepBasic_ApplicationContext self, Handle_TCollection_HAsciiString aApplication)

        :type aApplication: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationContext_SetApplication(self, *args)


    def Application(self, *args):
        """
        Application(StepBasic_ApplicationContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationContext_Application(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApplicationContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApplicationContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApplicationContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApplicationContext
StepBasic_ApplicationContext_swigregister = _StepBasic.StepBasic_ApplicationContext_swigregister
StepBasic_ApplicationContext_swigregister(StepBasic_ApplicationContext)

def StepBasic_ApplicationContext_get_type_name(*args):
    """
    StepBasic_ApplicationContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApplicationContext_get_type_name(*args)

def StepBasic_ApplicationContext_get_type_descriptor(*args):
    """
    StepBasic_ApplicationContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApplicationContext_get_type_descriptor(*args)

class StepBasic_Person(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Person
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Person(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Person self) -> StepBasic_Person

        Returns a Person


        """
        this = _StepBasic.new_StepBasic_Person(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Person self, Handle_TCollection_HAsciiString aId, Standard_Boolean const hasAlastName, Handle_TCollection_HAsciiString aLastName, Standard_Boolean const hasAfirstName, Handle_TCollection_HAsciiString aFirstName, Standard_Boolean const hasAmiddleNames, Handle_Interface_HArray1OfHAsciiString aMiddleNames, Standard_Boolean const hasAprefixTitles, Handle_Interface_HArray1OfHAsciiString aPrefixTitles, Standard_Boolean const hasAsuffixTitles, Handle_Interface_HArray1OfHAsciiString aSuffixTitles)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAlastName: bool
        :type aLastName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfirstName: bool
        :type aFirstName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAmiddleNames: bool
        :type aMiddleNames: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString
        :type hasAprefixTitles: bool
        :type aPrefixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString
        :type hasAsuffixTitles: bool
        :type aSuffixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_Person self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_SetId(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_Person self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_Id(self, *args)


    def SetLastName(self, *args):
        """
        SetLastName(StepBasic_Person self, Handle_TCollection_HAsciiString aLastName)

        :type aLastName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_SetLastName(self, *args)


    def UnSetLastName(self, *args):
        """UnSetLastName(StepBasic_Person self)"""
        return _StepBasic.StepBasic_Person_UnSetLastName(self, *args)


    def LastName(self, *args):
        """
        LastName(StepBasic_Person self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_LastName(self, *args)


    def HasLastName(self, *args):
        """
        HasLastName(StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Person_HasLastName(self, *args)


    def SetFirstName(self, *args):
        """
        SetFirstName(StepBasic_Person self, Handle_TCollection_HAsciiString aFirstName)

        :type aFirstName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_SetFirstName(self, *args)


    def UnSetFirstName(self, *args):
        """UnSetFirstName(StepBasic_Person self)"""
        return _StepBasic.StepBasic_Person_UnSetFirstName(self, *args)


    def FirstName(self, *args):
        """
        FirstName(StepBasic_Person self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_FirstName(self, *args)


    def HasFirstName(self, *args):
        """
        HasFirstName(StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Person_HasFirstName(self, *args)


    def SetMiddleNames(self, *args):
        """
        SetMiddleNames(StepBasic_Person self, Handle_Interface_HArray1OfHAsciiString aMiddleNames)

        :type aMiddleNames: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_SetMiddleNames(self, *args)


    def UnSetMiddleNames(self, *args):
        """UnSetMiddleNames(StepBasic_Person self)"""
        return _StepBasic.StepBasic_Person_UnSetMiddleNames(self, *args)


    def MiddleNames(self, *args):
        """
        MiddleNames(StepBasic_Person self) -> Handle_Interface_HArray1OfHAsciiString

        :rtype: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_MiddleNames(self, *args)


    def HasMiddleNames(self, *args):
        """
        HasMiddleNames(StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Person_HasMiddleNames(self, *args)


    def MiddleNamesValue(self, *args):
        """
        MiddleNamesValue(StepBasic_Person self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_MiddleNamesValue(self, *args)


    def NbMiddleNames(self, *args):
        """
        NbMiddleNames(StepBasic_Person self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_Person_NbMiddleNames(self, *args)


    def SetPrefixTitles(self, *args):
        """
        SetPrefixTitles(StepBasic_Person self, Handle_Interface_HArray1OfHAsciiString aPrefixTitles)

        :type aPrefixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_SetPrefixTitles(self, *args)


    def UnSetPrefixTitles(self, *args):
        """UnSetPrefixTitles(StepBasic_Person self)"""
        return _StepBasic.StepBasic_Person_UnSetPrefixTitles(self, *args)


    def PrefixTitles(self, *args):
        """
        PrefixTitles(StepBasic_Person self) -> Handle_Interface_HArray1OfHAsciiString

        :rtype: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_PrefixTitles(self, *args)


    def HasPrefixTitles(self, *args):
        """
        HasPrefixTitles(StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Person_HasPrefixTitles(self, *args)


    def PrefixTitlesValue(self, *args):
        """
        PrefixTitlesValue(StepBasic_Person self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_PrefixTitlesValue(self, *args)


    def NbPrefixTitles(self, *args):
        """
        NbPrefixTitles(StepBasic_Person self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_Person_NbPrefixTitles(self, *args)


    def SetSuffixTitles(self, *args):
        """
        SetSuffixTitles(StepBasic_Person self, Handle_Interface_HArray1OfHAsciiString aSuffixTitles)

        :type aSuffixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_SetSuffixTitles(self, *args)


    def UnSetSuffixTitles(self, *args):
        """UnSetSuffixTitles(StepBasic_Person self)"""
        return _StepBasic.StepBasic_Person_UnSetSuffixTitles(self, *args)


    def SuffixTitles(self, *args):
        """
        SuffixTitles(StepBasic_Person self) -> Handle_Interface_HArray1OfHAsciiString

        :rtype: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.StepBasic_Person_SuffixTitles(self, *args)


    def HasSuffixTitles(self, *args):
        """
        HasSuffixTitles(StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Person_HasSuffixTitles(self, *args)


    def SuffixTitlesValue(self, *args):
        """
        SuffixTitlesValue(StepBasic_Person self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Person_SuffixTitlesValue(self, *args)


    def NbSuffixTitles(self, *args):
        """
        NbSuffixTitles(StepBasic_Person self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_Person_NbSuffixTitles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Person_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Person_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Person_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Person
StepBasic_Person_swigregister = _StepBasic.StepBasic_Person_swigregister
StepBasic_Person_swigregister(StepBasic_Person)

def StepBasic_Person_get_type_name(*args):
    """
    StepBasic_Person_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Person_get_type_name(*args)

def StepBasic_Person_get_type_descriptor(*args):
    """
    StepBasic_Person_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Person_get_type_descriptor(*args)

class StepBasic_ApplicationProtocolDefinition(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApplicationProtocolDefinition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApplicationProtocolDefinition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApplicationProtocolDefinition self) -> StepBasic_ApplicationProtocolDefinition

        Returns a ApplicationProtocolDefinition


        """
        this = _StepBasic.new_StepBasic_ApplicationProtocolDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApplicationProtocolDefinition self, Handle_TCollection_HAsciiString aStatus, Handle_TCollection_HAsciiString aApplicationInterpretedModelSchemaName, Standard_Integer const aApplicationProtocolYear, Handle_StepBasic_ApplicationContext aApplication)

        :type aStatus: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aApplicationInterpretedModelSchemaName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aApplicationProtocolYear: int
        :type aApplication: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_Init(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(StepBasic_ApplicationProtocolDefinition self, Handle_TCollection_HAsciiString aStatus)

        :type aStatus: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_SetStatus(self, *args)


    def Status(self, *args):
        """
        Status(StepBasic_ApplicationProtocolDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_Status(self, *args)


    def SetApplicationInterpretedModelSchemaName(self, *args):
        """
        SetApplicationInterpretedModelSchemaName(StepBasic_ApplicationProtocolDefinition self, Handle_TCollection_HAsciiString aApplicationInterpretedModelSchemaName)

        :type aApplicationInterpretedModelSchemaName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_SetApplicationInterpretedModelSchemaName(self, *args)


    def ApplicationInterpretedModelSchemaName(self, *args):
        """
        ApplicationInterpretedModelSchemaName(StepBasic_ApplicationProtocolDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_ApplicationInterpretedModelSchemaName(self, *args)


    def SetApplicationProtocolYear(self, *args):
        """
        SetApplicationProtocolYear(StepBasic_ApplicationProtocolDefinition self, Standard_Integer const aApplicationProtocolYear)

        :type aApplicationProtocolYear: int

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_SetApplicationProtocolYear(self, *args)


    def ApplicationProtocolYear(self, *args):
        """
        ApplicationProtocolYear(StepBasic_ApplicationProtocolDefinition self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_ApplicationProtocolYear(self, *args)


    def SetApplication(self, *args):
        """
        SetApplication(StepBasic_ApplicationProtocolDefinition self, Handle_StepBasic_ApplicationContext aApplication)

        :type aApplication: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_SetApplication(self, *args)


    def Application(self, *args):
        """
        Application(StepBasic_ApplicationProtocolDefinition self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_Application(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApplicationProtocolDefinition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApplicationProtocolDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApplicationProtocolDefinition
StepBasic_ApplicationProtocolDefinition_swigregister = _StepBasic.StepBasic_ApplicationProtocolDefinition_swigregister
StepBasic_ApplicationProtocolDefinition_swigregister(StepBasic_ApplicationProtocolDefinition)

def StepBasic_ApplicationProtocolDefinition_get_type_name(*args):
    """
    StepBasic_ApplicationProtocolDefinition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApplicationProtocolDefinition_get_type_name(*args)

def StepBasic_ApplicationProtocolDefinition_get_type_descriptor(*args):
    """
    StepBasic_ApplicationProtocolDefinition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApplicationProtocolDefinition_get_type_descriptor(*args)

class StepBasic_Effectivity(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Effectivity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Effectivity(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_Effectivity self) -> StepBasic_Effectivity"""
        this = _StepBasic.new_StepBasic_Effectivity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Effectivity self, Handle_TCollection_HAsciiString aid)

        :type aid: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Effectivity_Init(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_Effectivity self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Effectivity_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_Effectivity self, Handle_TCollection_HAsciiString aid)

        :type aid: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Effectivity_SetId(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Effectivity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Effectivity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Effectivity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Effectivity
StepBasic_Effectivity_swigregister = _StepBasic.StepBasic_Effectivity_swigregister
StepBasic_Effectivity_swigregister(StepBasic_Effectivity)

def StepBasic_Effectivity_get_type_name(*args):
    """
    StepBasic_Effectivity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Effectivity_get_type_name(*args)

def StepBasic_Effectivity_get_type_descriptor(*args):
    """
    StepBasic_Effectivity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Effectivity_get_type_descriptor(*args)

class StepBasic_OrganizationAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_OrganizationAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_OrganizationAssignment(self) 
            return h


    def Init(self, *args):
        """
        Init(StepBasic_OrganizationAssignment self, Handle_StepBasic_Organization aAssignedOrganization, Handle_StepBasic_OrganizationRole aRole)

        :type aAssignedOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_OrganizationRole

        """
        return _StepBasic.StepBasic_OrganizationAssignment_Init(self, *args)


    def SetAssignedOrganization(self, *args):
        """
        SetAssignedOrganization(StepBasic_OrganizationAssignment self, Handle_StepBasic_Organization aAssignedOrganization)

        :type aAssignedOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_OrganizationAssignment_SetAssignedOrganization(self, *args)


    def AssignedOrganization(self, *args):
        """
        AssignedOrganization(StepBasic_OrganizationAssignment self) -> Handle_StepBasic_Organization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_OrganizationAssignment_AssignedOrganization(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_OrganizationAssignment self, Handle_StepBasic_OrganizationRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_OrganizationRole

        """
        return _StepBasic.StepBasic_OrganizationAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_OrganizationAssignment self) -> Handle_StepBasic_OrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_OrganizationRole

        """
        return _StepBasic.StepBasic_OrganizationAssignment_Role(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_OrganizationAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_OrganizationAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_OrganizationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_OrganizationAssignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_OrganizationAssignment
StepBasic_OrganizationAssignment_swigregister = _StepBasic.StepBasic_OrganizationAssignment_swigregister
StepBasic_OrganizationAssignment_swigregister(StepBasic_OrganizationAssignment)

def StepBasic_OrganizationAssignment_get_type_name(*args):
    """
    StepBasic_OrganizationAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_OrganizationAssignment_get_type_name(*args)

def StepBasic_OrganizationAssignment_get_type_descriptor(*args):
    """
    StepBasic_OrganizationAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_OrganizationAssignment_get_type_descriptor(*args)

class StepBasic_DocumentRelationship(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentRelationship(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_DocumentRelationship self) -> StepBasic_DocumentRelationship"""
        this = _StepBasic.new_StepBasic_DocumentRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DocumentRelationship self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Document aRelating, Handle_StepBasic_Document aRelated)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelating: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aRelated: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRelationship_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_DocumentRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_DocumentRelationship self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_DocumentRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_DocumentRelationship self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentRelationship_SetDescription(self, *args)


    def RelatingDocument(self, *args):
        """
        RelatingDocument(StepBasic_DocumentRelationship self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRelationship_RelatingDocument(self, *args)


    def SetRelatingDocument(self, *args):
        """
        SetRelatingDocument(StepBasic_DocumentRelationship self, Handle_StepBasic_Document aRelating)

        :type aRelating: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRelationship_SetRelatingDocument(self, *args)


    def RelatedDocument(self, *args):
        """
        RelatedDocument(StepBasic_DocumentRelationship self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRelationship_RelatedDocument(self, *args)


    def SetRelatedDocument(self, *args):
        """
        SetRelatedDocument(StepBasic_DocumentRelationship self, Handle_StepBasic_Document aRelated)

        :type aRelated: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRelationship_SetRelatedDocument(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentRelationship
StepBasic_DocumentRelationship_swigregister = _StepBasic.StepBasic_DocumentRelationship_swigregister
StepBasic_DocumentRelationship_swigregister(StepBasic_DocumentRelationship)

def StepBasic_DocumentRelationship_get_type_name(*args):
    """
    StepBasic_DocumentRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentRelationship_get_type_name(*args)

def StepBasic_DocumentRelationship_get_type_descriptor(*args):
    """
    StepBasic_DocumentRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentRelationship_get_type_descriptor(*args)

class StepBasic_DocumentRepresentationType(Standard.Standard_Transient):
    """Representation of STEP entity DocumentRepresentationType"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentRepresentationType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentRepresentationType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DocumentRepresentationType self) -> StepBasic_DocumentRepresentationType

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_DocumentRepresentationType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DocumentRepresentationType self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_Document aRepresentedDocument)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_DocumentRepresentationType self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_DocumentRepresentationType self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_SetName(self, *args)


    def RepresentedDocument(self, *args):
        """
        RepresentedDocument(StepBasic_DocumentRepresentationType self) -> Handle_StepBasic_Document

        Returns field RepresentedDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_RepresentedDocument(self, *args)


    def SetRepresentedDocument(self, *args):
        """
        SetRepresentedDocument(StepBasic_DocumentRepresentationType self, Handle_StepBasic_Document RepresentedDocument)

        Set field RepresentedDocument

        :type RepresentedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_SetRepresentedDocument(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentRepresentationType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentRepresentationType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentRepresentationType
StepBasic_DocumentRepresentationType_swigregister = _StepBasic.StepBasic_DocumentRepresentationType_swigregister
StepBasic_DocumentRepresentationType_swigregister(StepBasic_DocumentRepresentationType)

def StepBasic_DocumentRepresentationType_get_type_name(*args):
    """
    StepBasic_DocumentRepresentationType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentRepresentationType_get_type_name(*args)

def StepBasic_DocumentRepresentationType_get_type_descriptor(*args):
    """
    StepBasic_DocumentRepresentationType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentRepresentationType_get_type_descriptor(*args)

class StepBasic_OrganizationalAddress(StepBasic_Address):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_OrganizationalAddress
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_OrganizationalAddress(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_OrganizationalAddress self) -> StepBasic_OrganizationalAddress

        Returns a OrganizationalAddress


        """
        this = _StepBasic.new_StepBasic_OrganizationalAddress(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_OrganizationalAddress self, Standard_Boolean const hasAinternalLocation, Handle_TCollection_HAsciiString aInternalLocation, Standard_Boolean const hasAstreetNumber, Handle_TCollection_HAsciiString aStreetNumber, Standard_Boolean const hasAstreet, Handle_TCollection_HAsciiString aStreet, Standard_Boolean const hasApostalBox, Handle_TCollection_HAsciiString aPostalBox, Standard_Boolean const hasAtown, Handle_TCollection_HAsciiString aTown, Standard_Boolean const hasAregion, Handle_TCollection_HAsciiString aRegion, Standard_Boolean const hasApostalCode, Handle_TCollection_HAsciiString aPostalCode, Standard_Boolean const hasAcountry, Handle_TCollection_HAsciiString aCountry, Standard_Boolean const hasAfacsimileNumber, Handle_TCollection_HAsciiString aFacsimileNumber, Standard_Boolean const hasAtelephoneNumber, Handle_TCollection_HAsciiString aTelephoneNumber, Standard_Boolean const hasAelectronicMailAddress, Handle_TCollection_HAsciiString aElectronicMailAddress, Standard_Boolean const hasAtelexNumber, Handle_TCollection_HAsciiString aTelexNumber, Handle_StepBasic_HArray1OfOrganization aOrganizations, Handle_TCollection_HAsciiString aDescription)

        :type hasAinternalLocation: bool
        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreetNumber: bool
        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreet: bool
        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalBox: bool
        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtown: bool
        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAregion: bool
        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalCode: bool
        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAcountry: bool
        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfacsimileNumber: bool
        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelephoneNumber: bool
        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAelectronicMailAddress: bool
        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelexNumber: bool
        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOrganizations: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfOrganization
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_OrganizationalAddress_Init(self, *args)


    def SetOrganizations(self, *args):
        """
        SetOrganizations(StepBasic_OrganizationalAddress self, Handle_StepBasic_HArray1OfOrganization aOrganizations)

        :type aOrganizations: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfOrganization

        """
        return _StepBasic.StepBasic_OrganizationalAddress_SetOrganizations(self, *args)


    def Organizations(self, *args):
        """
        Organizations(StepBasic_OrganizationalAddress self) -> Handle_StepBasic_HArray1OfOrganization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfOrganization

        """
        return _StepBasic.StepBasic_OrganizationalAddress_Organizations(self, *args)


    def OrganizationsValue(self, *args):
        """
        OrganizationsValue(StepBasic_OrganizationalAddress self, Standard_Integer const num) -> Handle_StepBasic_Organization

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_OrganizationalAddress_OrganizationsValue(self, *args)


    def NbOrganizations(self, *args):
        """
        NbOrganizations(StepBasic_OrganizationalAddress self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_OrganizationalAddress_NbOrganizations(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_OrganizationalAddress_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_OrganizationalAddress_Description(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_OrganizationalAddress_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_OrganizationalAddress_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_OrganizationalAddress_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_OrganizationalAddress
StepBasic_OrganizationalAddress_swigregister = _StepBasic.StepBasic_OrganizationalAddress_swigregister
StepBasic_OrganizationalAddress_swigregister(StepBasic_OrganizationalAddress)

def StepBasic_OrganizationalAddress_get_type_name(*args):
    """
    StepBasic_OrganizationalAddress_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_OrganizationalAddress_get_type_name(*args)

def StepBasic_OrganizationalAddress_get_type_descriptor(*args):
    """
    StepBasic_OrganizationalAddress_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_OrganizationalAddress_get_type_descriptor(*args)

class StepBasic_DateAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DateAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DateAssignment(self) 
            return h


    def Init(self, *args):
        """
        Init(StepBasic_DateAssignment self, Handle_StepBasic_Date aAssignedDate, Handle_StepBasic_DateRole aRole)

        :type aAssignedDate: OCC.wrapper.StepBasic.Handle_StepBasic_Date
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateRole

        """
        return _StepBasic.StepBasic_DateAssignment_Init(self, *args)


    def SetAssignedDate(self, *args):
        """
        SetAssignedDate(StepBasic_DateAssignment self, Handle_StepBasic_Date aAssignedDate)

        :type aAssignedDate: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.StepBasic_DateAssignment_SetAssignedDate(self, *args)


    def AssignedDate(self, *args):
        """
        AssignedDate(StepBasic_DateAssignment self) -> Handle_StepBasic_Date

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.StepBasic_DateAssignment_AssignedDate(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_DateAssignment self, Handle_StepBasic_DateRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateRole

        """
        return _StepBasic.StepBasic_DateAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_DateAssignment self) -> Handle_StepBasic_DateRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateRole

        """
        return _StepBasic.StepBasic_DateAssignment_Role(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DateAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DateAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DateAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_DateAssignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_DateAssignment
StepBasic_DateAssignment_swigregister = _StepBasic.StepBasic_DateAssignment_swigregister
StepBasic_DateAssignment_swigregister(StepBasic_DateAssignment)

def StepBasic_DateAssignment_get_type_name(*args):
    """
    StepBasic_DateAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DateAssignment_get_type_name(*args)

def StepBasic_DateAssignment_get_type_descriptor(*args):
    """
    StepBasic_DateAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DateAssignment_get_type_descriptor(*args)

class StepBasic_MechanicalContext(StepBasic_ProductContext):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_MechanicalContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_MechanicalContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_MechanicalContext self) -> StepBasic_MechanicalContext

        Returns a MechanicalContext


        """
        this = _StepBasic.new_StepBasic_MechanicalContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_MechanicalContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_MechanicalContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_MechanicalContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_MechanicalContext
StepBasic_MechanicalContext_swigregister = _StepBasic.StepBasic_MechanicalContext_swigregister
StepBasic_MechanicalContext_swigregister(StepBasic_MechanicalContext)

def StepBasic_MechanicalContext_get_type_name(*args):
    """
    StepBasic_MechanicalContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_MechanicalContext_get_type_name(*args)

def StepBasic_MechanicalContext_get_type_descriptor(*args):
    """
    StepBasic_MechanicalContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_MechanicalContext_get_type_descriptor(*args)

class StepBasic_HArray1OfPerson(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfPerson
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfPerson(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfPerson self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfPerson
        __init__(StepBasic_HArray1OfPerson self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_Person theValue) -> StepBasic_HArray1OfPerson
        __init__(StepBasic_HArray1OfPerson self, NCollection_Array1_Handle_StepBasic_Person theOther) -> StepBasic_HArray1OfPerson

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfPerson

        """
        this = _StepBasic.new_StepBasic_HArray1OfPerson(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfPerson

        """
        res = _StepBasic.StepBasic_HArray1OfPerson_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfPerson self) -> NCollection_Array1_Handle_StepBasic_Person

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfPerson

        """
        return _StepBasic.StepBasic_HArray1OfPerson_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfPerson_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfPerson_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfPerson_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfPerson
StepBasic_HArray1OfPerson_swigregister = _StepBasic.StepBasic_HArray1OfPerson_swigregister
StepBasic_HArray1OfPerson_swigregister(StepBasic_HArray1OfPerson)

def StepBasic_HArray1OfPerson_get_type_name(*args):
    """
    StepBasic_HArray1OfPerson_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfPerson_get_type_name(*args)

def StepBasic_HArray1OfPerson_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfPerson_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfPerson_get_type_descriptor(*args)

class StepBasic_DocumentProductEquivalence(StepBasic_DocumentProductAssociation):
    """Representation of STEP entity DocumentProductEquivalence"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentProductEquivalence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentProductEquivalence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DocumentProductEquivalence self) -> StepBasic_DocumentProductEquivalence

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_DocumentProductEquivalence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentProductEquivalence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentProductEquivalence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentProductEquivalence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentProductEquivalence
StepBasic_DocumentProductEquivalence_swigregister = _StepBasic.StepBasic_DocumentProductEquivalence_swigregister
StepBasic_DocumentProductEquivalence_swigregister(StepBasic_DocumentProductEquivalence)

def StepBasic_DocumentProductEquivalence_get_type_name(*args):
    """
    StepBasic_DocumentProductEquivalence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentProductEquivalence_get_type_name(*args)

def StepBasic_DocumentProductEquivalence_get_type_descriptor(*args):
    """
    StepBasic_DocumentProductEquivalence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentProductEquivalence_get_type_descriptor(*args)

class StepBasic_ExternallyDefinedItem(Standard.Standard_Transient):
    """Representation of STEP entity ExternallyDefinedItem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ExternallyDefinedItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ExternallyDefinedItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ExternallyDefinedItem self) -> StepBasic_ExternallyDefinedItem

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ExternallyDefinedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ExternallyDefinedItem self, StepBasic_SourceItem aItemId, Handle_StepBasic_ExternalSource aSource)

        Initialize all fields (own and inherited)

        :type aItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem
        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_Init(self, *args)


    def ItemId(self, *args):
        """
        ItemId(StepBasic_ExternallyDefinedItem self) -> StepBasic_SourceItem

        Returns field ItemId

        :rtype: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_ItemId(self, *args)


    def SetItemId(self, *args):
        """
        SetItemId(StepBasic_ExternallyDefinedItem self, StepBasic_SourceItem ItemId)

        Set field ItemId

        :type ItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_SetItemId(self, *args)


    def Source(self, *args):
        """
        Source(StepBasic_ExternallyDefinedItem self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepBasic_ExternallyDefinedItem self, Handle_StepBasic_ExternalSource Source)

        Set field Source

        :type Source: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_SetSource(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ExternallyDefinedItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ExternallyDefinedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ExternallyDefinedItem
StepBasic_ExternallyDefinedItem_swigregister = _StepBasic.StepBasic_ExternallyDefinedItem_swigregister
StepBasic_ExternallyDefinedItem_swigregister(StepBasic_ExternallyDefinedItem)

def StepBasic_ExternallyDefinedItem_get_type_name(*args):
    """
    StepBasic_ExternallyDefinedItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ExternallyDefinedItem_get_type_name(*args)

def StepBasic_ExternallyDefinedItem_get_type_descriptor(*args):
    """
    StepBasic_ExternallyDefinedItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ExternallyDefinedItem_get_type_descriptor(*args)

class StepBasic_PersonAndOrganization(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PersonAndOrganization
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PersonAndOrganization(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_PersonAndOrganization self) -> StepBasic_PersonAndOrganization

        Returns a PersonAndOrganization


        """
        this = _StepBasic.new_StepBasic_PersonAndOrganization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_PersonAndOrganization self, Handle_StepBasic_Person aThePerson, Handle_StepBasic_Organization aTheOrganization)

        :type aThePerson: OCC.wrapper.StepBasic.Handle_StepBasic_Person
        :type aTheOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_PersonAndOrganization_Init(self, *args)


    def SetThePerson(self, *args):
        """
        SetThePerson(StepBasic_PersonAndOrganization self, Handle_StepBasic_Person aThePerson)

        :type aThePerson: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.StepBasic_PersonAndOrganization_SetThePerson(self, *args)


    def ThePerson(self, *args):
        """
        ThePerson(StepBasic_PersonAndOrganization self) -> Handle_StepBasic_Person

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.StepBasic_PersonAndOrganization_ThePerson(self, *args)


    def SetTheOrganization(self, *args):
        """
        SetTheOrganization(StepBasic_PersonAndOrganization self, Handle_StepBasic_Organization aTheOrganization)

        :type aTheOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_PersonAndOrganization_SetTheOrganization(self, *args)


    def TheOrganization(self, *args):
        """
        TheOrganization(StepBasic_PersonAndOrganization self) -> Handle_StepBasic_Organization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_PersonAndOrganization_TheOrganization(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PersonAndOrganization_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PersonAndOrganization_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PersonAndOrganization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_PersonAndOrganization
StepBasic_PersonAndOrganization_swigregister = _StepBasic.StepBasic_PersonAndOrganization_swigregister
StepBasic_PersonAndOrganization_swigregister(StepBasic_PersonAndOrganization)

def StepBasic_PersonAndOrganization_get_type_name(*args):
    """
    StepBasic_PersonAndOrganization_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PersonAndOrganization_get_type_name(*args)

def StepBasic_PersonAndOrganization_get_type_descriptor(*args):
    """
    StepBasic_PersonAndOrganization_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PersonAndOrganization_get_type_descriptor(*args)

class StepBasic_Approval(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Approval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Approval(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Approval self) -> StepBasic_Approval

        Returns a Approval


        """
        this = _StepBasic.new_StepBasic_Approval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Approval self, Handle_StepBasic_ApprovalStatus aStatus, Handle_TCollection_HAsciiString aLevel)

        :type aStatus: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalStatus
        :type aLevel: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Approval_Init(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(StepBasic_Approval self, Handle_StepBasic_ApprovalStatus aStatus)

        :type aStatus: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalStatus

        """
        return _StepBasic.StepBasic_Approval_SetStatus(self, *args)


    def Status(self, *args):
        """
        Status(StepBasic_Approval self) -> Handle_StepBasic_ApprovalStatus

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalStatus

        """
        return _StepBasic.StepBasic_Approval_Status(self, *args)


    def SetLevel(self, *args):
        """
        SetLevel(StepBasic_Approval self, Handle_TCollection_HAsciiString aLevel)

        :type aLevel: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Approval_SetLevel(self, *args)


    def Level(self, *args):
        """
        Level(StepBasic_Approval self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Approval_Level(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Approval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Approval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Approval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Approval
StepBasic_Approval_swigregister = _StepBasic.StepBasic_Approval_swigregister
StepBasic_Approval_swigregister(StepBasic_Approval)

def StepBasic_Approval_get_type_name(*args):
    """
    StepBasic_Approval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Approval_get_type_name(*args)

def StepBasic_Approval_get_type_descriptor(*args):
    """
    StepBasic_Approval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Approval_get_type_descriptor(*args)

class StepBasic_SiUnitAndRatioUnit(StepBasic_SiUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SiUnitAndRatioUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SiUnitAndRatioUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SiUnitAndRatioUnit self) -> StepBasic_SiUnitAndRatioUnit

        Returns a SiUnitAndRatioUnit


        """
        this = _StepBasic.new_StepBasic_SiUnitAndRatioUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_SiUnitAndRatioUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.StepBasic_SiUnitAndRatioUnit_Init(self, *args)


    def SetRatioUnit(self, *args):
        """
        SetRatioUnit(StepBasic_SiUnitAndRatioUnit self, Handle_StepBasic_RatioUnit aRatioUnit)

        :type aRatioUnit: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.StepBasic_SiUnitAndRatioUnit_SetRatioUnit(self, *args)


    def RatioUnit(self, *args):
        """
        RatioUnit(StepBasic_SiUnitAndRatioUnit self) -> Handle_StepBasic_RatioUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.StepBasic_SiUnitAndRatioUnit_RatioUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SiUnitAndRatioUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SiUnitAndRatioUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SiUnitAndRatioUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SiUnitAndRatioUnit
StepBasic_SiUnitAndRatioUnit_swigregister = _StepBasic.StepBasic_SiUnitAndRatioUnit_swigregister
StepBasic_SiUnitAndRatioUnit_swigregister(StepBasic_SiUnitAndRatioUnit)

def StepBasic_SiUnitAndRatioUnit_get_type_name(*args):
    """
    StepBasic_SiUnitAndRatioUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SiUnitAndRatioUnit_get_type_name(*args)

def StepBasic_SiUnitAndRatioUnit_get_type_descriptor(*args):
    """
    StepBasic_SiUnitAndRatioUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SiUnitAndRatioUnit_get_type_descriptor(*args)

class StepBasic_MassMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_MassMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_MassMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_MassMeasureWithUnit self) -> StepBasic_MassMeasureWithUnit

        Returns a MassMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_MassMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_MassMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_MassMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_MassMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_MassMeasureWithUnit
StepBasic_MassMeasureWithUnit_swigregister = _StepBasic.StepBasic_MassMeasureWithUnit_swigregister
StepBasic_MassMeasureWithUnit_swigregister(StepBasic_MassMeasureWithUnit)

def StepBasic_MassMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_MassMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_MassMeasureWithUnit_get_type_name(*args)

def StepBasic_MassMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_MassMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_MassMeasureWithUnit_get_type_descriptor(*args)

class StepBasic_PhysicallyModeledProductDefinition(StepBasic_ProductDefinition):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_PhysicallyModeledProductDefinition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_PhysicallyModeledProductDefinition(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_PhysicallyModeledProductDefinition self) -> StepBasic_PhysicallyModeledProductDefinition"""
        this = _StepBasic.new_StepBasic_PhysicallyModeledProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_PhysicallyModeledProductDefinition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_PhysicallyModeledProductDefinition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_PhysicallyModeledProductDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_PhysicallyModeledProductDefinition
StepBasic_PhysicallyModeledProductDefinition_swigregister = _StepBasic.StepBasic_PhysicallyModeledProductDefinition_swigregister
StepBasic_PhysicallyModeledProductDefinition_swigregister(StepBasic_PhysicallyModeledProductDefinition)

def StepBasic_PhysicallyModeledProductDefinition_get_type_name(*args):
    """
    StepBasic_PhysicallyModeledProductDefinition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_PhysicallyModeledProductDefinition_get_type_name(*args)

def StepBasic_PhysicallyModeledProductDefinition_get_type_descriptor(*args):
    """
    StepBasic_PhysicallyModeledProductDefinition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_PhysicallyModeledProductDefinition_get_type_descriptor(*args)

class StepBasic_ApprovalRole(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApprovalRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApprovalRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApprovalRole self) -> StepBasic_ApprovalRole

        Returns a ApprovalRole


        """
        this = _StepBasic.new_StepBasic_ApprovalRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApprovalRole self, Handle_TCollection_HAsciiString aRole)

        :type aRole: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRole_Init(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_ApprovalRole self, Handle_TCollection_HAsciiString aRole)

        :type aRole: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRole_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_ApprovalRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRole_Role(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApprovalRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApprovalRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApprovalRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApprovalRole
StepBasic_ApprovalRole_swigregister = _StepBasic.StepBasic_ApprovalRole_swigregister
StepBasic_ApprovalRole_swigregister(StepBasic_ApprovalRole)

def StepBasic_ApprovalRole_get_type_name(*args):
    """
    StepBasic_ApprovalRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApprovalRole_get_type_name(*args)

def StepBasic_ApprovalRole_get_type_descriptor(*args):
    """
    StepBasic_ApprovalRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApprovalRole_get_type_descriptor(*args)

class StepBasic_HArray1OfDerivedUnitElement(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfDerivedUnitElement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfDerivedUnitElement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfDerivedUnitElement self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfDerivedUnitElement
        __init__(StepBasic_HArray1OfDerivedUnitElement self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_DerivedUnitElement theValue) -> StepBasic_HArray1OfDerivedUnitElement
        __init__(StepBasic_HArray1OfDerivedUnitElement self, NCollection_Array1_Handle_StepBasic_DerivedUnitElement theOther) -> StepBasic_HArray1OfDerivedUnitElement

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfDerivedUnitElement

        """
        this = _StepBasic.new_StepBasic_HArray1OfDerivedUnitElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDerivedUnitElement

        """
        res = _StepBasic.StepBasic_HArray1OfDerivedUnitElement_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfDerivedUnitElement self) -> NCollection_Array1_Handle_StepBasic_DerivedUnitElement

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDerivedUnitElement

        """
        return _StepBasic.StepBasic_HArray1OfDerivedUnitElement_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfDerivedUnitElement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfDerivedUnitElement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfDerivedUnitElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfDerivedUnitElement
StepBasic_HArray1OfDerivedUnitElement_swigregister = _StepBasic.StepBasic_HArray1OfDerivedUnitElement_swigregister
StepBasic_HArray1OfDerivedUnitElement_swigregister(StepBasic_HArray1OfDerivedUnitElement)

def StepBasic_HArray1OfDerivedUnitElement_get_type_name(*args):
    """
    StepBasic_HArray1OfDerivedUnitElement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfDerivedUnitElement_get_type_name(*args)

def StepBasic_HArray1OfDerivedUnitElement_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfDerivedUnitElement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfDerivedUnitElement_get_type_descriptor(*args)

class StepBasic_HArray1OfApproval(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfApproval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfApproval(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfApproval self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfApproval
        __init__(StepBasic_HArray1OfApproval self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_Approval theValue) -> StepBasic_HArray1OfApproval
        __init__(StepBasic_HArray1OfApproval self, NCollection_Array1_Handle_StepBasic_Approval theOther) -> StepBasic_HArray1OfApproval

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfApproval

        """
        this = _StepBasic.new_StepBasic_HArray1OfApproval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfApproval

        """
        res = _StepBasic.StepBasic_HArray1OfApproval_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfApproval self) -> NCollection_Array1_Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfApproval

        """
        return _StepBasic.StepBasic_HArray1OfApproval_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfApproval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfApproval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfApproval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfApproval
StepBasic_HArray1OfApproval_swigregister = _StepBasic.StepBasic_HArray1OfApproval_swigregister
StepBasic_HArray1OfApproval_swigregister(StepBasic_HArray1OfApproval)

def StepBasic_HArray1OfApproval_get_type_name(*args):
    """
    StepBasic_HArray1OfApproval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfApproval_get_type_name(*args)

def StepBasic_HArray1OfApproval_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfApproval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfApproval_get_type_descriptor(*args)

class StepBasic_HArray1OfProductContext(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfProductContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfProductContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfProductContext self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfProductContext
        __init__(StepBasic_HArray1OfProductContext self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_ProductContext theValue) -> StepBasic_HArray1OfProductContext
        __init__(StepBasic_HArray1OfProductContext self, NCollection_Array1_Handle_StepBasic_ProductContext theOther) -> StepBasic_HArray1OfProductContext

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfProductContext

        """
        this = _StepBasic.new_StepBasic_HArray1OfProductContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductContext

        """
        res = _StepBasic.StepBasic_HArray1OfProductContext_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfProductContext self) -> NCollection_Array1_Handle_StepBasic_ProductContext

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductContext

        """
        return _StepBasic.StepBasic_HArray1OfProductContext_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfProductContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfProductContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfProductContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfProductContext
StepBasic_HArray1OfProductContext_swigregister = _StepBasic.StepBasic_HArray1OfProductContext_swigregister
StepBasic_HArray1OfProductContext_swigregister(StepBasic_HArray1OfProductContext)

def StepBasic_HArray1OfProductContext_get_type_name(*args):
    """
    StepBasic_HArray1OfProductContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfProductContext_get_type_name(*args)

def StepBasic_HArray1OfProductContext_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfProductContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfProductContext_get_type_descriptor(*args)

class StepBasic_Organization(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Organization
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Organization(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Organization self) -> StepBasic_Organization

        Returns a Organization


        """
        this = _StepBasic.new_StepBasic_Organization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Organization self, Standard_Boolean const hasAid, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription)

        :type hasAid: bool
        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_Organization self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_SetId(self, *args)


    def UnSetId(self, *args):
        """UnSetId(StepBasic_Organization self)"""
        return _StepBasic.StepBasic_Organization_UnSetId(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_Organization self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_Id(self, *args)


    def HasId(self, *args):
        """
        HasId(StepBasic_Organization self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Organization_HasId(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Organization self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Organization self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_Organization self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_Organization self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Organization_Description(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Organization_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Organization_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Organization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Organization
StepBasic_Organization_swigregister = _StepBasic.StepBasic_Organization_swigregister
StepBasic_Organization_swigregister(StepBasic_Organization)

def StepBasic_Organization_get_type_name(*args):
    """
    StepBasic_Organization_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Organization_get_type_name(*args)

def StepBasic_Organization_get_type_descriptor(*args):
    """
    StepBasic_Organization_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Organization_get_type_descriptor(*args)

class StepBasic_SizeMember(StepData.StepData_SelectReal):
    """
    For immediate members of SizeSelect, i.e. :
    ParameterValue (a Real)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SizeMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SizeMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_SizeMember self) -> StepBasic_SizeMember

        For immediate members of SizeSelect, i.e. :
        ParameterValue (a Real)
        """
        this = _StepBasic.new_StepBasic_SizeMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepBasic_SizeMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_SizeMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_SizeMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.StepBasic_SizeMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_SizeMember self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_SizeMember_SetName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SizeMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SizeMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SizeMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_SizeMember
StepBasic_SizeMember_swigregister = _StepBasic.StepBasic_SizeMember_swigregister
StepBasic_SizeMember_swigregister(StepBasic_SizeMember)

def StepBasic_SizeMember_get_type_name(*args):
    """
    StepBasic_SizeMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SizeMember_get_type_name(*args)

def StepBasic_SizeMember_get_type_descriptor(*args):
    """
    StepBasic_SizeMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SizeMember_get_type_descriptor(*args)

class StepBasic_ProductCategoryRelationship(Standard.Standard_Transient):
    """Representation of STEP entity ProductCategoryRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductCategoryRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductCategoryRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductCategoryRelationship self) -> StepBasic_ProductCategoryRelationship

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ProductCategoryRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductCategoryRelationship self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductCategory aCategory, Handle_StepBasic_ProductCategory aSubCategory)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCategory: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory
        :type aSubCategory: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ProductCategoryRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ProductCategoryRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ProductCategoryRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ProductCategoryRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_ProductCategoryRelationship self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_HasDescription(self, *args)


    def Category(self, *args):
        """
        Category(StepBasic_ProductCategoryRelationship self) -> Handle_StepBasic_ProductCategory

        Returns field Category

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_Category(self, *args)


    def SetCategory(self, *args):
        """
        SetCategory(StepBasic_ProductCategoryRelationship self, Handle_StepBasic_ProductCategory Category)

        Set field Category

        :type Category: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_SetCategory(self, *args)


    def SubCategory(self, *args):
        """
        SubCategory(StepBasic_ProductCategoryRelationship self) -> Handle_StepBasic_ProductCategory

        Returns field SubCategory

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_SubCategory(self, *args)


    def SetSubCategory(self, *args):
        """
        SetSubCategory(StepBasic_ProductCategoryRelationship self, Handle_StepBasic_ProductCategory SubCategory)

        Set field SubCategory

        :type SubCategory: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_SetSubCategory(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductCategoryRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductCategoryRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductCategoryRelationship
StepBasic_ProductCategoryRelationship_swigregister = _StepBasic.StepBasic_ProductCategoryRelationship_swigregister
StepBasic_ProductCategoryRelationship_swigregister(StepBasic_ProductCategoryRelationship)

def StepBasic_ProductCategoryRelationship_get_type_name(*args):
    """
    StepBasic_ProductCategoryRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductCategoryRelationship_get_type_name(*args)

def StepBasic_ProductCategoryRelationship_get_type_descriptor(*args):
    """
    StepBasic_ProductCategoryRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductCategoryRelationship_get_type_descriptor(*args)

class NCollection_Array1_Handle_StepBasic_NamedUnit(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_NamedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_NamedUnit self, Handle_StepBasic_NamedUnit theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_NamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_NamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_NamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> NCollection_Array1_Handle_StepBasic_NamedUnit
        assign(NCollection_Array1_Handle_StepBasic_NamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Handle_StepBasic_NamedUnit

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_NamedUnit self) -> Handle_StepBasic_NamedUnit

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_NamedUnit self, Standard_Integer const theIndex) -> Handle_StepBasic_NamedUnit

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_NamedUnit self, Standard_Integer const theIndex, Handle_StepBasic_NamedUnit theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_NamedUnit self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_NamedUnit
NCollection_Array1_Handle_StepBasic_NamedUnit_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_NamedUnit_swigregister
NCollection_Array1_Handle_StepBasic_NamedUnit_swigregister(NCollection_Array1_Handle_StepBasic_NamedUnit)


try:
	StepBasic_Array1OfNamedUnit = NCollection_Array1_Handle_StepBasic_NamedUnit
except NameError:
	pass # does not exist, probably ignored

class StepBasic_DateTimeRole(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DateTimeRole
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DateTimeRole(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DateTimeRole self) -> StepBasic_DateTimeRole

        Returns a DateTimeRole


        """
        this = _StepBasic.new_StepBasic_DateTimeRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DateTimeRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DateTimeRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_DateTimeRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DateTimeRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_DateTimeRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DateTimeRole_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DateTimeRole_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DateTimeRole_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DateTimeRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DateTimeRole
StepBasic_DateTimeRole_swigregister = _StepBasic.StepBasic_DateTimeRole_swigregister
StepBasic_DateTimeRole_swigregister(StepBasic_DateTimeRole)

def StepBasic_DateTimeRole_get_type_name(*args):
    """
    StepBasic_DateTimeRole_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DateTimeRole_get_type_name(*args)

def StepBasic_DateTimeRole_get_type_descriptor(*args):
    """
    StepBasic_DateTimeRole_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DateTimeRole_get_type_descriptor(*args)

class Handle_StepBasic_NameAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_NameAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_NameAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_NameAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_NameAssignment self, StepBasic_NameAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_NameAssignment self, Handle_StepBasic_NameAssignment theHandle) -> Handle_StepBasic_NameAssignment
        assign(Handle_StepBasic_NameAssignment self, StepBasic_NameAssignment thePtr) -> Handle_StepBasic_NameAssignment
        assign(Handle_StepBasic_NameAssignment self, Handle_StepBasic_NameAssignment theHandle) -> Handle_StepBasic_NameAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_NameAssignment self) -> StepBasic_NameAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_NameAssignment self) -> StepBasic_NameAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_NameAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_NameAssignment self) -> StepBasic_NameAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_NameAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_NameAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_NameAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_NameAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_NameAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_NameAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_NameAssignment self, Handle_TCollection_HAsciiString aAssignedName)

        Initialize all fields (own and inherited)

        :type aAssignedName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_Init(self, *args)


    def AssignedName(self, *args):
        """
        AssignedName(Handle_StepBasic_NameAssignment self) -> Handle_TCollection_HAsciiString

        Returns field AssignedName

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_AssignedName(self, *args)


    def SetAssignedName(self, *args):
        """
        SetAssignedName(Handle_StepBasic_NameAssignment self, Handle_TCollection_HAsciiString AssignedName)

        Set field AssignedName

        :type AssignedName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_SetAssignedName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_NameAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_NameAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_NameAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_NameAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_NameAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_NameAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_NameAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_NameAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_NameAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_NameAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_NameAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_NameAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_NameAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_NameAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_NameAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_NameAssignment_swigregister = _StepBasic.Handle_StepBasic_NameAssignment_swigregister
Handle_StepBasic_NameAssignment_swigregister(Handle_StepBasic_NameAssignment)

def Handle_StepBasic_NameAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_NameAssignment_DownCast(thing)
Handle_StepBasic_NameAssignment_DownCast = _StepBasic.Handle_StepBasic_NameAssignment_DownCast

class Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, StepBasic_SiUnitAndThermodynamicTemperatureUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit theHandle) -> Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit
        assign(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, StepBasic_SiUnitAndThermodynamicTemperatureUnit thePtr) -> Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit
        assign(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit theHandle) -> Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> StepBasic_SiUnitAndThermodynamicTemperatureUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> StepBasic_SiUnitAndThermodynamicTemperatureUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> StepBasic_SiUnitAndThermodynamicTemperatureUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_Init(self, *args)


    def SetThermodynamicTemperatureUnit(self, *args):
        """
        SetThermodynamicTemperatureUnit(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_StepBasic_ThermodynamicTemperatureUnit aThermodynamicTemperatureUnit)

        :type aThermodynamicTemperatureUnit: OCC.wrapper.StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_SetThermodynamicTemperatureUnit(self, *args)


    def ThermodynamicTemperatureUnit(self, *args):
        """
        ThermodynamicTemperatureUnit(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Handle_StepBasic_ThermodynamicTemperatureUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_ThermodynamicTemperatureUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_swigregister
Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_swigregister(Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit)

def Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndThermodynamicTemperatureUnit_DownCast

class StepBasic_CalendarDate(StepBasic_Date):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_CalendarDate
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_CalendarDate(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_CalendarDate self) -> StepBasic_CalendarDate

        Returns a CalendarDate


        """
        this = _StepBasic.new_StepBasic_CalendarDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_CalendarDate self, Standard_Integer const aYearComponent, Standard_Integer const aDayComponent, Standard_Integer const aMonthComponent)

        :type aYearComponent: int
        :type aDayComponent: int
        :type aMonthComponent: int

        """
        return _StepBasic.StepBasic_CalendarDate_Init(self, *args)


    def SetDayComponent(self, *args):
        """
        SetDayComponent(StepBasic_CalendarDate self, Standard_Integer const aDayComponent)

        :type aDayComponent: int

        """
        return _StepBasic.StepBasic_CalendarDate_SetDayComponent(self, *args)


    def DayComponent(self, *args):
        """
        DayComponent(StepBasic_CalendarDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_CalendarDate_DayComponent(self, *args)


    def SetMonthComponent(self, *args):
        """
        SetMonthComponent(StepBasic_CalendarDate self, Standard_Integer const aMonthComponent)

        :type aMonthComponent: int

        """
        return _StepBasic.StepBasic_CalendarDate_SetMonthComponent(self, *args)


    def MonthComponent(self, *args):
        """
        MonthComponent(StepBasic_CalendarDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_CalendarDate_MonthComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_CalendarDate_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_CalendarDate_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_CalendarDate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_CalendarDate
StepBasic_CalendarDate_swigregister = _StepBasic.StepBasic_CalendarDate_swigregister
StepBasic_CalendarDate_swigregister(StepBasic_CalendarDate)

def StepBasic_CalendarDate_get_type_name(*args):
    """
    StepBasic_CalendarDate_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_CalendarDate_get_type_name(*args)

def StepBasic_CalendarDate_get_type_descriptor(*args):
    """
    StepBasic_CalendarDate_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_CalendarDate_get_type_descriptor(*args)

class Handle_StepBasic_SecurityClassificationLevel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SecurityClassificationLevel self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SecurityClassificationLevel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SecurityClassificationLevel self, StepBasic_SecurityClassificationLevel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SecurityClassificationLevel self, Handle_StepBasic_SecurityClassificationLevel theHandle) -> Handle_StepBasic_SecurityClassificationLevel
        assign(Handle_StepBasic_SecurityClassificationLevel self, StepBasic_SecurityClassificationLevel thePtr) -> Handle_StepBasic_SecurityClassificationLevel
        assign(Handle_StepBasic_SecurityClassificationLevel self, Handle_StepBasic_SecurityClassificationLevel theHandle) -> Handle_StepBasic_SecurityClassificationLevel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SecurityClassificationLevel self) -> StepBasic_SecurityClassificationLevel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SecurityClassificationLevel self) -> StepBasic_SecurityClassificationLevel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SecurityClassificationLevel self) -> StepBasic_SecurityClassificationLevel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SecurityClassificationLevel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SecurityClassificationLevel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SecurityClassificationLevel_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SecurityClassificationLevel

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SecurityClassificationLevel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SecurityClassificationLevel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SecurityClassificationLevel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SecurityClassificationLevel self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SecurityClassificationLevel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SecurityClassificationLevel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SecurityClassificationLevel self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SecurityClassificationLevel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SecurityClassificationLevel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SecurityClassificationLevel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SecurityClassificationLevel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SecurityClassificationLevel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SecurityClassificationLevel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SecurityClassificationLevel self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SecurityClassificationLevel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_DecrementRefCounter(self, *args)

Handle_StepBasic_SecurityClassificationLevel_swigregister = _StepBasic.Handle_StepBasic_SecurityClassificationLevel_swigregister
Handle_StepBasic_SecurityClassificationLevel_swigregister(Handle_StepBasic_SecurityClassificationLevel)

def Handle_StepBasic_SecurityClassificationLevel_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SecurityClassificationLevel_DownCast(thing)
Handle_StepBasic_SecurityClassificationLevel_DownCast = _StepBasic.Handle_StepBasic_SecurityClassificationLevel_DownCast

class Handle_StepBasic_SiUnitAndLengthUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndLengthUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndLengthUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndLengthUnit self, StepBasic_SiUnitAndLengthUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndLengthUnit self, Handle_StepBasic_SiUnitAndLengthUnit theHandle) -> Handle_StepBasic_SiUnitAndLengthUnit
        assign(Handle_StepBasic_SiUnitAndLengthUnit self, StepBasic_SiUnitAndLengthUnit thePtr) -> Handle_StepBasic_SiUnitAndLengthUnit
        assign(Handle_StepBasic_SiUnitAndLengthUnit self, Handle_StepBasic_SiUnitAndLengthUnit theHandle) -> Handle_StepBasic_SiUnitAndLengthUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndLengthUnit self) -> StepBasic_SiUnitAndLengthUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndLengthUnit self) -> StepBasic_SiUnitAndLengthUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndLengthUnit self) -> StepBasic_SiUnitAndLengthUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndLengthUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndLengthUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndLengthUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_Init(self, *args)


    def SetLengthUnit(self, *args):
        """
        SetLengthUnit(Handle_StepBasic_SiUnitAndLengthUnit self, Handle_StepBasic_LengthUnit aLengthUnit)

        :type aLengthUnit: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_SetLengthUnit(self, *args)


    def LengthUnit(self, *args):
        """
        LengthUnit(Handle_StepBasic_SiUnitAndLengthUnit self) -> Handle_StepBasic_LengthUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_LengthUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndLengthUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndLengthUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndLengthUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndLengthUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndLengthUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndLengthUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndLengthUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndLengthUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndLengthUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndLengthUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndLengthUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndLengthUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndLengthUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndLengthUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndLengthUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndLengthUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndLengthUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndLengthUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndLengthUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_swigregister
Handle_StepBasic_SiUnitAndLengthUnit_swigregister(Handle_StepBasic_SiUnitAndLengthUnit)

def Handle_StepBasic_SiUnitAndLengthUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndLengthUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndLengthUnit_DownCast

class Handle_StepBasic_TimeMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_TimeMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_TimeMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_TimeMeasureWithUnit self, StepBasic_TimeMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_TimeMeasureWithUnit self, Handle_StepBasic_TimeMeasureWithUnit theHandle) -> Handle_StepBasic_TimeMeasureWithUnit
        assign(Handle_StepBasic_TimeMeasureWithUnit self, StepBasic_TimeMeasureWithUnit thePtr) -> Handle_StepBasic_TimeMeasureWithUnit
        assign(Handle_StepBasic_TimeMeasureWithUnit self, Handle_StepBasic_TimeMeasureWithUnit theHandle) -> Handle_StepBasic_TimeMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_TimeMeasureWithUnit self) -> StepBasic_TimeMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_TimeMeasureWithUnit self) -> StepBasic_TimeMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_TimeMeasureWithUnit self) -> StepBasic_TimeMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_TimeMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_TimeMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_TimeMeasureWithUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_TimeMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_TimeMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_TimeMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_TimeMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_TimeMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_TimeMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_TimeMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_TimeMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_TimeMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_TimeMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_TimeMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_TimeMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_TimeMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_TimeMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_TimeMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_TimeMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_TimeMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_TimeMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_swigregister
Handle_StepBasic_TimeMeasureWithUnit_swigregister(Handle_StepBasic_TimeMeasureWithUnit)

def Handle_StepBasic_TimeMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_DownCast(thing)
Handle_StepBasic_TimeMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_TimeMeasureWithUnit_DownCast

class Handle_StepBasic_ActionRequestSolution(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ActionRequestSolution self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ActionRequestSolution self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ActionRequestSolution self, StepBasic_ActionRequestSolution thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ActionRequestSolution self, Handle_StepBasic_ActionRequestSolution theHandle) -> Handle_StepBasic_ActionRequestSolution
        assign(Handle_StepBasic_ActionRequestSolution self, StepBasic_ActionRequestSolution thePtr) -> Handle_StepBasic_ActionRequestSolution
        assign(Handle_StepBasic_ActionRequestSolution self, Handle_StepBasic_ActionRequestSolution theHandle) -> Handle_StepBasic_ActionRequestSolution

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ActionRequestSolution self) -> StepBasic_ActionRequestSolution

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ActionRequestSolution self) -> StepBasic_ActionRequestSolution

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ActionRequestSolution self) -> StepBasic_ActionRequestSolution

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ActionRequestSolution___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ActionRequestSolution___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ActionRequestSolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ActionRequestSolution_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ActionRequestSolution

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ActionRequestSolution self, Handle_StepBasic_ActionMethod aMethod, Handle_StepBasic_VersionedActionRequest aRequest)

        Initialize all fields (own and inherited)

        :type aMethod: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod
        :type aRequest: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_Init(self, *args)


    def Method(self, *args):
        """
        Method(Handle_StepBasic_ActionRequestSolution self) -> Handle_StepBasic_ActionMethod

        Returns field Method

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_Method(self, *args)


    def SetMethod(self, *args):
        """
        SetMethod(Handle_StepBasic_ActionRequestSolution self, Handle_StepBasic_ActionMethod Method)

        Set field Method

        :type Method: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_SetMethod(self, *args)


    def Request(self, *args):
        """
        Request(Handle_StepBasic_ActionRequestSolution self) -> Handle_StepBasic_VersionedActionRequest

        Returns field Request

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_Request(self, *args)


    def SetRequest(self, *args):
        """
        SetRequest(Handle_StepBasic_ActionRequestSolution self, Handle_StepBasic_VersionedActionRequest Request)

        Set field Request

        :type Request: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_SetRequest(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ActionRequestSolution self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionRequestSolution_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionRequestSolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ActionRequestSolution self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ActionRequestSolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ActionRequestSolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ActionRequestSolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ActionRequestSolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ActionRequestSolution self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ActionRequestSolution self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ActionRequestSolution self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ActionRequestSolution self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionRequestSolution_DecrementRefCounter(self, *args)

Handle_StepBasic_ActionRequestSolution_swigregister = _StepBasic.Handle_StepBasic_ActionRequestSolution_swigregister
Handle_StepBasic_ActionRequestSolution_swigregister(Handle_StepBasic_ActionRequestSolution)

def Handle_StepBasic_ActionRequestSolution_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ActionRequestSolution_DownCast(thing)
Handle_StepBasic_ActionRequestSolution_DownCast = _StepBasic.Handle_StepBasic_ActionRequestSolution_DownCast

class Handle_StepBasic_DateAndTimeAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DateAndTimeAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DateAndTimeAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DateAndTimeAssignment self, StepBasic_DateAndTimeAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateAndTimeAssignment theHandle) -> Handle_StepBasic_DateAndTimeAssignment
        assign(Handle_StepBasic_DateAndTimeAssignment self, StepBasic_DateAndTimeAssignment thePtr) -> Handle_StepBasic_DateAndTimeAssignment
        assign(Handle_StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateAndTimeAssignment theHandle) -> Handle_StepBasic_DateAndTimeAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DateAndTimeAssignment self) -> StepBasic_DateAndTimeAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DateAndTimeAssignment self) -> StepBasic_DateAndTimeAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DateAndTimeAssignment self) -> StepBasic_DateAndTimeAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DateAndTimeAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DateAndTimeAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DateAndTimeAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DateAndTimeAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateAndTime aAssignedDateAndTime, Handle_StepBasic_DateTimeRole aRole)

        :type aAssignedDateAndTime: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_Init(self, *args)


    def SetAssignedDateAndTime(self, *args):
        """
        SetAssignedDateAndTime(Handle_StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateAndTime aAssignedDateAndTime)

        :type aAssignedDateAndTime: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_SetAssignedDateAndTime(self, *args)


    def AssignedDateAndTime(self, *args):
        """
        AssignedDateAndTime(Handle_StepBasic_DateAndTimeAssignment self) -> Handle_StepBasic_DateAndTime

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_AssignedDateAndTime(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_DateAndTimeAssignment self, Handle_StepBasic_DateTimeRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_DateAndTimeAssignment self) -> Handle_StepBasic_DateTimeRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_Role(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DateAndTimeAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateAndTimeAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateAndTimeAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DateAndTimeAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DateAndTimeAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DateAndTimeAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DateAndTimeAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DateAndTimeAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DateAndTimeAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DateAndTimeAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DateAndTimeAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DateAndTimeAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_DateAndTimeAssignment_swigregister = _StepBasic.Handle_StepBasic_DateAndTimeAssignment_swigregister
Handle_StepBasic_DateAndTimeAssignment_swigregister(Handle_StepBasic_DateAndTimeAssignment)

def Handle_StepBasic_DateAndTimeAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DateAndTimeAssignment_DownCast(thing)
Handle_StepBasic_DateAndTimeAssignment_DownCast = _StepBasic.Handle_StepBasic_DateAndTimeAssignment_DownCast

class Handle_StepBasic_DocumentType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentType self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentType self, StepBasic_DocumentType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentType self, Handle_StepBasic_DocumentType theHandle) -> Handle_StepBasic_DocumentType
        assign(Handle_StepBasic_DocumentType self, StepBasic_DocumentType thePtr) -> Handle_StepBasic_DocumentType
        assign(Handle_StepBasic_DocumentType self, Handle_StepBasic_DocumentType theHandle) -> Handle_StepBasic_DocumentType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentType self) -> StepBasic_DocumentType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentType self) -> StepBasic_DocumentType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentType self) -> StepBasic_DocumentType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentType___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentType_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentType

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentType self, Handle_TCollection_HAsciiString apdt)

        :type apdt: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentType_Init(self, *args)


    def ProductDataType(self, *args):
        """
        ProductDataType(Handle_StepBasic_DocumentType self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentType_ProductDataType(self, *args)


    def SetProductDataType(self, *args):
        """
        SetProductDataType(Handle_StepBasic_DocumentType self, Handle_TCollection_HAsciiString apdt)

        :type apdt: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentType_SetProductDataType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentType self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentType self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentType self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentType_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentType_swigregister = _StepBasic.Handle_StepBasic_DocumentType_swigregister
Handle_StepBasic_DocumentType_swigregister(Handle_StepBasic_DocumentType)

def Handle_StepBasic_DocumentType_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentType_DownCast(thing)
Handle_StepBasic_DocumentType_DownCast = _StepBasic.Handle_StepBasic_DocumentType_DownCast

class StepBasic_GeneralProperty(Standard.Standard_Transient):
    """Representation of STEP entity GeneralProperty"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_GeneralProperty
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_GeneralProperty(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_GeneralProperty self) -> StepBasic_GeneralProperty

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_GeneralProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_Init(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_GeneralProperty self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_SetId(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_GeneralProperty self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_GeneralProperty self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_GeneralProperty_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_GeneralProperty self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_GeneralProperty_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_GeneralProperty_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_GeneralProperty_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_GeneralProperty_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_GeneralProperty
StepBasic_GeneralProperty_swigregister = _StepBasic.StepBasic_GeneralProperty_swigregister
StepBasic_GeneralProperty_swigregister(StepBasic_GeneralProperty)

def StepBasic_GeneralProperty_get_type_name(*args):
    """
    StepBasic_GeneralProperty_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_GeneralProperty_get_type_name(*args)

def StepBasic_GeneralProperty_get_type_descriptor(*args):
    """
    StepBasic_GeneralProperty_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_GeneralProperty_get_type_descriptor(*args)

class Handle_StepBasic_GroupRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_GroupRelationship self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_GroupRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_GroupRelationship self, StepBasic_GroupRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_GroupRelationship self, Handle_StepBasic_GroupRelationship theHandle) -> Handle_StepBasic_GroupRelationship
        assign(Handle_StepBasic_GroupRelationship self, StepBasic_GroupRelationship thePtr) -> Handle_StepBasic_GroupRelationship
        assign(Handle_StepBasic_GroupRelationship self, Handle_StepBasic_GroupRelationship theHandle) -> Handle_StepBasic_GroupRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_GroupRelationship self) -> StepBasic_GroupRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_GroupRelationship self) -> StepBasic_GroupRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_GroupRelationship self) -> StepBasic_GroupRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_GroupRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_GroupRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_GroupRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_GroupRelationship_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_GroupRelationship

    def Init(self, *args):
        """
        Init(Handle_StepBasic_GroupRelationship self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Group aRelatingGroup, Handle_StepBasic_Group aRelatedGroup)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group
        :type aRelatedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_GroupRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_GroupRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_GroupRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_GroupRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_GroupRelationship self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_HasDescription(self, *args)


    def RelatingGroup(self, *args):
        """
        RelatingGroup(Handle_StepBasic_GroupRelationship self) -> Handle_StepBasic_Group

        Returns field RelatingGroup

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_RelatingGroup(self, *args)


    def SetRelatingGroup(self, *args):
        """
        SetRelatingGroup(Handle_StepBasic_GroupRelationship self, Handle_StepBasic_Group RelatingGroup)

        Set field RelatingGroup

        :type RelatingGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_SetRelatingGroup(self, *args)


    def RelatedGroup(self, *args):
        """
        RelatedGroup(Handle_StepBasic_GroupRelationship self) -> Handle_StepBasic_Group

        Returns field RelatedGroup

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_RelatedGroup(self, *args)


    def SetRelatedGroup(self, *args):
        """
        SetRelatedGroup(Handle_StepBasic_GroupRelationship self, Handle_StepBasic_Group RelatedGroup)

        Set field RelatedGroup

        :type RelatedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_SetRelatedGroup(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_GroupRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_GroupRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_GroupRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_GroupRelationship self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_GroupRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_GroupRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_GroupRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_GroupRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_GroupRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_GroupRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_GroupRelationship self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_GroupRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_GroupRelationship_DecrementRefCounter(self, *args)

Handle_StepBasic_GroupRelationship_swigregister = _StepBasic.Handle_StepBasic_GroupRelationship_swigregister
Handle_StepBasic_GroupRelationship_swigregister(Handle_StepBasic_GroupRelationship)

def Handle_StepBasic_GroupRelationship_DownCast(thing):
    return _StepBasic.Handle_StepBasic_GroupRelationship_DownCast(thing)
Handle_StepBasic_GroupRelationship_DownCast = _StepBasic.Handle_StepBasic_GroupRelationship_DownCast

class StepBasic_UncertaintyMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_UncertaintyMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_UncertaintyMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_UncertaintyMeasureWithUnit self) -> StepBasic_UncertaintyMeasureWithUnit

        Returns a UncertaintyMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_UncertaintyMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_UncertaintyMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_UncertaintyMeasureWithUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_UncertaintyMeasureWithUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_UncertaintyMeasureWithUnit self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_UncertaintyMeasureWithUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_Description(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_UncertaintyMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_UncertaintyMeasureWithUnit
StepBasic_UncertaintyMeasureWithUnit_swigregister = _StepBasic.StepBasic_UncertaintyMeasureWithUnit_swigregister
StepBasic_UncertaintyMeasureWithUnit_swigregister(StepBasic_UncertaintyMeasureWithUnit)

def StepBasic_UncertaintyMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_UncertaintyMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_get_type_name(*args)

def StepBasic_UncertaintyMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_UncertaintyMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_UncertaintyMeasureWithUnit_get_type_descriptor(*args)

class Handle_StepBasic_MassUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_MassUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_MassUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_MassUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_MassUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_MassUnit self, StepBasic_MassUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_MassUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_MassUnit self, Handle_StepBasic_MassUnit theHandle) -> Handle_StepBasic_MassUnit
        assign(Handle_StepBasic_MassUnit self, StepBasic_MassUnit thePtr) -> Handle_StepBasic_MassUnit
        assign(Handle_StepBasic_MassUnit self, Handle_StepBasic_MassUnit theHandle) -> Handle_StepBasic_MassUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_MassUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_MassUnit self) -> StepBasic_MassUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MassUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_MassUnit self) -> StepBasic_MassUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MassUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_MassUnit self) -> StepBasic_MassUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_MassUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_MassUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_MassUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_MassUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_MassUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_MassUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_MassUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_MassUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MassUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MassUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_MassUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_MassUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_MassUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_MassUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_MassUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_MassUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_MassUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_MassUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_MassUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_MassUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MassUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_MassUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_MassUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MassUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_MassUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_MassUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_MassUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MassUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_MassUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_MassUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_MassUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MassUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_MassUnit_swigregister = _StepBasic.Handle_StepBasic_MassUnit_swigregister
Handle_StepBasic_MassUnit_swigregister(Handle_StepBasic_MassUnit)

def Handle_StepBasic_MassUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_MassUnit_DownCast(thing)
Handle_StepBasic_MassUnit_DownCast = _StepBasic.Handle_StepBasic_MassUnit_DownCast

class StepBasic_Unit(StepData.StepData_SelectType):
    """Implements a select type unit (NamedUnit or DerivedUnit)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_Unit self) -> StepBasic_Unit

        Creates empty object


        """
        this = _StepBasic.new_StepBasic_Unit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_Unit self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a type of Unit Entity
        1 -> NamedUnit
        2 -> DerivedUnit

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_Unit_CaseNum(self, *args)


    def NamedUnit(self, *args):
        """
        NamedUnit(StepBasic_Unit self) -> Handle_StepBasic_NamedUnit

        returns Value as a NamedUnit (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit

        """
        return _StepBasic.StepBasic_Unit_NamedUnit(self, *args)


    def DerivedUnit(self, *args):
        """
        DerivedUnit(StepBasic_Unit self) -> Handle_StepBasic_DerivedUnit

        returns Value as a DerivedUnit (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DerivedUnit

        """
        return _StepBasic.StepBasic_Unit_DerivedUnit(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_Unit
StepBasic_Unit_swigregister = _StepBasic.StepBasic_Unit_swigregister
StepBasic_Unit_swigregister(StepBasic_Unit)

class StepBasic_ProductDefinitionFormationRelationship(Standard.Standard_Transient):
    """Representation of STEP entity ProductDefinitionFormationRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionFormationRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionFormationRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionFormationRelationship self) -> StepBasic_ProductDefinitionFormationRelationship

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionFormationRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aRelatingProductDefinitionFormation, Handle_StepBasic_ProductDefinitionFormation aRelatedProductDefinitionFormation)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aRelatedProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_Init(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_ProductDefinitionFormationRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_SetId(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ProductDefinitionFormationRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ProductDefinitionFormationRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_SetDescription(self, *args)


    def RelatingProductDefinitionFormation(self, *args):
        """
        RelatingProductDefinitionFormation(StepBasic_ProductDefinitionFormationRelationship self) -> Handle_StepBasic_ProductDefinitionFormation

        Returns field RelatingProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_RelatingProductDefinitionFormation(self, *args)


    def SetRelatingProductDefinitionFormation(self, *args):
        """
        SetRelatingProductDefinitionFormation(StepBasic_ProductDefinitionFormationRelationship self, Handle_StepBasic_ProductDefinitionFormation RelatingProductDefinitionFormation)

        Set field RelatingProductDefinitionFormation

        :type RelatingProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_SetRelatingProductDefinitionFormation(self, *args)


    def RelatedProductDefinitionFormation(self, *args):
        """
        RelatedProductDefinitionFormation(StepBasic_ProductDefinitionFormationRelationship self) -> Handle_StepBasic_ProductDefinitionFormation

        Returns field RelatedProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_RelatedProductDefinitionFormation(self, *args)


    def SetRelatedProductDefinitionFormation(self, *args):
        """
        SetRelatedProductDefinitionFormation(StepBasic_ProductDefinitionFormationRelationship self, Handle_StepBasic_ProductDefinitionFormation RelatedProductDefinitionFormation)

        Set field RelatedProductDefinitionFormation

        :type RelatedProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_SetRelatedProductDefinitionFormation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionFormationRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionFormationRelationship
StepBasic_ProductDefinitionFormationRelationship_swigregister = _StepBasic.StepBasic_ProductDefinitionFormationRelationship_swigregister
StepBasic_ProductDefinitionFormationRelationship_swigregister(StepBasic_ProductDefinitionFormationRelationship)

def StepBasic_ProductDefinitionFormationRelationship_get_type_name(*args):
    """
    StepBasic_ProductDefinitionFormationRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_get_type_name(*args)

def StepBasic_ProductDefinitionFormationRelationship_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionFormationRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionFormationRelationship_get_type_descriptor(*args)

class StepBasic_DocumentFile(StepBasic_Document):
    """Representation of STEP entity DocumentFile"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentFile
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentFile(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DocumentFile self) -> StepBasic_DocumentFile

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_DocumentFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DocumentFile self, Handle_TCollection_HAsciiString aDocument_Id, Handle_TCollection_HAsciiString aDocument_Name, Standard_Boolean const hasDocument_Description, Handle_TCollection_HAsciiString aDocument_Description, Handle_StepBasic_DocumentType aDocument_Kind, Handle_TCollection_HAsciiString aCharacterizedObject_Name, Standard_Boolean const hasCharacterizedObject_Description, Handle_TCollection_HAsciiString aCharacterizedObject_Description)

        Initialize all fields (own and inherited)

        :type aDocument_Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDocument_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDocument_Description: bool
        :type aDocument_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDocument_Kind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType
        :type aCharacterizedObject_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasCharacterizedObject_Description: bool
        :type aCharacterizedObject_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentFile_Init(self, *args)


    def CharacterizedObject(self, *args):
        """
        CharacterizedObject(StepBasic_DocumentFile self) -> Handle_StepBasic_CharacterizedObject

        Returns data for supertype CharacterizedObject

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CharacterizedObject

        """
        return _StepBasic.StepBasic_DocumentFile_CharacterizedObject(self, *args)


    def SetCharacterizedObject(self, *args):
        """
        SetCharacterizedObject(StepBasic_DocumentFile self, Handle_StepBasic_CharacterizedObject CharacterizedObject)

        Set data for supertype CharacterizedObject

        :type CharacterizedObject: OCC.wrapper.StepBasic.Handle_StepBasic_CharacterizedObject

        """
        return _StepBasic.StepBasic_DocumentFile_SetCharacterizedObject(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentFile_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentFile_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentFile_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentFile
StepBasic_DocumentFile_swigregister = _StepBasic.StepBasic_DocumentFile_swigregister
StepBasic_DocumentFile_swigregister(StepBasic_DocumentFile)

def StepBasic_DocumentFile_get_type_name(*args):
    """
    StepBasic_DocumentFile_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentFile_get_type_name(*args)

def StepBasic_DocumentFile_get_type_descriptor(*args):
    """
    StepBasic_DocumentFile_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentFile_get_type_descriptor(*args)

class Handle_StepBasic_LengthUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_LengthUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_LengthUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_LengthUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_LengthUnit self, StepBasic_LengthUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_LengthUnit self, Handle_StepBasic_LengthUnit theHandle) -> Handle_StepBasic_LengthUnit
        assign(Handle_StepBasic_LengthUnit self, StepBasic_LengthUnit thePtr) -> Handle_StepBasic_LengthUnit
        assign(Handle_StepBasic_LengthUnit self, Handle_StepBasic_LengthUnit theHandle) -> Handle_StepBasic_LengthUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_LengthUnit self) -> StepBasic_LengthUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_LengthUnit self) -> StepBasic_LengthUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_LengthUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_LengthUnit self) -> StepBasic_LengthUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_LengthUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_LengthUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_LengthUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_LengthUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_LengthUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_LengthUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_LengthUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_LengthUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_LengthUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_LengthUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_LengthUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_LengthUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_LengthUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_LengthUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_LengthUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_LengthUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_LengthUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_LengthUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_LengthUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_LengthUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_LengthUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_LengthUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_LengthUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LengthUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_LengthUnit_swigregister = _StepBasic.Handle_StepBasic_LengthUnit_swigregister
Handle_StepBasic_LengthUnit_swigregister(Handle_StepBasic_LengthUnit)

def Handle_StepBasic_LengthUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_LengthUnit_DownCast(thing)
Handle_StepBasic_LengthUnit_DownCast = _StepBasic.Handle_StepBasic_LengthUnit_DownCast

class StepBasic_ProductType(StepBasic_ProductRelatedProductCategory):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductType self) -> StepBasic_ProductType

        Returns a ProductType


        """
        this = _StepBasic.new_StepBasic_ProductType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductType
StepBasic_ProductType_swigregister = _StepBasic.StepBasic_ProductType_swigregister
StepBasic_ProductType_swigregister(StepBasic_ProductType)

def StepBasic_ProductType_get_type_name(*args):
    """
    StepBasic_ProductType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductType_get_type_name(*args)

def StepBasic_ProductType_get_type_descriptor(*args):
    """
    StepBasic_ProductType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductType_get_type_descriptor(*args)

class Handle_StepBasic_SiUnitAndTimeUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndTimeUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndTimeUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndTimeUnit self, StepBasic_SiUnitAndTimeUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndTimeUnit self, Handle_StepBasic_SiUnitAndTimeUnit theHandle) -> Handle_StepBasic_SiUnitAndTimeUnit
        assign(Handle_StepBasic_SiUnitAndTimeUnit self, StepBasic_SiUnitAndTimeUnit thePtr) -> Handle_StepBasic_SiUnitAndTimeUnit
        assign(Handle_StepBasic_SiUnitAndTimeUnit self, Handle_StepBasic_SiUnitAndTimeUnit theHandle) -> Handle_StepBasic_SiUnitAndTimeUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndTimeUnit self) -> StepBasic_SiUnitAndTimeUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndTimeUnit self) -> StepBasic_SiUnitAndTimeUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndTimeUnit self) -> StepBasic_SiUnitAndTimeUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndTimeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndTimeUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndTimeUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_Init(self, *args)


    def SetTimeUnit(self, *args):
        """
        SetTimeUnit(Handle_StepBasic_SiUnitAndTimeUnit self, Handle_StepBasic_TimeUnit aTimeUnit)

        :type aTimeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_SetTimeUnit(self, *args)


    def TimeUnit(self, *args):
        """
        TimeUnit(Handle_StepBasic_SiUnitAndTimeUnit self) -> Handle_StepBasic_TimeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_TimeUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndTimeUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndTimeUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndTimeUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndTimeUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndTimeUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndTimeUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndTimeUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndTimeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndTimeUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndTimeUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndTimeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndTimeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndTimeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndTimeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndTimeUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndTimeUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndTimeUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndTimeUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndTimeUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_swigregister
Handle_StepBasic_SiUnitAndTimeUnit_swigregister(Handle_StepBasic_SiUnitAndTimeUnit)

def Handle_StepBasic_SiUnitAndTimeUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndTimeUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndTimeUnit_DownCast

class Handle_StepBasic_DerivedUnitElement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DerivedUnitElement self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DerivedUnitElement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DerivedUnitElement self, StepBasic_DerivedUnitElement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DerivedUnitElement self, Handle_StepBasic_DerivedUnitElement theHandle) -> Handle_StepBasic_DerivedUnitElement
        assign(Handle_StepBasic_DerivedUnitElement self, StepBasic_DerivedUnitElement thePtr) -> Handle_StepBasic_DerivedUnitElement
        assign(Handle_StepBasic_DerivedUnitElement self, Handle_StepBasic_DerivedUnitElement theHandle) -> Handle_StepBasic_DerivedUnitElement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DerivedUnitElement self) -> StepBasic_DerivedUnitElement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DerivedUnitElement self) -> StepBasic_DerivedUnitElement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DerivedUnitElement self) -> StepBasic_DerivedUnitElement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DerivedUnitElement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DerivedUnitElement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DerivedUnitElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DerivedUnitElement_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DerivedUnitElement

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DerivedUnitElement self, Handle_StepBasic_NamedUnit aUnit, Standard_Real const aExponent)

        :type aUnit: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit
        :type aExponent: float

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_Init(self, *args)


    def SetUnit(self, *args):
        """
        SetUnit(Handle_StepBasic_DerivedUnitElement self, Handle_StepBasic_NamedUnit aUnit)

        :type aUnit: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_SetUnit(self, *args)


    def Unit(self, *args):
        """
        Unit(Handle_StepBasic_DerivedUnitElement self) -> Handle_StepBasic_NamedUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_Unit(self, *args)


    def SetExponent(self, *args):
        """
        SetExponent(Handle_StepBasic_DerivedUnitElement self, Standard_Real const aExponent)

        :type aExponent: float

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_SetExponent(self, *args)


    def Exponent(self, *args):
        """
        Exponent(Handle_StepBasic_DerivedUnitElement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_Exponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DerivedUnitElement self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DerivedUnitElement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DerivedUnitElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DerivedUnitElement self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DerivedUnitElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DerivedUnitElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DerivedUnitElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DerivedUnitElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DerivedUnitElement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DerivedUnitElement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DerivedUnitElement self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DerivedUnitElement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DerivedUnitElement_DecrementRefCounter(self, *args)

Handle_StepBasic_DerivedUnitElement_swigregister = _StepBasic.Handle_StepBasic_DerivedUnitElement_swigregister
Handle_StepBasic_DerivedUnitElement_swigregister(Handle_StepBasic_DerivedUnitElement)

def Handle_StepBasic_DerivedUnitElement_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DerivedUnitElement_DownCast(thing)
Handle_StepBasic_DerivedUnitElement_DownCast = _StepBasic.Handle_StepBasic_DerivedUnitElement_DownCast

class Handle_StepBasic_CertificationType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_CertificationType self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_CertificationType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_CertificationType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_CertificationType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_CertificationType self, StepBasic_CertificationType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_CertificationType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_CertificationType self, Handle_StepBasic_CertificationType theHandle) -> Handle_StepBasic_CertificationType
        assign(Handle_StepBasic_CertificationType self, StepBasic_CertificationType thePtr) -> Handle_StepBasic_CertificationType
        assign(Handle_StepBasic_CertificationType self, Handle_StepBasic_CertificationType theHandle) -> Handle_StepBasic_CertificationType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_CertificationType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_CertificationType self) -> StepBasic_CertificationType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CertificationType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_CertificationType self) -> StepBasic_CertificationType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CertificationType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_CertificationType self) -> StepBasic_CertificationType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_CertificationType___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_CertificationType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_CertificationType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_CertificationType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_CertificationType_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_CertificationType

    def Init(self, *args):
        """
        Init(Handle_StepBasic_CertificationType self, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CertificationType_Init(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_CertificationType self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CertificationType_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_CertificationType self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CertificationType_SetDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_CertificationType self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_CertificationType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CertificationType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CertificationType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_CertificationType self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_CertificationType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_CertificationType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_CertificationType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CertificationType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_CertificationType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_CertificationType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CertificationType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_CertificationType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_CertificationType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_CertificationType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CertificationType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_CertificationType self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_CertificationType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_CertificationType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CertificationType_DecrementRefCounter(self, *args)

Handle_StepBasic_CertificationType_swigregister = _StepBasic.Handle_StepBasic_CertificationType_swigregister
Handle_StepBasic_CertificationType_swigregister(Handle_StepBasic_CertificationType)

def Handle_StepBasic_CertificationType_DownCast(thing):
    return _StepBasic.Handle_StepBasic_CertificationType_DownCast(thing)
Handle_StepBasic_CertificationType_DownCast = _StepBasic.Handle_StepBasic_CertificationType_DownCast

class Handle_StepBasic_ApprovalDateTime(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApprovalDateTime self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApprovalDateTime self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApprovalDateTime self, StepBasic_ApprovalDateTime thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApprovalDateTime self, Handle_StepBasic_ApprovalDateTime theHandle) -> Handle_StepBasic_ApprovalDateTime
        assign(Handle_StepBasic_ApprovalDateTime self, StepBasic_ApprovalDateTime thePtr) -> Handle_StepBasic_ApprovalDateTime
        assign(Handle_StepBasic_ApprovalDateTime self, Handle_StepBasic_ApprovalDateTime theHandle) -> Handle_StepBasic_ApprovalDateTime

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApprovalDateTime self) -> StepBasic_ApprovalDateTime

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApprovalDateTime self) -> StepBasic_ApprovalDateTime

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApprovalDateTime self) -> StepBasic_ApprovalDateTime

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApprovalDateTime___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApprovalDateTime___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApprovalDateTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApprovalDateTime_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApprovalDateTime

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApprovalDateTime self, StepBasic_DateTimeSelect aDateTime, Handle_StepBasic_Approval aDatedApproval)

        :type aDateTime: OCC.wrapper.StepBasic.StepBasic_DateTimeSelect
        :type aDatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_Init(self, *args)


    def SetDateTime(self, *args):
        """
        SetDateTime(Handle_StepBasic_ApprovalDateTime self, StepBasic_DateTimeSelect aDateTime)

        :type aDateTime: OCC.wrapper.StepBasic.StepBasic_DateTimeSelect

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_SetDateTime(self, *args)


    def DateTime(self, *args):
        """
        DateTime(Handle_StepBasic_ApprovalDateTime self) -> StepBasic_DateTimeSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_DateTimeSelect

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_DateTime(self, *args)


    def SetDatedApproval(self, *args):
        """
        SetDatedApproval(Handle_StepBasic_ApprovalDateTime self, Handle_StepBasic_Approval aDatedApproval)

        :type aDatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_SetDatedApproval(self, *args)


    def DatedApproval(self, *args):
        """
        DatedApproval(Handle_StepBasic_ApprovalDateTime self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_DatedApproval(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApprovalDateTime self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalDateTime_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalDateTime_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApprovalDateTime self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApprovalDateTime self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApprovalDateTime self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApprovalDateTime self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApprovalDateTime self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApprovalDateTime self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApprovalDateTime self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApprovalDateTime self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApprovalDateTime self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalDateTime_DecrementRefCounter(self, *args)

Handle_StepBasic_ApprovalDateTime_swigregister = _StepBasic.Handle_StepBasic_ApprovalDateTime_swigregister
Handle_StepBasic_ApprovalDateTime_swigregister(Handle_StepBasic_ApprovalDateTime)

def Handle_StepBasic_ApprovalDateTime_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApprovalDateTime_DownCast(thing)
Handle_StepBasic_ApprovalDateTime_DownCast = _StepBasic.Handle_StepBasic_ApprovalDateTime_DownCast

class Handle_StepBasic_ExternalSource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ExternalSource self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ExternalSource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ExternalSource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ExternalSource self, StepBasic_ExternalSource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ExternalSource self, Handle_StepBasic_ExternalSource theHandle) -> Handle_StepBasic_ExternalSource
        assign(Handle_StepBasic_ExternalSource self, StepBasic_ExternalSource thePtr) -> Handle_StepBasic_ExternalSource
        assign(Handle_StepBasic_ExternalSource self, Handle_StepBasic_ExternalSource theHandle) -> Handle_StepBasic_ExternalSource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ExternalSource self) -> StepBasic_ExternalSource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ExternalSource self) -> StepBasic_ExternalSource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ExternalSource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ExternalSource self) -> StepBasic_ExternalSource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ExternalSource___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ExternalSource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ExternalSource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ExternalSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ExternalSource_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ExternalSource

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ExternalSource self, StepBasic_SourceItem aSourceId)

        Initialize all fields (own and inherited)

        :type aSourceId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_Init(self, *args)


    def SourceId(self, *args):
        """
        SourceId(Handle_StepBasic_ExternalSource self) -> StepBasic_SourceItem

        Returns field SourceId

        :rtype: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_SourceId(self, *args)


    def SetSourceId(self, *args):
        """
        SetSourceId(Handle_StepBasic_ExternalSource self, StepBasic_SourceItem SourceId)

        Set field SourceId

        :type SourceId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_SetSourceId(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ExternalSource self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ExternalSource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ExternalSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ExternalSource self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ExternalSource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ExternalSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ExternalSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ExternalSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ExternalSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ExternalSource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ExternalSource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ExternalSource self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ExternalSource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ExternalSource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ExternalSource_DecrementRefCounter(self, *args)

Handle_StepBasic_ExternalSource_swigregister = _StepBasic.Handle_StepBasic_ExternalSource_swigregister
Handle_StepBasic_ExternalSource_swigregister(Handle_StepBasic_ExternalSource)

def Handle_StepBasic_ExternalSource_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ExternalSource_DownCast(thing)
Handle_StepBasic_ExternalSource_DownCast = _StepBasic.Handle_StepBasic_ExternalSource_DownCast

class Handle_StepBasic_ConversionBasedUnitAndAreaUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, StepBasic_ConversionBasedUnitAndAreaUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_ConversionBasedUnitAndAreaUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndAreaUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, StepBasic_ConversionBasedUnitAndAreaUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndAreaUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_ConversionBasedUnitAndAreaUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndAreaUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> StepBasic_ConversionBasedUnitAndAreaUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> StepBasic_ConversionBasedUnitAndAreaUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> StepBasic_ConversionBasedUnitAndAreaUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndAreaUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndAreaUnit

    def SetAreaUnit(self, *args):
        """
        SetAreaUnit(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_AreaUnit anAreaUnit)

        :type anAreaUnit: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_SetAreaUnit(self, *args)


    def AreaUnit(self, *args):
        """
        AreaUnit(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Handle_StepBasic_AreaUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_AreaUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndAreaUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndAreaUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndAreaUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndAreaUnit)

def Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndAreaUnit_DownCast

class StepBasic_RoleSelect(StepData.StepData_SelectType):
    """Representation of STEP SELECT type RoleSelect"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_RoleSelect self) -> StepBasic_RoleSelect

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_RoleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_RoleSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of RoleSelect select type
        1 -> ActionAssignment from StepBasic
        2 -> ActionRequestAssignment from StepBasic
        3 -> ApprovalAssignment from StepBasic
        4 -> ApprovalDateTime from StepBasic
        5 -> CertificationAssignment from StepBasic
        6 -> ContractAssignment from StepBasic
        7 -> DocumentReference from StepBasic
        8 -> EffectivityAssignment from StepBasic
        9 -> GroupAssignment from StepBasic
        10 -> NameAssignment from StepBasic
        11 -> SecurityClassificationAssignment from StepBasic
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_RoleSelect_CaseNum(self, *args)


    def ActionAssignment(self, *args):
        """
        ActionAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_ActionAssignment

        Returns Value as ActionAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ActionAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_ActionAssignment(self, *args)


    def ActionRequestAssignment(self, *args):
        """
        ActionRequestAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_ActionRequestAssignment

        Returns Value as ActionRequestAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ActionRequestAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_ActionRequestAssignment(self, *args)


    def ApprovalAssignment(self, *args):
        """
        ApprovalAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_ApprovalAssignment

        Returns Value as ApprovalAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_ApprovalAssignment(self, *args)


    def ApprovalDateTime(self, *args):
        """
        ApprovalDateTime(StepBasic_RoleSelect self) -> Handle_StepBasic_ApprovalDateTime

        Returns Value as ApprovalDateTime (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalDateTime

        """
        return _StepBasic.StepBasic_RoleSelect_ApprovalDateTime(self, *args)


    def CertificationAssignment(self, *args):
        """
        CertificationAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_CertificationAssignment

        Returns Value as CertificationAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_CertificationAssignment(self, *args)


    def ContractAssignment(self, *args):
        """
        ContractAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_ContractAssignment

        Returns Value as ContractAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ContractAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_ContractAssignment(self, *args)


    def DocumentReference(self, *args):
        """
        DocumentReference(StepBasic_RoleSelect self) -> Handle_StepBasic_DocumentReference

        Returns Value as DocumentReference (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentReference

        """
        return _StepBasic.StepBasic_RoleSelect_DocumentReference(self, *args)


    def EffectivityAssignment(self, *args):
        """
        EffectivityAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_EffectivityAssignment

        Returns Value as EffectivityAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_EffectivityAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_EffectivityAssignment(self, *args)


    def GroupAssignment(self, *args):
        """
        GroupAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_GroupAssignment

        Returns Value as GroupAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_GroupAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_GroupAssignment(self, *args)


    def NameAssignment(self, *args):
        """
        NameAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_NameAssignment

        Returns Value as NameAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_NameAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_NameAssignment(self, *args)


    def SecurityClassificationAssignment(self, *args):
        """
        SecurityClassificationAssignment(StepBasic_RoleSelect self) -> Handle_StepBasic_SecurityClassificationAssignment

        Returns Value as SecurityClassificationAssignment (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationAssignment

        """
        return _StepBasic.StepBasic_RoleSelect_SecurityClassificationAssignment(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_RoleSelect
StepBasic_RoleSelect_swigregister = _StepBasic.StepBasic_RoleSelect_swigregister
StepBasic_RoleSelect_swigregister(StepBasic_RoleSelect)

class Handle_StepBasic_HArray1OfProductDefinition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfProductDefinition self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfProductDefinition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfProductDefinition self, StepBasic_HArray1OfProductDefinition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfProductDefinition self, Handle_StepBasic_HArray1OfProductDefinition theHandle) -> Handle_StepBasic_HArray1OfProductDefinition
        assign(Handle_StepBasic_HArray1OfProductDefinition self, StepBasic_HArray1OfProductDefinition thePtr) -> Handle_StepBasic_HArray1OfProductDefinition
        assign(Handle_StepBasic_HArray1OfProductDefinition self, Handle_StepBasic_HArray1OfProductDefinition theHandle) -> Handle_StepBasic_HArray1OfProductDefinition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfProductDefinition self) -> StepBasic_HArray1OfProductDefinition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfProductDefinition self) -> StepBasic_HArray1OfProductDefinition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfProductDefinition self) -> StepBasic_HArray1OfProductDefinition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfProductDefinition_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfProductDefinition

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductDefinition

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfProductDefinition self) -> NCollection_Array1_Handle_StepBasic_ProductDefinition

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductDefinition

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfProductDefinition self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfProductDefinition self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfProductDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfProductDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfProductDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfProductDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfProductDefinition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfProductDefinition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfProductDefinition self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfProductDefinition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfProductDefinition_swigregister = _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_swigregister
Handle_StepBasic_HArray1OfProductDefinition_swigregister(Handle_StepBasic_HArray1OfProductDefinition)

def Handle_StepBasic_HArray1OfProductDefinition_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_DownCast(thing)
Handle_StepBasic_HArray1OfProductDefinition_DownCast = _StepBasic.Handle_StepBasic_HArray1OfProductDefinition_DownCast

class Handle_StepBasic_UncertaintyMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_UncertaintyMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_UncertaintyMeasureWithUnit self, StepBasic_UncertaintyMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_StepBasic_UncertaintyMeasureWithUnit theHandle) -> Handle_StepBasic_UncertaintyMeasureWithUnit
        assign(Handle_StepBasic_UncertaintyMeasureWithUnit self, StepBasic_UncertaintyMeasureWithUnit thePtr) -> Handle_StepBasic_UncertaintyMeasureWithUnit
        assign(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_StepBasic_UncertaintyMeasureWithUnit theHandle) -> Handle_StepBasic_UncertaintyMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> StepBasic_UncertaintyMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> StepBasic_UncertaintyMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> StepBasic_UncertaintyMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_UncertaintyMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_UncertaintyMeasureWithUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_Description(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_UncertaintyMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_UncertaintyMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_UncertaintyMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_UncertaintyMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_UncertaintyMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_UncertaintyMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_UncertaintyMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_swigregister
Handle_StepBasic_UncertaintyMeasureWithUnit_swigregister(Handle_StepBasic_UncertaintyMeasureWithUnit)

def Handle_StepBasic_UncertaintyMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_DownCast(thing)
Handle_StepBasic_UncertaintyMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_UncertaintyMeasureWithUnit_DownCast

class Handle_StepBasic_CoordinatedUniversalTimeOffset(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_CoordinatedUniversalTimeOffset self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_CoordinatedUniversalTimeOffset self, StepBasic_CoordinatedUniversalTimeOffset thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Handle_StepBasic_CoordinatedUniversalTimeOffset theHandle) -> Handle_StepBasic_CoordinatedUniversalTimeOffset
        assign(Handle_StepBasic_CoordinatedUniversalTimeOffset self, StepBasic_CoordinatedUniversalTimeOffset thePtr) -> Handle_StepBasic_CoordinatedUniversalTimeOffset
        assign(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Handle_StepBasic_CoordinatedUniversalTimeOffset theHandle) -> Handle_StepBasic_CoordinatedUniversalTimeOffset

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> StepBasic_CoordinatedUniversalTimeOffset

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> StepBasic_CoordinatedUniversalTimeOffset

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> StepBasic_CoordinatedUniversalTimeOffset

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_CoordinatedUniversalTimeOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_CoordinatedUniversalTimeOffset

    def Init(self, *args):
        """
        Init(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Standard_Integer const aHourOffset, Standard_Boolean const hasAminuteOffset, Standard_Integer const aMinuteOffset, StepBasic_AheadOrBehind const aSense)

        :type aHourOffset: int
        :type hasAminuteOffset: bool
        :type aMinuteOffset: int
        :type aSense: OCC.wrapper.StepBasic.StepBasic_AheadOrBehind

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_Init(self, *args)


    def SetHourOffset(self, *args):
        """
        SetHourOffset(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Standard_Integer const aHourOffset)

        :type aHourOffset: int

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_SetHourOffset(self, *args)


    def HourOffset(self, *args):
        """
        HourOffset(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_HourOffset(self, *args)


    def SetMinuteOffset(self, *args):
        """
        SetMinuteOffset(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Standard_Integer const aMinuteOffset)

        :type aMinuteOffset: int

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_SetMinuteOffset(self, *args)


    def UnSetMinuteOffset(self, *args):
        """UnSetMinuteOffset(Handle_StepBasic_CoordinatedUniversalTimeOffset self)"""
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_UnSetMinuteOffset(self, *args)


    def MinuteOffset(self, *args):
        """
        MinuteOffset(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_MinuteOffset(self, *args)


    def HasMinuteOffset(self, *args):
        """
        HasMinuteOffset(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_HasMinuteOffset(self, *args)


    def SetSense(self, *args):
        """
        SetSense(Handle_StepBasic_CoordinatedUniversalTimeOffset self, StepBasic_AheadOrBehind const aSense)

        :type aSense: OCC.wrapper.StepBasic.StepBasic_AheadOrBehind

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_SetSense(self, *args)


    def Sense(self, *args):
        """
        Sense(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> StepBasic_AheadOrBehind

        :rtype: OCC.wrapper.StepBasic.StepBasic_AheadOrBehind

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_Sense(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_CoordinatedUniversalTimeOffset self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_CoordinatedUniversalTimeOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_CoordinatedUniversalTimeOffset self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_CoordinatedUniversalTimeOffset self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_DecrementRefCounter(self, *args)

Handle_StepBasic_CoordinatedUniversalTimeOffset_swigregister = _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_swigregister
Handle_StepBasic_CoordinatedUniversalTimeOffset_swigregister(Handle_StepBasic_CoordinatedUniversalTimeOffset)

def Handle_StepBasic_CoordinatedUniversalTimeOffset_DownCast(thing):
    return _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_DownCast(thing)
Handle_StepBasic_CoordinatedUniversalTimeOffset_DownCast = _StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset_DownCast

class StepBasic_DateTimeSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_DateTimeSelect self) -> StepBasic_DateTimeSelect

        Returns a DateTimeSelect SelectType


        """
        this = _StepBasic.new_StepBasic_DateTimeSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_DateTimeSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a DateTimeSelect Kind Entity that is :
        1 -> Date
        2 -> LocalTime
        3 -> DateAndTime
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_DateTimeSelect_CaseNum(self, *args)


    def Date(self, *args):
        """
        Date(StepBasic_DateTimeSelect self) -> Handle_StepBasic_Date

        returns Value as a Date (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.StepBasic_DateTimeSelect_Date(self, *args)


    def LocalTime(self, *args):
        """
        LocalTime(StepBasic_DateTimeSelect self) -> Handle_StepBasic_LocalTime

        returns Value as a LocalTime (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.StepBasic_DateTimeSelect_LocalTime(self, *args)


    def DateAndTime(self, *args):
        """
        DateAndTime(StepBasic_DateTimeSelect self) -> Handle_StepBasic_DateAndTime

        returns Value as a DateAndTime (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _StepBasic.StepBasic_DateTimeSelect_DateAndTime(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_DateTimeSelect
StepBasic_DateTimeSelect_swigregister = _StepBasic.StepBasic_DateTimeSelect_swigregister
StepBasic_DateTimeSelect_swigregister(StepBasic_DateTimeSelect)

class Handle_StepBasic_Date(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Date self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Date_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Date self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Date_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Date self, StepBasic_Date thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Date_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Date self, Handle_StepBasic_Date theHandle) -> Handle_StepBasic_Date
        assign(Handle_StepBasic_Date self, StepBasic_Date thePtr) -> Handle_StepBasic_Date
        assign(Handle_StepBasic_Date self, Handle_StepBasic_Date theHandle) -> Handle_StepBasic_Date

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Date_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Date self) -> StepBasic_Date

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Date_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Date self) -> StepBasic_Date

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Date___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Date self) -> StepBasic_Date

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Date___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Date___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Date___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Date(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Date_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Date

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Date self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.Handle_StepBasic_Date_Init(self, *args)


    def SetYearComponent(self, *args):
        """
        SetYearComponent(Handle_StepBasic_Date self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.Handle_StepBasic_Date_SetYearComponent(self, *args)


    def YearComponent(self, *args):
        """
        YearComponent(Handle_StepBasic_Date self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Date_YearComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Date self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Date_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Date_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Date_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Date self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Date_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Date self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Date self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Date_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Date self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Date self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Date_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Date self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Date_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Date self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Date_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Date self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Date_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Date self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Date_DecrementRefCounter(self, *args)

Handle_StepBasic_Date_swigregister = _StepBasic.Handle_StepBasic_Date_swigregister
Handle_StepBasic_Date_swigregister(Handle_StepBasic_Date)

def Handle_StepBasic_Date_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Date_DownCast(thing)
Handle_StepBasic_Date_DownCast = _StepBasic.Handle_StepBasic_Date_DownCast

class Handle_StepBasic_PlaneAngleUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PlaneAngleUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PlaneAngleUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PlaneAngleUnit self, StepBasic_PlaneAngleUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PlaneAngleUnit self, Handle_StepBasic_PlaneAngleUnit theHandle) -> Handle_StepBasic_PlaneAngleUnit
        assign(Handle_StepBasic_PlaneAngleUnit self, StepBasic_PlaneAngleUnit thePtr) -> Handle_StepBasic_PlaneAngleUnit
        assign(Handle_StepBasic_PlaneAngleUnit self, Handle_StepBasic_PlaneAngleUnit theHandle) -> Handle_StepBasic_PlaneAngleUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PlaneAngleUnit self) -> StepBasic_PlaneAngleUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PlaneAngleUnit self) -> StepBasic_PlaneAngleUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PlaneAngleUnit self) -> StepBasic_PlaneAngleUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PlaneAngleUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PlaneAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PlaneAngleUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PlaneAngleUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PlaneAngleUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PlaneAngleUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PlaneAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_PlaneAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_PlaneAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_PlaneAngleUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PlaneAngleUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PlaneAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PlaneAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PlaneAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PlaneAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PlaneAngleUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PlaneAngleUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PlaneAngleUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PlaneAngleUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_PlaneAngleUnit_swigregister = _StepBasic.Handle_StepBasic_PlaneAngleUnit_swigregister
Handle_StepBasic_PlaneAngleUnit_swigregister(Handle_StepBasic_PlaneAngleUnit)

def Handle_StepBasic_PlaneAngleUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PlaneAngleUnit_DownCast(thing)
Handle_StepBasic_PlaneAngleUnit_DownCast = _StepBasic.Handle_StepBasic_PlaneAngleUnit_DownCast

class Handle_StepBasic_SiUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnit self, StepBasic_SiUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnit self, Handle_StepBasic_SiUnit theHandle) -> Handle_StepBasic_SiUnit
        assign(Handle_StepBasic_SiUnit self, StepBasic_SiUnit thePtr) -> Handle_StepBasic_SiUnit
        assign(Handle_StepBasic_SiUnit self, Handle_StepBasic_SiUnit theHandle) -> Handle_StepBasic_SiUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnit self) -> StepBasic_SiUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnit self) -> StepBasic_SiUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnit self) -> StepBasic_SiUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnit_Init(self, *args)


    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnit_Dimensions(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnit_swigregister
Handle_StepBasic_SiUnit_swigregister(Handle_StepBasic_SiUnit)

def Handle_StepBasic_SiUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnit_DownCast(thing)
Handle_StepBasic_SiUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnit_DownCast

class Handle_StepBasic_ProductRelatedProductCategory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductRelatedProductCategory self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductRelatedProductCategory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductRelatedProductCategory self, StepBasic_ProductRelatedProductCategory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductRelatedProductCategory self, Handle_StepBasic_ProductRelatedProductCategory theHandle) -> Handle_StepBasic_ProductRelatedProductCategory
        assign(Handle_StepBasic_ProductRelatedProductCategory self, StepBasic_ProductRelatedProductCategory thePtr) -> Handle_StepBasic_ProductRelatedProductCategory
        assign(Handle_StepBasic_ProductRelatedProductCategory self, Handle_StepBasic_ProductRelatedProductCategory theHandle) -> Handle_StepBasic_ProductRelatedProductCategory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductRelatedProductCategory self) -> StepBasic_ProductRelatedProductCategory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductRelatedProductCategory self) -> StepBasic_ProductRelatedProductCategory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductRelatedProductCategory self) -> StepBasic_ProductRelatedProductCategory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductRelatedProductCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductRelatedProductCategory_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductRelatedProductCategory

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductRelatedProductCategory self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasAdescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_HArray1OfProduct aProducts)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAdescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aProducts: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_Init(self, *args)


    def SetProducts(self, *args):
        """
        SetProducts(Handle_StepBasic_ProductRelatedProductCategory self, Handle_StepBasic_HArray1OfProduct aProducts)

        :type aProducts: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_SetProducts(self, *args)


    def Products(self, *args):
        """
        Products(Handle_StepBasic_ProductRelatedProductCategory self) -> Handle_StepBasic_HArray1OfProduct

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_Products(self, *args)


    def ProductsValue(self, *args):
        """
        ProductsValue(Handle_StepBasic_ProductRelatedProductCategory self, Standard_Integer const num) -> Handle_StepBasic_Product

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_ProductsValue(self, *args)


    def NbProducts(self, *args):
        """
        NbProducts(Handle_StepBasic_ProductRelatedProductCategory self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_NbProducts(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductRelatedProductCategory self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductRelatedProductCategory self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductRelatedProductCategory self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductRelatedProductCategory self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_SetDescription(self, *args)


    def UnSetDescription(self, *args):
        """UnSetDescription(Handle_StepBasic_ProductRelatedProductCategory self)"""
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_UnSetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductRelatedProductCategory self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_Description(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ProductRelatedProductCategory self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_HasDescription(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductRelatedProductCategory self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductRelatedProductCategory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductRelatedProductCategory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductRelatedProductCategory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductRelatedProductCategory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductRelatedProductCategory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductRelatedProductCategory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductRelatedProductCategory self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductRelatedProductCategory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductRelatedProductCategory_swigregister = _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_swigregister
Handle_StepBasic_ProductRelatedProductCategory_swigregister(Handle_StepBasic_ProductRelatedProductCategory)

def Handle_StepBasic_ProductRelatedProductCategory_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_DownCast(thing)
Handle_StepBasic_ProductRelatedProductCategory_DownCast = _StepBasic.Handle_StepBasic_ProductRelatedProductCategory_DownCast

class Handle_StepBasic_ProductCategory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductCategory self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductCategory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductCategory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductCategory self, StepBasic_ProductCategory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductCategory self, Handle_StepBasic_ProductCategory theHandle) -> Handle_StepBasic_ProductCategory
        assign(Handle_StepBasic_ProductCategory self, StepBasic_ProductCategory thePtr) -> Handle_StepBasic_ProductCategory
        assign(Handle_StepBasic_ProductCategory self, Handle_StepBasic_ProductCategory theHandle) -> Handle_StepBasic_ProductCategory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductCategory self) -> StepBasic_ProductCategory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductCategory self) -> StepBasic_ProductCategory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductCategory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductCategory self) -> StepBasic_ProductCategory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductCategory___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductCategory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductCategory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductCategory_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductCategory

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductCategory self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasAdescription, Handle_TCollection_HAsciiString aDescription)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAdescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductCategory self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductCategory self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductCategory self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_SetDescription(self, *args)


    def UnSetDescription(self, *args):
        """UnSetDescription(Handle_StepBasic_ProductCategory self)"""
        return _StepBasic.Handle_StepBasic_ProductCategory_UnSetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductCategory self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_Description(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ProductCategory self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductCategory self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductCategory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductCategory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductCategory self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductCategory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductCategory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductCategory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductCategory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductCategory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductCategory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductCategory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductCategory self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductCategory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductCategory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductCategory_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductCategory_swigregister = _StepBasic.Handle_StepBasic_ProductCategory_swigregister
Handle_StepBasic_ProductCategory_swigregister(Handle_StepBasic_ProductCategory)

def Handle_StepBasic_ProductCategory_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductCategory_DownCast(thing)
Handle_StepBasic_ProductCategory_DownCast = _StepBasic.Handle_StepBasic_ProductCategory_DownCast

class NCollection_Array1_Handle_StepBasic_Product(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_Product self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_Product self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_Product self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_Product self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_Product(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_Product self, Handle_StepBasic_Product theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_Product self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_Product self, NCollection_Array1_Handle_StepBasic_Product theOther) -> NCollection_Array1_Handle_StepBasic_Product

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_Product self, NCollection_Array1_Handle_StepBasic_Product theOther) -> NCollection_Array1_Handle_StepBasic_Product

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_Product self, NCollection_Array1_Handle_StepBasic_Product theOther) -> NCollection_Array1_Handle_StepBasic_Product
        assign(NCollection_Array1_Handle_StepBasic_Product self, NCollection_Array1_Handle_StepBasic_Product theOther) -> NCollection_Array1_Handle_StepBasic_Product

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Product_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_Product self) -> Handle_StepBasic_Product

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_Product self) -> Handle_StepBasic_Product

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_Product self, Standard_Integer const theIndex) -> Handle_StepBasic_Product

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Product___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Product_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_Product self, Standard_Integer const theIndex, Handle_StepBasic_Product theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_Product self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Product_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_Product
NCollection_Array1_Handle_StepBasic_Product_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_Product_swigregister
NCollection_Array1_Handle_StepBasic_Product_swigregister(NCollection_Array1_Handle_StepBasic_Product)


try:
	StepBasic_Array1OfProduct = NCollection_Array1_Handle_StepBasic_Product
except NameError:
	pass # does not exist, probably ignored

class Handle_StepBasic_ConversionBasedUnitAndTimeUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, StepBasic_ConversionBasedUnitAndTimeUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_ConversionBasedUnitAndTimeUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndTimeUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, StepBasic_ConversionBasedUnitAndTimeUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndTimeUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_ConversionBasedUnitAndTimeUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndTimeUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> StepBasic_ConversionBasedUnitAndTimeUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> StepBasic_ConversionBasedUnitAndTimeUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> StepBasic_ConversionBasedUnitAndTimeUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndTimeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndTimeUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_Init(self, *args)


    def SetTimeUnit(self, *args):
        """
        SetTimeUnit(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_TimeUnit aTimeUnit)

        :type aTimeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_SetTimeUnit(self, *args)


    def TimeUnit(self, *args):
        """
        TimeUnit(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Handle_StepBasic_TimeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_TimeUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_TimeUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndTimeUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndTimeUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndTimeUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndTimeUnit)

def Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndTimeUnit_DownCast

class StepBasic_ProductOrFormationOrDefinition(StepData.StepData_SelectType):
    """Representation of STEP SELECT type ProductOrFormationOrDefinition"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_ProductOrFormationOrDefinition self) -> StepBasic_ProductOrFormationOrDefinition

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ProductOrFormationOrDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_ProductOrFormationOrDefinition self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of ProductOrFormationOrDefinition select type
        1 -> Product from StepBasic
        2 -> ProductDefinitionFormation from StepBasic
        3 -> ProductDefinition from StepBasic
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_ProductOrFormationOrDefinition_CaseNum(self, *args)


    def Product(self, *args):
        """
        Product(StepBasic_ProductOrFormationOrDefinition self) -> Handle_StepBasic_Product

        Returns Value as Product (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.StepBasic_ProductOrFormationOrDefinition_Product(self, *args)


    def ProductDefinitionFormation(self, *args):
        """
        ProductDefinitionFormation(StepBasic_ProductOrFormationOrDefinition self) -> Handle_StepBasic_ProductDefinitionFormation

        Returns Value as ProductDefinitionFormation (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.StepBasic_ProductOrFormationOrDefinition_ProductDefinitionFormation(self, *args)


    def ProductDefinition(self, *args):
        """
        ProductDefinition(StepBasic_ProductOrFormationOrDefinition self) -> Handle_StepBasic_ProductDefinition

        Returns Value as ProductDefinition (or Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _StepBasic.StepBasic_ProductOrFormationOrDefinition_ProductDefinition(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductOrFormationOrDefinition
StepBasic_ProductOrFormationOrDefinition_swigregister = _StepBasic.StepBasic_ProductOrFormationOrDefinition_swigregister
StepBasic_ProductOrFormationOrDefinition_swigregister(StepBasic_ProductOrFormationOrDefinition)

class Handle_StepBasic_AreaUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_AreaUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_AreaUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_AreaUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_AreaUnit self, StepBasic_AreaUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_AreaUnit self, Handle_StepBasic_AreaUnit theHandle) -> Handle_StepBasic_AreaUnit
        assign(Handle_StepBasic_AreaUnit self, StepBasic_AreaUnit thePtr) -> Handle_StepBasic_AreaUnit
        assign(Handle_StepBasic_AreaUnit self, Handle_StepBasic_AreaUnit theHandle) -> Handle_StepBasic_AreaUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_AreaUnit self) -> StepBasic_AreaUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_AreaUnit self) -> StepBasic_AreaUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_AreaUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_AreaUnit self) -> StepBasic_AreaUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_AreaUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_AreaUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_AreaUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_AreaUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_AreaUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_AreaUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_AreaUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_AreaUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_AreaUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_AreaUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_AreaUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_AreaUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_AreaUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_AreaUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_AreaUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_AreaUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_AreaUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_AreaUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_AreaUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_AreaUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_AreaUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_AreaUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_AreaUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_AreaUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_AreaUnit_swigregister = _StepBasic.Handle_StepBasic_AreaUnit_swigregister
Handle_StepBasic_AreaUnit_swigregister(Handle_StepBasic_AreaUnit)

def Handle_StepBasic_AreaUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_AreaUnit_DownCast(thing)
Handle_StepBasic_AreaUnit_DownCast = _StepBasic.Handle_StepBasic_AreaUnit_DownCast

class Handle_StepBasic_SecurityClassification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SecurityClassification self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SecurityClassification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SecurityClassification self, StepBasic_SecurityClassification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SecurityClassification self, Handle_StepBasic_SecurityClassification theHandle) -> Handle_StepBasic_SecurityClassification
        assign(Handle_StepBasic_SecurityClassification self, StepBasic_SecurityClassification thePtr) -> Handle_StepBasic_SecurityClassification
        assign(Handle_StepBasic_SecurityClassification self, Handle_StepBasic_SecurityClassification theHandle) -> Handle_StepBasic_SecurityClassification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SecurityClassification self) -> StepBasic_SecurityClassification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SecurityClassification self) -> StepBasic_SecurityClassification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SecurityClassification self) -> StepBasic_SecurityClassification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SecurityClassification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SecurityClassification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SecurityClassification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SecurityClassification_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SecurityClassification

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SecurityClassification self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aPurpose, Handle_StepBasic_SecurityClassificationLevel aSecurityLevel)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSecurityLevel: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SecurityClassification self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SecurityClassification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_Name(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(Handle_StepBasic_SecurityClassification self, Handle_TCollection_HAsciiString aPurpose)

        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_SetPurpose(self, *args)


    def Purpose(self, *args):
        """
        Purpose(Handle_StepBasic_SecurityClassification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_Purpose(self, *args)


    def SetSecurityLevel(self, *args):
        """
        SetSecurityLevel(Handle_StepBasic_SecurityClassification self, Handle_StepBasic_SecurityClassificationLevel aSecurityLevel)

        :type aSecurityLevel: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_SetSecurityLevel(self, *args)


    def SecurityLevel(self, *args):
        """
        SecurityLevel(Handle_StepBasic_SecurityClassification self) -> Handle_StepBasic_SecurityClassificationLevel

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_SecurityLevel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SecurityClassification self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SecurityClassification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SecurityClassification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SecurityClassification self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SecurityClassification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SecurityClassification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SecurityClassification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SecurityClassification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SecurityClassification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SecurityClassification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SecurityClassification self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SecurityClassification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SecurityClassification_DecrementRefCounter(self, *args)

Handle_StepBasic_SecurityClassification_swigregister = _StepBasic.Handle_StepBasic_SecurityClassification_swigregister
Handle_StepBasic_SecurityClassification_swigregister(Handle_StepBasic_SecurityClassification)

def Handle_StepBasic_SecurityClassification_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SecurityClassification_DownCast(thing)
Handle_StepBasic_SecurityClassification_DownCast = _StepBasic.Handle_StepBasic_SecurityClassification_DownCast

class Handle_StepBasic_ExternallyDefinedItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ExternallyDefinedItem self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ExternallyDefinedItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ExternallyDefinedItem self, StepBasic_ExternallyDefinedItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ExternallyDefinedItem self, Handle_StepBasic_ExternallyDefinedItem theHandle) -> Handle_StepBasic_ExternallyDefinedItem
        assign(Handle_StepBasic_ExternallyDefinedItem self, StepBasic_ExternallyDefinedItem thePtr) -> Handle_StepBasic_ExternallyDefinedItem
        assign(Handle_StepBasic_ExternallyDefinedItem self, Handle_StepBasic_ExternallyDefinedItem theHandle) -> Handle_StepBasic_ExternallyDefinedItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ExternallyDefinedItem self) -> StepBasic_ExternallyDefinedItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ExternallyDefinedItem self) -> StepBasic_ExternallyDefinedItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ExternallyDefinedItem self) -> StepBasic_ExternallyDefinedItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ExternallyDefinedItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ExternallyDefinedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ExternallyDefinedItem_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ExternallyDefinedItem

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ExternallyDefinedItem self, StepBasic_SourceItem aItemId, Handle_StepBasic_ExternalSource aSource)

        Initialize all fields (own and inherited)

        :type aItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem
        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_Init(self, *args)


    def ItemId(self, *args):
        """
        ItemId(Handle_StepBasic_ExternallyDefinedItem self) -> StepBasic_SourceItem

        Returns field ItemId

        :rtype: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_ItemId(self, *args)


    def SetItemId(self, *args):
        """
        SetItemId(Handle_StepBasic_ExternallyDefinedItem self, StepBasic_SourceItem ItemId)

        Set field ItemId

        :type ItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_SetItemId(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepBasic_ExternallyDefinedItem self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepBasic_ExternallyDefinedItem self, Handle_StepBasic_ExternalSource Source)

        Set field Source

        :type Source: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_SetSource(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ExternallyDefinedItem self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ExternallyDefinedItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ExternallyDefinedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ExternallyDefinedItem self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ExternallyDefinedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ExternallyDefinedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ExternallyDefinedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ExternallyDefinedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ExternallyDefinedItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ExternallyDefinedItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ExternallyDefinedItem self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ExternallyDefinedItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_DecrementRefCounter(self, *args)

Handle_StepBasic_ExternallyDefinedItem_swigregister = _StepBasic.Handle_StepBasic_ExternallyDefinedItem_swigregister
Handle_StepBasic_ExternallyDefinedItem_swigregister(Handle_StepBasic_ExternallyDefinedItem)

def Handle_StepBasic_ExternallyDefinedItem_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ExternallyDefinedItem_DownCast(thing)
Handle_StepBasic_ExternallyDefinedItem_DownCast = _StepBasic.Handle_StepBasic_ExternallyDefinedItem_DownCast

class Handle_StepBasic_ConversionBasedUnitAndVolumeUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, StepBasic_ConversionBasedUnitAndVolumeUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_ConversionBasedUnitAndVolumeUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndVolumeUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, StepBasic_ConversionBasedUnitAndVolumeUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndVolumeUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_ConversionBasedUnitAndVolumeUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndVolumeUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> StepBasic_ConversionBasedUnitAndVolumeUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> StepBasic_ConversionBasedUnitAndVolumeUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> StepBasic_ConversionBasedUnitAndVolumeUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndVolumeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndVolumeUnit

    def SetVolumeUnit(self, *args):
        """
        SetVolumeUnit(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_VolumeUnit aVolumeUnit)

        :type aVolumeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_SetVolumeUnit(self, *args)


    def VolumeUnit(self, *args):
        """
        VolumeUnit(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Handle_StepBasic_VolumeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_VolumeUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndVolumeUnit)

def Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndVolumeUnit_DownCast

class Handle_StepBasic_SiUnitAndAreaUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndAreaUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndAreaUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndAreaUnit self, StepBasic_SiUnitAndAreaUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndAreaUnit self, Handle_StepBasic_SiUnitAndAreaUnit theHandle) -> Handle_StepBasic_SiUnitAndAreaUnit
        assign(Handle_StepBasic_SiUnitAndAreaUnit self, StepBasic_SiUnitAndAreaUnit thePtr) -> Handle_StepBasic_SiUnitAndAreaUnit
        assign(Handle_StepBasic_SiUnitAndAreaUnit self, Handle_StepBasic_SiUnitAndAreaUnit theHandle) -> Handle_StepBasic_SiUnitAndAreaUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndAreaUnit self) -> StepBasic_SiUnitAndAreaUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndAreaUnit self) -> StepBasic_SiUnitAndAreaUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndAreaUnit self) -> StepBasic_SiUnitAndAreaUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndAreaUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndAreaUnit

    def SetAreaUnit(self, *args):
        """
        SetAreaUnit(Handle_StepBasic_SiUnitAndAreaUnit self, Handle_StepBasic_AreaUnit anAreaUnit)

        :type anAreaUnit: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_SetAreaUnit(self, *args)


    def AreaUnit(self, *args):
        """
        AreaUnit(Handle_StepBasic_SiUnitAndAreaUnit self) -> Handle_StepBasic_AreaUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_AreaUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_AreaUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndAreaUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndAreaUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_Init(self, *args)


    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndAreaUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndAreaUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndAreaUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndAreaUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndAreaUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndAreaUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndAreaUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndAreaUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndAreaUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndAreaUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndAreaUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndAreaUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndAreaUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndAreaUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndAreaUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndAreaUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndAreaUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndAreaUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_swigregister
Handle_StepBasic_SiUnitAndAreaUnit_swigregister(Handle_StepBasic_SiUnitAndAreaUnit)

def Handle_StepBasic_SiUnitAndAreaUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndAreaUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndAreaUnit_DownCast

class StepBasic_ThermodynamicTemperatureUnit(StepBasic_NamedUnit):
    """Representation of STEP entity ThermodynamicTemperatureUnit"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ThermodynamicTemperatureUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ThermodynamicTemperatureUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ThermodynamicTemperatureUnit self) -> StepBasic_ThermodynamicTemperatureUnit

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ThermodynamicTemperatureUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ThermodynamicTemperatureUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ThermodynamicTemperatureUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ThermodynamicTemperatureUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ThermodynamicTemperatureUnit
StepBasic_ThermodynamicTemperatureUnit_swigregister = _StepBasic.StepBasic_ThermodynamicTemperatureUnit_swigregister
StepBasic_ThermodynamicTemperatureUnit_swigregister(StepBasic_ThermodynamicTemperatureUnit)

def StepBasic_ThermodynamicTemperatureUnit_get_type_name(*args):
    """
    StepBasic_ThermodynamicTemperatureUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ThermodynamicTemperatureUnit_get_type_name(*args)

def StepBasic_ThermodynamicTemperatureUnit_get_type_descriptor(*args):
    """
    StepBasic_ThermodynamicTemperatureUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ThermodynamicTemperatureUnit_get_type_descriptor(*args)

class Handle_StepBasic_ProductDefinitionReference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionReference self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionReference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionReference self, StepBasic_ProductDefinitionReference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionReference self, Handle_StepBasic_ProductDefinitionReference theHandle) -> Handle_StepBasic_ProductDefinitionReference
        assign(Handle_StepBasic_ProductDefinitionReference self, StepBasic_ProductDefinitionReference thePtr) -> Handle_StepBasic_ProductDefinitionReference
        assign(Handle_StepBasic_ProductDefinitionReference self, Handle_StepBasic_ProductDefinitionReference theHandle) -> Handle_StepBasic_ProductDefinitionReference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionReference self) -> StepBasic_ProductDefinitionReference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionReference self) -> StepBasic_ProductDefinitionReference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionReference self) -> StepBasic_ProductDefinitionReference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionReference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionReference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionReference_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionReference

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionReference self, Handle_StepBasic_ExternalSource theSource, Handle_TCollection_HAsciiString theProductId, Handle_TCollection_HAsciiString theProductDefinitionFormationId, Handle_TCollection_HAsciiString theProductDefinitionId, Handle_TCollection_HAsciiString theIdOwningOrganizationName)
        Init(Handle_StepBasic_ProductDefinitionReference self, Handle_StepBasic_ExternalSource theSource, Handle_TCollection_HAsciiString theProductId, Handle_TCollection_HAsciiString theProductDefinitionFormationId, Handle_TCollection_HAsciiString theProductDefinitionId)

        Initialize all fields (own and inherited)

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource
        :type theProductId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theProductDefinitionFormationId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theProductDefinitionId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_Init(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepBasic_ProductDefinitionReference self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepBasic_ProductDefinitionReference self, Handle_StepBasic_ExternalSource theSource)

        Set field Source

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_SetSource(self, *args)


    def ProductId(self, *args):
        """
        ProductId(Handle_StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field ProductId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_ProductId(self, *args)


    def SetProductId(self, *args):
        """
        SetProductId(Handle_StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theProductId)

        Set field ProductId

        :type theProductId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_SetProductId(self, *args)


    def ProductDefinitionFormationId(self, *args):
        """
        ProductDefinitionFormationId(Handle_StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field ProductDefinitionFormationId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_ProductDefinitionFormationId(self, *args)


    def SetProductDefinitionFormationId(self, *args):
        """
        SetProductDefinitionFormationId(Handle_StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theProductDefinitionFormationId)

        Set field ProductDefinitionFormationId

        :type theProductDefinitionFormationId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_SetProductDefinitionFormationId(self, *args)


    def ProductDefinitionId(self, *args):
        """
        ProductDefinitionId(Handle_StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field ProductDefinitionId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_ProductDefinitionId(self, *args)


    def SetProductDefinitionId(self, *args):
        """
        SetProductDefinitionId(Handle_StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theProductDefinitionId)

        Set field ProductDefinitionId

        :type theProductDefinitionId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_SetProductDefinitionId(self, *args)


    def IdOwningOrganizationName(self, *args):
        """
        IdOwningOrganizationName(Handle_StepBasic_ProductDefinitionReference self) -> Handle_TCollection_HAsciiString

        Returns field IdOwningOrganizationName

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_IdOwningOrganizationName(self, *args)


    def SetIdOwningOrganizationName(self, *args):
        """
        SetIdOwningOrganizationName(Handle_StepBasic_ProductDefinitionReference self, Handle_TCollection_HAsciiString theIdOwningOrganizationName)

        Set field IdOwningOrganizationName

        :type theIdOwningOrganizationName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_SetIdOwningOrganizationName(self, *args)


    def HasIdOwningOrganizationName(self, *args):
        """
        HasIdOwningOrganizationName(Handle_StepBasic_ProductDefinitionReference self) -> Standard_Boolean

        Returns true if IdOwningOrganizationName exists

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_HasIdOwningOrganizationName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionReference self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionReference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionReference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionReference self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionReference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionReference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionReference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionReference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionReference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionReference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionReference self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionReference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReference_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionReference_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionReference_swigregister
Handle_StepBasic_ProductDefinitionReference_swigregister(Handle_StepBasic_ProductDefinitionReference)

def Handle_StepBasic_ProductDefinitionReference_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionReference_DownCast(thing)
Handle_StepBasic_ProductDefinitionReference_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionReference_DownCast

class Handle_StepBasic_LocalTime(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_LocalTime self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_LocalTime_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_LocalTime self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_LocalTime_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_LocalTime self, StepBasic_LocalTime thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_LocalTime_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_LocalTime self, Handle_StepBasic_LocalTime theHandle) -> Handle_StepBasic_LocalTime
        assign(Handle_StepBasic_LocalTime self, StepBasic_LocalTime thePtr) -> Handle_StepBasic_LocalTime
        assign(Handle_StepBasic_LocalTime self, Handle_StepBasic_LocalTime theHandle) -> Handle_StepBasic_LocalTime

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_LocalTime_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_LocalTime self) -> StepBasic_LocalTime

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_LocalTime_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_LocalTime self) -> StepBasic_LocalTime

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_LocalTime___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_LocalTime self) -> StepBasic_LocalTime

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_LocalTime___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_LocalTime___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_LocalTime___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_LocalTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_LocalTime_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_LocalTime

    def Init(self, *args):
        """
        Init(Handle_StepBasic_LocalTime self, Standard_Integer const aHourComponent, Standard_Boolean const hasAminuteComponent, Standard_Integer const aMinuteComponent, Standard_Boolean const hasAsecondComponent, Standard_Real const aSecondComponent, Handle_StepBasic_CoordinatedUniversalTimeOffset aZone)

        :type aHourComponent: int
        :type hasAminuteComponent: bool
        :type aMinuteComponent: int
        :type hasAsecondComponent: bool
        :type aSecondComponent: float
        :type aZone: OCC.wrapper.StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset

        """
        return _StepBasic.Handle_StepBasic_LocalTime_Init(self, *args)


    def SetHourComponent(self, *args):
        """
        SetHourComponent(Handle_StepBasic_LocalTime self, Standard_Integer const aHourComponent)

        :type aHourComponent: int

        """
        return _StepBasic.Handle_StepBasic_LocalTime_SetHourComponent(self, *args)


    def HourComponent(self, *args):
        """
        HourComponent(Handle_StepBasic_LocalTime self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LocalTime_HourComponent(self, *args)


    def SetMinuteComponent(self, *args):
        """
        SetMinuteComponent(Handle_StepBasic_LocalTime self, Standard_Integer const aMinuteComponent)

        :type aMinuteComponent: int

        """
        return _StepBasic.Handle_StepBasic_LocalTime_SetMinuteComponent(self, *args)


    def UnSetMinuteComponent(self, *args):
        """UnSetMinuteComponent(Handle_StepBasic_LocalTime self)"""
        return _StepBasic.Handle_StepBasic_LocalTime_UnSetMinuteComponent(self, *args)


    def MinuteComponent(self, *args):
        """
        MinuteComponent(Handle_StepBasic_LocalTime self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LocalTime_MinuteComponent(self, *args)


    def HasMinuteComponent(self, *args):
        """
        HasMinuteComponent(Handle_StepBasic_LocalTime self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LocalTime_HasMinuteComponent(self, *args)


    def SetSecondComponent(self, *args):
        """
        SetSecondComponent(Handle_StepBasic_LocalTime self, Standard_Real const aSecondComponent)

        :type aSecondComponent: float

        """
        return _StepBasic.Handle_StepBasic_LocalTime_SetSecondComponent(self, *args)


    def UnSetSecondComponent(self, *args):
        """UnSetSecondComponent(Handle_StepBasic_LocalTime self)"""
        return _StepBasic.Handle_StepBasic_LocalTime_UnSetSecondComponent(self, *args)


    def SecondComponent(self, *args):
        """
        SecondComponent(Handle_StepBasic_LocalTime self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_LocalTime_SecondComponent(self, *args)


    def HasSecondComponent(self, *args):
        """
        HasSecondComponent(Handle_StepBasic_LocalTime self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LocalTime_HasSecondComponent(self, *args)


    def SetZone(self, *args):
        """
        SetZone(Handle_StepBasic_LocalTime self, Handle_StepBasic_CoordinatedUniversalTimeOffset aZone)

        :type aZone: OCC.wrapper.StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset

        """
        return _StepBasic.Handle_StepBasic_LocalTime_SetZone(self, *args)


    def Zone(self, *args):
        """
        Zone(Handle_StepBasic_LocalTime self) -> Handle_StepBasic_CoordinatedUniversalTimeOffset

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CoordinatedUniversalTimeOffset

        """
        return _StepBasic.Handle_StepBasic_LocalTime_Zone(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_LocalTime self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_LocalTime_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_LocalTime_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_LocalTime_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_LocalTime self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_LocalTime_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_LocalTime self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_LocalTime self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LocalTime_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_LocalTime self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_LocalTime self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LocalTime_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_LocalTime self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_LocalTime_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_LocalTime self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LocalTime_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_LocalTime self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_LocalTime_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_LocalTime self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LocalTime_DecrementRefCounter(self, *args)

Handle_StepBasic_LocalTime_swigregister = _StepBasic.Handle_StepBasic_LocalTime_swigregister
Handle_StepBasic_LocalTime_swigregister(Handle_StepBasic_LocalTime)

def Handle_StepBasic_LocalTime_DownCast(thing):
    return _StepBasic.Handle_StepBasic_LocalTime_DownCast(thing)
Handle_StepBasic_LocalTime_DownCast = _StepBasic.Handle_StepBasic_LocalTime_DownCast

class Handle_StepBasic_ObjectRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ObjectRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ObjectRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ObjectRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ObjectRole self, StepBasic_ObjectRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ObjectRole self, Handle_StepBasic_ObjectRole theHandle) -> Handle_StepBasic_ObjectRole
        assign(Handle_StepBasic_ObjectRole self, StepBasic_ObjectRole thePtr) -> Handle_StepBasic_ObjectRole
        assign(Handle_StepBasic_ObjectRole self, Handle_StepBasic_ObjectRole theHandle) -> Handle_StepBasic_ObjectRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ObjectRole self) -> StepBasic_ObjectRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ObjectRole self) -> StepBasic_ObjectRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ObjectRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ObjectRole self) -> StepBasic_ObjectRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ObjectRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ObjectRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ObjectRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ObjectRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ObjectRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ObjectRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ObjectRole self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ObjectRole self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ObjectRole self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ObjectRole self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ObjectRole self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ObjectRole self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ObjectRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ObjectRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ObjectRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ObjectRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ObjectRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ObjectRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ObjectRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ObjectRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ObjectRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ObjectRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ObjectRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ObjectRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ObjectRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ObjectRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ObjectRole_DecrementRefCounter(self, *args)

Handle_StepBasic_ObjectRole_swigregister = _StepBasic.Handle_StepBasic_ObjectRole_swigregister
Handle_StepBasic_ObjectRole_swigregister(Handle_StepBasic_ObjectRole)

def Handle_StepBasic_ObjectRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ObjectRole_DownCast(thing)
Handle_StepBasic_ObjectRole_DownCast = _StepBasic.Handle_StepBasic_ObjectRole_DownCast

class Handle_StepBasic_ProductDefinitionFormation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionFormation self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionFormation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionFormation self, StepBasic_ProductDefinitionFormation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionFormation self, Handle_StepBasic_ProductDefinitionFormation theHandle) -> Handle_StepBasic_ProductDefinitionFormation
        assign(Handle_StepBasic_ProductDefinitionFormation self, StepBasic_ProductDefinitionFormation thePtr) -> Handle_StepBasic_ProductDefinitionFormation
        assign(Handle_StepBasic_ProductDefinitionFormation self, Handle_StepBasic_ProductDefinitionFormation theHandle) -> Handle_StepBasic_ProductDefinitionFormation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionFormation self) -> StepBasic_ProductDefinitionFormation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionFormation self) -> StepBasic_ProductDefinitionFormation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionFormation self) -> StepBasic_ProductDefinitionFormation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionFormation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionFormation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionFormation_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionFormation

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionFormation self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Product aOfProduct)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionFormation self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionFormation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinitionFormation self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinitionFormation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_Description(self, *args)


    def SetOfProduct(self, *args):
        """
        SetOfProduct(Handle_StepBasic_ProductDefinitionFormation self, Handle_StepBasic_Product aOfProduct)

        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_SetOfProduct(self, *args)


    def OfProduct(self, *args):
        """
        OfProduct(Handle_StepBasic_ProductDefinitionFormation self) -> Handle_StepBasic_Product

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_OfProduct(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionFormation self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionFormation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionFormation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionFormation self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionFormation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionFormation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionFormation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionFormation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionFormation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionFormation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionFormation self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionFormation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionFormation_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionFormation_swigregister
Handle_StepBasic_ProductDefinitionFormation_swigregister(Handle_StepBasic_ProductDefinitionFormation)

def Handle_StepBasic_ProductDefinitionFormation_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionFormation_DownCast(thing)
Handle_StepBasic_ProductDefinitionFormation_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionFormation_DownCast

class Handle_StepBasic_RatioMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_RatioMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_RatioMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_RatioMeasureWithUnit self, StepBasic_RatioMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_RatioMeasureWithUnit self, Handle_StepBasic_RatioMeasureWithUnit theHandle) -> Handle_StepBasic_RatioMeasureWithUnit
        assign(Handle_StepBasic_RatioMeasureWithUnit self, StepBasic_RatioMeasureWithUnit thePtr) -> Handle_StepBasic_RatioMeasureWithUnit
        assign(Handle_StepBasic_RatioMeasureWithUnit self, Handle_StepBasic_RatioMeasureWithUnit theHandle) -> Handle_StepBasic_RatioMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_RatioMeasureWithUnit self) -> StepBasic_RatioMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_RatioMeasureWithUnit self) -> StepBasic_RatioMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_RatioMeasureWithUnit self) -> StepBasic_RatioMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_RatioMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_RatioMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_RatioMeasureWithUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_RatioMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_RatioMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_RatioMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_RatioMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_RatioMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_RatioMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_RatioMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_RatioMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_RatioMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_RatioMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_RatioMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_RatioMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_RatioMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_RatioMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_RatioMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_RatioMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_RatioMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_RatioMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_swigregister
Handle_StepBasic_RatioMeasureWithUnit_swigregister(Handle_StepBasic_RatioMeasureWithUnit)

def Handle_StepBasic_RatioMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_DownCast(thing)
Handle_StepBasic_RatioMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_RatioMeasureWithUnit_DownCast

class Handle_StepBasic_RoleAssociation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_RoleAssociation self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_RoleAssociation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_RoleAssociation self, StepBasic_RoleAssociation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_RoleAssociation self, Handle_StepBasic_RoleAssociation theHandle) -> Handle_StepBasic_RoleAssociation
        assign(Handle_StepBasic_RoleAssociation self, StepBasic_RoleAssociation thePtr) -> Handle_StepBasic_RoleAssociation
        assign(Handle_StepBasic_RoleAssociation self, Handle_StepBasic_RoleAssociation theHandle) -> Handle_StepBasic_RoleAssociation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_RoleAssociation self) -> StepBasic_RoleAssociation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_RoleAssociation self) -> StepBasic_RoleAssociation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_RoleAssociation self) -> StepBasic_RoleAssociation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_RoleAssociation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_RoleAssociation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_RoleAssociation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_RoleAssociation_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_RoleAssociation

    def Init(self, *args):
        """
        Init(Handle_StepBasic_RoleAssociation self, Handle_StepBasic_ObjectRole aRole, StepBasic_RoleSelect aItemWithRole)

        Initialize all fields (own and inherited)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_ObjectRole
        :type aItemWithRole: OCC.wrapper.StepBasic.StepBasic_RoleSelect

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_Init(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_RoleAssociation self) -> Handle_StepBasic_ObjectRole

        Returns field Role

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ObjectRole

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_Role(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_RoleAssociation self, Handle_StepBasic_ObjectRole Role)

        Set field Role

        :type Role: OCC.wrapper.StepBasic.Handle_StepBasic_ObjectRole

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_SetRole(self, *args)


    def ItemWithRole(self, *args):
        """
        ItemWithRole(Handle_StepBasic_RoleAssociation self) -> StepBasic_RoleSelect

        Returns field ItemWithRole

        :rtype: OCC.wrapper.StepBasic.StepBasic_RoleSelect

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_ItemWithRole(self, *args)


    def SetItemWithRole(self, *args):
        """
        SetItemWithRole(Handle_StepBasic_RoleAssociation self, StepBasic_RoleSelect ItemWithRole)

        Set field ItemWithRole

        :type ItemWithRole: OCC.wrapper.StepBasic.StepBasic_RoleSelect

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_SetItemWithRole(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_RoleAssociation self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_RoleAssociation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_RoleAssociation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_RoleAssociation self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_RoleAssociation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_RoleAssociation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_RoleAssociation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_RoleAssociation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_RoleAssociation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_RoleAssociation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_RoleAssociation self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_RoleAssociation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_RoleAssociation_DecrementRefCounter(self, *args)

Handle_StepBasic_RoleAssociation_swigregister = _StepBasic.Handle_StepBasic_RoleAssociation_swigregister
Handle_StepBasic_RoleAssociation_swigregister(Handle_StepBasic_RoleAssociation)

def Handle_StepBasic_RoleAssociation_DownCast(thing):
    return _StepBasic.Handle_StepBasic_RoleAssociation_DownCast(thing)
Handle_StepBasic_RoleAssociation_DownCast = _StepBasic.Handle_StepBasic_RoleAssociation_DownCast

class Handle_StepBasic_VolumeUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_VolumeUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_VolumeUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_VolumeUnit self, StepBasic_VolumeUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_VolumeUnit self, Handle_StepBasic_VolumeUnit theHandle) -> Handle_StepBasic_VolumeUnit
        assign(Handle_StepBasic_VolumeUnit self, StepBasic_VolumeUnit thePtr) -> Handle_StepBasic_VolumeUnit
        assign(Handle_StepBasic_VolumeUnit self, Handle_StepBasic_VolumeUnit theHandle) -> Handle_StepBasic_VolumeUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_VolumeUnit self) -> StepBasic_VolumeUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_VolumeUnit self) -> StepBasic_VolumeUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_VolumeUnit self) -> StepBasic_VolumeUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_VolumeUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_VolumeUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_VolumeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_VolumeUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_VolumeUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_VolumeUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_VolumeUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_VolumeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_VolumeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_VolumeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_VolumeUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_VolumeUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_VolumeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_VolumeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_VolumeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_VolumeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_VolumeUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_VolumeUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_VolumeUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_VolumeUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_VolumeUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_VolumeUnit_swigregister = _StepBasic.Handle_StepBasic_VolumeUnit_swigregister
Handle_StepBasic_VolumeUnit_swigregister(Handle_StepBasic_VolumeUnit)

def Handle_StepBasic_VolumeUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_VolumeUnit_DownCast(thing)
Handle_StepBasic_VolumeUnit_DownCast = _StepBasic.Handle_StepBasic_VolumeUnit_DownCast

class Handle_StepBasic_SolidAngleMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SolidAngleMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SolidAngleMeasureWithUnit self, StepBasic_SolidAngleMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SolidAngleMeasureWithUnit self, Handle_StepBasic_SolidAngleMeasureWithUnit theHandle) -> Handle_StepBasic_SolidAngleMeasureWithUnit
        assign(Handle_StepBasic_SolidAngleMeasureWithUnit self, StepBasic_SolidAngleMeasureWithUnit thePtr) -> Handle_StepBasic_SolidAngleMeasureWithUnit
        assign(Handle_StepBasic_SolidAngleMeasureWithUnit self, Handle_StepBasic_SolidAngleMeasureWithUnit theHandle) -> Handle_StepBasic_SolidAngleMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> StepBasic_SolidAngleMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> StepBasic_SolidAngleMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> StepBasic_SolidAngleMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SolidAngleMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SolidAngleMeasureWithUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_SolidAngleMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_SolidAngleMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_SolidAngleMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_SolidAngleMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SolidAngleMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SolidAngleMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SolidAngleMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SolidAngleMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SolidAngleMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SolidAngleMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SolidAngleMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SolidAngleMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_swigregister
Handle_StepBasic_SolidAngleMeasureWithUnit_swigregister(Handle_StepBasic_SolidAngleMeasureWithUnit)

def Handle_StepBasic_SolidAngleMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_DownCast(thing)
Handle_StepBasic_SolidAngleMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_SolidAngleMeasureWithUnit_DownCast

class StepBasic_RatioUnit(StepBasic_NamedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_RatioUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_RatioUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_RatioUnit self) -> StepBasic_RatioUnit

        Returns a RatioUnit


        """
        this = _StepBasic.new_StepBasic_RatioUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_RatioUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_RatioUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_RatioUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_RatioUnit
StepBasic_RatioUnit_swigregister = _StepBasic.StepBasic_RatioUnit_swigregister
StepBasic_RatioUnit_swigregister(StepBasic_RatioUnit)

def StepBasic_RatioUnit_get_type_name(*args):
    """
    StepBasic_RatioUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_RatioUnit_get_type_name(*args)

def StepBasic_RatioUnit_get_type_descriptor(*args):
    """
    StepBasic_RatioUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_RatioUnit_get_type_descriptor(*args)

class Handle_StepBasic_SiUnitAndSolidAngleUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndSolidAngleUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndSolidAngleUnit self, StepBasic_SiUnitAndSolidAngleUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Handle_StepBasic_SiUnitAndSolidAngleUnit theHandle) -> Handle_StepBasic_SiUnitAndSolidAngleUnit
        assign(Handle_StepBasic_SiUnitAndSolidAngleUnit self, StepBasic_SiUnitAndSolidAngleUnit thePtr) -> Handle_StepBasic_SiUnitAndSolidAngleUnit
        assign(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Handle_StepBasic_SiUnitAndSolidAngleUnit theHandle) -> Handle_StepBasic_SiUnitAndSolidAngleUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> StepBasic_SiUnitAndSolidAngleUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> StepBasic_SiUnitAndSolidAngleUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> StepBasic_SiUnitAndSolidAngleUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndSolidAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndSolidAngleUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_Init(self, *args)


    def SetSolidAngleUnit(self, *args):
        """
        SetSolidAngleUnit(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Handle_StepBasic_SolidAngleUnit aSolidAngleUnit)

        :type aSolidAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_SetSolidAngleUnit(self, *args)


    def SolidAngleUnit(self, *args):
        """
        SolidAngleUnit(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> Handle_StepBasic_SolidAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_SolidAngleUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndSolidAngleUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndSolidAngleUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndSolidAngleUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndSolidAngleUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndSolidAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndSolidAngleUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndSolidAngleUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndSolidAngleUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_swigregister
Handle_StepBasic_SiUnitAndSolidAngleUnit_swigregister(Handle_StepBasic_SiUnitAndSolidAngleUnit)

def Handle_StepBasic_SiUnitAndSolidAngleUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndSolidAngleUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndSolidAngleUnit_DownCast

class Handle_StepBasic_TimeUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_TimeUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_TimeUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_TimeUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_TimeUnit self, StepBasic_TimeUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_TimeUnit self, Handle_StepBasic_TimeUnit theHandle) -> Handle_StepBasic_TimeUnit
        assign(Handle_StepBasic_TimeUnit self, StepBasic_TimeUnit thePtr) -> Handle_StepBasic_TimeUnit
        assign(Handle_StepBasic_TimeUnit self, Handle_StepBasic_TimeUnit theHandle) -> Handle_StepBasic_TimeUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_TimeUnit self) -> StepBasic_TimeUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_TimeUnit self) -> StepBasic_TimeUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_TimeUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_TimeUnit self) -> StepBasic_TimeUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_TimeUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_TimeUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_TimeUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_TimeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_TimeUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_TimeUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_TimeUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_TimeUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_TimeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_TimeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_TimeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_TimeUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_TimeUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_TimeUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_TimeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_TimeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_TimeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_TimeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_TimeUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_TimeUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_TimeUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_TimeUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_TimeUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_TimeUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_TimeUnit_swigregister = _StepBasic.Handle_StepBasic_TimeUnit_swigregister
Handle_StepBasic_TimeUnit_swigregister(Handle_StepBasic_TimeUnit)

def Handle_StepBasic_TimeUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_TimeUnit_DownCast(thing)
Handle_StepBasic_TimeUnit_DownCast = _StepBasic.Handle_StepBasic_TimeUnit_DownCast

class StepBasic_SourceItem(StepData.StepData_SelectType):
    """Representation of STEP SELECT type SourceItem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_SourceItem self) -> StepBasic_SourceItem

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_SourceItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_SourceItem self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of SourceItem select type
        1 -> HAsciiString from TCollection
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_SourceItem_CaseNum(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepBasic_SourceItem self) -> Handle_StepData_SelectMember

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepBasic.StepBasic_SourceItem_NewMember(self, *args)


    def Identifier(self, *args):
        """
        Identifier(StepBasic_SourceItem self) -> Handle_TCollection_HAsciiString

        Returns Value as Identifier (or Null if another type)

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_SourceItem_Identifier(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_SourceItem
StepBasic_SourceItem_swigregister = _StepBasic.StepBasic_SourceItem_swigregister
StepBasic_SourceItem_swigregister(StepBasic_SourceItem)

class Handle_StepBasic_ProductConceptContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductConceptContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductConceptContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductConceptContext self, StepBasic_ProductConceptContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductConceptContext self, Handle_StepBasic_ProductConceptContext theHandle) -> Handle_StepBasic_ProductConceptContext
        assign(Handle_StepBasic_ProductConceptContext self, StepBasic_ProductConceptContext thePtr) -> Handle_StepBasic_ProductConceptContext
        assign(Handle_StepBasic_ProductConceptContext self, Handle_StepBasic_ProductConceptContext theHandle) -> Handle_StepBasic_ProductConceptContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductConceptContext self) -> StepBasic_ProductConceptContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductConceptContext self) -> StepBasic_ProductConceptContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductConceptContext self) -> StepBasic_ProductConceptContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductConceptContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductConceptContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductConceptContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductConceptContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductConceptContext

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductConceptContext self, Handle_TCollection_HAsciiString aApplicationContextElement_Name, Handle_StepBasic_ApplicationContext aApplicationContextElement_FrameOfReference, Handle_TCollection_HAsciiString aMarketSegmentType)

        Initialize all fields (own and inherited)

        :type aApplicationContextElement_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aApplicationContextElement_FrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aMarketSegmentType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_Init(self, *args)


    def MarketSegmentType(self, *args):
        """
        MarketSegmentType(Handle_StepBasic_ProductConceptContext self) -> Handle_TCollection_HAsciiString

        Returns field MarketSegmentType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_MarketSegmentType(self, *args)


    def SetMarketSegmentType(self, *args):
        """
        SetMarketSegmentType(Handle_StepBasic_ProductConceptContext self, Handle_TCollection_HAsciiString MarketSegmentType)

        Set field MarketSegmentType

        :type MarketSegmentType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_SetMarketSegmentType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductConceptContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductConceptContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductConceptContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductConceptContext self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductConceptContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ProductConceptContext self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ProductConceptContext self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductConceptContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductConceptContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductConceptContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductConceptContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductConceptContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductConceptContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductConceptContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductConceptContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductConceptContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductConceptContext_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductConceptContext_swigregister = _StepBasic.Handle_StepBasic_ProductConceptContext_swigregister
Handle_StepBasic_ProductConceptContext_swigregister(Handle_StepBasic_ProductConceptContext)

def Handle_StepBasic_ProductConceptContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductConceptContext_DownCast(thing)
Handle_StepBasic_ProductConceptContext_DownCast = _StepBasic.Handle_StepBasic_ProductConceptContext_DownCast

class StepBasic_ProductDefinitionRelationship(Standard.Standard_Transient):
    """Representation of STEP entity ProductDefinitionRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionRelationship

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinition aRelatingProductDefinition, Handle_StepBasic_ProductDefinition aRelatedProductDefinition)
        Init(StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, StepBasic_ProductDefinitionOrReference aRelatingProductDefinition, StepBasic_ProductDefinitionOrReference aRelatedProductDefinition)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference
        :type aRelatedProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_Init(self, *args)


    def Id(self, *args):
        """
        Id(StepBasic_ProductDefinitionRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_SetId(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ProductDefinitionRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ProductDefinitionRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_ProductDefinitionRelationship self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_HasDescription(self, *args)


    def RelatingProductDefinition(self, *args):
        """
        RelatingProductDefinition(StepBasic_ProductDefinitionRelationship self) -> Handle_StepBasic_ProductDefinition

        Returns field RelatingProductDefinition

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_RelatingProductDefinition(self, *args)


    def RelatingProductDefinitionAP242(self, *args):
        """
        RelatingProductDefinitionAP242(StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionOrReference

        Returns field RelatingProductDefinition in AP242

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_RelatingProductDefinitionAP242(self, *args)


    def SetRelatingProductDefinition(self, *args):
        """
        SetRelatingProductDefinition(StepBasic_ProductDefinitionRelationship self, Handle_StepBasic_ProductDefinition RelatingProductDefinition)
        SetRelatingProductDefinition(StepBasic_ProductDefinitionRelationship self, StepBasic_ProductDefinitionOrReference RelatingProductDefinition)

        Set field RelatingProductDefinition in AP242

        :type RelatingProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_SetRelatingProductDefinition(self, *args)


    def RelatedProductDefinition(self, *args):
        """
        RelatedProductDefinition(StepBasic_ProductDefinitionRelationship self) -> Handle_StepBasic_ProductDefinition

        Returns field RelatedProductDefinition

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_RelatedProductDefinition(self, *args)


    def RelatedProductDefinitionAP242(self, *args):
        """
        RelatedProductDefinitionAP242(StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionOrReference

        Returns field RelatedProductDefinition in AP242

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_RelatedProductDefinitionAP242(self, *args)


    def SetRelatedProductDefinition(self, *args):
        """
        SetRelatedProductDefinition(StepBasic_ProductDefinitionRelationship self, Handle_StepBasic_ProductDefinition RelatedProductDefinition)
        SetRelatedProductDefinition(StepBasic_ProductDefinitionRelationship self, StepBasic_ProductDefinitionOrReference RelatedProductDefinition)

        Set field RelatedProductDefinition in AP242

        :type RelatedProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_SetRelatedProductDefinition(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionRelationship
StepBasic_ProductDefinitionRelationship_swigregister = _StepBasic.StepBasic_ProductDefinitionRelationship_swigregister
StepBasic_ProductDefinitionRelationship_swigregister(StepBasic_ProductDefinitionRelationship)

def StepBasic_ProductDefinitionRelationship_get_type_name(*args):
    """
    StepBasic_ProductDefinitionRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionRelationship_get_type_name(*args)

def StepBasic_ProductDefinitionRelationship_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionRelationship_get_type_descriptor(*args)

class Handle_StepBasic_ProductType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductType self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductType self, StepBasic_ProductType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductType self, Handle_StepBasic_ProductType theHandle) -> Handle_StepBasic_ProductType
        assign(Handle_StepBasic_ProductType self, StepBasic_ProductType thePtr) -> Handle_StepBasic_ProductType
        assign(Handle_StepBasic_ProductType self, Handle_StepBasic_ProductType theHandle) -> Handle_StepBasic_ProductType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductType self) -> StepBasic_ProductType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductType self) -> StepBasic_ProductType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductType self) -> StepBasic_ProductType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductType___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductType_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductType

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductType self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductType self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasAdescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_HArray1OfProduct aProducts)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAdescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aProducts: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.Handle_StepBasic_ProductType_Init(self, *args)


    def SetProducts(self, *args):
        """
        SetProducts(Handle_StepBasic_ProductType self, Handle_StepBasic_HArray1OfProduct aProducts)

        :type aProducts: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.Handle_StepBasic_ProductType_SetProducts(self, *args)


    def Products(self, *args):
        """
        Products(Handle_StepBasic_ProductType self) -> Handle_StepBasic_HArray1OfProduct

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProduct

        """
        return _StepBasic.Handle_StepBasic_ProductType_Products(self, *args)


    def ProductsValue(self, *args):
        """
        ProductsValue(Handle_StepBasic_ProductType self, Standard_Integer const num) -> Handle_StepBasic_Product

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductType_ProductsValue(self, *args)


    def NbProducts(self, *args):
        """
        NbProducts(Handle_StepBasic_ProductType self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductType_NbProducts(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductType self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductType_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductType self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductType_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductType self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductType_SetDescription(self, *args)


    def UnSetDescription(self, *args):
        """UnSetDescription(Handle_StepBasic_ProductType self)"""
        return _StepBasic.Handle_StepBasic_ProductType_UnSetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductType self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductType_Description(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ProductType self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductType_HasDescription(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductType self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductType self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductType_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductType_swigregister = _StepBasic.Handle_StepBasic_ProductType_swigregister
Handle_StepBasic_ProductType_swigregister(Handle_StepBasic_ProductType)

def Handle_StepBasic_ProductType_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductType_DownCast(thing)
Handle_StepBasic_ProductType_DownCast = _StepBasic.Handle_StepBasic_ProductType_DownCast

class StepBasic_CharacterizedObject(Standard.Standard_Transient):
    """Representation of STEP entity CharacterizedObject"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_CharacterizedObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_CharacterizedObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_CharacterizedObject self) -> StepBasic_CharacterizedObject

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_CharacterizedObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_CharacterizedObject self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CharacterizedObject_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_CharacterizedObject self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CharacterizedObject_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_CharacterizedObject self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CharacterizedObject_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_CharacterizedObject self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CharacterizedObject_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_CharacterizedObject self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_CharacterizedObject_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_CharacterizedObject self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_CharacterizedObject_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_CharacterizedObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_CharacterizedObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_CharacterizedObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_CharacterizedObject
StepBasic_CharacterizedObject_swigregister = _StepBasic.StepBasic_CharacterizedObject_swigregister
StepBasic_CharacterizedObject_swigregister(StepBasic_CharacterizedObject)

def StepBasic_CharacterizedObject_get_type_name(*args):
    """
    StepBasic_CharacterizedObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_CharacterizedObject_get_type_name(*args)

def StepBasic_CharacterizedObject_get_type_descriptor(*args):
    """
    StepBasic_CharacterizedObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_CharacterizedObject_get_type_descriptor(*args)

class Handle_StepBasic_DateRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DateRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DateRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DateRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DateRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DateRole self, StepBasic_DateRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DateRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DateRole self, Handle_StepBasic_DateRole theHandle) -> Handle_StepBasic_DateRole
        assign(Handle_StepBasic_DateRole self, StepBasic_DateRole thePtr) -> Handle_StepBasic_DateRole
        assign(Handle_StepBasic_DateRole self, Handle_StepBasic_DateRole theHandle) -> Handle_StepBasic_DateRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DateRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DateRole self) -> StepBasic_DateRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DateRole self) -> StepBasic_DateRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DateRole self) -> StepBasic_DateRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DateRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DateRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DateRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DateRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DateRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DateRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DateRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DateRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DateRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DateRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DateRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DateRole_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DateRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DateRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DateRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DateRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DateRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DateRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DateRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DateRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DateRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DateRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DateRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DateRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DateRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DateRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateRole_DecrementRefCounter(self, *args)

Handle_StepBasic_DateRole_swigregister = _StepBasic.Handle_StepBasic_DateRole_swigregister
Handle_StepBasic_DateRole_swigregister(Handle_StepBasic_DateRole)

def Handle_StepBasic_DateRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DateRole_DownCast(thing)
Handle_StepBasic_DateRole_DownCast = _StepBasic.Handle_StepBasic_DateRole_DownCast

class Handle_StepBasic_PlaneAngleMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PlaneAngleMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PlaneAngleMeasureWithUnit self, StepBasic_PlaneAngleMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Handle_StepBasic_PlaneAngleMeasureWithUnit theHandle) -> Handle_StepBasic_PlaneAngleMeasureWithUnit
        assign(Handle_StepBasic_PlaneAngleMeasureWithUnit self, StepBasic_PlaneAngleMeasureWithUnit thePtr) -> Handle_StepBasic_PlaneAngleMeasureWithUnit
        assign(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Handle_StepBasic_PlaneAngleMeasureWithUnit theHandle) -> Handle_StepBasic_PlaneAngleMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> StepBasic_PlaneAngleMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> StepBasic_PlaneAngleMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> StepBasic_PlaneAngleMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PlaneAngleMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PlaneAngleMeasureWithUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_PlaneAngleMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PlaneAngleMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PlaneAngleMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PlaneAngleMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PlaneAngleMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_PlaneAngleMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_swigregister
Handle_StepBasic_PlaneAngleMeasureWithUnit_swigregister(Handle_StepBasic_PlaneAngleMeasureWithUnit)

def Handle_StepBasic_PlaneAngleMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_DownCast(thing)
Handle_StepBasic_PlaneAngleMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_PlaneAngleMeasureWithUnit_DownCast

class Handle_StepBasic_VersionedActionRequest(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_VersionedActionRequest self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_VersionedActionRequest self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_VersionedActionRequest self, StepBasic_VersionedActionRequest thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_VersionedActionRequest self, Handle_StepBasic_VersionedActionRequest theHandle) -> Handle_StepBasic_VersionedActionRequest
        assign(Handle_StepBasic_VersionedActionRequest self, StepBasic_VersionedActionRequest thePtr) -> Handle_StepBasic_VersionedActionRequest
        assign(Handle_StepBasic_VersionedActionRequest self, Handle_StepBasic_VersionedActionRequest theHandle) -> Handle_StepBasic_VersionedActionRequest

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_VersionedActionRequest self) -> StepBasic_VersionedActionRequest

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_VersionedActionRequest self) -> StepBasic_VersionedActionRequest

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_VersionedActionRequest self) -> StepBasic_VersionedActionRequest

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_VersionedActionRequest___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_VersionedActionRequest___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_VersionedActionRequest(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_VersionedActionRequest_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_VersionedActionRequest

    def Init(self, *args):
        """
        Init(Handle_StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aVersion, Handle_TCollection_HAsciiString aPurpose, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aVersion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_SetId(self, *args)


    def Version(self, *args):
        """
        Version(Handle_StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Version

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Version(self, *args)


    def SetVersion(self, *args):
        """
        SetVersion(Handle_StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Version)

        Set field Version

        :type Version: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_SetVersion(self, *args)


    def Purpose(self, *args):
        """
        Purpose(Handle_StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(Handle_StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_SetPurpose(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_VersionedActionRequest self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_VersionedActionRequest self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_VersionedActionRequest self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_VersionedActionRequest self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_VersionedActionRequest_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_VersionedActionRequest_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_VersionedActionRequest self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_VersionedActionRequest self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_VersionedActionRequest self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_VersionedActionRequest self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_VersionedActionRequest self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_VersionedActionRequest self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_VersionedActionRequest self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_VersionedActionRequest self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_VersionedActionRequest self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_VersionedActionRequest_DecrementRefCounter(self, *args)

Handle_StepBasic_VersionedActionRequest_swigregister = _StepBasic.Handle_StepBasic_VersionedActionRequest_swigregister
Handle_StepBasic_VersionedActionRequest_swigregister(Handle_StepBasic_VersionedActionRequest)

def Handle_StepBasic_VersionedActionRequest_DownCast(thing):
    return _StepBasic.Handle_StepBasic_VersionedActionRequest_DownCast(thing)
Handle_StepBasic_VersionedActionRequest_DownCast = _StepBasic.Handle_StepBasic_VersionedActionRequest_DownCast

class Handle_StepBasic_IdentificationRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_IdentificationRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_IdentificationRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_IdentificationRole self, StepBasic_IdentificationRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_IdentificationRole self, Handle_StepBasic_IdentificationRole theHandle) -> Handle_StepBasic_IdentificationRole
        assign(Handle_StepBasic_IdentificationRole self, StepBasic_IdentificationRole thePtr) -> Handle_StepBasic_IdentificationRole
        assign(Handle_StepBasic_IdentificationRole self, Handle_StepBasic_IdentificationRole theHandle) -> Handle_StepBasic_IdentificationRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_IdentificationRole self) -> StepBasic_IdentificationRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_IdentificationRole self) -> StepBasic_IdentificationRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_IdentificationRole self) -> StepBasic_IdentificationRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_IdentificationRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_IdentificationRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_IdentificationRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_IdentificationRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_IdentificationRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_IdentificationRole self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_IdentificationRole self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_IdentificationRole self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_IdentificationRole self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_IdentificationRole self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_IdentificationRole self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_IdentificationRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_IdentificationRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_IdentificationRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_IdentificationRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_IdentificationRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_IdentificationRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_IdentificationRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_IdentificationRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_IdentificationRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_IdentificationRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_IdentificationRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_IdentificationRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_IdentificationRole_DecrementRefCounter(self, *args)

Handle_StepBasic_IdentificationRole_swigregister = _StepBasic.Handle_StepBasic_IdentificationRole_swigregister
Handle_StepBasic_IdentificationRole_swigregister(Handle_StepBasic_IdentificationRole)

def Handle_StepBasic_IdentificationRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_IdentificationRole_DownCast(thing)
Handle_StepBasic_IdentificationRole_DownCast = _StepBasic.Handle_StepBasic_IdentificationRole_DownCast

class Handle_StepBasic_GroupAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_GroupAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_GroupAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_GroupAssignment self, StepBasic_GroupAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_GroupAssignment self, Handle_StepBasic_GroupAssignment theHandle) -> Handle_StepBasic_GroupAssignment
        assign(Handle_StepBasic_GroupAssignment self, StepBasic_GroupAssignment thePtr) -> Handle_StepBasic_GroupAssignment
        assign(Handle_StepBasic_GroupAssignment self, Handle_StepBasic_GroupAssignment theHandle) -> Handle_StepBasic_GroupAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_GroupAssignment self) -> StepBasic_GroupAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_GroupAssignment self) -> StepBasic_GroupAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_GroupAssignment self) -> StepBasic_GroupAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_GroupAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_GroupAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_GroupAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_GroupAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_GroupAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_GroupAssignment self, Handle_StepBasic_Group aAssignedGroup)

        Initialize all fields (own and inherited)

        :type aAssignedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_Init(self, *args)


    def AssignedGroup(self, *args):
        """
        AssignedGroup(Handle_StepBasic_GroupAssignment self) -> Handle_StepBasic_Group

        Returns field AssignedGroup

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_AssignedGroup(self, *args)


    def SetAssignedGroup(self, *args):
        """
        SetAssignedGroup(Handle_StepBasic_GroupAssignment self, Handle_StepBasic_Group AssignedGroup)

        Set field AssignedGroup

        :type AssignedGroup: OCC.wrapper.StepBasic.Handle_StepBasic_Group

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_SetAssignedGroup(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_GroupAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_GroupAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_GroupAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_GroupAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_GroupAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_GroupAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_GroupAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_GroupAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_GroupAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_GroupAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_GroupAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_GroupAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_GroupAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_GroupAssignment_swigregister = _StepBasic.Handle_StepBasic_GroupAssignment_swigregister
Handle_StepBasic_GroupAssignment_swigregister(Handle_StepBasic_GroupAssignment)

def Handle_StepBasic_GroupAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_GroupAssignment_DownCast(thing)
Handle_StepBasic_GroupAssignment_DownCast = _StepBasic.Handle_StepBasic_GroupAssignment_DownCast

class Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, StepBasic_ProductDefinitionFormationWithSpecifiedSource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource theHandle) -> Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource
        assign(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, StepBasic_ProductDefinitionFormationWithSpecifiedSource thePtr) -> Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource
        assign(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource theHandle) -> Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> StepBasic_ProductDefinitionFormationWithSpecifiedSource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> StepBasic_ProductDefinitionFormationWithSpecifiedSource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> StepBasic_ProductDefinitionFormationWithSpecifiedSource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Product aOfProduct, StepBasic_Source const aMakeOrBuy)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product
        :type aMakeOrBuy: OCC.wrapper.StepBasic.StepBasic_Source

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_Init(self, *args)


    def SetMakeOrBuy(self, *args):
        """
        SetMakeOrBuy(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, StepBasic_Source const aMakeOrBuy)

        :type aMakeOrBuy: OCC.wrapper.StepBasic.StepBasic_Source

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_SetMakeOrBuy(self, *args)


    def MakeOrBuy(self, *args):
        """
        MakeOrBuy(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> StepBasic_Source

        :rtype: OCC.wrapper.StepBasic.StepBasic_Source

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_MakeOrBuy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_Description(self, *args)


    def SetOfProduct(self, *args):
        """
        SetOfProduct(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_StepBasic_Product aOfProduct)

        :type aOfProduct: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_SetOfProduct(self, *args)


    def OfProduct(self, *args):
        """
        OfProduct(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> Handle_StepBasic_Product

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_OfProduct(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_swigregister
Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_swigregister(Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource)

def Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DownCast(thing)
Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionFormationWithSpecifiedSource_DownCast

class Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, StepBasic_ConversionBasedUnitAndPlaneAngleUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, StepBasic_ConversionBasedUnitAndPlaneAngleUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> StepBasic_ConversionBasedUnitAndPlaneAngleUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> StepBasic_ConversionBasedUnitAndPlaneAngleUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> StepBasic_ConversionBasedUnitAndPlaneAngleUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_Init(self, *args)


    def SetPlaneAngleUnit(self, *args):
        """
        SetPlaneAngleUnit(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_PlaneAngleUnit aPlaneAngleUnit)

        :type aPlaneAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_SetPlaneAngleUnit(self, *args)


    def PlaneAngleUnit(self, *args):
        """
        PlaneAngleUnit(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Handle_StepBasic_PlaneAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_PlaneAngleUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit)

def Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndPlaneAngleUnit_DownCast

class StepBasic_Contract(Standard.Standard_Transient):
    """Representation of STEP entity Contract"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Contract
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Contract(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Contract self) -> StepBasic_Contract

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_Contract(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Contract self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aPurpose, Handle_StepBasic_ContractType aKind)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_ContractType

        """
        return _StepBasic.StepBasic_Contract_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Contract self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Contract_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Contract self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Contract_SetName(self, *args)


    def Purpose(self, *args):
        """
        Purpose(StepBasic_Contract self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Contract_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(StepBasic_Contract self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Contract_SetPurpose(self, *args)


    def Kind(self, *args):
        """
        Kind(StepBasic_Contract self) -> Handle_StepBasic_ContractType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ContractType

        """
        return _StepBasic.StepBasic_Contract_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(StepBasic_Contract self, Handle_StepBasic_ContractType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_ContractType

        """
        return _StepBasic.StepBasic_Contract_SetKind(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Contract_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Contract_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Contract_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Contract
StepBasic_Contract_swigregister = _StepBasic.StepBasic_Contract_swigregister
StepBasic_Contract_swigregister(StepBasic_Contract)

def StepBasic_Contract_get_type_name(*args):
    """
    StepBasic_Contract_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Contract_get_type_name(*args)

def StepBasic_Contract_get_type_descriptor(*args):
    """
    StepBasic_Contract_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Contract_get_type_descriptor(*args)

class Handle_StepBasic_SiUnitAndPlaneAngleUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndPlaneAngleUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, StepBasic_SiUnitAndPlaneAngleUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Handle_StepBasic_SiUnitAndPlaneAngleUnit theHandle) -> Handle_StepBasic_SiUnitAndPlaneAngleUnit
        assign(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, StepBasic_SiUnitAndPlaneAngleUnit thePtr) -> Handle_StepBasic_SiUnitAndPlaneAngleUnit
        assign(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Handle_StepBasic_SiUnitAndPlaneAngleUnit theHandle) -> Handle_StepBasic_SiUnitAndPlaneAngleUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> StepBasic_SiUnitAndPlaneAngleUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> StepBasic_SiUnitAndPlaneAngleUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> StepBasic_SiUnitAndPlaneAngleUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndPlaneAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndPlaneAngleUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_Init(self, *args)


    def SetPlaneAngleUnit(self, *args):
        """
        SetPlaneAngleUnit(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Handle_StepBasic_PlaneAngleUnit aPlaneAngleUnit)

        :type aPlaneAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_SetPlaneAngleUnit(self, *args)


    def PlaneAngleUnit(self, *args):
        """
        PlaneAngleUnit(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> Handle_StepBasic_PlaneAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PlaneAngleUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_PlaneAngleUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndPlaneAngleUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndPlaneAngleUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndPlaneAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndPlaneAngleUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndPlaneAngleUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndPlaneAngleUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_swigregister
Handle_StepBasic_SiUnitAndPlaneAngleUnit_swigregister(Handle_StepBasic_SiUnitAndPlaneAngleUnit)

def Handle_StepBasic_SiUnitAndPlaneAngleUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndPlaneAngleUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndPlaneAngleUnit_DownCast

class Handle_StepBasic_ConversionBasedUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnit self, StepBasic_ConversionBasedUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnit self, Handle_StepBasic_ConversionBasedUnit theHandle) -> Handle_StepBasic_ConversionBasedUnit
        assign(Handle_StepBasic_ConversionBasedUnit self, StepBasic_ConversionBasedUnit thePtr) -> Handle_StepBasic_ConversionBasedUnit
        assign(Handle_StepBasic_ConversionBasedUnit self, Handle_StepBasic_ConversionBasedUnit theHandle) -> Handle_StepBasic_ConversionBasedUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnit self) -> StepBasic_ConversionBasedUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnit self) -> StepBasic_ConversionBasedUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnit self) -> StepBasic_ConversionBasedUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_ConversionFactor(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnit_swigregister
Handle_StepBasic_ConversionBasedUnit_swigregister(Handle_StepBasic_ConversionBasedUnit)

def Handle_StepBasic_ConversionBasedUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnit_DownCast

class Handle_StepBasic_HArray1OfDocument(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfDocument self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfDocument self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfDocument self, StepBasic_HArray1OfDocument thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfDocument self, Handle_StepBasic_HArray1OfDocument theHandle) -> Handle_StepBasic_HArray1OfDocument
        assign(Handle_StepBasic_HArray1OfDocument self, StepBasic_HArray1OfDocument thePtr) -> Handle_StepBasic_HArray1OfDocument
        assign(Handle_StepBasic_HArray1OfDocument self, Handle_StepBasic_HArray1OfDocument theHandle) -> Handle_StepBasic_HArray1OfDocument

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfDocument self) -> StepBasic_HArray1OfDocument

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfDocument self) -> StepBasic_HArray1OfDocument

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfDocument self) -> StepBasic_HArray1OfDocument

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfDocument___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfDocument___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfDocument(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfDocument_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfDocument

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDocument

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfDocument_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfDocument self) -> NCollection_Array1_Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDocument

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfDocument self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfDocument_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfDocument_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfDocument self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfDocument self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfDocument self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfDocument self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfDocument self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfDocument self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfDocument self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfDocument self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfDocument self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDocument_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfDocument_swigregister = _StepBasic.Handle_StepBasic_HArray1OfDocument_swigregister
Handle_StepBasic_HArray1OfDocument_swigregister(Handle_StepBasic_HArray1OfDocument)

def Handle_StepBasic_HArray1OfDocument_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfDocument_DownCast(thing)
Handle_StepBasic_HArray1OfDocument_DownCast = _StepBasic.Handle_StepBasic_HArray1OfDocument_DownCast

class Handle_StepBasic_PersonAndOrganizationRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PersonAndOrganizationRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PersonAndOrganizationRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PersonAndOrganizationRole self, StepBasic_PersonAndOrganizationRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PersonAndOrganizationRole self, Handle_StepBasic_PersonAndOrganizationRole theHandle) -> Handle_StepBasic_PersonAndOrganizationRole
        assign(Handle_StepBasic_PersonAndOrganizationRole self, StepBasic_PersonAndOrganizationRole thePtr) -> Handle_StepBasic_PersonAndOrganizationRole
        assign(Handle_StepBasic_PersonAndOrganizationRole self, Handle_StepBasic_PersonAndOrganizationRole theHandle) -> Handle_StepBasic_PersonAndOrganizationRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PersonAndOrganizationRole self) -> StepBasic_PersonAndOrganizationRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PersonAndOrganizationRole self) -> StepBasic_PersonAndOrganizationRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PersonAndOrganizationRole self) -> StepBasic_PersonAndOrganizationRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PersonAndOrganizationRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PersonAndOrganizationRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PersonAndOrganizationRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_PersonAndOrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_PersonAndOrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_PersonAndOrganizationRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PersonAndOrganizationRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PersonAndOrganizationRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PersonAndOrganizationRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PersonAndOrganizationRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PersonAndOrganizationRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PersonAndOrganizationRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PersonAndOrganizationRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PersonAndOrganizationRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PersonAndOrganizationRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PersonAndOrganizationRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_DecrementRefCounter(self, *args)

Handle_StepBasic_PersonAndOrganizationRole_swigregister = _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_swigregister
Handle_StepBasic_PersonAndOrganizationRole_swigregister(Handle_StepBasic_PersonAndOrganizationRole)

def Handle_StepBasic_PersonAndOrganizationRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_DownCast(thing)
Handle_StepBasic_PersonAndOrganizationRole_DownCast = _StepBasic.Handle_StepBasic_PersonAndOrganizationRole_DownCast

class Handle_StepBasic_ConversionBasedUnitAndMassUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndMassUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, StepBasic_ConversionBasedUnitAndMassUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_ConversionBasedUnitAndMassUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndMassUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, StepBasic_ConversionBasedUnitAndMassUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndMassUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_ConversionBasedUnitAndMassUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndMassUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> StepBasic_ConversionBasedUnitAndMassUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> StepBasic_ConversionBasedUnitAndMassUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> StepBasic_ConversionBasedUnitAndMassUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndMassUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndMassUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_Init(self, *args)


    def SetMassUnit(self, *args):
        """
        SetMassUnit(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_MassUnit aMassUnit)

        :type aMassUnit: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_SetMassUnit(self, *args)


    def MassUnit(self, *args):
        """
        MassUnit(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Handle_StepBasic_MassUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_MassUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndMassUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndMassUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndMassUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndMassUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndMassUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndMassUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndMassUnit)

def Handle_StepBasic_ConversionBasedUnitAndMassUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndMassUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndMassUnit_DownCast

class Handle_StepBasic_ProductDefinitionFormationRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionFormationRelationship self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionFormationRelationship self, StepBasic_ProductDefinitionFormationRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_StepBasic_ProductDefinitionFormationRelationship theHandle) -> Handle_StepBasic_ProductDefinitionFormationRelationship
        assign(Handle_StepBasic_ProductDefinitionFormationRelationship self, StepBasic_ProductDefinitionFormationRelationship thePtr) -> Handle_StepBasic_ProductDefinitionFormationRelationship
        assign(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_StepBasic_ProductDefinitionFormationRelationship theHandle) -> Handle_StepBasic_ProductDefinitionFormationRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> StepBasic_ProductDefinitionFormationRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> StepBasic_ProductDefinitionFormationRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> StepBasic_ProductDefinitionFormationRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionFormationRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionFormationRelationship

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aRelatingProductDefinitionFormation, Handle_StepBasic_ProductDefinitionFormation aRelatedProductDefinitionFormation)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aRelatedProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_SetId(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_SetDescription(self, *args)


    def RelatingProductDefinitionFormation(self, *args):
        """
        RelatingProductDefinitionFormation(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Handle_StepBasic_ProductDefinitionFormation

        Returns field RelatingProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_RelatingProductDefinitionFormation(self, *args)


    def SetRelatingProductDefinitionFormation(self, *args):
        """
        SetRelatingProductDefinitionFormation(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_StepBasic_ProductDefinitionFormation RelatingProductDefinitionFormation)

        Set field RelatingProductDefinitionFormation

        :type RelatingProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_SetRelatingProductDefinitionFormation(self, *args)


    def RelatedProductDefinitionFormation(self, *args):
        """
        RelatedProductDefinitionFormation(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Handle_StepBasic_ProductDefinitionFormation

        Returns field RelatedProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_RelatedProductDefinitionFormation(self, *args)


    def SetRelatedProductDefinitionFormation(self, *args):
        """
        SetRelatedProductDefinitionFormation(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_StepBasic_ProductDefinitionFormation RelatedProductDefinitionFormation)

        Set field RelatedProductDefinitionFormation

        :type RelatedProductDefinitionFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_SetRelatedProductDefinitionFormation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionFormationRelationship self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionFormationRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionFormationRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionFormationRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionFormationRelationship self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionFormationRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionFormationRelationship_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_swigregister
Handle_StepBasic_ProductDefinitionFormationRelationship_swigregister(Handle_StepBasic_ProductDefinitionFormationRelationship)

def Handle_StepBasic_ProductDefinitionFormationRelationship_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_DownCast(thing)
Handle_StepBasic_ProductDefinitionFormationRelationship_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionFormationRelationship_DownCast

class StepBasic_ActionAssignment(Standard.Standard_Transient):
    """Representation of STEP entity ActionAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ActionAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ActionAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ActionAssignment self) -> StepBasic_ActionAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ActionAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ActionAssignment self, Handle_StepBasic_Action aAssignedAction)

        Initialize all fields (own and inherited)

        :type aAssignedAction: OCC.wrapper.StepBasic.Handle_StepBasic_Action

        """
        return _StepBasic.StepBasic_ActionAssignment_Init(self, *args)


    def AssignedAction(self, *args):
        """
        AssignedAction(StepBasic_ActionAssignment self) -> Handle_StepBasic_Action

        Returns field AssignedAction

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Action

        """
        return _StepBasic.StepBasic_ActionAssignment_AssignedAction(self, *args)


    def SetAssignedAction(self, *args):
        """
        SetAssignedAction(StepBasic_ActionAssignment self, Handle_StepBasic_Action AssignedAction)

        Set field AssignedAction

        :type AssignedAction: OCC.wrapper.StepBasic.Handle_StepBasic_Action

        """
        return _StepBasic.StepBasic_ActionAssignment_SetAssignedAction(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ActionAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ActionAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ActionAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ActionAssignment
StepBasic_ActionAssignment_swigregister = _StepBasic.StepBasic_ActionAssignment_swigregister
StepBasic_ActionAssignment_swigregister(StepBasic_ActionAssignment)

def StepBasic_ActionAssignment_get_type_name(*args):
    """
    StepBasic_ActionAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ActionAssignment_get_type_name(*args)

def StepBasic_ActionAssignment_get_type_descriptor(*args):
    """
    StepBasic_ActionAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ActionAssignment_get_type_descriptor(*args)

class StepBasic_LengthMeasureWithUnit(StepBasic_MeasureWithUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_LengthMeasureWithUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_LengthMeasureWithUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_LengthMeasureWithUnit self) -> StepBasic_LengthMeasureWithUnit

        Returns a LengthMeasureWithUnit


        """
        this = _StepBasic.new_StepBasic_LengthMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_LengthMeasureWithUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_LengthMeasureWithUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_LengthMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_LengthMeasureWithUnit
StepBasic_LengthMeasureWithUnit_swigregister = _StepBasic.StepBasic_LengthMeasureWithUnit_swigregister
StepBasic_LengthMeasureWithUnit_swigregister(StepBasic_LengthMeasureWithUnit)

def StepBasic_LengthMeasureWithUnit_get_type_name(*args):
    """
    StepBasic_LengthMeasureWithUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_LengthMeasureWithUnit_get_type_name(*args)

def StepBasic_LengthMeasureWithUnit_get_type_descriptor(*args):
    """
    StepBasic_LengthMeasureWithUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_LengthMeasureWithUnit_get_type_descriptor(*args)

class Handle_StepBasic_DocumentProductAssociation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentProductAssociation self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentProductAssociation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentProductAssociation self, StepBasic_DocumentProductAssociation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentProductAssociation self, Handle_StepBasic_DocumentProductAssociation theHandle) -> Handle_StepBasic_DocumentProductAssociation
        assign(Handle_StepBasic_DocumentProductAssociation self, StepBasic_DocumentProductAssociation thePtr) -> Handle_StepBasic_DocumentProductAssociation
        assign(Handle_StepBasic_DocumentProductAssociation self, Handle_StepBasic_DocumentProductAssociation theHandle) -> Handle_StepBasic_DocumentProductAssociation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentProductAssociation self) -> StepBasic_DocumentProductAssociation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentProductAssociation self) -> StepBasic_DocumentProductAssociation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentProductAssociation self) -> StepBasic_DocumentProductAssociation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentProductAssociation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentProductAssociation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentProductAssociation_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentProductAssociation

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentProductAssociation self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Document aRelatingDocument, StepBasic_ProductOrFormationOrDefinition aRelatedProduct)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aRelatedProduct: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DocumentProductAssociation self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DocumentProductAssociation self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_DocumentProductAssociation self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_DocumentProductAssociation self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_DocumentProductAssociation self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_HasDescription(self, *args)


    def RelatingDocument(self, *args):
        """
        RelatingDocument(Handle_StepBasic_DocumentProductAssociation self) -> Handle_StepBasic_Document

        Returns field RelatingDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_RelatingDocument(self, *args)


    def SetRelatingDocument(self, *args):
        """
        SetRelatingDocument(Handle_StepBasic_DocumentProductAssociation self, Handle_StepBasic_Document RelatingDocument)

        Set field RelatingDocument

        :type RelatingDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_SetRelatingDocument(self, *args)


    def RelatedProduct(self, *args):
        """
        RelatedProduct(Handle_StepBasic_DocumentProductAssociation self) -> StepBasic_ProductOrFormationOrDefinition

        Returns field RelatedProduct

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_RelatedProduct(self, *args)


    def SetRelatedProduct(self, *args):
        """
        SetRelatedProduct(Handle_StepBasic_DocumentProductAssociation self, StepBasic_ProductOrFormationOrDefinition RelatedProduct)

        Set field RelatedProduct

        :type RelatedProduct: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_SetRelatedProduct(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentProductAssociation self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentProductAssociation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentProductAssociation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentProductAssociation self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentProductAssociation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentProductAssociation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentProductAssociation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentProductAssociation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentProductAssociation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentProductAssociation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentProductAssociation self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentProductAssociation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentProductAssociation_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentProductAssociation_swigregister = _StepBasic.Handle_StepBasic_DocumentProductAssociation_swigregister
Handle_StepBasic_DocumentProductAssociation_swigregister(Handle_StepBasic_DocumentProductAssociation)

def Handle_StepBasic_DocumentProductAssociation_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentProductAssociation_DownCast(thing)
Handle_StepBasic_DocumentProductAssociation_DownCast = _StepBasic.Handle_StepBasic_DocumentProductAssociation_DownCast

class Handle_StepBasic_ContractType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ContractType self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ContractType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ContractType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ContractType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ContractType self, StepBasic_ContractType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ContractType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ContractType self, Handle_StepBasic_ContractType theHandle) -> Handle_StepBasic_ContractType
        assign(Handle_StepBasic_ContractType self, StepBasic_ContractType thePtr) -> Handle_StepBasic_ContractType
        assign(Handle_StepBasic_ContractType self, Handle_StepBasic_ContractType theHandle) -> Handle_StepBasic_ContractType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ContractType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ContractType self) -> StepBasic_ContractType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ContractType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ContractType self) -> StepBasic_ContractType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ContractType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ContractType self) -> StepBasic_ContractType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ContractType___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ContractType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ContractType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ContractType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ContractType_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ContractType

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ContractType self, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ContractType_Init(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ContractType self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ContractType_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ContractType self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ContractType_SetDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ContractType self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ContractType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ContractType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ContractType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ContractType self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ContractType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ContractType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ContractType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ContractType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ContractType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ContractType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ContractType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ContractType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ContractType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ContractType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ContractType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ContractType self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ContractType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ContractType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ContractType_DecrementRefCounter(self, *args)

Handle_StepBasic_ContractType_swigregister = _StepBasic.Handle_StepBasic_ContractType_swigregister
Handle_StepBasic_ContractType_swigregister(Handle_StepBasic_ContractType)

def Handle_StepBasic_ContractType_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ContractType_DownCast(thing)
Handle_StepBasic_ContractType_DownCast = _StepBasic.Handle_StepBasic_ContractType_DownCast

class NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_UncertaintyMeasureWithUnit > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_UncertaintyMeasureWithUnit > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_UncertaintyMeasureWithUnit > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_UncertaintyMeasureWithUnit > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, Handle_StepBasic_UncertaintyMeasureWithUnit theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit theOther) -> NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit theOther) -> NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit theOther) -> NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit
        assign(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit theOther) -> NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Handle_StepBasic_UncertaintyMeasureWithUnit

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self) -> Handle_StepBasic_UncertaintyMeasureWithUnit

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, Standard_Integer const theIndex) -> Handle_StepBasic_UncertaintyMeasureWithUnit

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, Standard_Integer const theIndex, Handle_StepBasic_UncertaintyMeasureWithUnit theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit
NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_swigregister
NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit_swigregister(NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit)


try:
	StepBasic_Array1OfUncertaintyMeasureWithUnit = NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit
except NameError:
	pass # does not exist, probably ignored

class StepBasic_CertificationAssignment(Standard.Standard_Transient):
    """Representation of STEP entity CertificationAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_CertificationAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_CertificationAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_CertificationAssignment self) -> StepBasic_CertificationAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_CertificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_CertificationAssignment self, Handle_StepBasic_Certification aAssignedCertification)

        Initialize all fields (own and inherited)

        :type aAssignedCertification: OCC.wrapper.StepBasic.Handle_StepBasic_Certification

        """
        return _StepBasic.StepBasic_CertificationAssignment_Init(self, *args)


    def AssignedCertification(self, *args):
        """
        AssignedCertification(StepBasic_CertificationAssignment self) -> Handle_StepBasic_Certification

        Returns field AssignedCertification

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Certification

        """
        return _StepBasic.StepBasic_CertificationAssignment_AssignedCertification(self, *args)


    def SetAssignedCertification(self, *args):
        """
        SetAssignedCertification(StepBasic_CertificationAssignment self, Handle_StepBasic_Certification AssignedCertification)

        Set field AssignedCertification

        :type AssignedCertification: OCC.wrapper.StepBasic.Handle_StepBasic_Certification

        """
        return _StepBasic.StepBasic_CertificationAssignment_SetAssignedCertification(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_CertificationAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_CertificationAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_CertificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_CertificationAssignment
StepBasic_CertificationAssignment_swigregister = _StepBasic.StepBasic_CertificationAssignment_swigregister
StepBasic_CertificationAssignment_swigregister(StepBasic_CertificationAssignment)

def StepBasic_CertificationAssignment_get_type_name(*args):
    """
    StepBasic_CertificationAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_CertificationAssignment_get_type_name(*args)

def StepBasic_CertificationAssignment_get_type_descriptor(*args):
    """
    StepBasic_CertificationAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_CertificationAssignment_get_type_descriptor(*args)

class Handle_StepBasic_Address(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Address self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Address_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Address self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Address_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Address self, StepBasic_Address thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Address_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Address self, Handle_StepBasic_Address theHandle) -> Handle_StepBasic_Address
        assign(Handle_StepBasic_Address self, StepBasic_Address thePtr) -> Handle_StepBasic_Address
        assign(Handle_StepBasic_Address self, Handle_StepBasic_Address theHandle) -> Handle_StepBasic_Address

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Address_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Address self) -> StepBasic_Address

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Address_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Address self) -> StepBasic_Address

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Address___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Address self) -> StepBasic_Address

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Address___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Address___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Address___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Address(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Address_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Address

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Address self, Standard_Boolean const hasAinternalLocation, Handle_TCollection_HAsciiString aInternalLocation, Standard_Boolean const hasAstreetNumber, Handle_TCollection_HAsciiString aStreetNumber, Standard_Boolean const hasAstreet, Handle_TCollection_HAsciiString aStreet, Standard_Boolean const hasApostalBox, Handle_TCollection_HAsciiString aPostalBox, Standard_Boolean const hasAtown, Handle_TCollection_HAsciiString aTown, Standard_Boolean const hasAregion, Handle_TCollection_HAsciiString aRegion, Standard_Boolean const hasApostalCode, Handle_TCollection_HAsciiString aPostalCode, Standard_Boolean const hasAcountry, Handle_TCollection_HAsciiString aCountry, Standard_Boolean const hasAfacsimileNumber, Handle_TCollection_HAsciiString aFacsimileNumber, Standard_Boolean const hasAtelephoneNumber, Handle_TCollection_HAsciiString aTelephoneNumber, Standard_Boolean const hasAelectronicMailAddress, Handle_TCollection_HAsciiString aElectronicMailAddress, Standard_Boolean const hasAtelexNumber, Handle_TCollection_HAsciiString aTelexNumber)

        :type hasAinternalLocation: bool
        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreetNumber: bool
        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreet: bool
        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalBox: bool
        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtown: bool
        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAregion: bool
        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalCode: bool
        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAcountry: bool
        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfacsimileNumber: bool
        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelephoneNumber: bool
        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAelectronicMailAddress: bool
        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelexNumber: bool
        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_Init(self, *args)


    def SetInternalLocation(self, *args):
        """
        SetInternalLocation(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aInternalLocation)

        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetInternalLocation(self, *args)


    def UnSetInternalLocation(self, *args):
        """UnSetInternalLocation(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetInternalLocation(self, *args)


    def InternalLocation(self, *args):
        """
        InternalLocation(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_InternalLocation(self, *args)


    def HasInternalLocation(self, *args):
        """
        HasInternalLocation(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasInternalLocation(self, *args)


    def SetStreetNumber(self, *args):
        """
        SetStreetNumber(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aStreetNumber)

        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetStreetNumber(self, *args)


    def UnSetStreetNumber(self, *args):
        """UnSetStreetNumber(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetStreetNumber(self, *args)


    def StreetNumber(self, *args):
        """
        StreetNumber(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_StreetNumber(self, *args)


    def HasStreetNumber(self, *args):
        """
        HasStreetNumber(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasStreetNumber(self, *args)


    def SetStreet(self, *args):
        """
        SetStreet(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aStreet)

        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetStreet(self, *args)


    def UnSetStreet(self, *args):
        """UnSetStreet(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetStreet(self, *args)


    def Street(self, *args):
        """
        Street(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_Street(self, *args)


    def HasStreet(self, *args):
        """
        HasStreet(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasStreet(self, *args)


    def SetPostalBox(self, *args):
        """
        SetPostalBox(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aPostalBox)

        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetPostalBox(self, *args)


    def UnSetPostalBox(self, *args):
        """UnSetPostalBox(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetPostalBox(self, *args)


    def PostalBox(self, *args):
        """
        PostalBox(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_PostalBox(self, *args)


    def HasPostalBox(self, *args):
        """
        HasPostalBox(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasPostalBox(self, *args)


    def SetTown(self, *args):
        """
        SetTown(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aTown)

        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetTown(self, *args)


    def UnSetTown(self, *args):
        """UnSetTown(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetTown(self, *args)


    def Town(self, *args):
        """
        Town(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_Town(self, *args)


    def HasTown(self, *args):
        """
        HasTown(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasTown(self, *args)


    def SetRegion(self, *args):
        """
        SetRegion(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aRegion)

        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetRegion(self, *args)


    def UnSetRegion(self, *args):
        """UnSetRegion(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetRegion(self, *args)


    def Region(self, *args):
        """
        Region(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_Region(self, *args)


    def HasRegion(self, *args):
        """
        HasRegion(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasRegion(self, *args)


    def SetPostalCode(self, *args):
        """
        SetPostalCode(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aPostalCode)

        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetPostalCode(self, *args)


    def UnSetPostalCode(self, *args):
        """UnSetPostalCode(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetPostalCode(self, *args)


    def PostalCode(self, *args):
        """
        PostalCode(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_PostalCode(self, *args)


    def HasPostalCode(self, *args):
        """
        HasPostalCode(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasPostalCode(self, *args)


    def SetCountry(self, *args):
        """
        SetCountry(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aCountry)

        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetCountry(self, *args)


    def UnSetCountry(self, *args):
        """UnSetCountry(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetCountry(self, *args)


    def Country(self, *args):
        """
        Country(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_Country(self, *args)


    def HasCountry(self, *args):
        """
        HasCountry(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasCountry(self, *args)


    def SetFacsimileNumber(self, *args):
        """
        SetFacsimileNumber(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aFacsimileNumber)

        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetFacsimileNumber(self, *args)


    def UnSetFacsimileNumber(self, *args):
        """UnSetFacsimileNumber(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetFacsimileNumber(self, *args)


    def FacsimileNumber(self, *args):
        """
        FacsimileNumber(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_FacsimileNumber(self, *args)


    def HasFacsimileNumber(self, *args):
        """
        HasFacsimileNumber(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasFacsimileNumber(self, *args)


    def SetTelephoneNumber(self, *args):
        """
        SetTelephoneNumber(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aTelephoneNumber)

        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetTelephoneNumber(self, *args)


    def UnSetTelephoneNumber(self, *args):
        """UnSetTelephoneNumber(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetTelephoneNumber(self, *args)


    def TelephoneNumber(self, *args):
        """
        TelephoneNumber(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_TelephoneNumber(self, *args)


    def HasTelephoneNumber(self, *args):
        """
        HasTelephoneNumber(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasTelephoneNumber(self, *args)


    def SetElectronicMailAddress(self, *args):
        """
        SetElectronicMailAddress(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aElectronicMailAddress)

        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetElectronicMailAddress(self, *args)


    def UnSetElectronicMailAddress(self, *args):
        """UnSetElectronicMailAddress(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetElectronicMailAddress(self, *args)


    def ElectronicMailAddress(self, *args):
        """
        ElectronicMailAddress(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_ElectronicMailAddress(self, *args)


    def HasElectronicMailAddress(self, *args):
        """
        HasElectronicMailAddress(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasElectronicMailAddress(self, *args)


    def SetTelexNumber(self, *args):
        """
        SetTelexNumber(Handle_StepBasic_Address self, Handle_TCollection_HAsciiString aTelexNumber)

        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_SetTelexNumber(self, *args)


    def UnSetTelexNumber(self, *args):
        """UnSetTelexNumber(Handle_StepBasic_Address self)"""
        return _StepBasic.Handle_StepBasic_Address_UnSetTelexNumber(self, *args)


    def TelexNumber(self, *args):
        """
        TelexNumber(Handle_StepBasic_Address self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Address_TelexNumber(self, *args)


    def HasTelexNumber(self, *args):
        """
        HasTelexNumber(Handle_StepBasic_Address self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_HasTelexNumber(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Address self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Address_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Address_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Address_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Address self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Address_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Address self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Address self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Address self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Address self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Address_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Address self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Address_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Address self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Address_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Address self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Address_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Address self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Address_DecrementRefCounter(self, *args)

Handle_StepBasic_Address_swigregister = _StepBasic.Handle_StepBasic_Address_swigregister
Handle_StepBasic_Address_swigregister(Handle_StepBasic_Address)

def Handle_StepBasic_Address_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Address_DownCast(thing)
Handle_StepBasic_Address_DownCast = _StepBasic.Handle_StepBasic_Address_DownCast

class Handle_StepBasic_ActionMethod(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ActionMethod self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ActionMethod self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ActionMethod self, StepBasic_ActionMethod thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ActionMethod self, Handle_StepBasic_ActionMethod theHandle) -> Handle_StepBasic_ActionMethod
        assign(Handle_StepBasic_ActionMethod self, StepBasic_ActionMethod thePtr) -> Handle_StepBasic_ActionMethod
        assign(Handle_StepBasic_ActionMethod self, Handle_StepBasic_ActionMethod theHandle) -> Handle_StepBasic_ActionMethod

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ActionMethod self) -> StepBasic_ActionMethod

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ActionMethod self) -> StepBasic_ActionMethod

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionMethod___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ActionMethod self) -> StepBasic_ActionMethod

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ActionMethod___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ActionMethod___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ActionMethod___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ActionMethod(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ActionMethod_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ActionMethod

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ActionMethod self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_TCollection_HAsciiString aConsequence, Handle_TCollection_HAsciiString aPurpose)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConsequence: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ActionMethod self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_HasDescription(self, *args)


    def Consequence(self, *args):
        """
        Consequence(Handle_StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Consequence

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Consequence(self, *args)


    def SetConsequence(self, *args):
        """
        SetConsequence(Handle_StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Consequence)

        Set field Consequence

        :type Consequence: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_SetConsequence(self, *args)


    def Purpose(self, *args):
        """
        Purpose(Handle_StepBasic_ActionMethod self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(Handle_StepBasic_ActionMethod self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_SetPurpose(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ActionMethod self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionMethod_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionMethod_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ActionMethod self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ActionMethod_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ActionMethod self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ActionMethod self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ActionMethod self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ActionMethod self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ActionMethod self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ActionMethod self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ActionMethod self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ActionMethod_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ActionMethod self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionMethod_DecrementRefCounter(self, *args)

Handle_StepBasic_ActionMethod_swigregister = _StepBasic.Handle_StepBasic_ActionMethod_swigregister
Handle_StepBasic_ActionMethod_swigregister(Handle_StepBasic_ActionMethod)

def Handle_StepBasic_ActionMethod_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ActionMethod_DownCast(thing)
Handle_StepBasic_ActionMethod_DownCast = _StepBasic.Handle_StepBasic_ActionMethod_DownCast

class Handle_StepBasic_ApplicationContextElement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApplicationContextElement self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApplicationContextElement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApplicationContextElement self, StepBasic_ApplicationContextElement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApplicationContextElement self, Handle_StepBasic_ApplicationContextElement theHandle) -> Handle_StepBasic_ApplicationContextElement
        assign(Handle_StepBasic_ApplicationContextElement self, StepBasic_ApplicationContextElement thePtr) -> Handle_StepBasic_ApplicationContextElement
        assign(Handle_StepBasic_ApplicationContextElement self, Handle_StepBasic_ApplicationContextElement theHandle) -> Handle_StepBasic_ApplicationContextElement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApplicationContextElement self) -> StepBasic_ApplicationContextElement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApplicationContextElement self) -> StepBasic_ApplicationContextElement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApplicationContextElement self) -> StepBasic_ApplicationContextElement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApplicationContextElement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApplicationContextElement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApplicationContextElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApplicationContextElement_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApplicationContextElement

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApplicationContextElement self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ApplicationContextElement self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ApplicationContextElement self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ApplicationContextElement self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ApplicationContextElement self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_FrameOfReference(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApplicationContextElement self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApplicationContextElement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApplicationContextElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApplicationContextElement self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApplicationContextElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApplicationContextElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApplicationContextElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApplicationContextElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApplicationContextElement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApplicationContextElement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApplicationContextElement self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApplicationContextElement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationContextElement_DecrementRefCounter(self, *args)

Handle_StepBasic_ApplicationContextElement_swigregister = _StepBasic.Handle_StepBasic_ApplicationContextElement_swigregister
Handle_StepBasic_ApplicationContextElement_swigregister(Handle_StepBasic_ApplicationContextElement)

def Handle_StepBasic_ApplicationContextElement_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApplicationContextElement_DownCast(thing)
Handle_StepBasic_ApplicationContextElement_DownCast = _StepBasic.Handle_StepBasic_ApplicationContextElement_DownCast

class StepBasic_DerivedUnit(Standard.Standard_Transient):
    """Added from StepBasic Rev2 to Rev4"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DerivedUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DerivedUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DerivedUnit self) -> StepBasic_DerivedUnit

        Added from StepBasic Rev2 to Rev4
        """
        this = _StepBasic.new_StepBasic_DerivedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DerivedUnit self, Handle_StepBasic_HArray1OfDerivedUnitElement elements)

        :type elements: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement

        """
        return _StepBasic.StepBasic_DerivedUnit_Init(self, *args)


    def SetElements(self, *args):
        """
        SetElements(StepBasic_DerivedUnit self, Handle_StepBasic_HArray1OfDerivedUnitElement elements)

        :type elements: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement

        """
        return _StepBasic.StepBasic_DerivedUnit_SetElements(self, *args)


    def Elements(self, *args):
        """
        Elements(StepBasic_DerivedUnit self) -> Handle_StepBasic_HArray1OfDerivedUnitElement

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement

        """
        return _StepBasic.StepBasic_DerivedUnit_Elements(self, *args)


    def NbElements(self, *args):
        """
        NbElements(StepBasic_DerivedUnit self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_DerivedUnit_NbElements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(StepBasic_DerivedUnit self, Standard_Integer const num) -> Handle_StepBasic_DerivedUnitElement

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DerivedUnitElement

        """
        return _StepBasic.StepBasic_DerivedUnit_ElementsValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DerivedUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DerivedUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DerivedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DerivedUnit
StepBasic_DerivedUnit_swigregister = _StepBasic.StepBasic_DerivedUnit_swigregister
StepBasic_DerivedUnit_swigregister(StepBasic_DerivedUnit)

def StepBasic_DerivedUnit_get_type_name(*args):
    """
    StepBasic_DerivedUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DerivedUnit_get_type_name(*args)

def StepBasic_DerivedUnit_get_type_descriptor(*args):
    """
    StepBasic_DerivedUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DerivedUnit_get_type_descriptor(*args)

class Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, StepBasic_ProductDefinitionReferenceWithLocalRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation theHandle) -> Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation
        assign(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, StepBasic_ProductDefinitionReferenceWithLocalRepresentation thePtr) -> Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation
        assign(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation theHandle) -> Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ExternalSource theSource, Handle_TCollection_HAsciiString theId, Handle_TCollection_HAsciiString theDescription, Handle_StepBasic_ProductDefinitionFormation theFormation, Handle_StepBasic_ProductDefinitionContext theFrameOfReference)

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource
        :type theId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type theFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Init(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ExternalSource theSource)

        Set field Source

        :type theSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_SetSource(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Description(self, *args)


    def SetFormation(self, *args):
        """
        SetFormation(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ProductDefinitionFormation aFormation)

        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_SetFormation(self, *args)


    def Formation(self, *args):
        """
        Formation(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Handle_StepBasic_ProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Formation(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Handle_StepBasic_ProductDefinitionContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_swigregister
Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_swigregister(Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation)

def Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DownCast(thing)
Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation_DownCast

class Handle_StepBasic_ActionRequestAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ActionRequestAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ActionRequestAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ActionRequestAssignment self, StepBasic_ActionRequestAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ActionRequestAssignment self, Handle_StepBasic_ActionRequestAssignment theHandle) -> Handle_StepBasic_ActionRequestAssignment
        assign(Handle_StepBasic_ActionRequestAssignment self, StepBasic_ActionRequestAssignment thePtr) -> Handle_StepBasic_ActionRequestAssignment
        assign(Handle_StepBasic_ActionRequestAssignment self, Handle_StepBasic_ActionRequestAssignment theHandle) -> Handle_StepBasic_ActionRequestAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ActionRequestAssignment self) -> StepBasic_ActionRequestAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ActionRequestAssignment self) -> StepBasic_ActionRequestAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ActionRequestAssignment self) -> StepBasic_ActionRequestAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ActionRequestAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ActionRequestAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ActionRequestAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ActionRequestAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ActionRequestAssignment self, Handle_StepBasic_VersionedActionRequest aAssignedActionRequest)

        Initialize all fields (own and inherited)

        :type aAssignedActionRequest: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_Init(self, *args)


    def AssignedActionRequest(self, *args):
        """
        AssignedActionRequest(Handle_StepBasic_ActionRequestAssignment self) -> Handle_StepBasic_VersionedActionRequest

        Returns field AssignedActionRequest

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_AssignedActionRequest(self, *args)


    def SetAssignedActionRequest(self, *args):
        """
        SetAssignedActionRequest(Handle_StepBasic_ActionRequestAssignment self, Handle_StepBasic_VersionedActionRequest AssignedActionRequest)

        Set field AssignedActionRequest

        :type AssignedActionRequest: OCC.wrapper.StepBasic.Handle_StepBasic_VersionedActionRequest

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_SetAssignedActionRequest(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ActionRequestAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionRequestAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionRequestAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ActionRequestAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ActionRequestAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ActionRequestAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ActionRequestAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ActionRequestAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ActionRequestAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ActionRequestAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ActionRequestAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ActionRequestAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionRequestAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_ActionRequestAssignment_swigregister = _StepBasic.Handle_StepBasic_ActionRequestAssignment_swigregister
Handle_StepBasic_ActionRequestAssignment_swigregister(Handle_StepBasic_ActionRequestAssignment)

def Handle_StepBasic_ActionRequestAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ActionRequestAssignment_DownCast(thing)
Handle_StepBasic_ActionRequestAssignment_DownCast = _StepBasic.Handle_StepBasic_ActionRequestAssignment_DownCast

class Handle_StepBasic_CalendarDate(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_CalendarDate self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_CalendarDate_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_CalendarDate self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_CalendarDate self, StepBasic_CalendarDate thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_CalendarDate self, Handle_StepBasic_CalendarDate theHandle) -> Handle_StepBasic_CalendarDate
        assign(Handle_StepBasic_CalendarDate self, StepBasic_CalendarDate thePtr) -> Handle_StepBasic_CalendarDate
        assign(Handle_StepBasic_CalendarDate self, Handle_StepBasic_CalendarDate theHandle) -> Handle_StepBasic_CalendarDate

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_CalendarDate self) -> StepBasic_CalendarDate

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_CalendarDate self) -> StepBasic_CalendarDate

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CalendarDate___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_CalendarDate self) -> StepBasic_CalendarDate

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_CalendarDate___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_CalendarDate___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_CalendarDate___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_CalendarDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_CalendarDate_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_CalendarDate

    def Init(self, *args):
        """
        Init(Handle_StepBasic_CalendarDate self, Standard_Integer const aYearComponent, Standard_Integer const aDayComponent, Standard_Integer const aMonthComponent)

        :type aYearComponent: int
        :type aDayComponent: int
        :type aMonthComponent: int

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_Init(self, *args)


    def SetDayComponent(self, *args):
        """
        SetDayComponent(Handle_StepBasic_CalendarDate self, Standard_Integer const aDayComponent)

        :type aDayComponent: int

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_SetDayComponent(self, *args)


    def DayComponent(self, *args):
        """
        DayComponent(Handle_StepBasic_CalendarDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_DayComponent(self, *args)


    def SetMonthComponent(self, *args):
        """
        SetMonthComponent(Handle_StepBasic_CalendarDate self, Standard_Integer const aMonthComponent)

        :type aMonthComponent: int

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_SetMonthComponent(self, *args)


    def MonthComponent(self, *args):
        """
        MonthComponent(Handle_StepBasic_CalendarDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_MonthComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_CalendarDate self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CalendarDate_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CalendarDate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetYearComponent(self, *args):
        """
        SetYearComponent(Handle_StepBasic_CalendarDate self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_SetYearComponent(self, *args)


    def YearComponent(self, *args):
        """
        YearComponent(Handle_StepBasic_CalendarDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_YearComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_CalendarDate self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_CalendarDate_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_CalendarDate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_CalendarDate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_CalendarDate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_CalendarDate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_CalendarDate self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_CalendarDate self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_CalendarDate self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_CalendarDate_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_CalendarDate self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CalendarDate_DecrementRefCounter(self, *args)

Handle_StepBasic_CalendarDate_swigregister = _StepBasic.Handle_StepBasic_CalendarDate_swigregister
Handle_StepBasic_CalendarDate_swigregister(Handle_StepBasic_CalendarDate)

def Handle_StepBasic_CalendarDate_DownCast(thing):
    return _StepBasic.Handle_StepBasic_CalendarDate_DownCast(thing)
Handle_StepBasic_CalendarDate_DownCast = _StepBasic.Handle_StepBasic_CalendarDate_DownCast

class StepBasic_DigitalDocument(StepBasic_Document):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DigitalDocument
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DigitalDocument(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_DigitalDocument self) -> StepBasic_DigitalDocument"""
        this = _StepBasic.new_StepBasic_DigitalDocument(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DigitalDocument_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DigitalDocument_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DigitalDocument_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DigitalDocument
StepBasic_DigitalDocument_swigregister = _StepBasic.StepBasic_DigitalDocument_swigregister
StepBasic_DigitalDocument_swigregister(StepBasic_DigitalDocument)

def StepBasic_DigitalDocument_get_type_name(*args):
    """
    StepBasic_DigitalDocument_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DigitalDocument_get_type_name(*args)

def StepBasic_DigitalDocument_get_type_descriptor(*args):
    """
    StepBasic_DigitalDocument_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DigitalDocument_get_type_descriptor(*args)

class Handle_StepBasic_Organization(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Organization self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Organization_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Organization self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Organization_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Organization self, StepBasic_Organization thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Organization_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Organization self, Handle_StepBasic_Organization theHandle) -> Handle_StepBasic_Organization
        assign(Handle_StepBasic_Organization self, StepBasic_Organization thePtr) -> Handle_StepBasic_Organization
        assign(Handle_StepBasic_Organization self, Handle_StepBasic_Organization theHandle) -> Handle_StepBasic_Organization

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Organization_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Organization self) -> StepBasic_Organization

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Organization_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Organization self) -> StepBasic_Organization

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Organization___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Organization self) -> StepBasic_Organization

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Organization___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Organization___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Organization___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Organization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Organization_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Organization

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Organization self, Standard_Boolean const hasAid, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription)

        :type hasAid: bool
        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_Organization self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_SetId(self, *args)


    def UnSetId(self, *args):
        """UnSetId(Handle_StepBasic_Organization self)"""
        return _StepBasic.Handle_StepBasic_Organization_UnSetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_Organization self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_Id(self, *args)


    def HasId(self, *args):
        """
        HasId(Handle_StepBasic_Organization self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Organization_HasId(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Organization self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Organization self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_Organization self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_Organization self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Organization_Description(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Organization self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Organization_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Organization_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Organization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Organization self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Organization_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Organization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Organization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Organization_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Organization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Organization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Organization_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Organization self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Organization_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Organization self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Organization_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Organization self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Organization_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Organization self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Organization_DecrementRefCounter(self, *args)

Handle_StepBasic_Organization_swigregister = _StepBasic.Handle_StepBasic_Organization_swigregister
Handle_StepBasic_Organization_swigregister(Handle_StepBasic_Organization)

def Handle_StepBasic_Organization_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Organization_DownCast(thing)
Handle_StepBasic_Organization_DownCast = _StepBasic.Handle_StepBasic_Organization_DownCast

class Handle_StepBasic_Product(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Product self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Product_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Product self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Product_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Product self, StepBasic_Product thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Product_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Product self, Handle_StepBasic_Product theHandle) -> Handle_StepBasic_Product
        assign(Handle_StepBasic_Product self, StepBasic_Product thePtr) -> Handle_StepBasic_Product
        assign(Handle_StepBasic_Product self, Handle_StepBasic_Product theHandle) -> Handle_StepBasic_Product

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Product_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Product self) -> StepBasic_Product

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Product_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Product self) -> StepBasic_Product

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Product___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Product self) -> StepBasic_Product

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Product___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Product___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Product___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Product(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Product_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Product

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Product self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_HArray1OfProductContext aFrameOfReference)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProductContext

        """
        return _StepBasic.Handle_StepBasic_Product_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_Product self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Product_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_Product self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Product_Id(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Product self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Product_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Product self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Product_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_Product self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Product_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_Product self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Product_Description(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_Product self, Handle_StepBasic_HArray1OfProductContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProductContext

        """
        return _StepBasic.Handle_StepBasic_Product_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_Product self) -> Handle_StepBasic_HArray1OfProductContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfProductContext

        """
        return _StepBasic.Handle_StepBasic_Product_FrameOfReference(self, *args)


    def FrameOfReferenceValue(self, *args):
        """
        FrameOfReferenceValue(Handle_StepBasic_Product self, Standard_Integer const num) -> Handle_StepBasic_ProductContext

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductContext

        """
        return _StepBasic.Handle_StepBasic_Product_FrameOfReferenceValue(self, *args)


    def NbFrameOfReference(self, *args):
        """
        NbFrameOfReference(Handle_StepBasic_Product self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Product_NbFrameOfReference(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Product self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Product_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Product_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Product_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Product self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Product_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Product self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Product self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Product_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Product self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Product self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Product_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Product self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Product_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Product self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Product_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Product self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Product_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Product self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Product_DecrementRefCounter(self, *args)

Handle_StepBasic_Product_swigregister = _StepBasic.Handle_StepBasic_Product_swigregister
Handle_StepBasic_Product_swigregister(Handle_StepBasic_Product)

def Handle_StepBasic_Product_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Product_DownCast(thing)
Handle_StepBasic_Product_DownCast = _StepBasic.Handle_StepBasic_Product_DownCast

class Handle_StepBasic_DerivedUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DerivedUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DerivedUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DerivedUnit self, StepBasic_DerivedUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DerivedUnit self, Handle_StepBasic_DerivedUnit theHandle) -> Handle_StepBasic_DerivedUnit
        assign(Handle_StepBasic_DerivedUnit self, StepBasic_DerivedUnit thePtr) -> Handle_StepBasic_DerivedUnit
        assign(Handle_StepBasic_DerivedUnit self, Handle_StepBasic_DerivedUnit theHandle) -> Handle_StepBasic_DerivedUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DerivedUnit self) -> StepBasic_DerivedUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DerivedUnit self) -> StepBasic_DerivedUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DerivedUnit self) -> StepBasic_DerivedUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DerivedUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DerivedUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DerivedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DerivedUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DerivedUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DerivedUnit self, Handle_StepBasic_HArray1OfDerivedUnitElement elements)

        :type elements: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_Init(self, *args)


    def SetElements(self, *args):
        """
        SetElements(Handle_StepBasic_DerivedUnit self, Handle_StepBasic_HArray1OfDerivedUnitElement elements)

        :type elements: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_SetElements(self, *args)


    def Elements(self, *args):
        """
        Elements(Handle_StepBasic_DerivedUnit self) -> Handle_StepBasic_HArray1OfDerivedUnitElement

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_Elements(self, *args)


    def NbElements(self, *args):
        """
        NbElements(Handle_StepBasic_DerivedUnit self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_NbElements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(Handle_StepBasic_DerivedUnit self, Standard_Integer const num) -> Handle_StepBasic_DerivedUnitElement

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DerivedUnitElement

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_ElementsValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DerivedUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DerivedUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DerivedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DerivedUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DerivedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DerivedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DerivedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DerivedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DerivedUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DerivedUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DerivedUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DerivedUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DerivedUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_DerivedUnit_swigregister = _StepBasic.Handle_StepBasic_DerivedUnit_swigregister
Handle_StepBasic_DerivedUnit_swigregister(Handle_StepBasic_DerivedUnit)

def Handle_StepBasic_DerivedUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DerivedUnit_DownCast(thing)
Handle_StepBasic_DerivedUnit_DownCast = _StepBasic.Handle_StepBasic_DerivedUnit_DownCast

class Handle_StepBasic_ContractAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ContractAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ContractAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ContractAssignment self, StepBasic_ContractAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ContractAssignment self, Handle_StepBasic_ContractAssignment theHandle) -> Handle_StepBasic_ContractAssignment
        assign(Handle_StepBasic_ContractAssignment self, StepBasic_ContractAssignment thePtr) -> Handle_StepBasic_ContractAssignment
        assign(Handle_StepBasic_ContractAssignment self, Handle_StepBasic_ContractAssignment theHandle) -> Handle_StepBasic_ContractAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ContractAssignment self) -> StepBasic_ContractAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ContractAssignment self) -> StepBasic_ContractAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ContractAssignment self) -> StepBasic_ContractAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ContractAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ContractAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ContractAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ContractAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ContractAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ContractAssignment self, Handle_StepBasic_Contract aAssignedContract)

        Initialize all fields (own and inherited)

        :type aAssignedContract: OCC.wrapper.StepBasic.Handle_StepBasic_Contract

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_Init(self, *args)


    def AssignedContract(self, *args):
        """
        AssignedContract(Handle_StepBasic_ContractAssignment self) -> Handle_StepBasic_Contract

        Returns field AssignedContract

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Contract

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_AssignedContract(self, *args)


    def SetAssignedContract(self, *args):
        """
        SetAssignedContract(Handle_StepBasic_ContractAssignment self, Handle_StepBasic_Contract AssignedContract)

        Set field AssignedContract

        :type AssignedContract: OCC.wrapper.StepBasic.Handle_StepBasic_Contract

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_SetAssignedContract(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ContractAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ContractAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ContractAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ContractAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ContractAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ContractAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ContractAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ContractAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ContractAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ContractAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ContractAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ContractAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ContractAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_ContractAssignment_swigregister = _StepBasic.Handle_StepBasic_ContractAssignment_swigregister
Handle_StepBasic_ContractAssignment_swigregister(Handle_StepBasic_ContractAssignment)

def Handle_StepBasic_ContractAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ContractAssignment_DownCast(thing)
Handle_StepBasic_ContractAssignment_DownCast = _StepBasic.Handle_StepBasic_ContractAssignment_DownCast

class Handle_StepBasic_DocumentFile(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentFile self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentFile self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentFile self, StepBasic_DocumentFile thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentFile self, Handle_StepBasic_DocumentFile theHandle) -> Handle_StepBasic_DocumentFile
        assign(Handle_StepBasic_DocumentFile self, StepBasic_DocumentFile thePtr) -> Handle_StepBasic_DocumentFile
        assign(Handle_StepBasic_DocumentFile self, Handle_StepBasic_DocumentFile theHandle) -> Handle_StepBasic_DocumentFile

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentFile self) -> StepBasic_DocumentFile

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentFile self) -> StepBasic_DocumentFile

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentFile___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentFile self) -> StepBasic_DocumentFile

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentFile___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentFile___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentFile___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentFile_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentFile

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentFile self, Handle_TCollection_HAsciiString aDocument_Id, Handle_TCollection_HAsciiString aDocument_Name, Standard_Boolean const hasDocument_Description, Handle_TCollection_HAsciiString aDocument_Description, Handle_StepBasic_DocumentType aDocument_Kind, Handle_TCollection_HAsciiString aCharacterizedObject_Name, Standard_Boolean const hasCharacterizedObject_Description, Handle_TCollection_HAsciiString aCharacterizedObject_Description)

        Initialize all fields (own and inherited)

        :type aDocument_Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDocument_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDocument_Description: bool
        :type aDocument_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDocument_Kind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType
        :type aCharacterizedObject_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasCharacterizedObject_Description: bool
        :type aCharacterizedObject_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Init(self, *args)


    def CharacterizedObject(self, *args):
        """
        CharacterizedObject(Handle_StepBasic_DocumentFile self) -> Handle_StepBasic_CharacterizedObject

        Returns data for supertype CharacterizedObject

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CharacterizedObject

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_CharacterizedObject(self, *args)


    def SetCharacterizedObject(self, *args):
        """
        SetCharacterizedObject(Handle_StepBasic_DocumentFile self, Handle_StepBasic_CharacterizedObject CharacterizedObject)

        Set data for supertype CharacterizedObject

        :type CharacterizedObject: OCC.wrapper.StepBasic.Handle_StepBasic_CharacterizedObject

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_SetCharacterizedObject(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentFile self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentFile_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentFile_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Id(self, *args):
        """
        Id(Handle_StepBasic_DocumentFile self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_DocumentFile self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_SetId(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DocumentFile self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DocumentFile self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_DocumentFile self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_DocumentFile self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_DocumentFile self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_HasDescription(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_DocumentFile self) -> Handle_StepBasic_DocumentType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_DocumentFile self, Handle_StepBasic_DocumentType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_SetKind(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentFile self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentFile_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentFile self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentFile self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentFile self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentFile self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentFile self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentFile self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentFile self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentFile_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentFile self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentFile_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentFile_swigregister = _StepBasic.Handle_StepBasic_DocumentFile_swigregister
Handle_StepBasic_DocumentFile_swigregister(Handle_StepBasic_DocumentFile)

def Handle_StepBasic_DocumentFile_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentFile_DownCast(thing)
Handle_StepBasic_DocumentFile_DownCast = _StepBasic.Handle_StepBasic_DocumentFile_DownCast

class StepBasic_DesignContext(StepBasic_ProductDefinitionContext):
    """class added to Schema AP214 around April 1996"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DesignContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DesignContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_DesignContext self) -> StepBasic_DesignContext

        class added to Schema AP214 around April 1996
        """
        this = _StepBasic.new_StepBasic_DesignContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DesignContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DesignContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DesignContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DesignContext
StepBasic_DesignContext_swigregister = _StepBasic.StepBasic_DesignContext_swigregister
StepBasic_DesignContext_swigregister(StepBasic_DesignContext)

def StepBasic_DesignContext_get_type_name(*args):
    """
    StepBasic_DesignContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DesignContext_get_type_name(*args)

def StepBasic_DesignContext_get_type_descriptor(*args):
    """
    StepBasic_DesignContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DesignContext_get_type_descriptor(*args)

class Handle_StepBasic_SizeMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SizeMember self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SizeMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SizeMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SizeMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SizeMember self, StepBasic_SizeMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SizeMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SizeMember self, Handle_StepBasic_SizeMember theHandle) -> Handle_StepBasic_SizeMember
        assign(Handle_StepBasic_SizeMember self, StepBasic_SizeMember thePtr) -> Handle_StepBasic_SizeMember
        assign(Handle_StepBasic_SizeMember self, Handle_StepBasic_SizeMember theHandle) -> Handle_StepBasic_SizeMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SizeMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SizeMember self) -> StepBasic_SizeMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SizeMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SizeMember self) -> StepBasic_SizeMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SizeMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SizeMember self) -> StepBasic_SizeMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SizeMember___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SizeMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SizeMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SizeMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SizeMember_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SizeMember

    def HasName(self, *args):
        """
        HasName(Handle_StepBasic_SizeMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SizeMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SizeMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SizeMember self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SizeMember self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SizeMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SizeMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SizeMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_SizeMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Kind(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepBasic_SizeMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepBasic_SizeMember self, Standard_Real const val)

        :type val: float

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetReal(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepBasic_SizeMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Matches(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_SizeMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetKind(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepBasic_SizeMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepBasic.Handle_StepBasic_SizeMember_ParamType(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepBasic_SizeMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepBasic_SizeMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetInt(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepBasic_SizeMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepBasic_SizeMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepBasic_SizeMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepBasic_SizeMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepBasic_SizeMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepBasic_SizeMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetLogical(self, *args)


    def String(self, *args):
        """
        String(Handle_StepBasic_SizeMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_SizeMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepBasic_SizeMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepBasic_SizeMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SizeMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepBasic_SizeMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_SizeMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepBasic_SizeMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepBasic_SizeMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_SizeMember_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SizeMember self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SizeMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SizeMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SizeMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SizeMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SizeMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SizeMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SizeMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SizeMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SizeMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SizeMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SizeMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SizeMember self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SizeMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SizeMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SizeMember_DecrementRefCounter(self, *args)

Handle_StepBasic_SizeMember_swigregister = _StepBasic.Handle_StepBasic_SizeMember_swigregister
Handle_StepBasic_SizeMember_swigregister(Handle_StepBasic_SizeMember)

def Handle_StepBasic_SizeMember_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SizeMember_DownCast(thing)
Handle_StepBasic_SizeMember_DownCast = _StepBasic.Handle_StepBasic_SizeMember_DownCast

class Handle_StepBasic_CharacterizedObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_CharacterizedObject self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_CharacterizedObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_CharacterizedObject self, StepBasic_CharacterizedObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_CharacterizedObject self, Handle_StepBasic_CharacterizedObject theHandle) -> Handle_StepBasic_CharacterizedObject
        assign(Handle_StepBasic_CharacterizedObject self, StepBasic_CharacterizedObject thePtr) -> Handle_StepBasic_CharacterizedObject
        assign(Handle_StepBasic_CharacterizedObject self, Handle_StepBasic_CharacterizedObject theHandle) -> Handle_StepBasic_CharacterizedObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_CharacterizedObject self) -> StepBasic_CharacterizedObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_CharacterizedObject self) -> StepBasic_CharacterizedObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_CharacterizedObject self) -> StepBasic_CharacterizedObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_CharacterizedObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_CharacterizedObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_CharacterizedObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_CharacterizedObject_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_CharacterizedObject

    def Init(self, *args):
        """
        Init(Handle_StepBasic_CharacterizedObject self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_CharacterizedObject self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_CharacterizedObject self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_CharacterizedObject self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_CharacterizedObject self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_CharacterizedObject self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_CharacterizedObject self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CharacterizedObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CharacterizedObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_CharacterizedObject self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_CharacterizedObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_CharacterizedObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_CharacterizedObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_CharacterizedObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_CharacterizedObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_CharacterizedObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_CharacterizedObject self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_CharacterizedObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CharacterizedObject_DecrementRefCounter(self, *args)

Handle_StepBasic_CharacterizedObject_swigregister = _StepBasic.Handle_StepBasic_CharacterizedObject_swigregister
Handle_StepBasic_CharacterizedObject_swigregister(Handle_StepBasic_CharacterizedObject)

def Handle_StepBasic_CharacterizedObject_DownCast(thing):
    return _StepBasic.Handle_StepBasic_CharacterizedObject_DownCast(thing)
Handle_StepBasic_CharacterizedObject_DownCast = _StepBasic.Handle_StepBasic_CharacterizedObject_DownCast

class Handle_StepBasic_SiUnitAndMassUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndMassUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndMassUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndMassUnit self, StepBasic_SiUnitAndMassUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndMassUnit self, Handle_StepBasic_SiUnitAndMassUnit theHandle) -> Handle_StepBasic_SiUnitAndMassUnit
        assign(Handle_StepBasic_SiUnitAndMassUnit self, StepBasic_SiUnitAndMassUnit thePtr) -> Handle_StepBasic_SiUnitAndMassUnit
        assign(Handle_StepBasic_SiUnitAndMassUnit self, Handle_StepBasic_SiUnitAndMassUnit theHandle) -> Handle_StepBasic_SiUnitAndMassUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndMassUnit self) -> StepBasic_SiUnitAndMassUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndMassUnit self) -> StepBasic_SiUnitAndMassUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndMassUnit self) -> StepBasic_SiUnitAndMassUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndMassUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndMassUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndMassUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndMassUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_Init(self, *args)


    def SetMassUnit(self, *args):
        """
        SetMassUnit(Handle_StepBasic_SiUnitAndMassUnit self, Handle_StepBasic_MassUnit aMassUnit)

        :type aMassUnit: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_SetMassUnit(self, *args)


    def MassUnit(self, *args):
        """
        MassUnit(Handle_StepBasic_SiUnitAndMassUnit self) -> Handle_StepBasic_MassUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MassUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_MassUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndMassUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndMassUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndMassUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndMassUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndMassUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndMassUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndMassUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndMassUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndMassUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndMassUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndMassUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndMassUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndMassUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndMassUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndMassUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndMassUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndMassUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndMassUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndMassUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_swigregister
Handle_StepBasic_SiUnitAndMassUnit_swigregister(Handle_StepBasic_SiUnitAndMassUnit)

def Handle_StepBasic_SiUnitAndMassUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndMassUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndMassUnit_DownCast

class Handle_StepBasic_GeneralProperty(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_GeneralProperty self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_GeneralProperty self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_GeneralProperty self, StepBasic_GeneralProperty thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_GeneralProperty self, Handle_StepBasic_GeneralProperty theHandle) -> Handle_StepBasic_GeneralProperty
        assign(Handle_StepBasic_GeneralProperty self, StepBasic_GeneralProperty thePtr) -> Handle_StepBasic_GeneralProperty
        assign(Handle_StepBasic_GeneralProperty self, Handle_StepBasic_GeneralProperty theHandle) -> Handle_StepBasic_GeneralProperty

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_GeneralProperty self) -> StepBasic_GeneralProperty

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_GeneralProperty self) -> StepBasic_GeneralProperty

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_GeneralProperty self) -> StepBasic_GeneralProperty

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_GeneralProperty___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_GeneralProperty___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_GeneralProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_GeneralProperty_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_GeneralProperty

    def Init(self, *args):
        """
        Init(Handle_StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_GeneralProperty self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_SetId(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_GeneralProperty self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_GeneralProperty self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_GeneralProperty self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_GeneralProperty self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_GeneralProperty self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_GeneralProperty_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_GeneralProperty_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_GeneralProperty self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_GeneralProperty self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_GeneralProperty self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_GeneralProperty self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_GeneralProperty self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_GeneralProperty self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_GeneralProperty self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_GeneralProperty self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_GeneralProperty self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_GeneralProperty_DecrementRefCounter(self, *args)

Handle_StepBasic_GeneralProperty_swigregister = _StepBasic.Handle_StepBasic_GeneralProperty_swigregister
Handle_StepBasic_GeneralProperty_swigregister(Handle_StepBasic_GeneralProperty)

def Handle_StepBasic_GeneralProperty_DownCast(thing):
    return _StepBasic.Handle_StepBasic_GeneralProperty_DownCast(thing)
Handle_StepBasic_GeneralProperty_DownCast = _StepBasic.Handle_StepBasic_GeneralProperty_DownCast

class NCollection_Array1_Handle_StepBasic_Document(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_Document self) -> NCollection_Array1< opencascade::handle< StepBasic_Document > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_Document self) -> NCollection_Array1< opencascade::handle< StepBasic_Document > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_Document self) -> NCollection_Array1< opencascade::handle< StepBasic_Document > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_Document self) -> NCollection_Array1< opencascade::handle< StepBasic_Document > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_Document self, Handle_StepBasic_Document theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_Document self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_Document self, NCollection_Array1_Handle_StepBasic_Document theOther) -> NCollection_Array1_Handle_StepBasic_Document

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_Document self, NCollection_Array1_Handle_StepBasic_Document theOther) -> NCollection_Array1_Handle_StepBasic_Document

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_Document self, NCollection_Array1_Handle_StepBasic_Document theOther) -> NCollection_Array1_Handle_StepBasic_Document
        assign(NCollection_Array1_Handle_StepBasic_Document self, NCollection_Array1_Handle_StepBasic_Document theOther) -> NCollection_Array1_Handle_StepBasic_Document

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Document_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_Document self) -> Handle_StepBasic_Document

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_Document self) -> Handle_StepBasic_Document

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_Document self, Standard_Integer const theIndex) -> Handle_StepBasic_Document

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Document___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Document_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_Document self, Standard_Integer const theIndex, Handle_StepBasic_Document theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_Document self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Document_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_Document
NCollection_Array1_Handle_StepBasic_Document_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_Document_swigregister
NCollection_Array1_Handle_StepBasic_Document_swigregister(NCollection_Array1_Handle_StepBasic_Document)


try:
	StepBasic_Array1OfDocument = NCollection_Array1_Handle_StepBasic_Document
except NameError:
	pass # does not exist, probably ignored

class Handle_StepBasic_MeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_MeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_MeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_MeasureWithUnit self, StepBasic_MeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_MeasureWithUnit self, Handle_StepBasic_MeasureWithUnit theHandle) -> Handle_StepBasic_MeasureWithUnit
        assign(Handle_StepBasic_MeasureWithUnit self, StepBasic_MeasureWithUnit thePtr) -> Handle_StepBasic_MeasureWithUnit
        assign(Handle_StepBasic_MeasureWithUnit self, Handle_StepBasic_MeasureWithUnit theHandle) -> Handle_StepBasic_MeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_MeasureWithUnit self) -> StepBasic_MeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_MeasureWithUnit self) -> StepBasic_MeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_MeasureWithUnit self) -> StepBasic_MeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_MeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_MeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_MeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_MeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_MeasureWithUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_MeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_MeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_MeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_MeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_MeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_MeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_MeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_UnitComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_MeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_MeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_MeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_MeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_MeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_MeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_MeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_MeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_MeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_MeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_MeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_MeasureWithUnit_swigregister
Handle_StepBasic_MeasureWithUnit_swigregister(Handle_StepBasic_MeasureWithUnit)

def Handle_StepBasic_MeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_MeasureWithUnit_DownCast(thing)
Handle_StepBasic_MeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_MeasureWithUnit_DownCast

class StepBasic_ProductDefinitionEffectivity(StepBasic_Effectivity):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionEffectivity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionEffectivity(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_ProductDefinitionEffectivity self) -> StepBasic_ProductDefinitionEffectivity"""
        this = _StepBasic.new_StepBasic_ProductDefinitionEffectivity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionEffectivity self, Handle_TCollection_HAsciiString aId, Handle_StepBasic_ProductDefinitionRelationship aUsage)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aUsage: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionRelationship

        """
        return _StepBasic.StepBasic_ProductDefinitionEffectivity_Init(self, *args)


    def Usage(self, *args):
        """
        Usage(StepBasic_ProductDefinitionEffectivity self) -> Handle_StepBasic_ProductDefinitionRelationship

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionRelationship

        """
        return _StepBasic.StepBasic_ProductDefinitionEffectivity_Usage(self, *args)


    def SetUsage(self, *args):
        """
        SetUsage(StepBasic_ProductDefinitionEffectivity self, Handle_StepBasic_ProductDefinitionRelationship aUsage)

        :type aUsage: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionRelationship

        """
        return _StepBasic.StepBasic_ProductDefinitionEffectivity_SetUsage(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionEffectivity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionEffectivity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionEffectivity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionEffectivity
StepBasic_ProductDefinitionEffectivity_swigregister = _StepBasic.StepBasic_ProductDefinitionEffectivity_swigregister
StepBasic_ProductDefinitionEffectivity_swigregister(StepBasic_ProductDefinitionEffectivity)

def StepBasic_ProductDefinitionEffectivity_get_type_name(*args):
    """
    StepBasic_ProductDefinitionEffectivity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionEffectivity_get_type_name(*args)

def StepBasic_ProductDefinitionEffectivity_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionEffectivity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionEffectivity_get_type_descriptor(*args)

class NCollection_Array1_Handle_StepBasic_ProductDefinition(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductDefinition > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductDefinition > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductDefinition > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductDefinition > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_ProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinition theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_ProductDefinition self, NCollection_Array1_Handle_StepBasic_ProductDefinition theOther) -> NCollection_Array1_Handle_StepBasic_ProductDefinition

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_ProductDefinition self, NCollection_Array1_Handle_StepBasic_ProductDefinition theOther) -> NCollection_Array1_Handle_StepBasic_ProductDefinition

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_ProductDefinition self, NCollection_Array1_Handle_StepBasic_ProductDefinition theOther) -> NCollection_Array1_Handle_StepBasic_ProductDefinition
        assign(NCollection_Array1_Handle_StepBasic_ProductDefinition self, NCollection_Array1_Handle_StepBasic_ProductDefinition theOther) -> NCollection_Array1_Handle_StepBasic_ProductDefinition

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Handle_StepBasic_ProductDefinition

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_ProductDefinition self) -> Handle_StepBasic_ProductDefinition

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_ProductDefinition self, Standard_Integer const theIndex) -> Handle_StepBasic_ProductDefinition

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_ProductDefinition self, Standard_Integer const theIndex, Handle_StepBasic_ProductDefinition theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_ProductDefinition self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_ProductDefinition
NCollection_Array1_Handle_StepBasic_ProductDefinition_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductDefinition_swigregister
NCollection_Array1_Handle_StepBasic_ProductDefinition_swigregister(NCollection_Array1_Handle_StepBasic_ProductDefinition)


try:
	StepBasic_Array1OfProductDefinition = NCollection_Array1_Handle_StepBasic_ProductDefinition
except NameError:
	pass # does not exist, probably ignored

class StepBasic_ConversionBasedUnitAndRatioUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndRatioUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndRatioUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndRatioUnit self) -> StepBasic_ConversionBasedUnitAndRatioUnit

        Returns a ConversionBasedUnitAndRatioUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndRatioUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_Init(self, *args)


    def SetRatioUnit(self, *args):
        """
        SetRatioUnit(StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_RatioUnit aRatioUnit)

        :type aRatioUnit: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_SetRatioUnit(self, *args)


    def RatioUnit(self, *args):
        """
        RatioUnit(StepBasic_ConversionBasedUnitAndRatioUnit self) -> Handle_StepBasic_RatioUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_RatioUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndRatioUnit
StepBasic_ConversionBasedUnitAndRatioUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_swigregister
StepBasic_ConversionBasedUnitAndRatioUnit_swigregister(StepBasic_ConversionBasedUnitAndRatioUnit)

def StepBasic_ConversionBasedUnitAndRatioUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndRatioUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndRatioUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndRatioUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndRatioUnit_get_type_descriptor(*args)

class Handle_StepBasic_ProductDefinitionContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionContext self, StepBasic_ProductDefinitionContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionContext self, Handle_StepBasic_ProductDefinitionContext theHandle) -> Handle_StepBasic_ProductDefinitionContext
        assign(Handle_StepBasic_ProductDefinitionContext self, StepBasic_ProductDefinitionContext thePtr) -> Handle_StepBasic_ProductDefinitionContext
        assign(Handle_StepBasic_ProductDefinitionContext self, Handle_StepBasic_ProductDefinitionContext theHandle) -> Handle_StepBasic_ProductDefinitionContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionContext self) -> StepBasic_ProductDefinitionContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionContext self) -> StepBasic_ProductDefinitionContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionContext self) -> StepBasic_ProductDefinitionContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionContext

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionContext self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference, Handle_TCollection_HAsciiString aLifeCycleStage)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aLifeCycleStage: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_Init(self, *args)


    def SetLifeCycleStage(self, *args):
        """
        SetLifeCycleStage(Handle_StepBasic_ProductDefinitionContext self, Handle_TCollection_HAsciiString aLifeCycleStage)

        :type aLifeCycleStage: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_SetLifeCycleStage(self, *args)


    def LifeCycleStage(self, *args):
        """
        LifeCycleStage(Handle_StepBasic_ProductDefinitionContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_LifeCycleStage(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductDefinitionContext self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductDefinitionContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ProductDefinitionContext self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ProductDefinitionContext self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionContext_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionContext_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionContext_swigregister
Handle_StepBasic_ProductDefinitionContext_swigregister(Handle_StepBasic_ProductDefinitionContext)

def Handle_StepBasic_ProductDefinitionContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionContext_DownCast(thing)
Handle_StepBasic_ProductDefinitionContext_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionContext_DownCast

class Handle_StepBasic_WeekOfYearAndDayDate(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_WeekOfYearAndDayDate self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_WeekOfYearAndDayDate self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_WeekOfYearAndDayDate self, StepBasic_WeekOfYearAndDayDate thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_WeekOfYearAndDayDate self, Handle_StepBasic_WeekOfYearAndDayDate theHandle) -> Handle_StepBasic_WeekOfYearAndDayDate
        assign(Handle_StepBasic_WeekOfYearAndDayDate self, StepBasic_WeekOfYearAndDayDate thePtr) -> Handle_StepBasic_WeekOfYearAndDayDate
        assign(Handle_StepBasic_WeekOfYearAndDayDate self, Handle_StepBasic_WeekOfYearAndDayDate theHandle) -> Handle_StepBasic_WeekOfYearAndDayDate

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_WeekOfYearAndDayDate self) -> StepBasic_WeekOfYearAndDayDate

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_WeekOfYearAndDayDate self) -> StepBasic_WeekOfYearAndDayDate

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_WeekOfYearAndDayDate self) -> StepBasic_WeekOfYearAndDayDate

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_WeekOfYearAndDayDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_WeekOfYearAndDayDate

    def Init(self, *args):
        """
        Init(Handle_StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aYearComponent, Standard_Integer const aWeekComponent, Standard_Boolean const hasAdayComponent, Standard_Integer const aDayComponent)

        :type aYearComponent: int
        :type aWeekComponent: int
        :type hasAdayComponent: bool
        :type aDayComponent: int

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_Init(self, *args)


    def SetWeekComponent(self, *args):
        """
        SetWeekComponent(Handle_StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aWeekComponent)

        :type aWeekComponent: int

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_SetWeekComponent(self, *args)


    def WeekComponent(self, *args):
        """
        WeekComponent(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_WeekComponent(self, *args)


    def SetDayComponent(self, *args):
        """
        SetDayComponent(Handle_StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aDayComponent)

        :type aDayComponent: int

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_SetDayComponent(self, *args)


    def UnSetDayComponent(self, *args):
        """UnSetDayComponent(Handle_StepBasic_WeekOfYearAndDayDate self)"""
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_UnSetDayComponent(self, *args)


    def DayComponent(self, *args):
        """
        DayComponent(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_DayComponent(self, *args)


    def HasDayComponent(self, *args):
        """
        HasDayComponent(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_HasDayComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_WeekOfYearAndDayDate self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetYearComponent(self, *args):
        """
        SetYearComponent(Handle_StepBasic_WeekOfYearAndDayDate self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_SetYearComponent(self, *args)


    def YearComponent(self, *args):
        """
        YearComponent(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_YearComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_WeekOfYearAndDayDate self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_WeekOfYearAndDayDate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_WeekOfYearAndDayDate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_WeekOfYearAndDayDate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_WeekOfYearAndDayDate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_WeekOfYearAndDayDate self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_WeekOfYearAndDayDate self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_DecrementRefCounter(self, *args)

Handle_StepBasic_WeekOfYearAndDayDate_swigregister = _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_swigregister
Handle_StepBasic_WeekOfYearAndDayDate_swigregister(Handle_StepBasic_WeekOfYearAndDayDate)

def Handle_StepBasic_WeekOfYearAndDayDate_DownCast(thing):
    return _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_DownCast(thing)
Handle_StepBasic_WeekOfYearAndDayDate_DownCast = _StepBasic.Handle_StepBasic_WeekOfYearAndDayDate_DownCast

class Handle_StepBasic_ProductDefinitionEffectivity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionEffectivity self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionEffectivity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionEffectivity self, StepBasic_ProductDefinitionEffectivity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_StepBasic_ProductDefinitionEffectivity theHandle) -> Handle_StepBasic_ProductDefinitionEffectivity
        assign(Handle_StepBasic_ProductDefinitionEffectivity self, StepBasic_ProductDefinitionEffectivity thePtr) -> Handle_StepBasic_ProductDefinitionEffectivity
        assign(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_StepBasic_ProductDefinitionEffectivity theHandle) -> Handle_StepBasic_ProductDefinitionEffectivity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionEffectivity self) -> StepBasic_ProductDefinitionEffectivity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionEffectivity self) -> StepBasic_ProductDefinitionEffectivity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionEffectivity self) -> StepBasic_ProductDefinitionEffectivity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionEffectivity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionEffectivity

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_TCollection_HAsciiString aId, Handle_StepBasic_ProductDefinitionRelationship aUsage)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aUsage: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionRelationship

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_Init(self, *args)


    def Usage(self, *args):
        """
        Usage(Handle_StepBasic_ProductDefinitionEffectivity self) -> Handle_StepBasic_ProductDefinitionRelationship

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionRelationship

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_Usage(self, *args)


    def SetUsage(self, *args):
        """
        SetUsage(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_StepBasic_ProductDefinitionRelationship aUsage)

        :type aUsage: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionRelationship

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_SetUsage(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionEffectivity self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionEffectivity self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_TCollection_HAsciiString aid)

        :type aid: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_SetId(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionEffectivity self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionEffectivity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionEffectivity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionEffectivity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionEffectivity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionEffectivity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionEffectivity self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionEffectivity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionEffectivity_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_swigregister
Handle_StepBasic_ProductDefinitionEffectivity_swigregister(Handle_StepBasic_ProductDefinitionEffectivity)

def Handle_StepBasic_ProductDefinitionEffectivity_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_DownCast(thing)
Handle_StepBasic_ProductDefinitionEffectivity_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionEffectivity_DownCast

class Handle_StepBasic_HArray1OfPerson(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfPerson self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfPerson self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfPerson self, StepBasic_HArray1OfPerson thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfPerson self, Handle_StepBasic_HArray1OfPerson theHandle) -> Handle_StepBasic_HArray1OfPerson
        assign(Handle_StepBasic_HArray1OfPerson self, StepBasic_HArray1OfPerson thePtr) -> Handle_StepBasic_HArray1OfPerson
        assign(Handle_StepBasic_HArray1OfPerson self, Handle_StepBasic_HArray1OfPerson theHandle) -> Handle_StepBasic_HArray1OfPerson

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfPerson self) -> StepBasic_HArray1OfPerson

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfPerson self) -> StepBasic_HArray1OfPerson

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfPerson self) -> StepBasic_HArray1OfPerson

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfPerson___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfPerson___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfPerson(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfPerson_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfPerson

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfPerson

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfPerson_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfPerson self) -> NCollection_Array1_Handle_StepBasic_Person

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfPerson

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfPerson self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfPerson_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfPerson_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfPerson self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfPerson self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfPerson self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfPerson self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfPerson self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfPerson self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfPerson self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfPerson self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfPerson self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfPerson_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfPerson_swigregister = _StepBasic.Handle_StepBasic_HArray1OfPerson_swigregister
Handle_StepBasic_HArray1OfPerson_swigregister(Handle_StepBasic_HArray1OfPerson)

def Handle_StepBasic_HArray1OfPerson_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfPerson_DownCast(thing)
Handle_StepBasic_HArray1OfPerson_DownCast = _StepBasic.Handle_StepBasic_HArray1OfPerson_DownCast

class Handle_StepBasic_Contract(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Contract self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Contract_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Contract self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Contract_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Contract self, StepBasic_Contract thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Contract_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Contract self, Handle_StepBasic_Contract theHandle) -> Handle_StepBasic_Contract
        assign(Handle_StepBasic_Contract self, StepBasic_Contract thePtr) -> Handle_StepBasic_Contract
        assign(Handle_StepBasic_Contract self, Handle_StepBasic_Contract theHandle) -> Handle_StepBasic_Contract

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Contract_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Contract self) -> StepBasic_Contract

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Contract_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Contract self) -> StepBasic_Contract

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Contract___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Contract self) -> StepBasic_Contract

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Contract___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Contract___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Contract___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Contract(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Contract_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Contract

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Contract self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aPurpose, Handle_StepBasic_ContractType aKind)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_ContractType

        """
        return _StepBasic.Handle_StepBasic_Contract_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Contract self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Contract_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Contract self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Contract_SetName(self, *args)


    def Purpose(self, *args):
        """
        Purpose(Handle_StepBasic_Contract self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Contract_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(Handle_StepBasic_Contract self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Contract_SetPurpose(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_Contract self) -> Handle_StepBasic_ContractType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ContractType

        """
        return _StepBasic.Handle_StepBasic_Contract_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_Contract self, Handle_StepBasic_ContractType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_ContractType

        """
        return _StepBasic.Handle_StepBasic_Contract_SetKind(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Contract self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Contract_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Contract_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Contract_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Contract self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Contract_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Contract self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Contract self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Contract_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Contract self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Contract self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Contract_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Contract self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Contract_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Contract self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Contract_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Contract self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Contract_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Contract self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Contract_DecrementRefCounter(self, *args)

Handle_StepBasic_Contract_swigregister = _StepBasic.Handle_StepBasic_Contract_swigregister
Handle_StepBasic_Contract_swigregister(Handle_StepBasic_Contract)

def Handle_StepBasic_Contract_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Contract_DownCast(thing)
Handle_StepBasic_Contract_DownCast = _StepBasic.Handle_StepBasic_Contract_DownCast

class Handle_StepBasic_Person(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Person self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Person_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Person self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Person_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Person self, StepBasic_Person thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Person_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Person self, Handle_StepBasic_Person theHandle) -> Handle_StepBasic_Person
        assign(Handle_StepBasic_Person self, StepBasic_Person thePtr) -> Handle_StepBasic_Person
        assign(Handle_StepBasic_Person self, Handle_StepBasic_Person theHandle) -> Handle_StepBasic_Person

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Person_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Person self) -> StepBasic_Person

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Person_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Person self) -> StepBasic_Person

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Person___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Person self) -> StepBasic_Person

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Person___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Person___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Person___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Person(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Person_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Person

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Person self, Handle_TCollection_HAsciiString aId, Standard_Boolean const hasAlastName, Handle_TCollection_HAsciiString aLastName, Standard_Boolean const hasAfirstName, Handle_TCollection_HAsciiString aFirstName, Standard_Boolean const hasAmiddleNames, Handle_Interface_HArray1OfHAsciiString aMiddleNames, Standard_Boolean const hasAprefixTitles, Handle_Interface_HArray1OfHAsciiString aPrefixTitles, Standard_Boolean const hasAsuffixTitles, Handle_Interface_HArray1OfHAsciiString aSuffixTitles)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAlastName: bool
        :type aLastName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfirstName: bool
        :type aFirstName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAmiddleNames: bool
        :type aMiddleNames: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString
        :type hasAprefixTitles: bool
        :type aPrefixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString
        :type hasAsuffixTitles: bool
        :type aSuffixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_Person self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_Person self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_Id(self, *args)


    def SetLastName(self, *args):
        """
        SetLastName(Handle_StepBasic_Person self, Handle_TCollection_HAsciiString aLastName)

        :type aLastName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SetLastName(self, *args)


    def UnSetLastName(self, *args):
        """UnSetLastName(Handle_StepBasic_Person self)"""
        return _StepBasic.Handle_StepBasic_Person_UnSetLastName(self, *args)


    def LastName(self, *args):
        """
        LastName(Handle_StepBasic_Person self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_LastName(self, *args)


    def HasLastName(self, *args):
        """
        HasLastName(Handle_StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_HasLastName(self, *args)


    def SetFirstName(self, *args):
        """
        SetFirstName(Handle_StepBasic_Person self, Handle_TCollection_HAsciiString aFirstName)

        :type aFirstName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SetFirstName(self, *args)


    def UnSetFirstName(self, *args):
        """UnSetFirstName(Handle_StepBasic_Person self)"""
        return _StepBasic.Handle_StepBasic_Person_UnSetFirstName(self, *args)


    def FirstName(self, *args):
        """
        FirstName(Handle_StepBasic_Person self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_FirstName(self, *args)


    def HasFirstName(self, *args):
        """
        HasFirstName(Handle_StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_HasFirstName(self, *args)


    def SetMiddleNames(self, *args):
        """
        SetMiddleNames(Handle_StepBasic_Person self, Handle_Interface_HArray1OfHAsciiString aMiddleNames)

        :type aMiddleNames: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SetMiddleNames(self, *args)


    def UnSetMiddleNames(self, *args):
        """UnSetMiddleNames(Handle_StepBasic_Person self)"""
        return _StepBasic.Handle_StepBasic_Person_UnSetMiddleNames(self, *args)


    def MiddleNames(self, *args):
        """
        MiddleNames(Handle_StepBasic_Person self) -> Handle_Interface_HArray1OfHAsciiString

        :rtype: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_MiddleNames(self, *args)


    def HasMiddleNames(self, *args):
        """
        HasMiddleNames(Handle_StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_HasMiddleNames(self, *args)


    def MiddleNamesValue(self, *args):
        """
        MiddleNamesValue(Handle_StepBasic_Person self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_MiddleNamesValue(self, *args)


    def NbMiddleNames(self, *args):
        """
        NbMiddleNames(Handle_StepBasic_Person self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Person_NbMiddleNames(self, *args)


    def SetPrefixTitles(self, *args):
        """
        SetPrefixTitles(Handle_StepBasic_Person self, Handle_Interface_HArray1OfHAsciiString aPrefixTitles)

        :type aPrefixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SetPrefixTitles(self, *args)


    def UnSetPrefixTitles(self, *args):
        """UnSetPrefixTitles(Handle_StepBasic_Person self)"""
        return _StepBasic.Handle_StepBasic_Person_UnSetPrefixTitles(self, *args)


    def PrefixTitles(self, *args):
        """
        PrefixTitles(Handle_StepBasic_Person self) -> Handle_Interface_HArray1OfHAsciiString

        :rtype: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_PrefixTitles(self, *args)


    def HasPrefixTitles(self, *args):
        """
        HasPrefixTitles(Handle_StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_HasPrefixTitles(self, *args)


    def PrefixTitlesValue(self, *args):
        """
        PrefixTitlesValue(Handle_StepBasic_Person self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_PrefixTitlesValue(self, *args)


    def NbPrefixTitles(self, *args):
        """
        NbPrefixTitles(Handle_StepBasic_Person self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Person_NbPrefixTitles(self, *args)


    def SetSuffixTitles(self, *args):
        """
        SetSuffixTitles(Handle_StepBasic_Person self, Handle_Interface_HArray1OfHAsciiString aSuffixTitles)

        :type aSuffixTitles: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SetSuffixTitles(self, *args)


    def UnSetSuffixTitles(self, *args):
        """UnSetSuffixTitles(Handle_StepBasic_Person self)"""
        return _StepBasic.Handle_StepBasic_Person_UnSetSuffixTitles(self, *args)


    def SuffixTitles(self, *args):
        """
        SuffixTitles(Handle_StepBasic_Person self) -> Handle_Interface_HArray1OfHAsciiString

        :rtype: OCC.wrapper.Interface.Handle_Interface_HArray1OfHAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SuffixTitles(self, *args)


    def HasSuffixTitles(self, *args):
        """
        HasSuffixTitles(Handle_StepBasic_Person self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_HasSuffixTitles(self, *args)


    def SuffixTitlesValue(self, *args):
        """
        SuffixTitlesValue(Handle_StepBasic_Person self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Person_SuffixTitlesValue(self, *args)


    def NbSuffixTitles(self, *args):
        """
        NbSuffixTitles(Handle_StepBasic_Person self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Person_NbSuffixTitles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Person self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Person_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Person_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Person_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Person self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Person_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Person self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Person self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Person self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Person self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Person_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Person self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Person_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Person self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Person_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Person self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Person_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Person self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Person_DecrementRefCounter(self, *args)

Handle_StepBasic_Person_swigregister = _StepBasic.Handle_StepBasic_Person_swigregister
Handle_StepBasic_Person_swigregister(Handle_StepBasic_Person)

def Handle_StepBasic_Person_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Person_DownCast(thing)
Handle_StepBasic_Person_DownCast = _StepBasic.Handle_StepBasic_Person_DownCast

class Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, StepBasic_ConversionBasedUnitAndSolidAngleUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, StepBasic_ConversionBasedUnitAndSolidAngleUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> StepBasic_ConversionBasedUnitAndSolidAngleUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> StepBasic_ConversionBasedUnitAndSolidAngleUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> StepBasic_ConversionBasedUnitAndSolidAngleUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_Init(self, *args)


    def SetSolidAngleUnit(self, *args):
        """
        SetSolidAngleUnit(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_SolidAngleUnit aSolidAngleUnit)

        :type aSolidAngleUnit: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_SetSolidAngleUnit(self, *args)


    def SolidAngleUnit(self, *args):
        """
        SolidAngleUnit(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Handle_StepBasic_SolidAngleUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SolidAngleUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_SolidAngleUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit)

def Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndSolidAngleUnit_DownCast

class StepBasic_ProductDefinitionWithAssociatedDocuments(StepBasic_ProductDefinition):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ProductDefinitionWithAssociatedDocuments
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ProductDefinitionWithAssociatedDocuments(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_ProductDefinitionWithAssociatedDocuments self) -> StepBasic_ProductDefinitionWithAssociatedDocuments"""
        this = _StepBasic.new_StepBasic_ProductDefinitionWithAssociatedDocuments(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aFormation, Handle_StepBasic_ProductDefinitionContext aFrame, Handle_StepBasic_HArray1OfDocument aDocIds)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aFrame: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext
        :type aDocIds: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDocument

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_Init(self, *args)


    def DocIds(self, *args):
        """
        DocIds(StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Handle_StepBasic_HArray1OfDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDocument

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_DocIds(self, *args)


    def SetDocIds(self, *args):
        """
        SetDocIds(StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_StepBasic_HArray1OfDocument DocIds)

        :type DocIds: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDocument

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_SetDocIds(self, *args)


    def NbDocIds(self, *args):
        """
        NbDocIds(StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_NbDocIds(self, *args)


    def DocIdsValue(self, *args):
        """
        DocIdsValue(StepBasic_ProductDefinitionWithAssociatedDocuments self, Standard_Integer const num) -> Handle_StepBasic_Document

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_DocIdsValue(self, *args)


    def SetDocIdsValue(self, *args):
        """
        SetDocIdsValue(StepBasic_ProductDefinitionWithAssociatedDocuments self, Standard_Integer const num, Handle_StepBasic_Document adoc)

        :type num: int
        :type adoc: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_SetDocIdsValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionWithAssociatedDocuments
StepBasic_ProductDefinitionWithAssociatedDocuments_swigregister = _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_swigregister
StepBasic_ProductDefinitionWithAssociatedDocuments_swigregister(StepBasic_ProductDefinitionWithAssociatedDocuments)

def StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_name(*args):
    """
    StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_name(*args)

def StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_descriptor(*args):
    """
    StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_descriptor(*args)

class Handle_StepBasic_Certification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Certification self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Certification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Certification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Certification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Certification self, StepBasic_Certification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Certification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Certification self, Handle_StepBasic_Certification theHandle) -> Handle_StepBasic_Certification
        assign(Handle_StepBasic_Certification self, StepBasic_Certification thePtr) -> Handle_StepBasic_Certification
        assign(Handle_StepBasic_Certification self, Handle_StepBasic_Certification theHandle) -> Handle_StepBasic_Certification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Certification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Certification self) -> StepBasic_Certification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Certification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Certification self) -> StepBasic_Certification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Certification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Certification self) -> StepBasic_Certification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Certification___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Certification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Certification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Certification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Certification_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Certification

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Certification self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aPurpose, Handle_StepBasic_CertificationType aKind)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPurpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationType

        """
        return _StepBasic.Handle_StepBasic_Certification_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Certification self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Certification_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Certification self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Certification_SetName(self, *args)


    def Purpose(self, *args):
        """
        Purpose(Handle_StepBasic_Certification self) -> Handle_TCollection_HAsciiString

        Returns field Purpose

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Certification_Purpose(self, *args)


    def SetPurpose(self, *args):
        """
        SetPurpose(Handle_StepBasic_Certification self, Handle_TCollection_HAsciiString Purpose)

        Set field Purpose

        :type Purpose: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Certification_SetPurpose(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_Certification self) -> Handle_StepBasic_CertificationType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationType

        """
        return _StepBasic.Handle_StepBasic_Certification_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_Certification self, Handle_StepBasic_CertificationType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_CertificationType

        """
        return _StepBasic.Handle_StepBasic_Certification_SetKind(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Certification self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Certification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Certification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Certification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Certification self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Certification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Certification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Certification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Certification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Certification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Certification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Certification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Certification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Certification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Certification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Certification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Certification self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Certification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Certification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Certification_DecrementRefCounter(self, *args)

Handle_StepBasic_Certification_swigregister = _StepBasic.Handle_StepBasic_Certification_swigregister
Handle_StepBasic_Certification_swigregister(Handle_StepBasic_Certification)

def Handle_StepBasic_Certification_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Certification_DownCast(thing)
Handle_StepBasic_Certification_DownCast = _StepBasic.Handle_StepBasic_Certification_DownCast

class Handle_StepBasic_DocumentReference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentReference self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentReference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentReference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentReference self, StepBasic_DocumentReference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentReference self, Handle_StepBasic_DocumentReference theHandle) -> Handle_StepBasic_DocumentReference
        assign(Handle_StepBasic_DocumentReference self, StepBasic_DocumentReference thePtr) -> Handle_StepBasic_DocumentReference
        assign(Handle_StepBasic_DocumentReference self, Handle_StepBasic_DocumentReference theHandle) -> Handle_StepBasic_DocumentReference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentReference self) -> StepBasic_DocumentReference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentReference self) -> StepBasic_DocumentReference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentReference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentReference self) -> StepBasic_DocumentReference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentReference___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentReference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentReference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentReference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentReference_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentReference

    def Init0(self, *args):
        """
        Init0(Handle_StepBasic_DocumentReference self, Handle_StepBasic_Document aAssignedDocument, Handle_TCollection_HAsciiString aSource)

        :type aAssignedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aSource: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_Init0(self, *args)


    def AssignedDocument(self, *args):
        """
        AssignedDocument(Handle_StepBasic_DocumentReference self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_AssignedDocument(self, *args)


    def SetAssignedDocument(self, *args):
        """
        SetAssignedDocument(Handle_StepBasic_DocumentReference self, Handle_StepBasic_Document aAssignedDocument)

        :type aAssignedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_SetAssignedDocument(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepBasic_DocumentReference self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepBasic_DocumentReference self, Handle_TCollection_HAsciiString aSource)

        :type aSource: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_SetSource(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentReference self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentReference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentReference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentReference self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentReference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentReference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentReference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentReference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentReference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentReference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentReference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentReference self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentReference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentReference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentReference_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentReference_swigregister = _StepBasic.Handle_StepBasic_DocumentReference_swigregister
Handle_StepBasic_DocumentReference_swigregister(Handle_StepBasic_DocumentReference)

def Handle_StepBasic_DocumentReference_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentReference_DownCast(thing)
Handle_StepBasic_DocumentReference_DownCast = _StepBasic.Handle_StepBasic_DocumentReference_DownCast

class StepBasic_MeasureValueMember(StepData.StepData_SelectReal):
    """
    for Select MeasureValue, i.e. :
    length_measure,time_measure,plane_angle_measure,
    solid_angle_measure,ratio_measure,parameter_value,
    context_dependent_measure,positive_length_measure,
    positive_plane_angle_measure,positive_ratio_measure,
    area_measure,volume_measure, count_measure
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_MeasureValueMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_MeasureValueMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_MeasureValueMember self) -> StepBasic_MeasureValueMember

        for Select MeasureValue, i.e. :
        length_measure,time_measure,plane_angle_measure,
        solid_angle_measure,ratio_measure,parameter_value,
        context_dependent_measure,positive_length_measure,
        positive_plane_angle_measure,positive_ratio_measure,
        area_measure,volume_measure, count_measure
        """
        this = _StepBasic.new_StepBasic_MeasureValueMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepBasic_MeasureValueMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_MeasureValueMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_MeasureValueMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.StepBasic_MeasureValueMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_MeasureValueMember self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_MeasureValueMember_SetName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_MeasureValueMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_MeasureValueMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_MeasureValueMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_MeasureValueMember
StepBasic_MeasureValueMember_swigregister = _StepBasic.StepBasic_MeasureValueMember_swigregister
StepBasic_MeasureValueMember_swigregister(StepBasic_MeasureValueMember)

def StepBasic_MeasureValueMember_get_type_name(*args):
    """
    StepBasic_MeasureValueMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_MeasureValueMember_get_type_name(*args)

def StepBasic_MeasureValueMember_get_type_descriptor(*args):
    """
    StepBasic_MeasureValueMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_MeasureValueMember_get_type_descriptor(*args)

class Handle_StepBasic_CertificationAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_CertificationAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_CertificationAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_CertificationAssignment self, StepBasic_CertificationAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_CertificationAssignment self, Handle_StepBasic_CertificationAssignment theHandle) -> Handle_StepBasic_CertificationAssignment
        assign(Handle_StepBasic_CertificationAssignment self, StepBasic_CertificationAssignment thePtr) -> Handle_StepBasic_CertificationAssignment
        assign(Handle_StepBasic_CertificationAssignment self, Handle_StepBasic_CertificationAssignment theHandle) -> Handle_StepBasic_CertificationAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_CertificationAssignment self) -> StepBasic_CertificationAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_CertificationAssignment self) -> StepBasic_CertificationAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_CertificationAssignment self) -> StepBasic_CertificationAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_CertificationAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_CertificationAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_CertificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_CertificationAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_CertificationAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_CertificationAssignment self, Handle_StepBasic_Certification aAssignedCertification)

        Initialize all fields (own and inherited)

        :type aAssignedCertification: OCC.wrapper.StepBasic.Handle_StepBasic_Certification

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_Init(self, *args)


    def AssignedCertification(self, *args):
        """
        AssignedCertification(Handle_StepBasic_CertificationAssignment self) -> Handle_StepBasic_Certification

        Returns field AssignedCertification

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Certification

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_AssignedCertification(self, *args)


    def SetAssignedCertification(self, *args):
        """
        SetAssignedCertification(Handle_StepBasic_CertificationAssignment self, Handle_StepBasic_Certification AssignedCertification)

        Set field AssignedCertification

        :type AssignedCertification: OCC.wrapper.StepBasic.Handle_StepBasic_Certification

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_SetAssignedCertification(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_CertificationAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CertificationAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_CertificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_CertificationAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_CertificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_CertificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_CertificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_CertificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_CertificationAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_CertificationAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_CertificationAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_CertificationAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_CertificationAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_CertificationAssignment_swigregister = _StepBasic.Handle_StepBasic_CertificationAssignment_swigregister
Handle_StepBasic_CertificationAssignment_swigregister(Handle_StepBasic_CertificationAssignment)

def Handle_StepBasic_CertificationAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_CertificationAssignment_DownCast(thing)
Handle_StepBasic_CertificationAssignment_DownCast = _StepBasic.Handle_StepBasic_CertificationAssignment_DownCast

class Handle_StepBasic_EulerAngles(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_EulerAngles self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_EulerAngles_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_EulerAngles self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_EulerAngles self, StepBasic_EulerAngles thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_EulerAngles self, Handle_StepBasic_EulerAngles theHandle) -> Handle_StepBasic_EulerAngles
        assign(Handle_StepBasic_EulerAngles self, StepBasic_EulerAngles thePtr) -> Handle_StepBasic_EulerAngles
        assign(Handle_StepBasic_EulerAngles self, Handle_StepBasic_EulerAngles theHandle) -> Handle_StepBasic_EulerAngles

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_EulerAngles self) -> StepBasic_EulerAngles

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_EulerAngles self) -> StepBasic_EulerAngles

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_EulerAngles___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_EulerAngles self) -> StepBasic_EulerAngles

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_EulerAngles___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_EulerAngles___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_EulerAngles___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_EulerAngles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_EulerAngles_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_EulerAngles

    def Init(self, *args):
        """
        Init(Handle_StepBasic_EulerAngles self, Handle_TColStd_HArray1OfReal aAngles)

        Initialize all fields (own and inherited)

        :type aAngles: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_Init(self, *args)


    def Angles(self, *args):
        """
        Angles(Handle_StepBasic_EulerAngles self) -> Handle_TColStd_HArray1OfReal

        Returns field Angles

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_Angles(self, *args)


    def SetAngles(self, *args):
        """
        SetAngles(Handle_StepBasic_EulerAngles self, Handle_TColStd_HArray1OfReal Angles)

        Set field Angles

        :type Angles: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_SetAngles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_EulerAngles self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_EulerAngles_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_EulerAngles_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_EulerAngles self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_EulerAngles_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_EulerAngles self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_EulerAngles self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_EulerAngles self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_EulerAngles self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_EulerAngles self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_EulerAngles self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_EulerAngles self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_EulerAngles_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_EulerAngles self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_EulerAngles_DecrementRefCounter(self, *args)

Handle_StepBasic_EulerAngles_swigregister = _StepBasic.Handle_StepBasic_EulerAngles_swigregister
Handle_StepBasic_EulerAngles_swigregister(Handle_StepBasic_EulerAngles)

def Handle_StepBasic_EulerAngles_DownCast(thing):
    return _StepBasic.Handle_StepBasic_EulerAngles_DownCast(thing)
Handle_StepBasic_EulerAngles_DownCast = _StepBasic.Handle_StepBasic_EulerAngles_DownCast

class StepBasic_SecurityClassificationAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_SecurityClassificationAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_SecurityClassificationAssignment(self) 
            return h


    def Init(self, *args):
        """
        Init(StepBasic_SecurityClassificationAssignment self, Handle_StepBasic_SecurityClassification aAssignedSecurityClassification)

        :type aAssignedSecurityClassification: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassification

        """
        return _StepBasic.StepBasic_SecurityClassificationAssignment_Init(self, *args)


    def SetAssignedSecurityClassification(self, *args):
        """
        SetAssignedSecurityClassification(StepBasic_SecurityClassificationAssignment self, Handle_StepBasic_SecurityClassification aAssignedSecurityClassification)

        :type aAssignedSecurityClassification: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassification

        """
        return _StepBasic.StepBasic_SecurityClassificationAssignment_SetAssignedSecurityClassification(self, *args)


    def AssignedSecurityClassification(self, *args):
        """
        AssignedSecurityClassification(StepBasic_SecurityClassificationAssignment self) -> Handle_StepBasic_SecurityClassification

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassification

        """
        return _StepBasic.StepBasic_SecurityClassificationAssignment_AssignedSecurityClassification(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_SecurityClassificationAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_SecurityClassificationAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_SecurityClassificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepBasic.new_StepBasic_SecurityClassificationAssignment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepBasic.delete_StepBasic_SecurityClassificationAssignment
StepBasic_SecurityClassificationAssignment_swigregister = _StepBasic.StepBasic_SecurityClassificationAssignment_swigregister
StepBasic_SecurityClassificationAssignment_swigregister(StepBasic_SecurityClassificationAssignment)

def StepBasic_SecurityClassificationAssignment_get_type_name(*args):
    """
    StepBasic_SecurityClassificationAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_SecurityClassificationAssignment_get_type_name(*args)

def StepBasic_SecurityClassificationAssignment_get_type_descriptor(*args):
    """
    StepBasic_SecurityClassificationAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_SecurityClassificationAssignment_get_type_descriptor(*args)

class Handle_StepBasic_OrganizationAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_OrganizationAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_OrganizationAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_OrganizationAssignment self, StepBasic_OrganizationAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_OrganizationAssignment self, Handle_StepBasic_OrganizationAssignment theHandle) -> Handle_StepBasic_OrganizationAssignment
        assign(Handle_StepBasic_OrganizationAssignment self, StepBasic_OrganizationAssignment thePtr) -> Handle_StepBasic_OrganizationAssignment
        assign(Handle_StepBasic_OrganizationAssignment self, Handle_StepBasic_OrganizationAssignment theHandle) -> Handle_StepBasic_OrganizationAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_OrganizationAssignment self) -> StepBasic_OrganizationAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_OrganizationAssignment self) -> StepBasic_OrganizationAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_OrganizationAssignment self) -> StepBasic_OrganizationAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_OrganizationAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_OrganizationAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_OrganizationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_OrganizationAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_OrganizationAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_OrganizationAssignment self, Handle_StepBasic_Organization aAssignedOrganization, Handle_StepBasic_OrganizationRole aRole)

        :type aAssignedOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_OrganizationRole

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_Init(self, *args)


    def SetAssignedOrganization(self, *args):
        """
        SetAssignedOrganization(Handle_StepBasic_OrganizationAssignment self, Handle_StepBasic_Organization aAssignedOrganization)

        :type aAssignedOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_SetAssignedOrganization(self, *args)


    def AssignedOrganization(self, *args):
        """
        AssignedOrganization(Handle_StepBasic_OrganizationAssignment self) -> Handle_StepBasic_Organization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_AssignedOrganization(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_OrganizationAssignment self, Handle_StepBasic_OrganizationRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_OrganizationRole

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_OrganizationAssignment self) -> Handle_StepBasic_OrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_OrganizationRole

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_Role(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_OrganizationAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrganizationAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrganizationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_OrganizationAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_OrganizationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_OrganizationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_OrganizationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_OrganizationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_OrganizationAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_OrganizationAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_OrganizationAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_OrganizationAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_OrganizationAssignment_swigregister = _StepBasic.Handle_StepBasic_OrganizationAssignment_swigregister
Handle_StepBasic_OrganizationAssignment_swigregister(Handle_StepBasic_OrganizationAssignment)

def Handle_StepBasic_OrganizationAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_OrganizationAssignment_DownCast(thing)
Handle_StepBasic_OrganizationAssignment_DownCast = _StepBasic.Handle_StepBasic_OrganizationAssignment_DownCast

class Handle_StepBasic_ApprovalStatus(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApprovalStatus self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApprovalStatus self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApprovalStatus self, StepBasic_ApprovalStatus thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApprovalStatus self, Handle_StepBasic_ApprovalStatus theHandle) -> Handle_StepBasic_ApprovalStatus
        assign(Handle_StepBasic_ApprovalStatus self, StepBasic_ApprovalStatus thePtr) -> Handle_StepBasic_ApprovalStatus
        assign(Handle_StepBasic_ApprovalStatus self, Handle_StepBasic_ApprovalStatus theHandle) -> Handle_StepBasic_ApprovalStatus

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApprovalStatus self) -> StepBasic_ApprovalStatus

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApprovalStatus self) -> StepBasic_ApprovalStatus

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApprovalStatus self) -> StepBasic_ApprovalStatus

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApprovalStatus___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApprovalStatus___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApprovalStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApprovalStatus_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApprovalStatus

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApprovalStatus self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ApprovalStatus self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ApprovalStatus self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApprovalStatus self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalStatus_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApprovalStatus self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApprovalStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApprovalStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApprovalStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApprovalStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApprovalStatus self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApprovalStatus self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApprovalStatus self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApprovalStatus self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalStatus_DecrementRefCounter(self, *args)

Handle_StepBasic_ApprovalStatus_swigregister = _StepBasic.Handle_StepBasic_ApprovalStatus_swigregister
Handle_StepBasic_ApprovalStatus_swigregister(Handle_StepBasic_ApprovalStatus)

def Handle_StepBasic_ApprovalStatus_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApprovalStatus_DownCast(thing)
Handle_StepBasic_ApprovalStatus_DownCast = _StepBasic.Handle_StepBasic_ApprovalStatus_DownCast

class Handle_StepBasic_OrdinalDate(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_OrdinalDate self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_OrdinalDate self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_OrdinalDate self, StepBasic_OrdinalDate thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_OrdinalDate self, Handle_StepBasic_OrdinalDate theHandle) -> Handle_StepBasic_OrdinalDate
        assign(Handle_StepBasic_OrdinalDate self, StepBasic_OrdinalDate thePtr) -> Handle_StepBasic_OrdinalDate
        assign(Handle_StepBasic_OrdinalDate self, Handle_StepBasic_OrdinalDate theHandle) -> Handle_StepBasic_OrdinalDate

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_OrdinalDate self) -> StepBasic_OrdinalDate

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_OrdinalDate self) -> StepBasic_OrdinalDate

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_OrdinalDate self) -> StepBasic_OrdinalDate

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_OrdinalDate___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_OrdinalDate___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_OrdinalDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_OrdinalDate_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_OrdinalDate

    def Init(self, *args):
        """
        Init(Handle_StepBasic_OrdinalDate self, Standard_Integer const aYearComponent, Standard_Integer const aDayComponent)

        :type aYearComponent: int
        :type aDayComponent: int

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_Init(self, *args)


    def SetDayComponent(self, *args):
        """
        SetDayComponent(Handle_StepBasic_OrdinalDate self, Standard_Integer const aDayComponent)

        :type aDayComponent: int

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_SetDayComponent(self, *args)


    def DayComponent(self, *args):
        """
        DayComponent(Handle_StepBasic_OrdinalDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_DayComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_OrdinalDate self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrdinalDate_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrdinalDate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetYearComponent(self, *args):
        """
        SetYearComponent(Handle_StepBasic_OrdinalDate self, Standard_Integer const aYearComponent)

        :type aYearComponent: int

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_SetYearComponent(self, *args)


    def YearComponent(self, *args):
        """
        YearComponent(Handle_StepBasic_OrdinalDate self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_YearComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_OrdinalDate self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_OrdinalDate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_OrdinalDate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_OrdinalDate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_OrdinalDate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_OrdinalDate self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_OrdinalDate self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_OrdinalDate self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_OrdinalDate self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrdinalDate_DecrementRefCounter(self, *args)

Handle_StepBasic_OrdinalDate_swigregister = _StepBasic.Handle_StepBasic_OrdinalDate_swigregister
Handle_StepBasic_OrdinalDate_swigregister(Handle_StepBasic_OrdinalDate)

def Handle_StepBasic_OrdinalDate_DownCast(thing):
    return _StepBasic.Handle_StepBasic_OrdinalDate_DownCast(thing)
Handle_StepBasic_OrdinalDate_DownCast = _StepBasic.Handle_StepBasic_OrdinalDate_DownCast

class Handle_StepBasic_ProductDefinitionWithAssociatedDocuments(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, StepBasic_ProductDefinitionWithAssociatedDocuments thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_StepBasic_ProductDefinitionWithAssociatedDocuments theHandle) -> Handle_StepBasic_ProductDefinitionWithAssociatedDocuments
        assign(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, StepBasic_ProductDefinitionWithAssociatedDocuments thePtr) -> Handle_StepBasic_ProductDefinitionWithAssociatedDocuments
        assign(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_StepBasic_ProductDefinitionWithAssociatedDocuments theHandle) -> Handle_StepBasic_ProductDefinitionWithAssociatedDocuments

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> StepBasic_ProductDefinitionWithAssociatedDocuments

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> StepBasic_ProductDefinitionWithAssociatedDocuments

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> StepBasic_ProductDefinitionWithAssociatedDocuments

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionWithAssociatedDocuments(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionWithAssociatedDocuments

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aFormation, Handle_StepBasic_ProductDefinitionContext aFrame, Handle_StepBasic_HArray1OfDocument aDocIds)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aFrame: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext
        :type aDocIds: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDocument

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_Init(self, *args)


    def DocIds(self, *args):
        """
        DocIds(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Handle_StepBasic_HArray1OfDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDocument

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DocIds(self, *args)


    def SetDocIds(self, *args):
        """
        SetDocIds(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_StepBasic_HArray1OfDocument DocIds)

        :type DocIds: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfDocument

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_SetDocIds(self, *args)


    def NbDocIds(self, *args):
        """
        NbDocIds(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_NbDocIds(self, *args)


    def DocIdsValue(self, *args):
        """
        DocIdsValue(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Standard_Integer const num) -> Handle_StepBasic_Document

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DocIdsValue(self, *args)


    def SetDocIdsValue(self, *args):
        """
        SetDocIdsValue(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Standard_Integer const num, Handle_StepBasic_Document adoc)

        :type num: int
        :type adoc: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_SetDocIdsValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_Description(self, *args)


    def SetFormation(self, *args):
        """
        SetFormation(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_StepBasic_ProductDefinitionFormation aFormation)

        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_SetFormation(self, *args)


    def Formation(self, *args):
        """
        Formation(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Handle_StepBasic_ProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_Formation(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Handle_StepBasic_ProductDefinitionContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_swigregister
Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_swigregister(Handle_StepBasic_ProductDefinitionWithAssociatedDocuments)

def Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DownCast(thing)
Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionWithAssociatedDocuments_DownCast

class StepBasic_Group(Standard.Standard_Transient):
    """Representation of STEP entity Group"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_Group
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_Group(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_Group self) -> StepBasic_Group

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_Group self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Group_Init(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_Group self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Group_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_Group self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Group_SetName(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_Group self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Group_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_Group self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_Group_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(StepBasic_Group self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.StepBasic_Group_HasDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_Group_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_Group_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_Group_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_Group
StepBasic_Group_swigregister = _StepBasic.StepBasic_Group_swigregister
StepBasic_Group_swigregister(StepBasic_Group)

def StepBasic_Group_get_type_name(*args):
    """
    StepBasic_Group_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_Group_get_type_name(*args)

def StepBasic_Group_get_type_descriptor(*args):
    """
    StepBasic_Group_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_Group_get_type_descriptor(*args)

class Handle_StepBasic_ApprovalAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApprovalAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApprovalAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApprovalAssignment self, StepBasic_ApprovalAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApprovalAssignment self, Handle_StepBasic_ApprovalAssignment theHandle) -> Handle_StepBasic_ApprovalAssignment
        assign(Handle_StepBasic_ApprovalAssignment self, StepBasic_ApprovalAssignment thePtr) -> Handle_StepBasic_ApprovalAssignment
        assign(Handle_StepBasic_ApprovalAssignment self, Handle_StepBasic_ApprovalAssignment theHandle) -> Handle_StepBasic_ApprovalAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApprovalAssignment self) -> StepBasic_ApprovalAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApprovalAssignment self) -> StepBasic_ApprovalAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApprovalAssignment self) -> StepBasic_ApprovalAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApprovalAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApprovalAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApprovalAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApprovalAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApprovalAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApprovalAssignment self, Handle_StepBasic_Approval aAssignedApproval)

        :type aAssignedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_Init(self, *args)


    def SetAssignedApproval(self, *args):
        """
        SetAssignedApproval(Handle_StepBasic_ApprovalAssignment self, Handle_StepBasic_Approval aAssignedApproval)

        :type aAssignedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_SetAssignedApproval(self, *args)


    def AssignedApproval(self, *args):
        """
        AssignedApproval(Handle_StepBasic_ApprovalAssignment self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_AssignedApproval(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApprovalAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApprovalAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApprovalAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApprovalAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApprovalAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApprovalAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApprovalAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApprovalAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApprovalAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApprovalAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_ApprovalAssignment_swigregister = _StepBasic.Handle_StepBasic_ApprovalAssignment_swigregister
Handle_StepBasic_ApprovalAssignment_swigregister(Handle_StepBasic_ApprovalAssignment)

def Handle_StepBasic_ApprovalAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApprovalAssignment_DownCast(thing)
Handle_StepBasic_ApprovalAssignment_DownCast = _StepBasic.Handle_StepBasic_ApprovalAssignment_DownCast

class StepBasic_ConversionBasedUnitAndLengthUnit(StepBasic_ConversionBasedUnit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ConversionBasedUnitAndLengthUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ConversionBasedUnitAndLengthUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ConversionBasedUnitAndLengthUnit self) -> StepBasic_ConversionBasedUnitAndLengthUnit

        Returns a ConversionBasedUnitAndLengthUnit


        """
        this = _StepBasic.new_StepBasic_ConversionBasedUnitAndLengthUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_Init(self, *args)


    def SetLengthUnit(self, *args):
        """
        SetLengthUnit(StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_LengthUnit aLengthUnit)

        :type aLengthUnit: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_SetLengthUnit(self, *args)


    def LengthUnit(self, *args):
        """
        LengthUnit(StepBasic_ConversionBasedUnitAndLengthUnit self) -> Handle_StepBasic_LengthUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_LengthUnit(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ConversionBasedUnitAndLengthUnit
StepBasic_ConversionBasedUnitAndLengthUnit_swigregister = _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_swigregister
StepBasic_ConversionBasedUnitAndLengthUnit_swigregister(StepBasic_ConversionBasedUnitAndLengthUnit)

def StepBasic_ConversionBasedUnitAndLengthUnit_get_type_name(*args):
    """
    StepBasic_ConversionBasedUnitAndLengthUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_get_type_name(*args)

def StepBasic_ConversionBasedUnitAndLengthUnit_get_type_descriptor(*args):
    """
    StepBasic_ConversionBasedUnitAndLengthUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ConversionBasedUnitAndLengthUnit_get_type_descriptor(*args)

class NCollection_Array1_Handle_StepBasic_Approval(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_Approval self) -> NCollection_Array1< opencascade::handle< StepBasic_Approval > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_Approval self) -> NCollection_Array1< opencascade::handle< StepBasic_Approval > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_Approval self) -> NCollection_Array1< opencascade::handle< StepBasic_Approval > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_Approval self) -> NCollection_Array1< opencascade::handle< StepBasic_Approval > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_Approval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_Approval self, Handle_StepBasic_Approval theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_Approval self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_Approval self, NCollection_Array1_Handle_StepBasic_Approval theOther) -> NCollection_Array1_Handle_StepBasic_Approval

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_Approval self, NCollection_Array1_Handle_StepBasic_Approval theOther) -> NCollection_Array1_Handle_StepBasic_Approval

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_Approval self, NCollection_Array1_Handle_StepBasic_Approval theOther) -> NCollection_Array1_Handle_StepBasic_Approval
        assign(NCollection_Array1_Handle_StepBasic_Approval self, NCollection_Array1_Handle_StepBasic_Approval theOther) -> NCollection_Array1_Handle_StepBasic_Approval

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_Approval self) -> Handle_StepBasic_Approval

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_Approval self) -> Handle_StepBasic_Approval

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_Approval self, Standard_Integer const theIndex) -> Handle_StepBasic_Approval

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Approval___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_Approval self, Standard_Integer const theIndex, Handle_StepBasic_Approval theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_Approval self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_Approval
NCollection_Array1_Handle_StepBasic_Approval_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_Approval_swigregister
NCollection_Array1_Handle_StepBasic_Approval_swigregister(NCollection_Array1_Handle_StepBasic_Approval)


try:
	StepBasic_Array1OfApproval = NCollection_Array1_Handle_StepBasic_Approval
except NameError:
	pass # does not exist, probably ignored

class Handle_StepBasic_DocumentRepresentationType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentRepresentationType self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentRepresentationType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentRepresentationType self, StepBasic_DocumentRepresentationType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentRepresentationType self, Handle_StepBasic_DocumentRepresentationType theHandle) -> Handle_StepBasic_DocumentRepresentationType
        assign(Handle_StepBasic_DocumentRepresentationType self, StepBasic_DocumentRepresentationType thePtr) -> Handle_StepBasic_DocumentRepresentationType
        assign(Handle_StepBasic_DocumentRepresentationType self, Handle_StepBasic_DocumentRepresentationType theHandle) -> Handle_StepBasic_DocumentRepresentationType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentRepresentationType self) -> StepBasic_DocumentRepresentationType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentRepresentationType self) -> StepBasic_DocumentRepresentationType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentRepresentationType self) -> StepBasic_DocumentRepresentationType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentRepresentationType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentRepresentationType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentRepresentationType_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentRepresentationType

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentRepresentationType self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_Document aRepresentedDocument)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DocumentRepresentationType self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DocumentRepresentationType self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_SetName(self, *args)


    def RepresentedDocument(self, *args):
        """
        RepresentedDocument(Handle_StepBasic_DocumentRepresentationType self) -> Handle_StepBasic_Document

        Returns field RepresentedDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_RepresentedDocument(self, *args)


    def SetRepresentedDocument(self, *args):
        """
        SetRepresentedDocument(Handle_StepBasic_DocumentRepresentationType self, Handle_StepBasic_Document RepresentedDocument)

        Set field RepresentedDocument

        :type RepresentedDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_SetRepresentedDocument(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentRepresentationType self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentRepresentationType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentRepresentationType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentRepresentationType self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentRepresentationType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentRepresentationType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentRepresentationType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentRepresentationType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentRepresentationType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentRepresentationType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentRepresentationType self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentRepresentationType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentRepresentationType_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentRepresentationType_swigregister = _StepBasic.Handle_StepBasic_DocumentRepresentationType_swigregister
Handle_StepBasic_DocumentRepresentationType_swigregister(Handle_StepBasic_DocumentRepresentationType)

def Handle_StepBasic_DocumentRepresentationType_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentRepresentationType_DownCast(thing)
Handle_StepBasic_DocumentRepresentationType_DownCast = _StepBasic.Handle_StepBasic_DocumentRepresentationType_DownCast

class Handle_StepBasic_ApplicationContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApplicationContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApplicationContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApplicationContext self, StepBasic_ApplicationContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApplicationContext self, Handle_StepBasic_ApplicationContext theHandle) -> Handle_StepBasic_ApplicationContext
        assign(Handle_StepBasic_ApplicationContext self, StepBasic_ApplicationContext thePtr) -> Handle_StepBasic_ApplicationContext
        assign(Handle_StepBasic_ApplicationContext self, Handle_StepBasic_ApplicationContext theHandle) -> Handle_StepBasic_ApplicationContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApplicationContext self) -> StepBasic_ApplicationContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApplicationContext self) -> StepBasic_ApplicationContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApplicationContext self) -> StepBasic_ApplicationContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApplicationContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApplicationContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApplicationContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApplicationContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApplicationContext

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApplicationContext self, Handle_TCollection_HAsciiString aApplication)

        :type aApplication: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_Init(self, *args)


    def SetApplication(self, *args):
        """
        SetApplication(Handle_StepBasic_ApplicationContext self, Handle_TCollection_HAsciiString aApplication)

        :type aApplication: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_SetApplication(self, *args)


    def Application(self, *args):
        """
        Application(Handle_StepBasic_ApplicationContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_Application(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApplicationContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApplicationContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApplicationContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApplicationContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApplicationContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApplicationContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApplicationContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApplicationContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApplicationContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApplicationContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApplicationContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApplicationContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationContext_DecrementRefCounter(self, *args)

Handle_StepBasic_ApplicationContext_swigregister = _StepBasic.Handle_StepBasic_ApplicationContext_swigregister
Handle_StepBasic_ApplicationContext_swigregister(Handle_StepBasic_ApplicationContext)

def Handle_StepBasic_ApplicationContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApplicationContext_DownCast(thing)
Handle_StepBasic_ApplicationContext_DownCast = _StepBasic.Handle_StepBasic_ApplicationContext_DownCast

class Handle_StepBasic_ActionAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ActionAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ActionAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ActionAssignment self, StepBasic_ActionAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ActionAssignment self, Handle_StepBasic_ActionAssignment theHandle) -> Handle_StepBasic_ActionAssignment
        assign(Handle_StepBasic_ActionAssignment self, StepBasic_ActionAssignment thePtr) -> Handle_StepBasic_ActionAssignment
        assign(Handle_StepBasic_ActionAssignment self, Handle_StepBasic_ActionAssignment theHandle) -> Handle_StepBasic_ActionAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ActionAssignment self) -> StepBasic_ActionAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ActionAssignment self) -> StepBasic_ActionAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ActionAssignment self) -> StepBasic_ActionAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ActionAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ActionAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ActionAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ActionAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ActionAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ActionAssignment self, Handle_StepBasic_Action aAssignedAction)

        Initialize all fields (own and inherited)

        :type aAssignedAction: OCC.wrapper.StepBasic.Handle_StepBasic_Action

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_Init(self, *args)


    def AssignedAction(self, *args):
        """
        AssignedAction(Handle_StepBasic_ActionAssignment self) -> Handle_StepBasic_Action

        Returns field AssignedAction

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Action

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_AssignedAction(self, *args)


    def SetAssignedAction(self, *args):
        """
        SetAssignedAction(Handle_StepBasic_ActionAssignment self, Handle_StepBasic_Action AssignedAction)

        Set field AssignedAction

        :type AssignedAction: OCC.wrapper.StepBasic.Handle_StepBasic_Action

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_SetAssignedAction(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ActionAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ActionAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ActionAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ActionAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ActionAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ActionAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ActionAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ActionAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ActionAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ActionAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ActionAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ActionAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_ActionAssignment_swigregister = _StepBasic.Handle_StepBasic_ActionAssignment_swigregister
Handle_StepBasic_ActionAssignment_swigregister(Handle_StepBasic_ActionAssignment)

def Handle_StepBasic_ActionAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ActionAssignment_DownCast(thing)
Handle_StepBasic_ActionAssignment_DownCast = _StepBasic.Handle_StepBasic_ActionAssignment_DownCast

class Handle_StepBasic_OrganizationRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_OrganizationRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_OrganizationRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_OrganizationRole self, StepBasic_OrganizationRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_OrganizationRole self, Handle_StepBasic_OrganizationRole theHandle) -> Handle_StepBasic_OrganizationRole
        assign(Handle_StepBasic_OrganizationRole self, StepBasic_OrganizationRole thePtr) -> Handle_StepBasic_OrganizationRole
        assign(Handle_StepBasic_OrganizationRole self, Handle_StepBasic_OrganizationRole theHandle) -> Handle_StepBasic_OrganizationRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_OrganizationRole self) -> StepBasic_OrganizationRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_OrganizationRole self) -> StepBasic_OrganizationRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_OrganizationRole self) -> StepBasic_OrganizationRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_OrganizationRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_OrganizationRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_OrganizationRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_OrganizationRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_OrganizationRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_OrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_OrganizationRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_OrganizationRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_OrganizationRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrganizationRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrganizationRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_OrganizationRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_OrganizationRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_OrganizationRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_OrganizationRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_OrganizationRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_OrganizationRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_OrganizationRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_OrganizationRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_OrganizationRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationRole_DecrementRefCounter(self, *args)

Handle_StepBasic_OrganizationRole_swigregister = _StepBasic.Handle_StepBasic_OrganizationRole_swigregister
Handle_StepBasic_OrganizationRole_swigregister(Handle_StepBasic_OrganizationRole)

def Handle_StepBasic_OrganizationRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_OrganizationRole_DownCast(thing)
Handle_StepBasic_OrganizationRole_DownCast = _StepBasic.Handle_StepBasic_OrganizationRole_DownCast

class Handle_StepBasic_ConversionBasedUnitAndRatioUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, StepBasic_ConversionBasedUnitAndRatioUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_ConversionBasedUnitAndRatioUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndRatioUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, StepBasic_ConversionBasedUnitAndRatioUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndRatioUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_ConversionBasedUnitAndRatioUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndRatioUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> StepBasic_ConversionBasedUnitAndRatioUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> StepBasic_ConversionBasedUnitAndRatioUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> StepBasic_ConversionBasedUnitAndRatioUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndRatioUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndRatioUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_Init(self, *args)


    def SetRatioUnit(self, *args):
        """
        SetRatioUnit(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_RatioUnit aRatioUnit)

        :type aRatioUnit: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_SetRatioUnit(self, *args)


    def RatioUnit(self, *args):
        """
        RatioUnit(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Handle_StepBasic_RatioUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_RatioUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndRatioUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndRatioUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndRatioUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndRatioUnit)

def Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndRatioUnit_DownCast

class Handle_StepBasic_HArray1OfProductContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfProductContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfProductContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfProductContext self, StepBasic_HArray1OfProductContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfProductContext self, Handle_StepBasic_HArray1OfProductContext theHandle) -> Handle_StepBasic_HArray1OfProductContext
        assign(Handle_StepBasic_HArray1OfProductContext self, StepBasic_HArray1OfProductContext thePtr) -> Handle_StepBasic_HArray1OfProductContext
        assign(Handle_StepBasic_HArray1OfProductContext self, Handle_StepBasic_HArray1OfProductContext theHandle) -> Handle_StepBasic_HArray1OfProductContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfProductContext self) -> StepBasic_HArray1OfProductContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfProductContext self) -> StepBasic_HArray1OfProductContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfProductContext self) -> StepBasic_HArray1OfProductContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfProductContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfProductContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfProductContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfProductContext

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductContext

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProductContext_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfProductContext self) -> NCollection_Array1_Handle_StepBasic_ProductContext

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProductContext

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfProductContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProductContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProductContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfProductContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfProductContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfProductContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfProductContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfProductContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfProductContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfProductContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfProductContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfProductContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProductContext_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfProductContext_swigregister = _StepBasic.Handle_StepBasic_HArray1OfProductContext_swigregister
Handle_StepBasic_HArray1OfProductContext_swigregister(Handle_StepBasic_HArray1OfProductContext)

def Handle_StepBasic_HArray1OfProductContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfProductContext_DownCast(thing)
Handle_StepBasic_HArray1OfProductContext_DownCast = _StepBasic.Handle_StepBasic_HArray1OfProductContext_DownCast

class Handle_StepBasic_DateAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DateAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DateAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DateAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DateAssignment self, StepBasic_DateAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DateAssignment self, Handle_StepBasic_DateAssignment theHandle) -> Handle_StepBasic_DateAssignment
        assign(Handle_StepBasic_DateAssignment self, StepBasic_DateAssignment thePtr) -> Handle_StepBasic_DateAssignment
        assign(Handle_StepBasic_DateAssignment self, Handle_StepBasic_DateAssignment theHandle) -> Handle_StepBasic_DateAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DateAssignment self) -> StepBasic_DateAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DateAssignment self) -> StepBasic_DateAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DateAssignment self) -> StepBasic_DateAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DateAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DateAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DateAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DateAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DateAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DateAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DateAssignment self, Handle_StepBasic_Date aAssignedDate, Handle_StepBasic_DateRole aRole)

        :type aAssignedDate: OCC.wrapper.StepBasic.Handle_StepBasic_Date
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateRole

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_Init(self, *args)


    def SetAssignedDate(self, *args):
        """
        SetAssignedDate(Handle_StepBasic_DateAssignment self, Handle_StepBasic_Date aAssignedDate)

        :type aAssignedDate: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_SetAssignedDate(self, *args)


    def AssignedDate(self, *args):
        """
        AssignedDate(Handle_StepBasic_DateAssignment self) -> Handle_StepBasic_Date

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_AssignedDate(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_DateAssignment self, Handle_StepBasic_DateRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_DateRole

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_DateAssignment self) -> Handle_StepBasic_DateRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateRole

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_Role(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DateAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DateAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DateAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DateAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DateAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DateAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DateAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DateAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DateAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DateAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DateAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DateAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_DateAssignment_swigregister = _StepBasic.Handle_StepBasic_DateAssignment_swigregister
Handle_StepBasic_DateAssignment_swigregister(Handle_StepBasic_DateAssignment)

def Handle_StepBasic_DateAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DateAssignment_DownCast(thing)
Handle_StepBasic_DateAssignment_DownCast = _StepBasic.Handle_StepBasic_DateAssignment_DownCast

class Handle_StepBasic_SolidAngleUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SolidAngleUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SolidAngleUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SolidAngleUnit self, StepBasic_SolidAngleUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SolidAngleUnit self, Handle_StepBasic_SolidAngleUnit theHandle) -> Handle_StepBasic_SolidAngleUnit
        assign(Handle_StepBasic_SolidAngleUnit self, StepBasic_SolidAngleUnit thePtr) -> Handle_StepBasic_SolidAngleUnit
        assign(Handle_StepBasic_SolidAngleUnit self, Handle_StepBasic_SolidAngleUnit theHandle) -> Handle_StepBasic_SolidAngleUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SolidAngleUnit self) -> StepBasic_SolidAngleUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SolidAngleUnit self) -> StepBasic_SolidAngleUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SolidAngleUnit self) -> StepBasic_SolidAngleUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SolidAngleUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SolidAngleUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SolidAngleUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SolidAngleUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SolidAngleUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SolidAngleUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SolidAngleUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SolidAngleUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_SolidAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SolidAngleUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SolidAngleUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SolidAngleUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SolidAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SolidAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SolidAngleUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SolidAngleUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SolidAngleUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SolidAngleUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SolidAngleUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SolidAngleUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SolidAngleUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SolidAngleUnit_swigregister = _StepBasic.Handle_StepBasic_SolidAngleUnit_swigregister
Handle_StepBasic_SolidAngleUnit_swigregister(Handle_StepBasic_SolidAngleUnit)

def Handle_StepBasic_SolidAngleUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SolidAngleUnit_DownCast(thing)
Handle_StepBasic_SolidAngleUnit_DownCast = _StepBasic.Handle_StepBasic_SolidAngleUnit_DownCast

class Handle_StepBasic_DateTimeRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DateTimeRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DateTimeRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DateTimeRole self, StepBasic_DateTimeRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DateTimeRole self, Handle_StepBasic_DateTimeRole theHandle) -> Handle_StepBasic_DateTimeRole
        assign(Handle_StepBasic_DateTimeRole self, StepBasic_DateTimeRole thePtr) -> Handle_StepBasic_DateTimeRole
        assign(Handle_StepBasic_DateTimeRole self, Handle_StepBasic_DateTimeRole theHandle) -> Handle_StepBasic_DateTimeRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DateTimeRole self) -> StepBasic_DateTimeRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DateTimeRole self) -> StepBasic_DateTimeRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DateTimeRole self) -> StepBasic_DateTimeRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DateTimeRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DateTimeRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DateTimeRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DateTimeRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DateTimeRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DateTimeRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DateTimeRole self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DateTimeRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DateTimeRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateTimeRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateTimeRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DateTimeRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DateTimeRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DateTimeRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DateTimeRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DateTimeRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DateTimeRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DateTimeRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DateTimeRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DateTimeRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateTimeRole_DecrementRefCounter(self, *args)

Handle_StepBasic_DateTimeRole_swigregister = _StepBasic.Handle_StepBasic_DateTimeRole_swigregister
Handle_StepBasic_DateTimeRole_swigregister(Handle_StepBasic_DateTimeRole)

def Handle_StepBasic_DateTimeRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DateTimeRole_DownCast(thing)
Handle_StepBasic_DateTimeRole_DownCast = _StepBasic.Handle_StepBasic_DateTimeRole_DownCast

class Handle_StepBasic_PersonAndOrganizationAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PersonAndOrganizationAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PersonAndOrganizationAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PersonAndOrganizationAssignment self, StepBasic_PersonAndOrganizationAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganizationAssignment theHandle) -> Handle_StepBasic_PersonAndOrganizationAssignment
        assign(Handle_StepBasic_PersonAndOrganizationAssignment self, StepBasic_PersonAndOrganizationAssignment thePtr) -> Handle_StepBasic_PersonAndOrganizationAssignment
        assign(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganizationAssignment theHandle) -> Handle_StepBasic_PersonAndOrganizationAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PersonAndOrganizationAssignment self) -> StepBasic_PersonAndOrganizationAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PersonAndOrganizationAssignment self) -> StepBasic_PersonAndOrganizationAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PersonAndOrganizationAssignment self) -> StepBasic_PersonAndOrganizationAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PersonAndOrganizationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PersonAndOrganizationAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganization aAssignedPersonAndOrganization, Handle_StepBasic_PersonAndOrganizationRole aRole)

        :type aAssignedPersonAndOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_Init(self, *args)


    def SetAssignedPersonAndOrganization(self, *args):
        """
        SetAssignedPersonAndOrganization(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganization aAssignedPersonAndOrganization)

        :type aAssignedPersonAndOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_SetAssignedPersonAndOrganization(self, *args)


    def AssignedPersonAndOrganization(self, *args):
        """
        AssignedPersonAndOrganization(Handle_StepBasic_PersonAndOrganizationAssignment self) -> Handle_StepBasic_PersonAndOrganization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_AssignedPersonAndOrganization(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_StepBasic_PersonAndOrganizationRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_PersonAndOrganizationAssignment self) -> Handle_StepBasic_PersonAndOrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_Role(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PersonAndOrganizationAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PersonAndOrganizationAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PersonAndOrganizationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PersonAndOrganizationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PersonAndOrganizationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PersonAndOrganizationAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PersonAndOrganizationAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PersonAndOrganizationAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PersonAndOrganizationAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_PersonAndOrganizationAssignment_swigregister = _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_swigregister
Handle_StepBasic_PersonAndOrganizationAssignment_swigregister(Handle_StepBasic_PersonAndOrganizationAssignment)

def Handle_StepBasic_PersonAndOrganizationAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_DownCast(thing)
Handle_StepBasic_PersonAndOrganizationAssignment_DownCast = _StepBasic.Handle_StepBasic_PersonAndOrganizationAssignment_DownCast

class Handle_StepBasic_Action(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Action self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Action_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Action self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Action_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Action self, StepBasic_Action thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Action_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Action self, Handle_StepBasic_Action theHandle) -> Handle_StepBasic_Action
        assign(Handle_StepBasic_Action self, StepBasic_Action thePtr) -> Handle_StepBasic_Action
        assign(Handle_StepBasic_Action self, Handle_StepBasic_Action theHandle) -> Handle_StepBasic_Action

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Action_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Action self) -> StepBasic_Action

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Action_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Action self) -> StepBasic_Action

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Action___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Action self) -> StepBasic_Action

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Action___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Action___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Action___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Action(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Action_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Action

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Action self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ActionMethod aChosenMethod)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aChosenMethod: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.Handle_StepBasic_Action_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Action self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Action_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Action self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Action_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_Action self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Action_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_Action self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Action_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_Action self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Action_HasDescription(self, *args)


    def ChosenMethod(self, *args):
        """
        ChosenMethod(Handle_StepBasic_Action self) -> Handle_StepBasic_ActionMethod

        Returns field ChosenMethod

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.Handle_StepBasic_Action_ChosenMethod(self, *args)


    def SetChosenMethod(self, *args):
        """
        SetChosenMethod(Handle_StepBasic_Action self, Handle_StepBasic_ActionMethod ChosenMethod)

        Set field ChosenMethod

        :type ChosenMethod: OCC.wrapper.StepBasic.Handle_StepBasic_ActionMethod

        """
        return _StepBasic.Handle_StepBasic_Action_SetChosenMethod(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Action self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Action_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Action_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Action_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Action self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Action_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Action self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Action self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Action_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Action self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Action self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Action_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Action self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Action_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Action self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Action_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Action self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Action_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Action self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Action_DecrementRefCounter(self, *args)

Handle_StepBasic_Action_swigregister = _StepBasic.Handle_StepBasic_Action_swigregister
Handle_StepBasic_Action_swigregister(Handle_StepBasic_Action)

def Handle_StepBasic_Action_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Action_DownCast(thing)
Handle_StepBasic_Action_DownCast = _StepBasic.Handle_StepBasic_Action_DownCast

class Handle_StepBasic_PersonalAddress(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PersonalAddress self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PersonalAddress self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PersonalAddress self, StepBasic_PersonalAddress thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PersonalAddress self, Handle_StepBasic_PersonalAddress theHandle) -> Handle_StepBasic_PersonalAddress
        assign(Handle_StepBasic_PersonalAddress self, StepBasic_PersonalAddress thePtr) -> Handle_StepBasic_PersonalAddress
        assign(Handle_StepBasic_PersonalAddress self, Handle_StepBasic_PersonalAddress theHandle) -> Handle_StepBasic_PersonalAddress

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PersonalAddress self) -> StepBasic_PersonalAddress

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PersonalAddress self) -> StepBasic_PersonalAddress

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PersonalAddress self) -> StepBasic_PersonalAddress

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PersonalAddress___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PersonalAddress___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PersonalAddress(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PersonalAddress_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PersonalAddress

    def Init(self, *args):
        """
        Init(Handle_StepBasic_PersonalAddress self, Standard_Boolean const hasAinternalLocation, Handle_TCollection_HAsciiString aInternalLocation, Standard_Boolean const hasAstreetNumber, Handle_TCollection_HAsciiString aStreetNumber, Standard_Boolean const hasAstreet, Handle_TCollection_HAsciiString aStreet, Standard_Boolean const hasApostalBox, Handle_TCollection_HAsciiString aPostalBox, Standard_Boolean const hasAtown, Handle_TCollection_HAsciiString aTown, Standard_Boolean const hasAregion, Handle_TCollection_HAsciiString aRegion, Standard_Boolean const hasApostalCode, Handle_TCollection_HAsciiString aPostalCode, Standard_Boolean const hasAcountry, Handle_TCollection_HAsciiString aCountry, Standard_Boolean const hasAfacsimileNumber, Handle_TCollection_HAsciiString aFacsimileNumber, Standard_Boolean const hasAtelephoneNumber, Handle_TCollection_HAsciiString aTelephoneNumber, Standard_Boolean const hasAelectronicMailAddress, Handle_TCollection_HAsciiString aElectronicMailAddress, Standard_Boolean const hasAtelexNumber, Handle_TCollection_HAsciiString aTelexNumber, Handle_StepBasic_HArray1OfPerson aPeople, Handle_TCollection_HAsciiString aDescription)

        :type hasAinternalLocation: bool
        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreetNumber: bool
        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreet: bool
        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalBox: bool
        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtown: bool
        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAregion: bool
        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalCode: bool
        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAcountry: bool
        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfacsimileNumber: bool
        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelephoneNumber: bool
        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAelectronicMailAddress: bool
        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelexNumber: bool
        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPeople: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfPerson
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Init(self, *args)


    def SetPeople(self, *args):
        """
        SetPeople(Handle_StepBasic_PersonalAddress self, Handle_StepBasic_HArray1OfPerson aPeople)

        :type aPeople: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfPerson

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetPeople(self, *args)


    def People(self, *args):
        """
        People(Handle_StepBasic_PersonalAddress self) -> Handle_StepBasic_HArray1OfPerson

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfPerson

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_People(self, *args)


    def PeopleValue(self, *args):
        """
        PeopleValue(Handle_StepBasic_PersonalAddress self, Standard_Integer const num) -> Handle_StepBasic_Person

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_PeopleValue(self, *args)


    def NbPeople(self, *args):
        """
        NbPeople(Handle_StepBasic_PersonalAddress self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_NbPeople(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Description(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PersonalAddress self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonalAddress_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonalAddress_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInternalLocation(self, *args):
        """
        SetInternalLocation(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aInternalLocation)

        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetInternalLocation(self, *args)


    def UnSetInternalLocation(self, *args):
        """UnSetInternalLocation(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetInternalLocation(self, *args)


    def InternalLocation(self, *args):
        """
        InternalLocation(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_InternalLocation(self, *args)


    def HasInternalLocation(self, *args):
        """
        HasInternalLocation(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasInternalLocation(self, *args)


    def SetStreetNumber(self, *args):
        """
        SetStreetNumber(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aStreetNumber)

        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetStreetNumber(self, *args)


    def UnSetStreetNumber(self, *args):
        """UnSetStreetNumber(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetStreetNumber(self, *args)


    def StreetNumber(self, *args):
        """
        StreetNumber(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_StreetNumber(self, *args)


    def HasStreetNumber(self, *args):
        """
        HasStreetNumber(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasStreetNumber(self, *args)


    def SetStreet(self, *args):
        """
        SetStreet(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aStreet)

        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetStreet(self, *args)


    def UnSetStreet(self, *args):
        """UnSetStreet(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetStreet(self, *args)


    def Street(self, *args):
        """
        Street(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Street(self, *args)


    def HasStreet(self, *args):
        """
        HasStreet(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasStreet(self, *args)


    def SetPostalBox(self, *args):
        """
        SetPostalBox(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aPostalBox)

        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetPostalBox(self, *args)


    def UnSetPostalBox(self, *args):
        """UnSetPostalBox(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetPostalBox(self, *args)


    def PostalBox(self, *args):
        """
        PostalBox(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_PostalBox(self, *args)


    def HasPostalBox(self, *args):
        """
        HasPostalBox(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasPostalBox(self, *args)


    def SetTown(self, *args):
        """
        SetTown(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aTown)

        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetTown(self, *args)


    def UnSetTown(self, *args):
        """UnSetTown(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetTown(self, *args)


    def Town(self, *args):
        """
        Town(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Town(self, *args)


    def HasTown(self, *args):
        """
        HasTown(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasTown(self, *args)


    def SetRegion(self, *args):
        """
        SetRegion(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aRegion)

        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetRegion(self, *args)


    def UnSetRegion(self, *args):
        """UnSetRegion(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetRegion(self, *args)


    def Region(self, *args):
        """
        Region(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Region(self, *args)


    def HasRegion(self, *args):
        """
        HasRegion(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasRegion(self, *args)


    def SetPostalCode(self, *args):
        """
        SetPostalCode(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aPostalCode)

        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetPostalCode(self, *args)


    def UnSetPostalCode(self, *args):
        """UnSetPostalCode(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetPostalCode(self, *args)


    def PostalCode(self, *args):
        """
        PostalCode(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_PostalCode(self, *args)


    def HasPostalCode(self, *args):
        """
        HasPostalCode(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasPostalCode(self, *args)


    def SetCountry(self, *args):
        """
        SetCountry(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aCountry)

        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetCountry(self, *args)


    def UnSetCountry(self, *args):
        """UnSetCountry(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetCountry(self, *args)


    def Country(self, *args):
        """
        Country(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Country(self, *args)


    def HasCountry(self, *args):
        """
        HasCountry(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasCountry(self, *args)


    def SetFacsimileNumber(self, *args):
        """
        SetFacsimileNumber(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aFacsimileNumber)

        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetFacsimileNumber(self, *args)


    def UnSetFacsimileNumber(self, *args):
        """UnSetFacsimileNumber(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetFacsimileNumber(self, *args)


    def FacsimileNumber(self, *args):
        """
        FacsimileNumber(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_FacsimileNumber(self, *args)


    def HasFacsimileNumber(self, *args):
        """
        HasFacsimileNumber(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasFacsimileNumber(self, *args)


    def SetTelephoneNumber(self, *args):
        """
        SetTelephoneNumber(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aTelephoneNumber)

        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetTelephoneNumber(self, *args)


    def UnSetTelephoneNumber(self, *args):
        """UnSetTelephoneNumber(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetTelephoneNumber(self, *args)


    def TelephoneNumber(self, *args):
        """
        TelephoneNumber(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_TelephoneNumber(self, *args)


    def HasTelephoneNumber(self, *args):
        """
        HasTelephoneNumber(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasTelephoneNumber(self, *args)


    def SetElectronicMailAddress(self, *args):
        """
        SetElectronicMailAddress(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aElectronicMailAddress)

        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetElectronicMailAddress(self, *args)


    def UnSetElectronicMailAddress(self, *args):
        """UnSetElectronicMailAddress(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetElectronicMailAddress(self, *args)


    def ElectronicMailAddress(self, *args):
        """
        ElectronicMailAddress(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_ElectronicMailAddress(self, *args)


    def HasElectronicMailAddress(self, *args):
        """
        HasElectronicMailAddress(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasElectronicMailAddress(self, *args)


    def SetTelexNumber(self, *args):
        """
        SetTelexNumber(Handle_StepBasic_PersonalAddress self, Handle_TCollection_HAsciiString aTelexNumber)

        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_SetTelexNumber(self, *args)


    def UnSetTelexNumber(self, *args):
        """UnSetTelexNumber(Handle_StepBasic_PersonalAddress self)"""
        return _StepBasic.Handle_StepBasic_PersonalAddress_UnSetTelexNumber(self, *args)


    def TelexNumber(self, *args):
        """
        TelexNumber(Handle_StepBasic_PersonalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_TelexNumber(self, *args)


    def HasTelexNumber(self, *args):
        """
        HasTelexNumber(Handle_StepBasic_PersonalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_HasTelexNumber(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PersonalAddress self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PersonalAddress self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PersonalAddress self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PersonalAddress self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PersonalAddress self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PersonalAddress self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PersonalAddress self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PersonalAddress self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PersonalAddress self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonalAddress_DecrementRefCounter(self, *args)

Handle_StepBasic_PersonalAddress_swigregister = _StepBasic.Handle_StepBasic_PersonalAddress_swigregister
Handle_StepBasic_PersonalAddress_swigregister(Handle_StepBasic_PersonalAddress)

def Handle_StepBasic_PersonalAddress_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PersonalAddress_DownCast(thing)
Handle_StepBasic_PersonalAddress_DownCast = _StepBasic.Handle_StepBasic_PersonalAddress_DownCast

class Handle_StepBasic_SecurityClassificationAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SecurityClassificationAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SecurityClassificationAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SecurityClassificationAssignment self, StepBasic_SecurityClassificationAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SecurityClassificationAssignment self, Handle_StepBasic_SecurityClassificationAssignment theHandle) -> Handle_StepBasic_SecurityClassificationAssignment
        assign(Handle_StepBasic_SecurityClassificationAssignment self, StepBasic_SecurityClassificationAssignment thePtr) -> Handle_StepBasic_SecurityClassificationAssignment
        assign(Handle_StepBasic_SecurityClassificationAssignment self, Handle_StepBasic_SecurityClassificationAssignment theHandle) -> Handle_StepBasic_SecurityClassificationAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SecurityClassificationAssignment self) -> StepBasic_SecurityClassificationAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SecurityClassificationAssignment self) -> StepBasic_SecurityClassificationAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SecurityClassificationAssignment self) -> StepBasic_SecurityClassificationAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SecurityClassificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SecurityClassificationAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SecurityClassificationAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SecurityClassificationAssignment self, Handle_StepBasic_SecurityClassification aAssignedSecurityClassification)

        :type aAssignedSecurityClassification: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassification

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_Init(self, *args)


    def SetAssignedSecurityClassification(self, *args):
        """
        SetAssignedSecurityClassification(Handle_StepBasic_SecurityClassificationAssignment self, Handle_StepBasic_SecurityClassification aAssignedSecurityClassification)

        :type aAssignedSecurityClassification: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassification

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_SetAssignedSecurityClassification(self, *args)


    def AssignedSecurityClassification(self, *args):
        """
        AssignedSecurityClassification(Handle_StepBasic_SecurityClassificationAssignment self) -> Handle_StepBasic_SecurityClassification

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassification

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_AssignedSecurityClassification(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SecurityClassificationAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SecurityClassificationAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SecurityClassificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SecurityClassificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SecurityClassificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SecurityClassificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SecurityClassificationAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SecurityClassificationAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SecurityClassificationAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SecurityClassificationAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_SecurityClassificationAssignment_swigregister = _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_swigregister
Handle_StepBasic_SecurityClassificationAssignment_swigregister(Handle_StepBasic_SecurityClassificationAssignment)

def Handle_StepBasic_SecurityClassificationAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_DownCast(thing)
Handle_StepBasic_SecurityClassificationAssignment_DownCast = _StepBasic.Handle_StepBasic_SecurityClassificationAssignment_DownCast

class Handle_StepBasic_Group(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Group self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Group_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Group self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Group_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Group self, StepBasic_Group thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Group_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Group self, Handle_StepBasic_Group theHandle) -> Handle_StepBasic_Group
        assign(Handle_StepBasic_Group self, StepBasic_Group thePtr) -> Handle_StepBasic_Group
        assign(Handle_StepBasic_Group self, Handle_StepBasic_Group theHandle) -> Handle_StepBasic_Group

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Group_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Group self) -> StepBasic_Group

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Group_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Group self) -> StepBasic_Group

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Group___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Group self) -> StepBasic_Group

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Group___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Group___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Group___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Group_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Group

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Group self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Group_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Group self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Group_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Group self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Group_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_Group self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Group_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_Group self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Group_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_Group self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Group_HasDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Group self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Group_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Group_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Group_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Group self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Group_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Group self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Group self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Group_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Group self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Group self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Group_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Group self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Group_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Group self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Group_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Group self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Group_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Group self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Group_DecrementRefCounter(self, *args)

Handle_StepBasic_Group_swigregister = _StepBasic.Handle_StepBasic_Group_swigregister
Handle_StepBasic_Group_swigregister(Handle_StepBasic_Group)

def Handle_StepBasic_Group_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Group_DownCast(thing)
Handle_StepBasic_Group_DownCast = _StepBasic.Handle_StepBasic_Group_DownCast

class Handle_StepBasic_DateAndTime(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DateAndTime self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DateAndTime_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DateAndTime self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DateAndTime self, StepBasic_DateAndTime thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DateAndTime self, Handle_StepBasic_DateAndTime theHandle) -> Handle_StepBasic_DateAndTime
        assign(Handle_StepBasic_DateAndTime self, StepBasic_DateAndTime thePtr) -> Handle_StepBasic_DateAndTime
        assign(Handle_StepBasic_DateAndTime self, Handle_StepBasic_DateAndTime theHandle) -> Handle_StepBasic_DateAndTime

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DateAndTime self) -> StepBasic_DateAndTime

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DateAndTime self) -> StepBasic_DateAndTime

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DateAndTime___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DateAndTime self) -> StepBasic_DateAndTime

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DateAndTime___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DateAndTime___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DateAndTime___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DateAndTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DateAndTime_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DateAndTime

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DateAndTime self, Handle_StepBasic_Date aDateComponent, Handle_StepBasic_LocalTime aTimeComponent)

        :type aDateComponent: OCC.wrapper.StepBasic.Handle_StepBasic_Date
        :type aTimeComponent: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_Init(self, *args)


    def SetDateComponent(self, *args):
        """
        SetDateComponent(Handle_StepBasic_DateAndTime self, Handle_StepBasic_Date aDateComponent)

        :type aDateComponent: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_SetDateComponent(self, *args)


    def DateComponent(self, *args):
        """
        DateComponent(Handle_StepBasic_DateAndTime self) -> Handle_StepBasic_Date

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Date

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_DateComponent(self, *args)


    def SetTimeComponent(self, *args):
        """
        SetTimeComponent(Handle_StepBasic_DateAndTime self, Handle_StepBasic_LocalTime aTimeComponent)

        :type aTimeComponent: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_SetTimeComponent(self, *args)


    def TimeComponent(self, *args):
        """
        TimeComponent(Handle_StepBasic_DateAndTime self) -> Handle_StepBasic_LocalTime

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LocalTime

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_TimeComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DateAndTime self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateAndTime_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DateAndTime_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DateAndTime self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DateAndTime_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DateAndTime self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DateAndTime self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DateAndTime self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DateAndTime self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DateAndTime self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DateAndTime self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DateAndTime self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DateAndTime_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DateAndTime self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DateAndTime_DecrementRefCounter(self, *args)

Handle_StepBasic_DateAndTime_swigregister = _StepBasic.Handle_StepBasic_DateAndTime_swigregister
Handle_StepBasic_DateAndTime_swigregister(Handle_StepBasic_DateAndTime)

def Handle_StepBasic_DateAndTime_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DateAndTime_DownCast(thing)
Handle_StepBasic_DateAndTime_DownCast = _StepBasic.Handle_StepBasic_DateAndTime_DownCast

class Handle_StepBasic_HArray1OfOrganization(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfOrganization self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfOrganization self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfOrganization self, StepBasic_HArray1OfOrganization thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfOrganization self, Handle_StepBasic_HArray1OfOrganization theHandle) -> Handle_StepBasic_HArray1OfOrganization
        assign(Handle_StepBasic_HArray1OfOrganization self, StepBasic_HArray1OfOrganization thePtr) -> Handle_StepBasic_HArray1OfOrganization
        assign(Handle_StepBasic_HArray1OfOrganization self, Handle_StepBasic_HArray1OfOrganization theHandle) -> Handle_StepBasic_HArray1OfOrganization

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfOrganization self) -> StepBasic_HArray1OfOrganization

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfOrganization self) -> StepBasic_HArray1OfOrganization

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfOrganization self) -> StepBasic_HArray1OfOrganization

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfOrganization___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfOrganization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfOrganization_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfOrganization

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfOrganization

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfOrganization_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfOrganization self) -> NCollection_Array1_Handle_StepBasic_Organization

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfOrganization

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfOrganization self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfOrganization_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfOrganization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfOrganization self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfOrganization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfOrganization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfOrganization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfOrganization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfOrganization self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfOrganization self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfOrganization self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfOrganization self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfOrganization_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfOrganization_swigregister = _StepBasic.Handle_StepBasic_HArray1OfOrganization_swigregister
Handle_StepBasic_HArray1OfOrganization_swigregister(Handle_StepBasic_HArray1OfOrganization)

def Handle_StepBasic_HArray1OfOrganization_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfOrganization_DownCast(thing)
Handle_StepBasic_HArray1OfOrganization_DownCast = _StepBasic.Handle_StepBasic_HArray1OfOrganization_DownCast

class Handle_StepBasic_Effectivity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Effectivity self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Effectivity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Effectivity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Effectivity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Effectivity self, StepBasic_Effectivity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Effectivity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Effectivity self, Handle_StepBasic_Effectivity theHandle) -> Handle_StepBasic_Effectivity
        assign(Handle_StepBasic_Effectivity self, StepBasic_Effectivity thePtr) -> Handle_StepBasic_Effectivity
        assign(Handle_StepBasic_Effectivity self, Handle_StepBasic_Effectivity theHandle) -> Handle_StepBasic_Effectivity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Effectivity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Effectivity self) -> StepBasic_Effectivity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Effectivity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Effectivity self) -> StepBasic_Effectivity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Effectivity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Effectivity self) -> StepBasic_Effectivity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Effectivity___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Effectivity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Effectivity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Effectivity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Effectivity_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Effectivity

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Effectivity self, Handle_TCollection_HAsciiString aid)

        :type aid: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Effectivity_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_Effectivity self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Effectivity_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_Effectivity self, Handle_TCollection_HAsciiString aid)

        :type aid: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Effectivity_SetId(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Effectivity self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Effectivity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Effectivity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Effectivity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Effectivity self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Effectivity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Effectivity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Effectivity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Effectivity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Effectivity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Effectivity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Effectivity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Effectivity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Effectivity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Effectivity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Effectivity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Effectivity self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Effectivity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Effectivity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Effectivity_DecrementRefCounter(self, *args)

Handle_StepBasic_Effectivity_swigregister = _StepBasic.Handle_StepBasic_Effectivity_swigregister
Handle_StepBasic_Effectivity_swigregister(Handle_StepBasic_Effectivity)

def Handle_StepBasic_Effectivity_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Effectivity_DownCast(thing)
Handle_StepBasic_Effectivity_DownCast = _StepBasic.Handle_StepBasic_Effectivity_DownCast

class StepBasic_EffectivityAssignment(Standard.Standard_Transient):
    """Representation of STEP entity EffectivityAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_EffectivityAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_EffectivityAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_EffectivityAssignment self) -> StepBasic_EffectivityAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_EffectivityAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_EffectivityAssignment self, Handle_StepBasic_Effectivity aAssignedEffectivity)

        Initialize all fields (own and inherited)

        :type aAssignedEffectivity: OCC.wrapper.StepBasic.Handle_StepBasic_Effectivity

        """
        return _StepBasic.StepBasic_EffectivityAssignment_Init(self, *args)


    def AssignedEffectivity(self, *args):
        """
        AssignedEffectivity(StepBasic_EffectivityAssignment self) -> Handle_StepBasic_Effectivity

        Returns field AssignedEffectivity

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Effectivity

        """
        return _StepBasic.StepBasic_EffectivityAssignment_AssignedEffectivity(self, *args)


    def SetAssignedEffectivity(self, *args):
        """
        SetAssignedEffectivity(StepBasic_EffectivityAssignment self, Handle_StepBasic_Effectivity AssignedEffectivity)

        Set field AssignedEffectivity

        :type AssignedEffectivity: OCC.wrapper.StepBasic.Handle_StepBasic_Effectivity

        """
        return _StepBasic.StepBasic_EffectivityAssignment_SetAssignedEffectivity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_EffectivityAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_EffectivityAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_EffectivityAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_EffectivityAssignment
StepBasic_EffectivityAssignment_swigregister = _StepBasic.StepBasic_EffectivityAssignment_swigregister
StepBasic_EffectivityAssignment_swigregister(StepBasic_EffectivityAssignment)

def StepBasic_EffectivityAssignment_get_type_name(*args):
    """
    StepBasic_EffectivityAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_EffectivityAssignment_get_type_name(*args)

def StepBasic_EffectivityAssignment_get_type_descriptor(*args):
    """
    StepBasic_EffectivityAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_EffectivityAssignment_get_type_descriptor(*args)

class Handle_StepBasic_HArray1OfApproval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfApproval self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfApproval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfApproval self, StepBasic_HArray1OfApproval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfApproval self, Handle_StepBasic_HArray1OfApproval theHandle) -> Handle_StepBasic_HArray1OfApproval
        assign(Handle_StepBasic_HArray1OfApproval self, StepBasic_HArray1OfApproval thePtr) -> Handle_StepBasic_HArray1OfApproval
        assign(Handle_StepBasic_HArray1OfApproval self, Handle_StepBasic_HArray1OfApproval theHandle) -> Handle_StepBasic_HArray1OfApproval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfApproval self) -> StepBasic_HArray1OfApproval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfApproval self) -> StepBasic_HArray1OfApproval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfApproval self) -> StepBasic_HArray1OfApproval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfApproval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfApproval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfApproval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfApproval_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfApproval

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfApproval

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfApproval_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfApproval self) -> NCollection_Array1_Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfApproval

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfApproval self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfApproval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfApproval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfApproval self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfApproval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfApproval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfApproval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfApproval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfApproval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfApproval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfApproval self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfApproval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfApproval_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfApproval_swigregister = _StepBasic.Handle_StepBasic_HArray1OfApproval_swigregister
Handle_StepBasic_HArray1OfApproval_swigregister(Handle_StepBasic_HArray1OfApproval)

def Handle_StepBasic_HArray1OfApproval_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfApproval_DownCast(thing)
Handle_StepBasic_HArray1OfApproval_DownCast = _StepBasic.Handle_StepBasic_HArray1OfApproval_DownCast

class Handle_StepBasic_ProductDefinitionRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinitionRelationship self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinitionRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinitionRelationship self, StepBasic_ProductDefinitionRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinitionRelationship self, Handle_StepBasic_ProductDefinitionRelationship theHandle) -> Handle_StepBasic_ProductDefinitionRelationship
        assign(Handle_StepBasic_ProductDefinitionRelationship self, StepBasic_ProductDefinitionRelationship thePtr) -> Handle_StepBasic_ProductDefinitionRelationship
        assign(Handle_StepBasic_ProductDefinitionRelationship self, Handle_StepBasic_ProductDefinitionRelationship theHandle) -> Handle_StepBasic_ProductDefinitionRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinitionRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinitionRelationship_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinitionRelationship

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinition aRelatingProductDefinition, Handle_StepBasic_ProductDefinition aRelatedProductDefinition)
        Init(Handle_StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, StepBasic_ProductDefinitionOrReference aRelatingProductDefinition, StepBasic_ProductDefinitionOrReference aRelatedProductDefinition)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference
        :type aRelatedProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinitionRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_SetId(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductDefinitionRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinitionRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinitionRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ProductDefinitionRelationship self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_HasDescription(self, *args)


    def RelatingProductDefinition(self, *args):
        """
        RelatingProductDefinition(Handle_StepBasic_ProductDefinitionRelationship self) -> Handle_StepBasic_ProductDefinition

        Returns field RelatingProductDefinition

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_RelatingProductDefinition(self, *args)


    def RelatingProductDefinitionAP242(self, *args):
        """
        RelatingProductDefinitionAP242(Handle_StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionOrReference

        Returns field RelatingProductDefinition in AP242

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_RelatingProductDefinitionAP242(self, *args)


    def SetRelatingProductDefinition(self, *args):
        """
        SetRelatingProductDefinition(Handle_StepBasic_ProductDefinitionRelationship self, Handle_StepBasic_ProductDefinition RelatingProductDefinition)
        SetRelatingProductDefinition(Handle_StepBasic_ProductDefinitionRelationship self, StepBasic_ProductDefinitionOrReference RelatingProductDefinition)

        Set field RelatingProductDefinition in AP242

        :type RelatingProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_SetRelatingProductDefinition(self, *args)


    def RelatedProductDefinition(self, *args):
        """
        RelatedProductDefinition(Handle_StepBasic_ProductDefinitionRelationship self) -> Handle_StepBasic_ProductDefinition

        Returns field RelatedProductDefinition

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_RelatedProductDefinition(self, *args)


    def RelatedProductDefinitionAP242(self, *args):
        """
        RelatedProductDefinitionAP242(Handle_StepBasic_ProductDefinitionRelationship self) -> StepBasic_ProductDefinitionOrReference

        Returns field RelatedProductDefinition in AP242

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_RelatedProductDefinitionAP242(self, *args)


    def SetRelatedProductDefinition(self, *args):
        """
        SetRelatedProductDefinition(Handle_StepBasic_ProductDefinitionRelationship self, Handle_StepBasic_ProductDefinition RelatedProductDefinition)
        SetRelatedProductDefinition(Handle_StepBasic_ProductDefinitionRelationship self, StepBasic_ProductDefinitionOrReference RelatedProductDefinition)

        Set field RelatedProductDefinition in AP242

        :type RelatedProductDefinition: OCC.wrapper.StepBasic.StepBasic_ProductDefinitionOrReference

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_SetRelatedProductDefinition(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinitionRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinitionRelationship self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinitionRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinitionRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinitionRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinitionRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinitionRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinitionRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinitionRelationship self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinitionRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinitionRelationship_swigregister = _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_swigregister
Handle_StepBasic_ProductDefinitionRelationship_swigregister(Handle_StepBasic_ProductDefinitionRelationship)

def Handle_StepBasic_ProductDefinitionRelationship_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_DownCast(thing)
Handle_StepBasic_ProductDefinitionRelationship_DownCast = _StepBasic.Handle_StepBasic_ProductDefinitionRelationship_DownCast

class Handle_StepBasic_MassMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_MassMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_MassMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_MassMeasureWithUnit self, StepBasic_MassMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_MassMeasureWithUnit self, Handle_StepBasic_MassMeasureWithUnit theHandle) -> Handle_StepBasic_MassMeasureWithUnit
        assign(Handle_StepBasic_MassMeasureWithUnit self, StepBasic_MassMeasureWithUnit thePtr) -> Handle_StepBasic_MassMeasureWithUnit
        assign(Handle_StepBasic_MassMeasureWithUnit self, Handle_StepBasic_MassMeasureWithUnit theHandle) -> Handle_StepBasic_MassMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_MassMeasureWithUnit self) -> StepBasic_MassMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_MassMeasureWithUnit self) -> StepBasic_MassMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_MassMeasureWithUnit self) -> StepBasic_MassMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_MassMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_MassMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_MassMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_MassMeasureWithUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_MassMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MassMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MassMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_MassMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_MassMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_MassMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_MassMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_MassMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_MassMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_MassMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_MassMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_MassMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_MassMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_MassMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_MassMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_MassMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_MassMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_MassMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_MassMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_MassMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_MassMeasureWithUnit_swigregister
Handle_StepBasic_MassMeasureWithUnit_swigregister(Handle_StepBasic_MassMeasureWithUnit)

def Handle_StepBasic_MassMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_MassMeasureWithUnit_DownCast(thing)
Handle_StepBasic_MassMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_MassMeasureWithUnit_DownCast

class Handle_StepBasic_ProductDefinition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductDefinition self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductDefinition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductDefinition self, StepBasic_ProductDefinition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinition theHandle) -> Handle_StepBasic_ProductDefinition
        assign(Handle_StepBasic_ProductDefinition self, StepBasic_ProductDefinition thePtr) -> Handle_StepBasic_ProductDefinition
        assign(Handle_StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinition theHandle) -> Handle_StepBasic_ProductDefinition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductDefinition self) -> StepBasic_ProductDefinition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductDefinition self) -> StepBasic_ProductDefinition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductDefinition self) -> StepBasic_ProductDefinition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductDefinition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductDefinition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductDefinition_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductDefinition

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductDefinition self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aFormation, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_ProductDefinition self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_ProductDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductDefinition self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_Description(self, *args)


    def SetFormation(self, *args):
        """
        SetFormation(Handle_StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinitionFormation aFormation)

        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_SetFormation(self, *args)


    def Formation(self, *args):
        """
        Formation(Handle_StepBasic_ProductDefinition self) -> Handle_StepBasic_ProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_Formation(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ProductDefinition self, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ProductDefinition self) -> Handle_StepBasic_ProductDefinitionContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_FrameOfReference(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductDefinition self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductDefinition self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductDefinition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductDefinition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductDefinition self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductDefinition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductDefinition_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductDefinition_swigregister = _StepBasic.Handle_StepBasic_ProductDefinition_swigregister
Handle_StepBasic_ProductDefinition_swigregister(Handle_StepBasic_ProductDefinition)

def Handle_StepBasic_ProductDefinition_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductDefinition_DownCast(thing)
Handle_StepBasic_ProductDefinition_DownCast = _StepBasic.Handle_StepBasic_ProductDefinition_DownCast

class Handle_StepBasic_DigitalDocument(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DigitalDocument self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DigitalDocument self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DigitalDocument self, StepBasic_DigitalDocument thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DigitalDocument self, Handle_StepBasic_DigitalDocument theHandle) -> Handle_StepBasic_DigitalDocument
        assign(Handle_StepBasic_DigitalDocument self, StepBasic_DigitalDocument thePtr) -> Handle_StepBasic_DigitalDocument
        assign(Handle_StepBasic_DigitalDocument self, Handle_StepBasic_DigitalDocument theHandle) -> Handle_StepBasic_DigitalDocument

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DigitalDocument self) -> StepBasic_DigitalDocument

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DigitalDocument self) -> StepBasic_DigitalDocument

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DigitalDocument self) -> StepBasic_DigitalDocument

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DigitalDocument___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DigitalDocument___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DigitalDocument(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DigitalDocument_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DigitalDocument

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DigitalDocument self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DigitalDocument_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DigitalDocument_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_DigitalDocument self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_DocumentType aKind)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_DigitalDocument self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_DigitalDocument self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_SetId(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DigitalDocument self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DigitalDocument self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_DigitalDocument self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_DigitalDocument self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_DigitalDocument self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_HasDescription(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_DigitalDocument self) -> Handle_StepBasic_DocumentType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_DigitalDocument self, Handle_StepBasic_DocumentType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_SetKind(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DigitalDocument self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DigitalDocument self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DigitalDocument self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DigitalDocument self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DigitalDocument self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DigitalDocument self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DigitalDocument self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DigitalDocument self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DigitalDocument self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DigitalDocument_DecrementRefCounter(self, *args)

Handle_StepBasic_DigitalDocument_swigregister = _StepBasic.Handle_StepBasic_DigitalDocument_swigregister
Handle_StepBasic_DigitalDocument_swigregister(Handle_StepBasic_DigitalDocument)

def Handle_StepBasic_DigitalDocument_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DigitalDocument_DownCast(thing)
Handle_StepBasic_DigitalDocument_DownCast = _StepBasic.Handle_StepBasic_DigitalDocument_DownCast

class Handle_StepBasic_HArray1OfDerivedUnitElement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfDerivedUnitElement self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfDerivedUnitElement self, StepBasic_HArray1OfDerivedUnitElement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfDerivedUnitElement self, Handle_StepBasic_HArray1OfDerivedUnitElement theHandle) -> Handle_StepBasic_HArray1OfDerivedUnitElement
        assign(Handle_StepBasic_HArray1OfDerivedUnitElement self, StepBasic_HArray1OfDerivedUnitElement thePtr) -> Handle_StepBasic_HArray1OfDerivedUnitElement
        assign(Handle_StepBasic_HArray1OfDerivedUnitElement self, Handle_StepBasic_HArray1OfDerivedUnitElement theHandle) -> Handle_StepBasic_HArray1OfDerivedUnitElement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> StepBasic_HArray1OfDerivedUnitElement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> StepBasic_HArray1OfDerivedUnitElement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> StepBasic_HArray1OfDerivedUnitElement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfDerivedUnitElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfDerivedUnitElement

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDerivedUnitElement

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> NCollection_Array1_Handle_StepBasic_DerivedUnitElement

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfDerivedUnitElement

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfDerivedUnitElement self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfDerivedUnitElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfDerivedUnitElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfDerivedUnitElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfDerivedUnitElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfDerivedUnitElement self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfDerivedUnitElement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfDerivedUnitElement_swigregister = _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_swigregister
Handle_StepBasic_HArray1OfDerivedUnitElement_swigregister(Handle_StepBasic_HArray1OfDerivedUnitElement)

def Handle_StepBasic_HArray1OfDerivedUnitElement_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_DownCast(thing)
Handle_StepBasic_HArray1OfDerivedUnitElement_DownCast = _StepBasic.Handle_StepBasic_HArray1OfDerivedUnitElement_DownCast

class StepBasic_PersonOrganizationSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_PersonOrganizationSelect self) -> StepBasic_PersonOrganizationSelect

        Returns a PersonOrganizationSelect SelectType


        """
        this = _StepBasic.new_StepBasic_PersonOrganizationSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_PersonOrganizationSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a PersonOrganizationSelect Kind Entity that is :
        1 -> Person
        2 -> Organization
        3 -> PersonAndOrganization
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_PersonOrganizationSelect_CaseNum(self, *args)


    def Person(self, *args):
        """
        Person(StepBasic_PersonOrganizationSelect self) -> Handle_StepBasic_Person

        returns Value as a Person (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.StepBasic_PersonOrganizationSelect_Person(self, *args)


    def Organization(self, *args):
        """
        Organization(StepBasic_PersonOrganizationSelect self) -> Handle_StepBasic_Organization

        returns Value as a Organization (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.StepBasic_PersonOrganizationSelect_Organization(self, *args)


    def PersonAndOrganization(self, *args):
        """
        PersonAndOrganization(StepBasic_PersonOrganizationSelect self) -> Handle_StepBasic_PersonAndOrganization

        returns Value as a PersonAndOrganization (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _StepBasic.StepBasic_PersonOrganizationSelect_PersonAndOrganization(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_PersonOrganizationSelect
StepBasic_PersonOrganizationSelect_swigregister = _StepBasic.StepBasic_PersonOrganizationSelect_swigregister
StepBasic_PersonOrganizationSelect_swigregister(StepBasic_PersonOrganizationSelect)

class Handle_StepBasic_DimensionalExponents(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DimensionalExponents self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DimensionalExponents self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DimensionalExponents self, StepBasic_DimensionalExponents thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DimensionalExponents self, Handle_StepBasic_DimensionalExponents theHandle) -> Handle_StepBasic_DimensionalExponents
        assign(Handle_StepBasic_DimensionalExponents self, StepBasic_DimensionalExponents thePtr) -> Handle_StepBasic_DimensionalExponents
        assign(Handle_StepBasic_DimensionalExponents self, Handle_StepBasic_DimensionalExponents theHandle) -> Handle_StepBasic_DimensionalExponents

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DimensionalExponents self) -> StepBasic_DimensionalExponents

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DimensionalExponents self) -> StepBasic_DimensionalExponents

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DimensionalExponents self) -> StepBasic_DimensionalExponents

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DimensionalExponents___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DimensionalExponents___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DimensionalExponents(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DimensionalExponents_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DimensionalExponents

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DimensionalExponents self, Standard_Real const aLengthExponent, Standard_Real const aMassExponent, Standard_Real const aTimeExponent, Standard_Real const aElectricCurrentExponent, Standard_Real const aThermodynamicTemperatureExponent, Standard_Real const aAmountOfSubstanceExponent, Standard_Real const aLuminousIntensityExponent)

        :type aLengthExponent: float
        :type aMassExponent: float
        :type aTimeExponent: float
        :type aElectricCurrentExponent: float
        :type aThermodynamicTemperatureExponent: float
        :type aAmountOfSubstanceExponent: float
        :type aLuminousIntensityExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_Init(self, *args)


    def SetLengthExponent(self, *args):
        """
        SetLengthExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aLengthExponent)

        :type aLengthExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetLengthExponent(self, *args)


    def LengthExponent(self, *args):
        """
        LengthExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_LengthExponent(self, *args)


    def SetMassExponent(self, *args):
        """
        SetMassExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aMassExponent)

        :type aMassExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetMassExponent(self, *args)


    def MassExponent(self, *args):
        """
        MassExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_MassExponent(self, *args)


    def SetTimeExponent(self, *args):
        """
        SetTimeExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aTimeExponent)

        :type aTimeExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetTimeExponent(self, *args)


    def TimeExponent(self, *args):
        """
        TimeExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_TimeExponent(self, *args)


    def SetElectricCurrentExponent(self, *args):
        """
        SetElectricCurrentExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aElectricCurrentExponent)

        :type aElectricCurrentExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetElectricCurrentExponent(self, *args)


    def ElectricCurrentExponent(self, *args):
        """
        ElectricCurrentExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_ElectricCurrentExponent(self, *args)


    def SetThermodynamicTemperatureExponent(self, *args):
        """
        SetThermodynamicTemperatureExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aThermodynamicTemperatureExponent)

        :type aThermodynamicTemperatureExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetThermodynamicTemperatureExponent(self, *args)


    def ThermodynamicTemperatureExponent(self, *args):
        """
        ThermodynamicTemperatureExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_ThermodynamicTemperatureExponent(self, *args)


    def SetAmountOfSubstanceExponent(self, *args):
        """
        SetAmountOfSubstanceExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aAmountOfSubstanceExponent)

        :type aAmountOfSubstanceExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetAmountOfSubstanceExponent(self, *args)


    def AmountOfSubstanceExponent(self, *args):
        """
        AmountOfSubstanceExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_AmountOfSubstanceExponent(self, *args)


    def SetLuminousIntensityExponent(self, *args):
        """
        SetLuminousIntensityExponent(Handle_StepBasic_DimensionalExponents self, Standard_Real const aLuminousIntensityExponent)

        :type aLuminousIntensityExponent: float

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_SetLuminousIntensityExponent(self, *args)


    def LuminousIntensityExponent(self, *args):
        """
        LuminousIntensityExponent(Handle_StepBasic_DimensionalExponents self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_LuminousIntensityExponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DimensionalExponents self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DimensionalExponents_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DimensionalExponents_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DimensionalExponents self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DimensionalExponents self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DimensionalExponents self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DimensionalExponents self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DimensionalExponents self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DimensionalExponents self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DimensionalExponents self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DimensionalExponents self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DimensionalExponents self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DimensionalExponents_DecrementRefCounter(self, *args)

Handle_StepBasic_DimensionalExponents_swigregister = _StepBasic.Handle_StepBasic_DimensionalExponents_swigregister
Handle_StepBasic_DimensionalExponents_swigregister(Handle_StepBasic_DimensionalExponents)

def Handle_StepBasic_DimensionalExponents_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DimensionalExponents_DownCast(thing)
Handle_StepBasic_DimensionalExponents_DownCast = _StepBasic.Handle_StepBasic_DimensionalExponents_DownCast

class Handle_StepBasic_ApplicationProtocolDefinition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApplicationProtocolDefinition self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApplicationProtocolDefinition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApplicationProtocolDefinition self, StepBasic_ApplicationProtocolDefinition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_StepBasic_ApplicationProtocolDefinition theHandle) -> Handle_StepBasic_ApplicationProtocolDefinition
        assign(Handle_StepBasic_ApplicationProtocolDefinition self, StepBasic_ApplicationProtocolDefinition thePtr) -> Handle_StepBasic_ApplicationProtocolDefinition
        assign(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_StepBasic_ApplicationProtocolDefinition theHandle) -> Handle_StepBasic_ApplicationProtocolDefinition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApplicationProtocolDefinition self) -> StepBasic_ApplicationProtocolDefinition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApplicationProtocolDefinition self) -> StepBasic_ApplicationProtocolDefinition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApplicationProtocolDefinition self) -> StepBasic_ApplicationProtocolDefinition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApplicationProtocolDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApplicationProtocolDefinition

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_TCollection_HAsciiString aStatus, Handle_TCollection_HAsciiString aApplicationInterpretedModelSchemaName, Standard_Integer const aApplicationProtocolYear, Handle_StepBasic_ApplicationContext aApplication)

        :type aStatus: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aApplicationInterpretedModelSchemaName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aApplicationProtocolYear: int
        :type aApplication: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_Init(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_TCollection_HAsciiString aStatus)

        :type aStatus: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_SetStatus(self, *args)


    def Status(self, *args):
        """
        Status(Handle_StepBasic_ApplicationProtocolDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_Status(self, *args)


    def SetApplicationInterpretedModelSchemaName(self, *args):
        """
        SetApplicationInterpretedModelSchemaName(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_TCollection_HAsciiString aApplicationInterpretedModelSchemaName)

        :type aApplicationInterpretedModelSchemaName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_SetApplicationInterpretedModelSchemaName(self, *args)


    def ApplicationInterpretedModelSchemaName(self, *args):
        """
        ApplicationInterpretedModelSchemaName(Handle_StepBasic_ApplicationProtocolDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_ApplicationInterpretedModelSchemaName(self, *args)


    def SetApplicationProtocolYear(self, *args):
        """
        SetApplicationProtocolYear(Handle_StepBasic_ApplicationProtocolDefinition self, Standard_Integer const aApplicationProtocolYear)

        :type aApplicationProtocolYear: int

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_SetApplicationProtocolYear(self, *args)


    def ApplicationProtocolYear(self, *args):
        """
        ApplicationProtocolYear(Handle_StepBasic_ApplicationProtocolDefinition self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_ApplicationProtocolYear(self, *args)


    def SetApplication(self, *args):
        """
        SetApplication(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_StepBasic_ApplicationContext aApplication)

        :type aApplication: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_SetApplication(self, *args)


    def Application(self, *args):
        """
        Application(Handle_StepBasic_ApplicationProtocolDefinition self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_Application(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApplicationProtocolDefinition self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApplicationProtocolDefinition self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApplicationProtocolDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApplicationProtocolDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApplicationProtocolDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApplicationProtocolDefinition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApplicationProtocolDefinition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApplicationProtocolDefinition self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApplicationProtocolDefinition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_DecrementRefCounter(self, *args)

Handle_StepBasic_ApplicationProtocolDefinition_swigregister = _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_swigregister
Handle_StepBasic_ApplicationProtocolDefinition_swigregister(Handle_StepBasic_ApplicationProtocolDefinition)

def Handle_StepBasic_ApplicationProtocolDefinition_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_DownCast(thing)
Handle_StepBasic_ApplicationProtocolDefinition_DownCast = _StepBasic.Handle_StepBasic_ApplicationProtocolDefinition_DownCast

class StepBasic_ApprovalRelationship(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApprovalRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApprovalRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApprovalRelationship self) -> StepBasic_ApprovalRelationship

        Returns a ApprovalRelationship


        """
        this = _StepBasic.new_StepBasic_ApprovalRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApprovalRelationship self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Approval aRelatingApproval, Handle_StepBasic_Approval aRelatedApproval)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval
        :type aRelatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalRelationship_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepBasic_ApprovalRelationship self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRelationship_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepBasic_ApprovalRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRelationship_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepBasic_ApprovalRelationship self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRelationship_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepBasic_ApprovalRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_ApprovalRelationship_Description(self, *args)


    def SetRelatingApproval(self, *args):
        """
        SetRelatingApproval(StepBasic_ApprovalRelationship self, Handle_StepBasic_Approval aRelatingApproval)

        :type aRelatingApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalRelationship_SetRelatingApproval(self, *args)


    def RelatingApproval(self, *args):
        """
        RelatingApproval(StepBasic_ApprovalRelationship self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalRelationship_RelatingApproval(self, *args)


    def SetRelatedApproval(self, *args):
        """
        SetRelatedApproval(StepBasic_ApprovalRelationship self, Handle_StepBasic_Approval aRelatedApproval)

        :type aRelatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalRelationship_SetRelatedApproval(self, *args)


    def RelatedApproval(self, *args):
        """
        RelatedApproval(StepBasic_ApprovalRelationship self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalRelationship_RelatedApproval(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApprovalRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApprovalRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApprovalRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApprovalRelationship
StepBasic_ApprovalRelationship_swigregister = _StepBasic.StepBasic_ApprovalRelationship_swigregister
StepBasic_ApprovalRelationship_swigregister(StepBasic_ApprovalRelationship)

def StepBasic_ApprovalRelationship_get_type_name(*args):
    """
    StepBasic_ApprovalRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApprovalRelationship_get_type_name(*args)

def StepBasic_ApprovalRelationship_get_type_descriptor(*args):
    """
    StepBasic_ApprovalRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApprovalRelationship_get_type_descriptor(*args)

class Handle_StepBasic_PhysicallyModeledProductDefinition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PhysicallyModeledProductDefinition self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PhysicallyModeledProductDefinition self, StepBasic_PhysicallyModeledProductDefinition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_StepBasic_PhysicallyModeledProductDefinition theHandle) -> Handle_StepBasic_PhysicallyModeledProductDefinition
        assign(Handle_StepBasic_PhysicallyModeledProductDefinition self, StepBasic_PhysicallyModeledProductDefinition thePtr) -> Handle_StepBasic_PhysicallyModeledProductDefinition
        assign(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_StepBasic_PhysicallyModeledProductDefinition theHandle) -> Handle_StepBasic_PhysicallyModeledProductDefinition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> StepBasic_PhysicallyModeledProductDefinition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> StepBasic_PhysicallyModeledProductDefinition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> StepBasic_PhysicallyModeledProductDefinition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PhysicallyModeledProductDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PhysicallyModeledProductDefinition

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductDefinitionFormation aFormation, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_Init(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_TCollection_HAsciiString aId)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_SetId(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_Id(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_Description(self, *args)


    def SetFormation(self, *args):
        """
        SetFormation(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_StepBasic_ProductDefinitionFormation aFormation)

        :type aFormation: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_SetFormation(self, *args)


    def Formation(self, *args):
        """
        Formation(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Handle_StepBasic_ProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_Formation(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_StepBasic_ProductDefinitionContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Handle_StepBasic_ProductDefinitionContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PhysicallyModeledProductDefinition self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PhysicallyModeledProductDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PhysicallyModeledProductDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PhysicallyModeledProductDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PhysicallyModeledProductDefinition self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PhysicallyModeledProductDefinition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_DecrementRefCounter(self, *args)

Handle_StepBasic_PhysicallyModeledProductDefinition_swigregister = _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_swigregister
Handle_StepBasic_PhysicallyModeledProductDefinition_swigregister(Handle_StepBasic_PhysicallyModeledProductDefinition)

def Handle_StepBasic_PhysicallyModeledProductDefinition_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_DownCast(thing)
Handle_StepBasic_PhysicallyModeledProductDefinition_DownCast = _StepBasic.Handle_StepBasic_PhysicallyModeledProductDefinition_DownCast

class Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, StepBasic_HArray1OfUncertaintyMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit theHandle) -> Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit
        assign(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, StepBasic_HArray1OfUncertaintyMeasureWithUnit thePtr) -> Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit
        assign(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit theHandle) -> Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> StepBasic_HArray1OfUncertaintyMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> StepBasic_HArray1OfUncertaintyMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> StepBasic_HArray1OfUncertaintyMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfUncertaintyMeasureWithUnit

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> NCollection_Array1_Handle_StepBasic_UncertaintyMeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfUncertaintyMeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_swigregister
Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_swigregister(Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit)

def Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DownCast(thing)
Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_HArray1OfUncertaintyMeasureWithUnit_DownCast

class StepBasic_ExternalIdentificationAssignment(StepBasic_IdentificationAssignment):
    """Representation of STEP entity ExternalIdentificationAssignment"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ExternalIdentificationAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ExternalIdentificationAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ExternalIdentificationAssignment self) -> StepBasic_ExternalIdentificationAssignment

        Empty constructor


        """
        this = _StepBasic.new_StepBasic_ExternalIdentificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ExternalIdentificationAssignment self, Handle_TCollection_HAsciiString aIdentificationAssignment_AssignedId, Handle_StepBasic_IdentificationRole aIdentificationAssignment_Role, Handle_StepBasic_ExternalSource aSource)

        Initialize all fields (own and inherited)

        :type aIdentificationAssignment_AssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIdentificationAssignment_Role: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole
        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ExternalIdentificationAssignment_Init(self, *args)


    def Source(self, *args):
        """
        Source(StepBasic_ExternalIdentificationAssignment self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ExternalIdentificationAssignment_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepBasic_ExternalIdentificationAssignment self, Handle_StepBasic_ExternalSource Source)

        Set field Source

        :type Source: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.StepBasic_ExternalIdentificationAssignment_SetSource(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ExternalIdentificationAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ExternalIdentificationAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ExternalIdentificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ExternalIdentificationAssignment
StepBasic_ExternalIdentificationAssignment_swigregister = _StepBasic.StepBasic_ExternalIdentificationAssignment_swigregister
StepBasic_ExternalIdentificationAssignment_swigregister(StepBasic_ExternalIdentificationAssignment)

def StepBasic_ExternalIdentificationAssignment_get_type_name(*args):
    """
    StepBasic_ExternalIdentificationAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ExternalIdentificationAssignment_get_type_name(*args)

def StepBasic_ExternalIdentificationAssignment_get_type_descriptor(*args):
    """
    StepBasic_ExternalIdentificationAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ExternalIdentificationAssignment_get_type_descriptor(*args)

class Handle_StepBasic_MechanicalContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_MechanicalContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_MechanicalContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_MechanicalContext self, StepBasic_MechanicalContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_MechanicalContext self, Handle_StepBasic_MechanicalContext theHandle) -> Handle_StepBasic_MechanicalContext
        assign(Handle_StepBasic_MechanicalContext self, StepBasic_MechanicalContext thePtr) -> Handle_StepBasic_MechanicalContext
        assign(Handle_StepBasic_MechanicalContext self, Handle_StepBasic_MechanicalContext theHandle) -> Handle_StepBasic_MechanicalContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_MechanicalContext self) -> StepBasic_MechanicalContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_MechanicalContext self) -> StepBasic_MechanicalContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_MechanicalContext self) -> StepBasic_MechanicalContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_MechanicalContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_MechanicalContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_MechanicalContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_MechanicalContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_MechanicalContext

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_MechanicalContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MechanicalContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MechanicalContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_MechanicalContext self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference, Handle_TCollection_HAsciiString aDisciplineType)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aDisciplineType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_Init(self, *args)


    def SetDisciplineType(self, *args):
        """
        SetDisciplineType(Handle_StepBasic_MechanicalContext self, Handle_TCollection_HAsciiString aDisciplineType)

        :type aDisciplineType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_SetDisciplineType(self, *args)


    def DisciplineType(self, *args):
        """
        DisciplineType(Handle_StepBasic_MechanicalContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_DisciplineType(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_MechanicalContext self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_MechanicalContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_MechanicalContext self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_MechanicalContext self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_MechanicalContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_MechanicalContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_MechanicalContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_MechanicalContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_MechanicalContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_MechanicalContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_MechanicalContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_MechanicalContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_MechanicalContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MechanicalContext_DecrementRefCounter(self, *args)

Handle_StepBasic_MechanicalContext_swigregister = _StepBasic.Handle_StepBasic_MechanicalContext_swigregister
Handle_StepBasic_MechanicalContext_swigregister(Handle_StepBasic_MechanicalContext)

def Handle_StepBasic_MechanicalContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_MechanicalContext_DownCast(thing)
Handle_StepBasic_MechanicalContext_DownCast = _StepBasic.Handle_StepBasic_MechanicalContext_DownCast

class Handle_StepBasic_DesignContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DesignContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DesignContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DesignContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DesignContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DesignContext self, StepBasic_DesignContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DesignContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DesignContext self, Handle_StepBasic_DesignContext theHandle) -> Handle_StepBasic_DesignContext
        assign(Handle_StepBasic_DesignContext self, StepBasic_DesignContext thePtr) -> Handle_StepBasic_DesignContext
        assign(Handle_StepBasic_DesignContext self, Handle_StepBasic_DesignContext theHandle) -> Handle_StepBasic_DesignContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DesignContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DesignContext self) -> StepBasic_DesignContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DesignContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DesignContext self) -> StepBasic_DesignContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DesignContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DesignContext self) -> StepBasic_DesignContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DesignContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DesignContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DesignContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DesignContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DesignContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DesignContext

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DesignContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DesignContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DesignContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DesignContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_DesignContext self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference, Handle_TCollection_HAsciiString aLifeCycleStage)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aLifeCycleStage: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DesignContext_Init(self, *args)


    def SetLifeCycleStage(self, *args):
        """
        SetLifeCycleStage(Handle_StepBasic_DesignContext self, Handle_TCollection_HAsciiString aLifeCycleStage)

        :type aLifeCycleStage: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DesignContext_SetLifeCycleStage(self, *args)


    def LifeCycleStage(self, *args):
        """
        LifeCycleStage(Handle_StepBasic_DesignContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DesignContext_LifeCycleStage(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DesignContext self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DesignContext_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DesignContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DesignContext_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_DesignContext self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_DesignContext_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_DesignContext self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_DesignContext_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DesignContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DesignContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DesignContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DesignContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DesignContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DesignContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DesignContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DesignContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DesignContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DesignContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DesignContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DesignContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DesignContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DesignContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DesignContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DesignContext_DecrementRefCounter(self, *args)

Handle_StepBasic_DesignContext_swigregister = _StepBasic.Handle_StepBasic_DesignContext_swigregister
Handle_StepBasic_DesignContext_swigregister(Handle_StepBasic_DesignContext)

def Handle_StepBasic_DesignContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DesignContext_DownCast(thing)
Handle_StepBasic_DesignContext_DownCast = _StepBasic.Handle_StepBasic_DesignContext_DownCast

class Handle_StepBasic_SiUnitAndVolumeUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndVolumeUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndVolumeUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndVolumeUnit self, StepBasic_SiUnitAndVolumeUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndVolumeUnit self, Handle_StepBasic_SiUnitAndVolumeUnit theHandle) -> Handle_StepBasic_SiUnitAndVolumeUnit
        assign(Handle_StepBasic_SiUnitAndVolumeUnit self, StepBasic_SiUnitAndVolumeUnit thePtr) -> Handle_StepBasic_SiUnitAndVolumeUnit
        assign(Handle_StepBasic_SiUnitAndVolumeUnit self, Handle_StepBasic_SiUnitAndVolumeUnit theHandle) -> Handle_StepBasic_SiUnitAndVolumeUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndVolumeUnit self) -> StepBasic_SiUnitAndVolumeUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndVolumeUnit self) -> StepBasic_SiUnitAndVolumeUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndVolumeUnit self) -> StepBasic_SiUnitAndVolumeUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndVolumeUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndVolumeUnit

    def SetVolumeUnit(self, *args):
        """
        SetVolumeUnit(Handle_StepBasic_SiUnitAndVolumeUnit self, Handle_StepBasic_VolumeUnit aVolumeUnit)

        :type aVolumeUnit: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_SetVolumeUnit(self, *args)


    def VolumeUnit(self, *args):
        """
        VolumeUnit(Handle_StepBasic_SiUnitAndVolumeUnit self) -> Handle_StepBasic_VolumeUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_VolumeUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_VolumeUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndVolumeUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndVolumeUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_Init(self, *args)


    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndVolumeUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndVolumeUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndVolumeUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndVolumeUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndVolumeUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndVolumeUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndVolumeUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndVolumeUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndVolumeUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndVolumeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndVolumeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndVolumeUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndVolumeUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndVolumeUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndVolumeUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndVolumeUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndVolumeUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndVolumeUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_swigregister
Handle_StepBasic_SiUnitAndVolumeUnit_swigregister(Handle_StepBasic_SiUnitAndVolumeUnit)

def Handle_StepBasic_SiUnitAndVolumeUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndVolumeUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndVolumeUnit_DownCast

class StepBasic_SizeSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_SizeSelect self) -> StepBasic_SizeSelect

        Returns a SizeSelect SelectType


        """
        this = _StepBasic.new_StepBasic_SizeSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_SizeSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a TrimmingSelect Kind Entity that is :
        1 -> SizeMember
        0 else (i.e. Real)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_SizeSelect_CaseNum(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepBasic_SizeSelect self) -> Handle_StepData_SelectMember

        Returns a SizeMember (POSITIVE_LENGTH_MEASURE) as preferred

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepBasic.StepBasic_SizeSelect_NewMember(self, *args)


    def CaseMem(self, *args):
        """
        CaseMem(StepBasic_SizeSelect self, Handle_StepData_SelectMember ent) -> Standard_Integer

        Recognizes a SelectMember as Real, named as PARAMETER_VALUE
        1 -> PositiveLengthMeasure i.e. Real
        0 else (i.e. Entity)

        :type ent: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_SizeSelect_CaseMem(self, *args)


    def SetRealValue(self, *args):
        """
        SetRealValue(StepBasic_SizeSelect self, Standard_Real const aReal)

        :type aReal: float

        """
        return _StepBasic.StepBasic_SizeSelect_SetRealValue(self, *args)


    def RealValue(self, *args):
        """
        RealValue(StepBasic_SizeSelect self) -> Standard_Real

        returns Value as a Real (Null if another type)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.StepBasic_SizeSelect_RealValue(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_SizeSelect
StepBasic_SizeSelect_swigregister = _StepBasic.StepBasic_SizeSelect_swigregister
StepBasic_SizeSelect_swigregister(StepBasic_SizeSelect)

class StepBasic_ProductDefinitionOrReference(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepBasic_ProductDefinitionOrReference self) -> StepBasic_ProductDefinitionOrReference

        Returns a ProductDefinitionOrReference SelectType


        """
        this = _StepBasic.new_StepBasic_ProductDefinitionOrReference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepBasic_ProductDefinitionOrReference self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a ProductDefinitionOrReference Kind Entity that is :
        1 -> ProductDefinition
        2 -> ProductDefinitionReference
        3 -> ProductDefinitionReferenceWithLocalPresentation
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.StepBasic_ProductDefinitionOrReference_CaseNum(self, *args)


    def ProductDefinition(self, *args):
        """
        ProductDefinition(StepBasic_ProductDefinitionOrReference self) -> Handle_StepBasic_ProductDefinition

        returns Value as a ProductDefinition (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _StepBasic.StepBasic_ProductDefinitionOrReference_ProductDefinition(self, *args)


    def ProductDefinitionReference(self, *args):
        """
        ProductDefinitionReference(StepBasic_ProductDefinitionOrReference self) -> Handle_StepBasic_ProductDefinitionReference

        returns Value as a ProductDefinitionReference (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionReference

        """
        return _StepBasic.StepBasic_ProductDefinitionOrReference_ProductDefinitionReference(self, *args)


    def ProductDefinitionReferenceWithLocalRepresentation(self, *args):
        """
        ProductDefinitionReferenceWithLocalRepresentation(StepBasic_ProductDefinitionOrReference self) -> Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        returns Value as a ProductDefinitionReferenceWithLocalRepresentation (Null if another type)

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionReferenceWithLocalRepresentation

        """
        return _StepBasic.StepBasic_ProductDefinitionOrReference_ProductDefinitionReferenceWithLocalRepresentation(self, *args)

    __swig_destroy__ = _StepBasic.delete_StepBasic_ProductDefinitionOrReference
StepBasic_ProductDefinitionOrReference_swigregister = _StepBasic.StepBasic_ProductDefinitionOrReference_swigregister
StepBasic_ProductDefinitionOrReference_swigregister(StepBasic_ProductDefinitionOrReference)

class Handle_StepBasic_Document(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Document self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Document_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Document self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Document_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Document self, StepBasic_Document thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Document_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Document self, Handle_StepBasic_Document theHandle) -> Handle_StepBasic_Document
        assign(Handle_StepBasic_Document self, StepBasic_Document thePtr) -> Handle_StepBasic_Document
        assign(Handle_StepBasic_Document self, Handle_StepBasic_Document theHandle) -> Handle_StepBasic_Document

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Document_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Document self) -> StepBasic_Document

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Document_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Document self) -> StepBasic_Document

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Document___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Document self) -> StepBasic_Document

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Document___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Document___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Document___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Document_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Document

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Document self, Handle_TCollection_HAsciiString aId, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_DocumentType aKind)

        Initialize all fields (own and inherited)

        :type aId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aKind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_Document_Init(self, *args)


    def Id(self, *args):
        """
        Id(Handle_StepBasic_Document self) -> Handle_TCollection_HAsciiString

        Returns field Id

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Document_Id(self, *args)


    def SetId(self, *args):
        """
        SetId(Handle_StepBasic_Document self, Handle_TCollection_HAsciiString Id)

        Set field Id

        :type Id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Document_SetId(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_Document self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Document_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_Document self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Document_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_Document self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Document_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_Document self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Document_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_Document self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Document_HasDescription(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_Document self) -> Handle_StepBasic_DocumentType

        Returns field Kind

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_Document_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_Document self, Handle_StepBasic_DocumentType Kind)

        Set field Kind

        :type Kind: OCC.wrapper.StepBasic.Handle_StepBasic_DocumentType

        """
        return _StepBasic.Handle_StepBasic_Document_SetKind(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Document self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Document_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Document_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Document_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Document self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Document_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Document self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Document self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Document_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Document self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Document self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Document_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Document self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Document_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Document self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Document_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Document self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Document_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Document self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Document_DecrementRefCounter(self, *args)

Handle_StepBasic_Document_swigregister = _StepBasic.Handle_StepBasic_Document_swigregister
Handle_StepBasic_Document_swigregister(Handle_StepBasic_Document)

def Handle_StepBasic_Document_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Document_DownCast(thing)
Handle_StepBasic_Document_DownCast = _StepBasic.Handle_StepBasic_Document_DownCast

class Handle_StepBasic_OrganizationalAddress(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_OrganizationalAddress self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_OrganizationalAddress self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_OrganizationalAddress self, StepBasic_OrganizationalAddress thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_OrganizationalAddress self, Handle_StepBasic_OrganizationalAddress theHandle) -> Handle_StepBasic_OrganizationalAddress
        assign(Handle_StepBasic_OrganizationalAddress self, StepBasic_OrganizationalAddress thePtr) -> Handle_StepBasic_OrganizationalAddress
        assign(Handle_StepBasic_OrganizationalAddress self, Handle_StepBasic_OrganizationalAddress theHandle) -> Handle_StepBasic_OrganizationalAddress

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_OrganizationalAddress self) -> StepBasic_OrganizationalAddress

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_OrganizationalAddress self) -> StepBasic_OrganizationalAddress

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_OrganizationalAddress self) -> StepBasic_OrganizationalAddress

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_OrganizationalAddress___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_OrganizationalAddress___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_OrganizationalAddress(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_OrganizationalAddress_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_OrganizationalAddress

    def Init(self, *args):
        """
        Init(Handle_StepBasic_OrganizationalAddress self, Standard_Boolean const hasAinternalLocation, Handle_TCollection_HAsciiString aInternalLocation, Standard_Boolean const hasAstreetNumber, Handle_TCollection_HAsciiString aStreetNumber, Standard_Boolean const hasAstreet, Handle_TCollection_HAsciiString aStreet, Standard_Boolean const hasApostalBox, Handle_TCollection_HAsciiString aPostalBox, Standard_Boolean const hasAtown, Handle_TCollection_HAsciiString aTown, Standard_Boolean const hasAregion, Handle_TCollection_HAsciiString aRegion, Standard_Boolean const hasApostalCode, Handle_TCollection_HAsciiString aPostalCode, Standard_Boolean const hasAcountry, Handle_TCollection_HAsciiString aCountry, Standard_Boolean const hasAfacsimileNumber, Handle_TCollection_HAsciiString aFacsimileNumber, Standard_Boolean const hasAtelephoneNumber, Handle_TCollection_HAsciiString aTelephoneNumber, Standard_Boolean const hasAelectronicMailAddress, Handle_TCollection_HAsciiString aElectronicMailAddress, Standard_Boolean const hasAtelexNumber, Handle_TCollection_HAsciiString aTelexNumber, Handle_StepBasic_HArray1OfOrganization aOrganizations, Handle_TCollection_HAsciiString aDescription)

        :type hasAinternalLocation: bool
        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreetNumber: bool
        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAstreet: bool
        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalBox: bool
        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtown: bool
        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAregion: bool
        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasApostalCode: bool
        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAcountry: bool
        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAfacsimileNumber: bool
        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelephoneNumber: bool
        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAelectronicMailAddress: bool
        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasAtelexNumber: bool
        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOrganizations: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfOrganization
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Init(self, *args)


    def SetOrganizations(self, *args):
        """
        SetOrganizations(Handle_StepBasic_OrganizationalAddress self, Handle_StepBasic_HArray1OfOrganization aOrganizations)

        :type aOrganizations: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfOrganization

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetOrganizations(self, *args)


    def Organizations(self, *args):
        """
        Organizations(Handle_StepBasic_OrganizationalAddress self) -> Handle_StepBasic_HArray1OfOrganization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_HArray1OfOrganization

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Organizations(self, *args)


    def OrganizationsValue(self, *args):
        """
        OrganizationsValue(Handle_StepBasic_OrganizationalAddress self, Standard_Integer const num) -> Handle_StepBasic_Organization

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_OrganizationsValue(self, *args)


    def NbOrganizations(self, *args):
        """
        NbOrganizations(Handle_StepBasic_OrganizationalAddress self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_NbOrganizations(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Description(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_OrganizationalAddress self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrganizationalAddress_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_OrganizationalAddress_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInternalLocation(self, *args):
        """
        SetInternalLocation(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aInternalLocation)

        :type aInternalLocation: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetInternalLocation(self, *args)


    def UnSetInternalLocation(self, *args):
        """UnSetInternalLocation(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetInternalLocation(self, *args)


    def InternalLocation(self, *args):
        """
        InternalLocation(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_InternalLocation(self, *args)


    def HasInternalLocation(self, *args):
        """
        HasInternalLocation(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasInternalLocation(self, *args)


    def SetStreetNumber(self, *args):
        """
        SetStreetNumber(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aStreetNumber)

        :type aStreetNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetStreetNumber(self, *args)


    def UnSetStreetNumber(self, *args):
        """UnSetStreetNumber(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetStreetNumber(self, *args)


    def StreetNumber(self, *args):
        """
        StreetNumber(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_StreetNumber(self, *args)


    def HasStreetNumber(self, *args):
        """
        HasStreetNumber(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasStreetNumber(self, *args)


    def SetStreet(self, *args):
        """
        SetStreet(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aStreet)

        :type aStreet: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetStreet(self, *args)


    def UnSetStreet(self, *args):
        """UnSetStreet(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetStreet(self, *args)


    def Street(self, *args):
        """
        Street(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Street(self, *args)


    def HasStreet(self, *args):
        """
        HasStreet(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasStreet(self, *args)


    def SetPostalBox(self, *args):
        """
        SetPostalBox(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aPostalBox)

        :type aPostalBox: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetPostalBox(self, *args)


    def UnSetPostalBox(self, *args):
        """UnSetPostalBox(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetPostalBox(self, *args)


    def PostalBox(self, *args):
        """
        PostalBox(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_PostalBox(self, *args)


    def HasPostalBox(self, *args):
        """
        HasPostalBox(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasPostalBox(self, *args)


    def SetTown(self, *args):
        """
        SetTown(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aTown)

        :type aTown: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetTown(self, *args)


    def UnSetTown(self, *args):
        """UnSetTown(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetTown(self, *args)


    def Town(self, *args):
        """
        Town(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Town(self, *args)


    def HasTown(self, *args):
        """
        HasTown(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasTown(self, *args)


    def SetRegion(self, *args):
        """
        SetRegion(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aRegion)

        :type aRegion: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetRegion(self, *args)


    def UnSetRegion(self, *args):
        """UnSetRegion(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetRegion(self, *args)


    def Region(self, *args):
        """
        Region(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Region(self, *args)


    def HasRegion(self, *args):
        """
        HasRegion(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasRegion(self, *args)


    def SetPostalCode(self, *args):
        """
        SetPostalCode(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aPostalCode)

        :type aPostalCode: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetPostalCode(self, *args)


    def UnSetPostalCode(self, *args):
        """UnSetPostalCode(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetPostalCode(self, *args)


    def PostalCode(self, *args):
        """
        PostalCode(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_PostalCode(self, *args)


    def HasPostalCode(self, *args):
        """
        HasPostalCode(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasPostalCode(self, *args)


    def SetCountry(self, *args):
        """
        SetCountry(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aCountry)

        :type aCountry: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetCountry(self, *args)


    def UnSetCountry(self, *args):
        """UnSetCountry(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetCountry(self, *args)


    def Country(self, *args):
        """
        Country(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Country(self, *args)


    def HasCountry(self, *args):
        """
        HasCountry(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasCountry(self, *args)


    def SetFacsimileNumber(self, *args):
        """
        SetFacsimileNumber(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aFacsimileNumber)

        :type aFacsimileNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetFacsimileNumber(self, *args)


    def UnSetFacsimileNumber(self, *args):
        """UnSetFacsimileNumber(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetFacsimileNumber(self, *args)


    def FacsimileNumber(self, *args):
        """
        FacsimileNumber(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_FacsimileNumber(self, *args)


    def HasFacsimileNumber(self, *args):
        """
        HasFacsimileNumber(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasFacsimileNumber(self, *args)


    def SetTelephoneNumber(self, *args):
        """
        SetTelephoneNumber(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aTelephoneNumber)

        :type aTelephoneNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetTelephoneNumber(self, *args)


    def UnSetTelephoneNumber(self, *args):
        """UnSetTelephoneNumber(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetTelephoneNumber(self, *args)


    def TelephoneNumber(self, *args):
        """
        TelephoneNumber(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_TelephoneNumber(self, *args)


    def HasTelephoneNumber(self, *args):
        """
        HasTelephoneNumber(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasTelephoneNumber(self, *args)


    def SetElectronicMailAddress(self, *args):
        """
        SetElectronicMailAddress(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aElectronicMailAddress)

        :type aElectronicMailAddress: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetElectronicMailAddress(self, *args)


    def UnSetElectronicMailAddress(self, *args):
        """UnSetElectronicMailAddress(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetElectronicMailAddress(self, *args)


    def ElectronicMailAddress(self, *args):
        """
        ElectronicMailAddress(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_ElectronicMailAddress(self, *args)


    def HasElectronicMailAddress(self, *args):
        """
        HasElectronicMailAddress(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasElectronicMailAddress(self, *args)


    def SetTelexNumber(self, *args):
        """
        SetTelexNumber(Handle_StepBasic_OrganizationalAddress self, Handle_TCollection_HAsciiString aTelexNumber)

        :type aTelexNumber: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_SetTelexNumber(self, *args)


    def UnSetTelexNumber(self, *args):
        """UnSetTelexNumber(Handle_StepBasic_OrganizationalAddress self)"""
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_UnSetTelexNumber(self, *args)


    def TelexNumber(self, *args):
        """
        TelexNumber(Handle_StepBasic_OrganizationalAddress self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_TelexNumber(self, *args)


    def HasTelexNumber(self, *args):
        """
        HasTelexNumber(Handle_StepBasic_OrganizationalAddress self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_HasTelexNumber(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_OrganizationalAddress self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_OrganizationalAddress self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_OrganizationalAddress self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_OrganizationalAddress self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_OrganizationalAddress self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_OrganizationalAddress self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_OrganizationalAddress self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_OrganizationalAddress self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_OrganizationalAddress self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_OrganizationalAddress_DecrementRefCounter(self, *args)

Handle_StepBasic_OrganizationalAddress_swigregister = _StepBasic.Handle_StepBasic_OrganizationalAddress_swigregister
Handle_StepBasic_OrganizationalAddress_swigregister(Handle_StepBasic_OrganizationalAddress)

def Handle_StepBasic_OrganizationalAddress_DownCast(thing):
    return _StepBasic.Handle_StepBasic_OrganizationalAddress_DownCast(thing)
Handle_StepBasic_OrganizationalAddress_DownCast = _StepBasic.Handle_StepBasic_OrganizationalAddress_DownCast

class NCollection_Array1_Handle_StepBasic_ProductContext(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_ProductContext self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductContext > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_ProductContext self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductContext > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_ProductContext self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductContext > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_ProductContext self) -> NCollection_Array1< opencascade::handle< StepBasic_ProductContext > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_ProductContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_ProductContext self, Handle_StepBasic_ProductContext theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_ProductContext self, NCollection_Array1_Handle_StepBasic_ProductContext theOther) -> NCollection_Array1_Handle_StepBasic_ProductContext

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_ProductContext self, NCollection_Array1_Handle_StepBasic_ProductContext theOther) -> NCollection_Array1_Handle_StepBasic_ProductContext

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_ProductContext self, NCollection_Array1_Handle_StepBasic_ProductContext theOther) -> NCollection_Array1_Handle_StepBasic_ProductContext
        assign(NCollection_Array1_Handle_StepBasic_ProductContext self, NCollection_Array1_Handle_StepBasic_ProductContext theOther) -> NCollection_Array1_Handle_StepBasic_ProductContext

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Handle_StepBasic_ProductContext

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_ProductContext self) -> Handle_StepBasic_ProductContext

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_ProductContext self, Standard_Integer const theIndex) -> Handle_StepBasic_ProductContext

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_ProductContext self, Standard_Integer const theIndex, Handle_StepBasic_ProductContext theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_ProductContext self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_ProductContext
NCollection_Array1_Handle_StepBasic_ProductContext_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_ProductContext_swigregister
NCollection_Array1_Handle_StepBasic_ProductContext_swigregister(NCollection_Array1_Handle_StepBasic_ProductContext)


try:
	StepBasic_Array1OfProductContext = NCollection_Array1_Handle_StepBasic_ProductContext
except NameError:
	pass # does not exist, probably ignored

class Handle_StepBasic_DocumentProductEquivalence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentProductEquivalence self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentProductEquivalence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentProductEquivalence self, StepBasic_DocumentProductEquivalence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentProductEquivalence self, Handle_StepBasic_DocumentProductEquivalence theHandle) -> Handle_StepBasic_DocumentProductEquivalence
        assign(Handle_StepBasic_DocumentProductEquivalence self, StepBasic_DocumentProductEquivalence thePtr) -> Handle_StepBasic_DocumentProductEquivalence
        assign(Handle_StepBasic_DocumentProductEquivalence self, Handle_StepBasic_DocumentProductEquivalence theHandle) -> Handle_StepBasic_DocumentProductEquivalence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentProductEquivalence self) -> StepBasic_DocumentProductEquivalence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentProductEquivalence self) -> StepBasic_DocumentProductEquivalence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentProductEquivalence self) -> StepBasic_DocumentProductEquivalence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentProductEquivalence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentProductEquivalence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentProductEquivalence_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentProductEquivalence

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentProductEquivalence self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentProductEquivalence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentProductEquivalence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentProductEquivalence self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Document aRelatingDocument, StepBasic_ProductOrFormationOrDefinition aRelatedProduct)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aRelatedProduct: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DocumentProductEquivalence self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DocumentProductEquivalence self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_DocumentProductEquivalence self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_DocumentProductEquivalence self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_DocumentProductEquivalence self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_HasDescription(self, *args)


    def RelatingDocument(self, *args):
        """
        RelatingDocument(Handle_StepBasic_DocumentProductEquivalence self) -> Handle_StepBasic_Document

        Returns field RelatingDocument

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_RelatingDocument(self, *args)


    def SetRelatingDocument(self, *args):
        """
        SetRelatingDocument(Handle_StepBasic_DocumentProductEquivalence self, Handle_StepBasic_Document RelatingDocument)

        Set field RelatingDocument

        :type RelatingDocument: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_SetRelatingDocument(self, *args)


    def RelatedProduct(self, *args):
        """
        RelatedProduct(Handle_StepBasic_DocumentProductEquivalence self) -> StepBasic_ProductOrFormationOrDefinition

        Returns field RelatedProduct

        :rtype: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_RelatedProduct(self, *args)


    def SetRelatedProduct(self, *args):
        """
        SetRelatedProduct(Handle_StepBasic_DocumentProductEquivalence self, StepBasic_ProductOrFormationOrDefinition RelatedProduct)

        Set field RelatedProduct

        :type RelatedProduct: OCC.wrapper.StepBasic.StepBasic_ProductOrFormationOrDefinition

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_SetRelatedProduct(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentProductEquivalence self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentProductEquivalence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentProductEquivalence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentProductEquivalence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentProductEquivalence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentProductEquivalence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentProductEquivalence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentProductEquivalence self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentProductEquivalence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentProductEquivalence_swigregister = _StepBasic.Handle_StepBasic_DocumentProductEquivalence_swigregister
Handle_StepBasic_DocumentProductEquivalence_swigregister(Handle_StepBasic_DocumentProductEquivalence)

def Handle_StepBasic_DocumentProductEquivalence_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentProductEquivalence_DownCast(thing)
Handle_StepBasic_DocumentProductEquivalence_DownCast = _StepBasic.Handle_StepBasic_DocumentProductEquivalence_DownCast

class Handle_StepBasic_ApprovalRole(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApprovalRole self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApprovalRole self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApprovalRole self, StepBasic_ApprovalRole thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApprovalRole self, Handle_StepBasic_ApprovalRole theHandle) -> Handle_StepBasic_ApprovalRole
        assign(Handle_StepBasic_ApprovalRole self, StepBasic_ApprovalRole thePtr) -> Handle_StepBasic_ApprovalRole
        assign(Handle_StepBasic_ApprovalRole self, Handle_StepBasic_ApprovalRole theHandle) -> Handle_StepBasic_ApprovalRole

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApprovalRole self) -> StepBasic_ApprovalRole

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApprovalRole self) -> StepBasic_ApprovalRole

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApprovalRole self) -> StepBasic_ApprovalRole

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApprovalRole___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApprovalRole___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApprovalRole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApprovalRole_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApprovalRole

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApprovalRole self, Handle_TCollection_HAsciiString aRole)

        :type aRole: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_Init(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_ApprovalRole self, Handle_TCollection_HAsciiString aRole)

        :type aRole: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_ApprovalRole self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_Role(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApprovalRole self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalRole_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalRole_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApprovalRole self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApprovalRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApprovalRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApprovalRole self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApprovalRole self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApprovalRole self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApprovalRole self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApprovalRole self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApprovalRole self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalRole_DecrementRefCounter(self, *args)

Handle_StepBasic_ApprovalRole_swigregister = _StepBasic.Handle_StepBasic_ApprovalRole_swigregister
Handle_StepBasic_ApprovalRole_swigregister(Handle_StepBasic_ApprovalRole)

def Handle_StepBasic_ApprovalRole_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApprovalRole_DownCast(thing)
Handle_StepBasic_ApprovalRole_DownCast = _StepBasic.Handle_StepBasic_ApprovalRole_DownCast

class Handle_StepBasic_DocumentRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentRelationship self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentRelationship self, StepBasic_DocumentRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentRelationship self, Handle_StepBasic_DocumentRelationship theHandle) -> Handle_StepBasic_DocumentRelationship
        assign(Handle_StepBasic_DocumentRelationship self, StepBasic_DocumentRelationship thePtr) -> Handle_StepBasic_DocumentRelationship
        assign(Handle_StepBasic_DocumentRelationship self, Handle_StepBasic_DocumentRelationship theHandle) -> Handle_StepBasic_DocumentRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentRelationship self) -> StepBasic_DocumentRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentRelationship self) -> StepBasic_DocumentRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentRelationship self) -> StepBasic_DocumentRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentRelationship_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentRelationship

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentRelationship self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Document aRelating, Handle_StepBasic_Document aRelated)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelating: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type aRelated: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_DocumentRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_DocumentRelationship self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_DocumentRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_DocumentRelationship self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_SetDescription(self, *args)


    def RelatingDocument(self, *args):
        """
        RelatingDocument(Handle_StepBasic_DocumentRelationship self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_RelatingDocument(self, *args)


    def SetRelatingDocument(self, *args):
        """
        SetRelatingDocument(Handle_StepBasic_DocumentRelationship self, Handle_StepBasic_Document aRelating)

        :type aRelating: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_SetRelatingDocument(self, *args)


    def RelatedDocument(self, *args):
        """
        RelatedDocument(Handle_StepBasic_DocumentRelationship self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_RelatedDocument(self, *args)


    def SetRelatedDocument(self, *args):
        """
        SetRelatedDocument(Handle_StepBasic_DocumentRelationship self, Handle_StepBasic_Document aRelated)

        :type aRelated: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_SetRelatedDocument(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentRelationship self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentRelationship self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentRelationship_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentRelationship_swigregister = _StepBasic.Handle_StepBasic_DocumentRelationship_swigregister
Handle_StepBasic_DocumentRelationship_swigregister(Handle_StepBasic_DocumentRelationship)

def Handle_StepBasic_DocumentRelationship_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentRelationship_DownCast(thing)
Handle_StepBasic_DocumentRelationship_DownCast = _StepBasic.Handle_StepBasic_DocumentRelationship_DownCast

class Handle_StepBasic_RatioUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_RatioUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_RatioUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_RatioUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_RatioUnit self, StepBasic_RatioUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_RatioUnit self, Handle_StepBasic_RatioUnit theHandle) -> Handle_StepBasic_RatioUnit
        assign(Handle_StepBasic_RatioUnit self, StepBasic_RatioUnit thePtr) -> Handle_StepBasic_RatioUnit
        assign(Handle_StepBasic_RatioUnit self, Handle_StepBasic_RatioUnit theHandle) -> Handle_StepBasic_RatioUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_RatioUnit self) -> StepBasic_RatioUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_RatioUnit self) -> StepBasic_RatioUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_RatioUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_RatioUnit self) -> StepBasic_RatioUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_RatioUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_RatioUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_RatioUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_RatioUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_RatioUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_RatioUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_RatioUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_RatioUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_RatioUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_RatioUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_RatioUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_RatioUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_RatioUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_RatioUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_RatioUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_RatioUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_RatioUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_RatioUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_RatioUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_RatioUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_RatioUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_RatioUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_RatioUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_RatioUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_RatioUnit_swigregister = _StepBasic.Handle_StepBasic_RatioUnit_swigregister
Handle_StepBasic_RatioUnit_swigregister(Handle_StepBasic_RatioUnit)

def Handle_StepBasic_RatioUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_RatioUnit_DownCast(thing)
Handle_StepBasic_RatioUnit_DownCast = _StepBasic.Handle_StepBasic_RatioUnit_DownCast

class Handle_StepBasic_PersonAndOrganization(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_PersonAndOrganization self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_PersonAndOrganization self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_PersonAndOrganization self, StepBasic_PersonAndOrganization thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_PersonAndOrganization self, Handle_StepBasic_PersonAndOrganization theHandle) -> Handle_StepBasic_PersonAndOrganization
        assign(Handle_StepBasic_PersonAndOrganization self, StepBasic_PersonAndOrganization thePtr) -> Handle_StepBasic_PersonAndOrganization
        assign(Handle_StepBasic_PersonAndOrganization self, Handle_StepBasic_PersonAndOrganization theHandle) -> Handle_StepBasic_PersonAndOrganization

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_PersonAndOrganization self) -> StepBasic_PersonAndOrganization

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_PersonAndOrganization self) -> StepBasic_PersonAndOrganization

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_PersonAndOrganization self) -> StepBasic_PersonAndOrganization

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_PersonAndOrganization___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_PersonAndOrganization___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_PersonAndOrganization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_PersonAndOrganization_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_PersonAndOrganization

    def Init(self, *args):
        """
        Init(Handle_StepBasic_PersonAndOrganization self, Handle_StepBasic_Person aThePerson, Handle_StepBasic_Organization aTheOrganization)

        :type aThePerson: OCC.wrapper.StepBasic.Handle_StepBasic_Person
        :type aTheOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_Init(self, *args)


    def SetThePerson(self, *args):
        """
        SetThePerson(Handle_StepBasic_PersonAndOrganization self, Handle_StepBasic_Person aThePerson)

        :type aThePerson: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_SetThePerson(self, *args)


    def ThePerson(self, *args):
        """
        ThePerson(Handle_StepBasic_PersonAndOrganization self) -> Handle_StepBasic_Person

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Person

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_ThePerson(self, *args)


    def SetTheOrganization(self, *args):
        """
        SetTheOrganization(Handle_StepBasic_PersonAndOrganization self, Handle_StepBasic_Organization aTheOrganization)

        :type aTheOrganization: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_SetTheOrganization(self, *args)


    def TheOrganization(self, *args):
        """
        TheOrganization(Handle_StepBasic_PersonAndOrganization self) -> Handle_StepBasic_Organization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Organization

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_TheOrganization(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_PersonAndOrganization self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonAndOrganization_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_PersonAndOrganization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_PersonAndOrganization self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_PersonAndOrganization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_PersonAndOrganization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_PersonAndOrganization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_PersonAndOrganization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_PersonAndOrganization self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_PersonAndOrganization self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_PersonAndOrganization self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_PersonAndOrganization self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_PersonAndOrganization_DecrementRefCounter(self, *args)

Handle_StepBasic_PersonAndOrganization_swigregister = _StepBasic.Handle_StepBasic_PersonAndOrganization_swigregister
Handle_StepBasic_PersonAndOrganization_swigregister(Handle_StepBasic_PersonAndOrganization)

def Handle_StepBasic_PersonAndOrganization_DownCast(thing):
    return _StepBasic.Handle_StepBasic_PersonAndOrganization_DownCast(thing)
Handle_StepBasic_PersonAndOrganization_DownCast = _StepBasic.Handle_StepBasic_PersonAndOrganization_DownCast

class Handle_StepBasic_SiUnitAndRatioUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_SiUnitAndRatioUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_SiUnitAndRatioUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_SiUnitAndRatioUnit self, StepBasic_SiUnitAndRatioUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_SiUnitAndRatioUnit self, Handle_StepBasic_SiUnitAndRatioUnit theHandle) -> Handle_StepBasic_SiUnitAndRatioUnit
        assign(Handle_StepBasic_SiUnitAndRatioUnit self, StepBasic_SiUnitAndRatioUnit thePtr) -> Handle_StepBasic_SiUnitAndRatioUnit
        assign(Handle_StepBasic_SiUnitAndRatioUnit self, Handle_StepBasic_SiUnitAndRatioUnit theHandle) -> Handle_StepBasic_SiUnitAndRatioUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_SiUnitAndRatioUnit self) -> StepBasic_SiUnitAndRatioUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_SiUnitAndRatioUnit self) -> StepBasic_SiUnitAndRatioUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_SiUnitAndRatioUnit self) -> StepBasic_SiUnitAndRatioUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_SiUnitAndRatioUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_SiUnitAndRatioUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_SiUnitAndRatioUnit self, Standard_Boolean const hasAprefix, StepBasic_SiPrefix const aPrefix, StepBasic_SiUnitName const aName)

        :type hasAprefix: bool
        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_Init(self, *args)


    def SetRatioUnit(self, *args):
        """
        SetRatioUnit(Handle_StepBasic_SiUnitAndRatioUnit self, Handle_StepBasic_RatioUnit aRatioUnit)

        :type aRatioUnit: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_SetRatioUnit(self, *args)


    def RatioUnit(self, *args):
        """
        RatioUnit(Handle_StepBasic_SiUnitAndRatioUnit self) -> Handle_StepBasic_RatioUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_RatioUnit

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_RatioUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_SiUnitAndRatioUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_StepBasic_SiUnitAndRatioUnit self, StepBasic_SiPrefix const aPrefix)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_SetPrefix(self, *args)


    def UnSetPrefix(self, *args):
        """UnSetPrefix(Handle_StepBasic_SiUnitAndRatioUnit self)"""
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_UnSetPrefix(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_StepBasic_SiUnitAndRatioUnit self) -> StepBasic_SiPrefix

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiPrefix

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_Prefix(self, *args)


    def HasPrefix(self, *args):
        """
        HasPrefix(Handle_StepBasic_SiUnitAndRatioUnit self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_HasPrefix(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_SiUnitAndRatioUnit self, StepBasic_SiUnitName const aName)

        :type aName: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_SiUnitAndRatioUnit self) -> StepBasic_SiUnitName

        :rtype: OCC.wrapper.StepBasic.StepBasic_SiUnitName

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_Name(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_SiUnitAndRatioUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_SiUnitAndRatioUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_SiUnitAndRatioUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_SiUnitAndRatioUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_SiUnitAndRatioUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_SiUnitAndRatioUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_SiUnitAndRatioUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_SiUnitAndRatioUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_SiUnitAndRatioUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_SiUnitAndRatioUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_SiUnitAndRatioUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_SiUnitAndRatioUnit_swigregister = _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_swigregister
Handle_StepBasic_SiUnitAndRatioUnit_swigregister(Handle_StepBasic_SiUnitAndRatioUnit)

def Handle_StepBasic_SiUnitAndRatioUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_DownCast(thing)
Handle_StepBasic_SiUnitAndRatioUnit_DownCast = _StepBasic.Handle_StepBasic_SiUnitAndRatioUnit_DownCast

class NCollection_Array1_Handle_StepBasic_Organization(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_Organization self) -> NCollection_Array1< opencascade::handle< StepBasic_Organization > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_Organization self) -> NCollection_Array1< opencascade::handle< StepBasic_Organization > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_Organization self) -> NCollection_Array1< opencascade::handle< StepBasic_Organization > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_Organization self) -> NCollection_Array1< opencascade::handle< StepBasic_Organization > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_Organization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_Organization self, Handle_StepBasic_Organization theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_Organization self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_Organization self, NCollection_Array1_Handle_StepBasic_Organization theOther) -> NCollection_Array1_Handle_StepBasic_Organization

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_Organization self, NCollection_Array1_Handle_StepBasic_Organization theOther) -> NCollection_Array1_Handle_StepBasic_Organization

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_Organization self, NCollection_Array1_Handle_StepBasic_Organization theOther) -> NCollection_Array1_Handle_StepBasic_Organization
        assign(NCollection_Array1_Handle_StepBasic_Organization self, NCollection_Array1_Handle_StepBasic_Organization theOther) -> NCollection_Array1_Handle_StepBasic_Organization

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_Organization self) -> Handle_StepBasic_Organization

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_Organization self) -> Handle_StepBasic_Organization

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_Organization self, Standard_Integer const theIndex) -> Handle_StepBasic_Organization

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Organization___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_Organization self, Standard_Integer const theIndex, Handle_StepBasic_Organization theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_Organization self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_Organization
NCollection_Array1_Handle_StepBasic_Organization_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_Organization_swigregister
NCollection_Array1_Handle_StepBasic_Organization_swigregister(NCollection_Array1_Handle_StepBasic_Organization)


try:
	StepBasic_Array1OfOrganization = NCollection_Array1_Handle_StepBasic_Organization
except NameError:
	pass # does not exist, probably ignored

class StepBasic_ApprovalPersonOrganization(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_ApprovalPersonOrganization
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_ApprovalPersonOrganization(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_ApprovalPersonOrganization self) -> StepBasic_ApprovalPersonOrganization

        Returns a ApprovalPersonOrganization


        """
        this = _StepBasic.new_StepBasic_ApprovalPersonOrganization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_ApprovalPersonOrganization self, StepBasic_PersonOrganizationSelect aPersonOrganization, Handle_StepBasic_Approval aAuthorizedApproval, Handle_StepBasic_ApprovalRole aRole)

        :type aPersonOrganization: OCC.wrapper.StepBasic.StepBasic_PersonOrganizationSelect
        :type aAuthorizedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_Init(self, *args)


    def SetPersonOrganization(self, *args):
        """
        SetPersonOrganization(StepBasic_ApprovalPersonOrganization self, StepBasic_PersonOrganizationSelect aPersonOrganization)

        :type aPersonOrganization: OCC.wrapper.StepBasic.StepBasic_PersonOrganizationSelect

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_SetPersonOrganization(self, *args)


    def PersonOrganization(self, *args):
        """
        PersonOrganization(StepBasic_ApprovalPersonOrganization self) -> StepBasic_PersonOrganizationSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_PersonOrganizationSelect

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_PersonOrganization(self, *args)


    def SetAuthorizedApproval(self, *args):
        """
        SetAuthorizedApproval(StepBasic_ApprovalPersonOrganization self, Handle_StepBasic_Approval aAuthorizedApproval)

        :type aAuthorizedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_SetAuthorizedApproval(self, *args)


    def AuthorizedApproval(self, *args):
        """
        AuthorizedApproval(StepBasic_ApprovalPersonOrganization self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_AuthorizedApproval(self, *args)


    def SetRole(self, *args):
        """
        SetRole(StepBasic_ApprovalPersonOrganization self, Handle_StepBasic_ApprovalRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(StepBasic_ApprovalPersonOrganization self) -> Handle_StepBasic_ApprovalRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_Role(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_ApprovalPersonOrganization_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_ApprovalPersonOrganization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_ApprovalPersonOrganization
StepBasic_ApprovalPersonOrganization_swigregister = _StepBasic.StepBasic_ApprovalPersonOrganization_swigregister
StepBasic_ApprovalPersonOrganization_swigregister(StepBasic_ApprovalPersonOrganization)

def StepBasic_ApprovalPersonOrganization_get_type_name(*args):
    """
    StepBasic_ApprovalPersonOrganization_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_ApprovalPersonOrganization_get_type_name(*args)

def StepBasic_ApprovalPersonOrganization_get_type_descriptor(*args):
    """
    StepBasic_ApprovalPersonOrganization_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_ApprovalPersonOrganization_get_type_descriptor(*args)

class Handle_StepBasic_ConversionBasedUnitAndLengthUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, StepBasic_ConversionBasedUnitAndLengthUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_ConversionBasedUnitAndLengthUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndLengthUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, StepBasic_ConversionBasedUnitAndLengthUnit thePtr) -> Handle_StepBasic_ConversionBasedUnitAndLengthUnit
        assign(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_ConversionBasedUnitAndLengthUnit theHandle) -> Handle_StepBasic_ConversionBasedUnitAndLengthUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> StepBasic_ConversionBasedUnitAndLengthUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> StepBasic_ConversionBasedUnitAndLengthUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> StepBasic_ConversionBasedUnitAndLengthUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ConversionBasedUnitAndLengthUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ConversionBasedUnitAndLengthUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_DimensionalExponents aDimensions, Handle_TCollection_HAsciiString aName, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_Init(self, *args)


    def SetLengthUnit(self, *args):
        """
        SetLengthUnit(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_LengthUnit aLengthUnit)

        :type aLengthUnit: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_SetLengthUnit(self, *args)


    def LengthUnit(self, *args):
        """
        LengthUnit(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Handle_StepBasic_LengthUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_LengthUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_LengthUnit(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_Name(self, *args)


    def SetConversionFactor(self, *args):
        """
        SetConversionFactor(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_MeasureWithUnit aConversionFactor)

        :type aConversionFactor: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_SetConversionFactor(self, *args)


    def ConversionFactor(self, *args):
        """
        ConversionFactor(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Handle_StepBasic_MeasureWithUnit

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureWithUnit

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_ConversionFactor(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ConversionBasedUnitAndLengthUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ConversionBasedUnitAndLengthUnit_swigregister = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_swigregister
Handle_StepBasic_ConversionBasedUnitAndLengthUnit_swigregister(Handle_StepBasic_ConversionBasedUnitAndLengthUnit)

def Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DownCast(thing)
Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DownCast = _StepBasic.Handle_StepBasic_ConversionBasedUnitAndLengthUnit_DownCast

class Handle_StepBasic_NamedUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_NamedUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_NamedUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_NamedUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_NamedUnit self, StepBasic_NamedUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_NamedUnit self, Handle_StepBasic_NamedUnit theHandle) -> Handle_StepBasic_NamedUnit
        assign(Handle_StepBasic_NamedUnit self, StepBasic_NamedUnit thePtr) -> Handle_StepBasic_NamedUnit
        assign(Handle_StepBasic_NamedUnit self, Handle_StepBasic_NamedUnit theHandle) -> Handle_StepBasic_NamedUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_NamedUnit self) -> StepBasic_NamedUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_NamedUnit self) -> StepBasic_NamedUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_NamedUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_NamedUnit self) -> StepBasic_NamedUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_NamedUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_NamedUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_NamedUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_NamedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_NamedUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_NamedUnit

    def Init(self, *args):
        """
        Init(Handle_StepBasic_NamedUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_NamedUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_NamedUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_Dimensions(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_NamedUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_NamedUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_NamedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_NamedUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_NamedUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_NamedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_NamedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_NamedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_NamedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_NamedUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_NamedUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_NamedUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_NamedUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_NamedUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_NamedUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_NamedUnit_swigregister = _StepBasic.Handle_StepBasic_NamedUnit_swigregister
Handle_StepBasic_NamedUnit_swigregister(Handle_StepBasic_NamedUnit)

def Handle_StepBasic_NamedUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_NamedUnit_DownCast(thing)
Handle_StepBasic_NamedUnit_DownCast = _StepBasic.Handle_StepBasic_NamedUnit_DownCast

class Handle_StepBasic_ProductCategoryRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductCategoryRelationship self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductCategoryRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductCategoryRelationship self, StepBasic_ProductCategoryRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductCategoryRelationship self, Handle_StepBasic_ProductCategoryRelationship theHandle) -> Handle_StepBasic_ProductCategoryRelationship
        assign(Handle_StepBasic_ProductCategoryRelationship self, StepBasic_ProductCategoryRelationship thePtr) -> Handle_StepBasic_ProductCategoryRelationship
        assign(Handle_StepBasic_ProductCategoryRelationship self, Handle_StepBasic_ProductCategoryRelationship theHandle) -> Handle_StepBasic_ProductCategoryRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductCategoryRelationship self) -> StepBasic_ProductCategoryRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductCategoryRelationship self) -> StepBasic_ProductCategoryRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductCategoryRelationship self) -> StepBasic_ProductCategoryRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductCategoryRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductCategoryRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductCategoryRelationship_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductCategoryRelationship

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductCategoryRelationship self, Handle_TCollection_HAsciiString aName, Standard_Boolean const hasDescription, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_ProductCategory aCategory, Handle_StepBasic_ProductCategory aSubCategory)

        Initialize all fields (own and inherited)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type hasDescription: bool
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCategory: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory
        :type aSubCategory: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_Init(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductCategoryRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductCategoryRelationship self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ProductCategoryRelationship self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ProductCategoryRelationship self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepBasic_ProductCategoryRelationship self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_HasDescription(self, *args)


    def Category(self, *args):
        """
        Category(Handle_StepBasic_ProductCategoryRelationship self) -> Handle_StepBasic_ProductCategory

        Returns field Category

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_Category(self, *args)


    def SetCategory(self, *args):
        """
        SetCategory(Handle_StepBasic_ProductCategoryRelationship self, Handle_StepBasic_ProductCategory Category)

        Set field Category

        :type Category: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_SetCategory(self, *args)


    def SubCategory(self, *args):
        """
        SubCategory(Handle_StepBasic_ProductCategoryRelationship self) -> Handle_StepBasic_ProductCategory

        Returns field SubCategory

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_SubCategory(self, *args)


    def SetSubCategory(self, *args):
        """
        SetSubCategory(Handle_StepBasic_ProductCategoryRelationship self, Handle_StepBasic_ProductCategory SubCategory)

        Set field SubCategory

        :type SubCategory: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategory

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_SetSubCategory(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductCategoryRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductCategoryRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductCategoryRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductCategoryRelationship self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductCategoryRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductCategoryRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductCategoryRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductCategoryRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductCategoryRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductCategoryRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductCategoryRelationship self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductCategoryRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductCategoryRelationship_swigregister = _StepBasic.Handle_StepBasic_ProductCategoryRelationship_swigregister
Handle_StepBasic_ProductCategoryRelationship_swigregister(Handle_StepBasic_ProductCategoryRelationship)

def Handle_StepBasic_ProductCategoryRelationship_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductCategoryRelationship_DownCast(thing)
Handle_StepBasic_ProductCategoryRelationship_DownCast = _StepBasic.Handle_StepBasic_ProductCategoryRelationship_DownCast

class Handle_StepBasic_MeasureValueMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_MeasureValueMember self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_MeasureValueMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_MeasureValueMember self, StepBasic_MeasureValueMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_MeasureValueMember self, Handle_StepBasic_MeasureValueMember theHandle) -> Handle_StepBasic_MeasureValueMember
        assign(Handle_StepBasic_MeasureValueMember self, StepBasic_MeasureValueMember thePtr) -> Handle_StepBasic_MeasureValueMember
        assign(Handle_StepBasic_MeasureValueMember self, Handle_StepBasic_MeasureValueMember theHandle) -> Handle_StepBasic_MeasureValueMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_MeasureValueMember self) -> StepBasic_MeasureValueMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_MeasureValueMember self) -> StepBasic_MeasureValueMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_MeasureValueMember self) -> StepBasic_MeasureValueMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_MeasureValueMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_MeasureValueMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_MeasureValueMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_MeasureValueMember_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_MeasureValueMember

    def HasName(self, *args):
        """
        HasName(Handle_StepBasic_MeasureValueMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_MeasureValueMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_MeasureValueMember self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_MeasureValueMember self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MeasureValueMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_MeasureValueMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Kind(self, *args):
        """
        Kind(Handle_StepBasic_MeasureValueMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Kind(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepBasic_MeasureValueMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepBasic_MeasureValueMember self, Standard_Real const val)

        :type val: float

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetReal(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepBasic_MeasureValueMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Matches(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepBasic_MeasureValueMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetKind(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepBasic_MeasureValueMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_ParamType(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepBasic_MeasureValueMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepBasic_MeasureValueMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetInt(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepBasic_MeasureValueMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepBasic_MeasureValueMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepBasic_MeasureValueMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepBasic_MeasureValueMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepBasic_MeasureValueMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepBasic_MeasureValueMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetLogical(self, *args)


    def String(self, *args):
        """
        String(Handle_StepBasic_MeasureValueMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepBasic_MeasureValueMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepBasic_MeasureValueMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepBasic_MeasureValueMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepBasic_MeasureValueMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepBasic_MeasureValueMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_MeasureValueMember self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_MeasureValueMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_MeasureValueMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_MeasureValueMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_MeasureValueMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_MeasureValueMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_MeasureValueMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_MeasureValueMember self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_MeasureValueMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_MeasureValueMember_DecrementRefCounter(self, *args)

Handle_StepBasic_MeasureValueMember_swigregister = _StepBasic.Handle_StepBasic_MeasureValueMember_swigregister
Handle_StepBasic_MeasureValueMember_swigregister(Handle_StepBasic_MeasureValueMember)

def Handle_StepBasic_MeasureValueMember_DownCast(thing):
    return _StepBasic.Handle_StepBasic_MeasureValueMember_DownCast(thing)
Handle_StepBasic_MeasureValueMember_DownCast = _StepBasic.Handle_StepBasic_MeasureValueMember_DownCast

class Handle_StepBasic_ApprovalPersonOrganization(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApprovalPersonOrganization self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApprovalPersonOrganization self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApprovalPersonOrganization self, StepBasic_ApprovalPersonOrganization thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApprovalPersonOrganization self, Handle_StepBasic_ApprovalPersonOrganization theHandle) -> Handle_StepBasic_ApprovalPersonOrganization
        assign(Handle_StepBasic_ApprovalPersonOrganization self, StepBasic_ApprovalPersonOrganization thePtr) -> Handle_StepBasic_ApprovalPersonOrganization
        assign(Handle_StepBasic_ApprovalPersonOrganization self, Handle_StepBasic_ApprovalPersonOrganization theHandle) -> Handle_StepBasic_ApprovalPersonOrganization

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApprovalPersonOrganization self) -> StepBasic_ApprovalPersonOrganization

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApprovalPersonOrganization self) -> StepBasic_ApprovalPersonOrganization

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApprovalPersonOrganization self) -> StepBasic_ApprovalPersonOrganization

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApprovalPersonOrganization(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApprovalPersonOrganization_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApprovalPersonOrganization

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApprovalPersonOrganization self, StepBasic_PersonOrganizationSelect aPersonOrganization, Handle_StepBasic_Approval aAuthorizedApproval, Handle_StepBasic_ApprovalRole aRole)

        :type aPersonOrganization: OCC.wrapper.StepBasic.StepBasic_PersonOrganizationSelect
        :type aAuthorizedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_Init(self, *args)


    def SetPersonOrganization(self, *args):
        """
        SetPersonOrganization(Handle_StepBasic_ApprovalPersonOrganization self, StepBasic_PersonOrganizationSelect aPersonOrganization)

        :type aPersonOrganization: OCC.wrapper.StepBasic.StepBasic_PersonOrganizationSelect

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_SetPersonOrganization(self, *args)


    def PersonOrganization(self, *args):
        """
        PersonOrganization(Handle_StepBasic_ApprovalPersonOrganization self) -> StepBasic_PersonOrganizationSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_PersonOrganizationSelect

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_PersonOrganization(self, *args)


    def SetAuthorizedApproval(self, *args):
        """
        SetAuthorizedApproval(Handle_StepBasic_ApprovalPersonOrganization self, Handle_StepBasic_Approval aAuthorizedApproval)

        :type aAuthorizedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_SetAuthorizedApproval(self, *args)


    def AuthorizedApproval(self, *args):
        """
        AuthorizedApproval(Handle_StepBasic_ApprovalPersonOrganization self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_AuthorizedApproval(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_ApprovalPersonOrganization self, Handle_StepBasic_ApprovalRole aRole)

        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_SetRole(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_ApprovalPersonOrganization self) -> Handle_StepBasic_ApprovalRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_Role(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApprovalPersonOrganization self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApprovalPersonOrganization self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApprovalPersonOrganization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApprovalPersonOrganization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApprovalPersonOrganization self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApprovalPersonOrganization self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApprovalPersonOrganization self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApprovalPersonOrganization self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApprovalPersonOrganization self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApprovalPersonOrganization self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_DecrementRefCounter(self, *args)

Handle_StepBasic_ApprovalPersonOrganization_swigregister = _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_swigregister
Handle_StepBasic_ApprovalPersonOrganization_swigregister(Handle_StepBasic_ApprovalPersonOrganization)

def Handle_StepBasic_ApprovalPersonOrganization_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_DownCast(thing)
Handle_StepBasic_ApprovalPersonOrganization_DownCast = _StepBasic.Handle_StepBasic_ApprovalPersonOrganization_DownCast

class Handle_StepBasic_ProductContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ProductContext self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ProductContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ProductContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ProductContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ProductContext self, StepBasic_ProductContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ProductContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ProductContext self, Handle_StepBasic_ProductContext theHandle) -> Handle_StepBasic_ProductContext
        assign(Handle_StepBasic_ProductContext self, StepBasic_ProductContext thePtr) -> Handle_StepBasic_ProductContext
        assign(Handle_StepBasic_ProductContext self, Handle_StepBasic_ProductContext theHandle) -> Handle_StepBasic_ProductContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ProductContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ProductContext self) -> StepBasic_ProductContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ProductContext self) -> StepBasic_ProductContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ProductContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ProductContext self) -> StepBasic_ProductContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ProductContext___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ProductContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ProductContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ProductContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ProductContext_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ProductContext

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ProductContext self, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext aFrameOfReference, Handle_TCollection_HAsciiString aDisciplineType)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext
        :type aDisciplineType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductContext_Init(self, *args)


    def SetDisciplineType(self, *args):
        """
        SetDisciplineType(Handle_StepBasic_ProductContext self, Handle_TCollection_HAsciiString aDisciplineType)

        :type aDisciplineType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductContext_SetDisciplineType(self, *args)


    def DisciplineType(self, *args):
        """
        DisciplineType(Handle_StepBasic_ProductContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductContext_DisciplineType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ProductContext self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ProductContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ProductContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ProductContext self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductContext_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ProductContext self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ProductContext_Name(self, *args)


    def SetFrameOfReference(self, *args):
        """
        SetFrameOfReference(Handle_StepBasic_ProductContext self, Handle_StepBasic_ApplicationContext aFrameOfReference)

        :type aFrameOfReference: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ProductContext_SetFrameOfReference(self, *args)


    def FrameOfReference(self, *args):
        """
        FrameOfReference(Handle_StepBasic_ProductContext self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _StepBasic.Handle_StepBasic_ProductContext_FrameOfReference(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ProductContext self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ProductContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ProductContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ProductContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ProductContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ProductContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ProductContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ProductContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ProductContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ProductContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ProductContext self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ProductContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ProductContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ProductContext_DecrementRefCounter(self, *args)

Handle_StepBasic_ProductContext_swigregister = _StepBasic.Handle_StepBasic_ProductContext_swigregister
Handle_StepBasic_ProductContext_swigregister(Handle_StepBasic_ProductContext)

def Handle_StepBasic_ProductContext_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ProductContext_DownCast(thing)
Handle_StepBasic_ProductContext_DownCast = _StepBasic.Handle_StepBasic_ProductContext_DownCast

class Handle_StepBasic_ExternalIdentificationAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ExternalIdentificationAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ExternalIdentificationAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ExternalIdentificationAssignment self, StepBasic_ExternalIdentificationAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_StepBasic_ExternalIdentificationAssignment theHandle) -> Handle_StepBasic_ExternalIdentificationAssignment
        assign(Handle_StepBasic_ExternalIdentificationAssignment self, StepBasic_ExternalIdentificationAssignment thePtr) -> Handle_StepBasic_ExternalIdentificationAssignment
        assign(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_StepBasic_ExternalIdentificationAssignment theHandle) -> Handle_StepBasic_ExternalIdentificationAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ExternalIdentificationAssignment self) -> StepBasic_ExternalIdentificationAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ExternalIdentificationAssignment self) -> StepBasic_ExternalIdentificationAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ExternalIdentificationAssignment self) -> StepBasic_ExternalIdentificationAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ExternalIdentificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ExternalIdentificationAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_TCollection_HAsciiString aIdentificationAssignment_AssignedId, Handle_StepBasic_IdentificationRole aIdentificationAssignment_Role, Handle_StepBasic_ExternalSource aSource)

        Initialize all fields (own and inherited)

        :type aIdentificationAssignment_AssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIdentificationAssignment_Role: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole
        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_Init(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepBasic_ExternalIdentificationAssignment self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_StepBasic_ExternalSource Source)

        Set field Source

        :type Source: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_SetSource(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ExternalIdentificationAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AssignedId(self, *args):
        """
        AssignedId(Handle_StepBasic_ExternalIdentificationAssignment self) -> Handle_TCollection_HAsciiString

        Returns field AssignedId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_AssignedId(self, *args)


    def SetAssignedId(self, *args):
        """
        SetAssignedId(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_TCollection_HAsciiString AssignedId)

        Set field AssignedId

        :type AssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_SetAssignedId(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_ExternalIdentificationAssignment self) -> Handle_StepBasic_IdentificationRole

        Returns field Role

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_Role(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_StepBasic_IdentificationRole Role)

        Set field Role

        :type Role: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_SetRole(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ExternalIdentificationAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ExternalIdentificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ExternalIdentificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ExternalIdentificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ExternalIdentificationAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ExternalIdentificationAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ExternalIdentificationAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ExternalIdentificationAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_ExternalIdentificationAssignment_swigregister = _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_swigregister
Handle_StepBasic_ExternalIdentificationAssignment_swigregister(Handle_StepBasic_ExternalIdentificationAssignment)

def Handle_StepBasic_ExternalIdentificationAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_DownCast(thing)
Handle_StepBasic_ExternalIdentificationAssignment_DownCast = _StepBasic.Handle_StepBasic_ExternalIdentificationAssignment_DownCast

class Handle_StepBasic_EffectivityAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_EffectivityAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_EffectivityAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_EffectivityAssignment self, StepBasic_EffectivityAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_EffectivityAssignment self, Handle_StepBasic_EffectivityAssignment theHandle) -> Handle_StepBasic_EffectivityAssignment
        assign(Handle_StepBasic_EffectivityAssignment self, StepBasic_EffectivityAssignment thePtr) -> Handle_StepBasic_EffectivityAssignment
        assign(Handle_StepBasic_EffectivityAssignment self, Handle_StepBasic_EffectivityAssignment theHandle) -> Handle_StepBasic_EffectivityAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_EffectivityAssignment self) -> StepBasic_EffectivityAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_EffectivityAssignment self) -> StepBasic_EffectivityAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_EffectivityAssignment self) -> StepBasic_EffectivityAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_EffectivityAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_EffectivityAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_EffectivityAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_EffectivityAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_EffectivityAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_EffectivityAssignment self, Handle_StepBasic_Effectivity aAssignedEffectivity)

        Initialize all fields (own and inherited)

        :type aAssignedEffectivity: OCC.wrapper.StepBasic.Handle_StepBasic_Effectivity

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_Init(self, *args)


    def AssignedEffectivity(self, *args):
        """
        AssignedEffectivity(Handle_StepBasic_EffectivityAssignment self) -> Handle_StepBasic_Effectivity

        Returns field AssignedEffectivity

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Effectivity

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_AssignedEffectivity(self, *args)


    def SetAssignedEffectivity(self, *args):
        """
        SetAssignedEffectivity(Handle_StepBasic_EffectivityAssignment self, Handle_StepBasic_Effectivity AssignedEffectivity)

        Set field AssignedEffectivity

        :type AssignedEffectivity: OCC.wrapper.StepBasic.Handle_StepBasic_Effectivity

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_SetAssignedEffectivity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_EffectivityAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_EffectivityAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_EffectivityAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_EffectivityAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_EffectivityAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_EffectivityAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_EffectivityAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_EffectivityAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_EffectivityAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_EffectivityAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_EffectivityAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_EffectivityAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_EffectivityAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_EffectivityAssignment_swigregister = _StepBasic.Handle_StepBasic_EffectivityAssignment_swigregister
Handle_StepBasic_EffectivityAssignment_swigregister(Handle_StepBasic_EffectivityAssignment)

def Handle_StepBasic_EffectivityAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_EffectivityAssignment_DownCast(thing)
Handle_StepBasic_EffectivityAssignment_DownCast = _StepBasic.Handle_StepBasic_EffectivityAssignment_DownCast

class StepBasic_DocumentUsageConstraint(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_DocumentUsageConstraint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_DocumentUsageConstraint(self) 
            return h


    def __init__(self, *args):
        """__init__(StepBasic_DocumentUsageConstraint self) -> StepBasic_DocumentUsageConstraint"""
        this = _StepBasic.new_StepBasic_DocumentUsageConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepBasic_DocumentUsageConstraint self, Handle_StepBasic_Document aSource, Handle_TCollection_HAsciiString ase, Handle_TCollection_HAsciiString asev)

        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type ase: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type asev: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_Init(self, *args)


    def Source(self, *args):
        """
        Source(StepBasic_DocumentUsageConstraint self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(StepBasic_DocumentUsageConstraint self, Handle_StepBasic_Document aSource)

        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_SetSource(self, *args)


    def SubjectElement(self, *args):
        """
        SubjectElement(StepBasic_DocumentUsageConstraint self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_SubjectElement(self, *args)


    def SetSubjectElement(self, *args):
        """
        SetSubjectElement(StepBasic_DocumentUsageConstraint self, Handle_TCollection_HAsciiString ase)

        :type ase: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_SetSubjectElement(self, *args)


    def SubjectElementValue(self, *args):
        """
        SubjectElementValue(StepBasic_DocumentUsageConstraint self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_SubjectElementValue(self, *args)


    def SetSubjectElementValue(self, *args):
        """
        SetSubjectElementValue(StepBasic_DocumentUsageConstraint self, Handle_TCollection_HAsciiString asev)

        :type asev: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_SetSubjectElementValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_DocumentUsageConstraint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_DocumentUsageConstraint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_DocumentUsageConstraint
StepBasic_DocumentUsageConstraint_swigregister = _StepBasic.StepBasic_DocumentUsageConstraint_swigregister
StepBasic_DocumentUsageConstraint_swigregister(StepBasic_DocumentUsageConstraint)

def StepBasic_DocumentUsageConstraint_get_type_name(*args):
    """
    StepBasic_DocumentUsageConstraint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_DocumentUsageConstraint_get_type_name(*args)

def StepBasic_DocumentUsageConstraint_get_type_descriptor(*args):
    """
    StepBasic_DocumentUsageConstraint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_DocumentUsageConstraint_get_type_descriptor(*args)

class Handle_StepBasic_DocumentUsageConstraint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_DocumentUsageConstraint self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_DocumentUsageConstraint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_DocumentUsageConstraint self, StepBasic_DocumentUsageConstraint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_DocumentUsageConstraint self, Handle_StepBasic_DocumentUsageConstraint theHandle) -> Handle_StepBasic_DocumentUsageConstraint
        assign(Handle_StepBasic_DocumentUsageConstraint self, StepBasic_DocumentUsageConstraint thePtr) -> Handle_StepBasic_DocumentUsageConstraint
        assign(Handle_StepBasic_DocumentUsageConstraint self, Handle_StepBasic_DocumentUsageConstraint theHandle) -> Handle_StepBasic_DocumentUsageConstraint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_DocumentUsageConstraint self) -> StepBasic_DocumentUsageConstraint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_DocumentUsageConstraint self) -> StepBasic_DocumentUsageConstraint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_DocumentUsageConstraint self) -> StepBasic_DocumentUsageConstraint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_DocumentUsageConstraint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_DocumentUsageConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_DocumentUsageConstraint_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_DocumentUsageConstraint

    def Init(self, *args):
        """
        Init(Handle_StepBasic_DocumentUsageConstraint self, Handle_StepBasic_Document aSource, Handle_TCollection_HAsciiString ase, Handle_TCollection_HAsciiString asev)

        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_Document
        :type ase: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type asev: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_Init(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepBasic_DocumentUsageConstraint self) -> Handle_StepBasic_Document

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepBasic_DocumentUsageConstraint self, Handle_StepBasic_Document aSource)

        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_Document

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_SetSource(self, *args)


    def SubjectElement(self, *args):
        """
        SubjectElement(Handle_StepBasic_DocumentUsageConstraint self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_SubjectElement(self, *args)


    def SetSubjectElement(self, *args):
        """
        SetSubjectElement(Handle_StepBasic_DocumentUsageConstraint self, Handle_TCollection_HAsciiString ase)

        :type ase: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_SetSubjectElement(self, *args)


    def SubjectElementValue(self, *args):
        """
        SubjectElementValue(Handle_StepBasic_DocumentUsageConstraint self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_SubjectElementValue(self, *args)


    def SetSubjectElementValue(self, *args):
        """
        SetSubjectElementValue(Handle_StepBasic_DocumentUsageConstraint self, Handle_TCollection_HAsciiString asev)

        :type asev: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_SetSubjectElementValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_DocumentUsageConstraint self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentUsageConstraint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_DocumentUsageConstraint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_DocumentUsageConstraint self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_DocumentUsageConstraint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_DocumentUsageConstraint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_DocumentUsageConstraint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_DocumentUsageConstraint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_DocumentUsageConstraint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_DocumentUsageConstraint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_DocumentUsageConstraint self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_DocumentUsageConstraint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_DecrementRefCounter(self, *args)

Handle_StepBasic_DocumentUsageConstraint_swigregister = _StepBasic.Handle_StepBasic_DocumentUsageConstraint_swigregister
Handle_StepBasic_DocumentUsageConstraint_swigregister(Handle_StepBasic_DocumentUsageConstraint)

def Handle_StepBasic_DocumentUsageConstraint_DownCast(thing):
    return _StepBasic.Handle_StepBasic_DocumentUsageConstraint_DownCast(thing)
Handle_StepBasic_DocumentUsageConstraint_DownCast = _StepBasic.Handle_StepBasic_DocumentUsageConstraint_DownCast

class Handle_StepBasic_Approval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_Approval self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_Approval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_Approval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_Approval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_Approval self, StepBasic_Approval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_Approval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_Approval self, Handle_StepBasic_Approval theHandle) -> Handle_StepBasic_Approval
        assign(Handle_StepBasic_Approval self, StepBasic_Approval thePtr) -> Handle_StepBasic_Approval
        assign(Handle_StepBasic_Approval self, Handle_StepBasic_Approval theHandle) -> Handle_StepBasic_Approval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_Approval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_Approval self) -> StepBasic_Approval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Approval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_Approval self) -> StepBasic_Approval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_Approval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_Approval self) -> StepBasic_Approval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_Approval___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_Approval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_Approval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_Approval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_Approval_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_Approval

    def Init(self, *args):
        """
        Init(Handle_StepBasic_Approval self, Handle_StepBasic_ApprovalStatus aStatus, Handle_TCollection_HAsciiString aLevel)

        :type aStatus: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalStatus
        :type aLevel: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Approval_Init(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_StepBasic_Approval self, Handle_StepBasic_ApprovalStatus aStatus)

        :type aStatus: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalStatus

        """
        return _StepBasic.Handle_StepBasic_Approval_SetStatus(self, *args)


    def Status(self, *args):
        """
        Status(Handle_StepBasic_Approval self) -> Handle_StepBasic_ApprovalStatus

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalStatus

        """
        return _StepBasic.Handle_StepBasic_Approval_Status(self, *args)


    def SetLevel(self, *args):
        """
        SetLevel(Handle_StepBasic_Approval self, Handle_TCollection_HAsciiString aLevel)

        :type aLevel: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Approval_SetLevel(self, *args)


    def Level(self, *args):
        """
        Level(Handle_StepBasic_Approval self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_Approval_Level(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_Approval self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_Approval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Approval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_Approval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_Approval self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_Approval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_Approval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_Approval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Approval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_Approval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_Approval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_Approval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_Approval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_Approval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_Approval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Approval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_Approval self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_Approval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_Approval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_Approval_DecrementRefCounter(self, *args)

Handle_StepBasic_Approval_swigregister = _StepBasic.Handle_StepBasic_Approval_swigregister
Handle_StepBasic_Approval_swigregister(Handle_StepBasic_Approval)

def Handle_StepBasic_Approval_DownCast(thing):
    return _StepBasic.Handle_StepBasic_Approval_DownCast(thing)
Handle_StepBasic_Approval_DownCast = _StepBasic.Handle_StepBasic_Approval_DownCast

class Handle_StepBasic_IdentificationAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_IdentificationAssignment self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_IdentificationAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_IdentificationAssignment self, StepBasic_IdentificationAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_IdentificationAssignment self, Handle_StepBasic_IdentificationAssignment theHandle) -> Handle_StepBasic_IdentificationAssignment
        assign(Handle_StepBasic_IdentificationAssignment self, StepBasic_IdentificationAssignment thePtr) -> Handle_StepBasic_IdentificationAssignment
        assign(Handle_StepBasic_IdentificationAssignment self, Handle_StepBasic_IdentificationAssignment theHandle) -> Handle_StepBasic_IdentificationAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_IdentificationAssignment self) -> StepBasic_IdentificationAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_IdentificationAssignment self) -> StepBasic_IdentificationAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_IdentificationAssignment self) -> StepBasic_IdentificationAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_IdentificationAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_IdentificationAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_IdentificationAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_IdentificationAssignment_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_IdentificationAssignment

    def Init(self, *args):
        """
        Init(Handle_StepBasic_IdentificationAssignment self, Handle_TCollection_HAsciiString aAssignedId, Handle_StepBasic_IdentificationRole aRole)

        Initialize all fields (own and inherited)

        :type aAssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRole: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_Init(self, *args)


    def AssignedId(self, *args):
        """
        AssignedId(Handle_StepBasic_IdentificationAssignment self) -> Handle_TCollection_HAsciiString

        Returns field AssignedId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_AssignedId(self, *args)


    def SetAssignedId(self, *args):
        """
        SetAssignedId(Handle_StepBasic_IdentificationAssignment self, Handle_TCollection_HAsciiString AssignedId)

        Set field AssignedId

        :type AssignedId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_SetAssignedId(self, *args)


    def Role(self, *args):
        """
        Role(Handle_StepBasic_IdentificationAssignment self) -> Handle_StepBasic_IdentificationRole

        Returns field Role

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_Role(self, *args)


    def SetRole(self, *args):
        """
        SetRole(Handle_StepBasic_IdentificationAssignment self, Handle_StepBasic_IdentificationRole Role)

        Set field Role

        :type Role: OCC.wrapper.StepBasic.Handle_StepBasic_IdentificationRole

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_SetRole(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_IdentificationAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_IdentificationAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_IdentificationAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_IdentificationAssignment self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_IdentificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_IdentificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_IdentificationAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_IdentificationAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_IdentificationAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_IdentificationAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_IdentificationAssignment self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_IdentificationAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_IdentificationAssignment_DecrementRefCounter(self, *args)

Handle_StepBasic_IdentificationAssignment_swigregister = _StepBasic.Handle_StepBasic_IdentificationAssignment_swigregister
Handle_StepBasic_IdentificationAssignment_swigregister(Handle_StepBasic_IdentificationAssignment)

def Handle_StepBasic_IdentificationAssignment_DownCast(thing):
    return _StepBasic.Handle_StepBasic_IdentificationAssignment_DownCast(thing)
Handle_StepBasic_IdentificationAssignment_DownCast = _StepBasic.Handle_StepBasic_IdentificationAssignment_DownCast

class StepBasic_HArray1OfProduct(NCollection_Array1_Handle_StepBasic_Product, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfProduct
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfProduct(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfProduct self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfProduct
        __init__(StepBasic_HArray1OfProduct self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_Product theValue) -> StepBasic_HArray1OfProduct
        __init__(StepBasic_HArray1OfProduct self, NCollection_Array1_Handle_StepBasic_Product theOther) -> StepBasic_HArray1OfProduct

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfProduct

        """
        this = _StepBasic.new_StepBasic_HArray1OfProduct(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProduct

        """
        res = _StepBasic.StepBasic_HArray1OfProduct_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfProduct self) -> NCollection_Array1_Handle_StepBasic_Product

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProduct

        """
        return _StepBasic.StepBasic_HArray1OfProduct_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfProduct_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfProduct_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfProduct_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfProduct
StepBasic_HArray1OfProduct_swigregister = _StepBasic.StepBasic_HArray1OfProduct_swigregister
StepBasic_HArray1OfProduct_swigregister(StepBasic_HArray1OfProduct)

def StepBasic_HArray1OfProduct_get_type_name(*args):
    """
    StepBasic_HArray1OfProduct_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfProduct_get_type_name(*args)

def StepBasic_HArray1OfProduct_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfProduct_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfProduct_get_type_descriptor(*args)

class Handle_StepBasic_ApprovalRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ApprovalRelationship self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ApprovalRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ApprovalRelationship self, StepBasic_ApprovalRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ApprovalRelationship self, Handle_StepBasic_ApprovalRelationship theHandle) -> Handle_StepBasic_ApprovalRelationship
        assign(Handle_StepBasic_ApprovalRelationship self, StepBasic_ApprovalRelationship thePtr) -> Handle_StepBasic_ApprovalRelationship
        assign(Handle_StepBasic_ApprovalRelationship self, Handle_StepBasic_ApprovalRelationship theHandle) -> Handle_StepBasic_ApprovalRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ApprovalRelationship self) -> StepBasic_ApprovalRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ApprovalRelationship self) -> StepBasic_ApprovalRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ApprovalRelationship self) -> StepBasic_ApprovalRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ApprovalRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ApprovalRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ApprovalRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ApprovalRelationship_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ApprovalRelationship

    def Init(self, *args):
        """
        Init(Handle_StepBasic_ApprovalRelationship self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepBasic_Approval aRelatingApproval, Handle_StepBasic_Approval aRelatedApproval)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRelatingApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval
        :type aRelatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepBasic_ApprovalRelationship self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepBasic_ApprovalRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepBasic_ApprovalRelationship self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepBasic_ApprovalRelationship self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_Description(self, *args)


    def SetRelatingApproval(self, *args):
        """
        SetRelatingApproval(Handle_StepBasic_ApprovalRelationship self, Handle_StepBasic_Approval aRelatingApproval)

        :type aRelatingApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_SetRelatingApproval(self, *args)


    def RelatingApproval(self, *args):
        """
        RelatingApproval(Handle_StepBasic_ApprovalRelationship self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_RelatingApproval(self, *args)


    def SetRelatedApproval(self, *args):
        """
        SetRelatedApproval(Handle_StepBasic_ApprovalRelationship self, Handle_StepBasic_Approval aRelatedApproval)

        :type aRelatedApproval: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_SetRelatedApproval(self, *args)


    def RelatedApproval(self, *args):
        """
        RelatedApproval(Handle_StepBasic_ApprovalRelationship self) -> Handle_StepBasic_Approval

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_RelatedApproval(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ApprovalRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ApprovalRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ApprovalRelationship self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ApprovalRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ApprovalRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ApprovalRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ApprovalRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ApprovalRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ApprovalRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ApprovalRelationship self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ApprovalRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ApprovalRelationship_DecrementRefCounter(self, *args)

Handle_StepBasic_ApprovalRelationship_swigregister = _StepBasic.Handle_StepBasic_ApprovalRelationship_swigregister
Handle_StepBasic_ApprovalRelationship_swigregister(Handle_StepBasic_ApprovalRelationship)

def Handle_StepBasic_ApprovalRelationship_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ApprovalRelationship_DownCast(thing)
Handle_StepBasic_ApprovalRelationship_DownCast = _StepBasic.Handle_StepBasic_ApprovalRelationship_DownCast

class StepBasic_HArray1OfNamedUnit(NCollection_Array1_Handle_StepBasic_NamedUnit, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepBasic_HArray1OfNamedUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepBasic_HArray1OfNamedUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepBasic_HArray1OfNamedUnit self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepBasic_HArray1OfNamedUnit
        __init__(StepBasic_HArray1OfNamedUnit self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepBasic_NamedUnit theValue) -> StepBasic_HArray1OfNamedUnit
        __init__(StepBasic_HArray1OfNamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> StepBasic_HArray1OfNamedUnit

        :type theOther: OCC.wrapper.StepBasic.StepBasic_Array1OfNamedUnit

        """
        this = _StepBasic.new_StepBasic_HArray1OfNamedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfNamedUnit

        """
        res = _StepBasic.StepBasic_HArray1OfNamedUnit_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepBasic_HArray1OfNamedUnit self) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfNamedUnit

        """
        return _StepBasic.StepBasic_HArray1OfNamedUnit_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepBasic.StepBasic_HArray1OfNamedUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepBasic.StepBasic_HArray1OfNamedUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.StepBasic_HArray1OfNamedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepBasic.delete_StepBasic_HArray1OfNamedUnit
StepBasic_HArray1OfNamedUnit_swigregister = _StepBasic.StepBasic_HArray1OfNamedUnit_swigregister
StepBasic_HArray1OfNamedUnit_swigregister(StepBasic_HArray1OfNamedUnit)

def StepBasic_HArray1OfNamedUnit_get_type_name(*args):
    """
    StepBasic_HArray1OfNamedUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepBasic.StepBasic_HArray1OfNamedUnit_get_type_name(*args)

def StepBasic_HArray1OfNamedUnit_get_type_descriptor(*args):
    """
    StepBasic_HArray1OfNamedUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepBasic.StepBasic_HArray1OfNamedUnit_get_type_descriptor(*args)

class NCollection_Array1_Handle_StepBasic_DerivedUnitElement(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> NCollection_Array1< opencascade::handle< StepBasic_DerivedUnitElement > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> NCollection_Array1< opencascade::handle< StepBasic_DerivedUnitElement > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> NCollection_Array1< opencascade::handle< StepBasic_DerivedUnitElement > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> NCollection_Array1< opencascade::handle< StepBasic_DerivedUnitElement > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_DerivedUnitElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, Handle_StepBasic_DerivedUnitElement theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, NCollection_Array1_Handle_StepBasic_DerivedUnitElement theOther) -> NCollection_Array1_Handle_StepBasic_DerivedUnitElement

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, NCollection_Array1_Handle_StepBasic_DerivedUnitElement theOther) -> NCollection_Array1_Handle_StepBasic_DerivedUnitElement

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, NCollection_Array1_Handle_StepBasic_DerivedUnitElement theOther) -> NCollection_Array1_Handle_StepBasic_DerivedUnitElement
        assign(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, NCollection_Array1_Handle_StepBasic_DerivedUnitElement theOther) -> NCollection_Array1_Handle_StepBasic_DerivedUnitElement

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Handle_StepBasic_DerivedUnitElement

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self) -> Handle_StepBasic_DerivedUnitElement

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, Standard_Integer const theIndex) -> Handle_StepBasic_DerivedUnitElement

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, Standard_Integer const theIndex, Handle_StepBasic_DerivedUnitElement theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_DerivedUnitElement self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_DerivedUnitElement
NCollection_Array1_Handle_StepBasic_DerivedUnitElement_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_DerivedUnitElement_swigregister
NCollection_Array1_Handle_StepBasic_DerivedUnitElement_swigregister(NCollection_Array1_Handle_StepBasic_DerivedUnitElement)


try:
	StepBasic_Array1OfDerivedUnitElement = NCollection_Array1_Handle_StepBasic_DerivedUnitElement
except NameError:
	pass # does not exist, probably ignored

class Handle_StepBasic_ThermodynamicTemperatureUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_ThermodynamicTemperatureUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_ThermodynamicTemperatureUnit self, StepBasic_ThermodynamicTemperatureUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_ThermodynamicTemperatureUnit self, Handle_StepBasic_ThermodynamicTemperatureUnit theHandle) -> Handle_StepBasic_ThermodynamicTemperatureUnit
        assign(Handle_StepBasic_ThermodynamicTemperatureUnit self, StepBasic_ThermodynamicTemperatureUnit thePtr) -> Handle_StepBasic_ThermodynamicTemperatureUnit
        assign(Handle_StepBasic_ThermodynamicTemperatureUnit self, Handle_StepBasic_ThermodynamicTemperatureUnit theHandle) -> Handle_StepBasic_ThermodynamicTemperatureUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> StepBasic_ThermodynamicTemperatureUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> StepBasic_ThermodynamicTemperatureUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> StepBasic_ThermodynamicTemperatureUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_ThermodynamicTemperatureUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_ThermodynamicTemperatureUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_ThermodynamicTemperatureUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_Init(self, *args)


    def SetDimensions(self, *args):
        """
        SetDimensions(Handle_StepBasic_ThermodynamicTemperatureUnit self, Handle_StepBasic_DimensionalExponents aDimensions)

        :type aDimensions: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_SetDimensions(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> Handle_StepBasic_DimensionalExponents

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DimensionalExponents

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_Dimensions(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_ThermodynamicTemperatureUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_ThermodynamicTemperatureUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_ThermodynamicTemperatureUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_ThermodynamicTemperatureUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_ThermodynamicTemperatureUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_ThermodynamicTemperatureUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_ThermodynamicTemperatureUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_ThermodynamicTemperatureUnit_swigregister = _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_swigregister
Handle_StepBasic_ThermodynamicTemperatureUnit_swigregister(Handle_StepBasic_ThermodynamicTemperatureUnit)

def Handle_StepBasic_ThermodynamicTemperatureUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_DownCast(thing)
Handle_StepBasic_ThermodynamicTemperatureUnit_DownCast = _StepBasic.Handle_StepBasic_ThermodynamicTemperatureUnit_DownCast

class NCollection_Array1_Handle_StepBasic_Person(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepBasic_Person self) -> NCollection_Array1< opencascade::handle< StepBasic_Person > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepBasic_Person self) -> NCollection_Array1< opencascade::handle< StepBasic_Person > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepBasic_Person self) -> NCollection_Array1< opencascade::handle< StepBasic_Person > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepBasic_Person self) -> NCollection_Array1< opencascade::handle< StepBasic_Person > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepBasic.new_NCollection_Array1_Handle_StepBasic_Person(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepBasic_Person self, Handle_StepBasic_Person theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepBasic_Person self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepBasic_Person self, NCollection_Array1_Handle_StepBasic_Person theOther) -> NCollection_Array1_Handle_StepBasic_Person

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepBasic_Person self, NCollection_Array1_Handle_StepBasic_Person theOther) -> NCollection_Array1_Handle_StepBasic_Person

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepBasic_Person self, NCollection_Array1_Handle_StepBasic_Person theOther) -> NCollection_Array1_Handle_StepBasic_Person
        assign(NCollection_Array1_Handle_StepBasic_Person self, NCollection_Array1_Handle_StepBasic_Person theOther) -> NCollection_Array1_Handle_StepBasic_Person

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Person_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepBasic_Person self) -> Handle_StepBasic_Person

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepBasic_Person self) -> Handle_StepBasic_Person

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepBasic_Person self, Standard_Integer const theIndex) -> Handle_StepBasic_Person

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Person___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.NCollection_Array1_Handle_StepBasic_Person_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepBasic_Person self, Standard_Integer const theIndex, Handle_StepBasic_Person theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepBasic_Person self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.NCollection_Array1_Handle_StepBasic_Person_Resize(self, *args)

    __swig_destroy__ = _StepBasic.delete_NCollection_Array1_Handle_StepBasic_Person
NCollection_Array1_Handle_StepBasic_Person_swigregister = _StepBasic.NCollection_Array1_Handle_StepBasic_Person_swigregister
NCollection_Array1_Handle_StepBasic_Person_swigregister(NCollection_Array1_Handle_StepBasic_Person)


try:
	StepBasic_Array1OfPerson = NCollection_Array1_Handle_StepBasic_Person
except NameError:
	pass # does not exist, probably ignored

class Handle_StepBasic_HArray1OfNamedUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfNamedUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfNamedUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfNamedUnit self, StepBasic_HArray1OfNamedUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfNamedUnit self, Handle_StepBasic_HArray1OfNamedUnit theHandle) -> Handle_StepBasic_HArray1OfNamedUnit
        assign(Handle_StepBasic_HArray1OfNamedUnit self, StepBasic_HArray1OfNamedUnit thePtr) -> Handle_StepBasic_HArray1OfNamedUnit
        assign(Handle_StepBasic_HArray1OfNamedUnit self, Handle_StepBasic_HArray1OfNamedUnit theHandle) -> Handle_StepBasic_HArray1OfNamedUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfNamedUnit self) -> StepBasic_HArray1OfNamedUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfNamedUnit self) -> StepBasic_HArray1OfNamedUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfNamedUnit self) -> StepBasic_HArray1OfNamedUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfNamedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfNamedUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfNamedUnit

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfNamedUnit

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfNamedUnit self) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfNamedUnit

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfNamedUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_StepBasic_HArray1OfNamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_StepBasic_HArray1OfNamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_StepBasic_HArray1OfNamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_StepBasic_HArray1OfNamedUnit self) -> NCollection_Array1< opencascade::handle< StepBasic_NamedUnit > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_StepBasic_HArray1OfNamedUnit self, Handle_StepBasic_NamedUnit theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_StepBasic_HArray1OfNamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_StepBasic_HArray1OfNamedUnit self, NCollection_Array1_Handle_StepBasic_NamedUnit theOther) -> NCollection_Array1_Handle_StepBasic_NamedUnit

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_StepBasic_HArray1OfNamedUnit self) -> Handle_StepBasic_NamedUnit

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_StepBasic_HArray1OfNamedUnit self) -> Handle_StepBasic_NamedUnit

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_StepBasic_HArray1OfNamedUnit self, Standard_Integer const theIndex) -> Handle_StepBasic_NamedUnit

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepBasic_HArray1OfNamedUnit self, Standard_Integer const theIndex, Handle_StepBasic_NamedUnit theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_StepBasic_HArray1OfNamedUnit self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfNamedUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfNamedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfNamedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfNamedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfNamedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfNamedUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfNamedUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfNamedUnit_swigregister = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_swigregister
Handle_StepBasic_HArray1OfNamedUnit_swigregister(Handle_StepBasic_HArray1OfNamedUnit)

def Handle_StepBasic_HArray1OfNamedUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_DownCast(thing)
Handle_StepBasic_HArray1OfNamedUnit_DownCast = _StepBasic.Handle_StepBasic_HArray1OfNamedUnit_DownCast

class Handle_StepBasic_HArray1OfProduct(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_HArray1OfProduct self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_HArray1OfProduct self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_HArray1OfProduct self, StepBasic_HArray1OfProduct thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_HArray1OfProduct self, Handle_StepBasic_HArray1OfProduct theHandle) -> Handle_StepBasic_HArray1OfProduct
        assign(Handle_StepBasic_HArray1OfProduct self, StepBasic_HArray1OfProduct thePtr) -> Handle_StepBasic_HArray1OfProduct
        assign(Handle_StepBasic_HArray1OfProduct self, Handle_StepBasic_HArray1OfProduct theHandle) -> Handle_StepBasic_HArray1OfProduct

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_HArray1OfProduct self) -> StepBasic_HArray1OfProduct

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_HArray1OfProduct self) -> StepBasic_HArray1OfProduct

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_HArray1OfProduct self) -> StepBasic_HArray1OfProduct

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_HArray1OfProduct___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_HArray1OfProduct___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_HArray1OfProduct(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_HArray1OfProduct_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_HArray1OfProduct

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProduct

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepBasic_HArray1OfProduct self) -> NCollection_Array1_Handle_StepBasic_Product

        :rtype: OCC.wrapper.StepBasic.StepBasic_Array1OfProduct

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_HArray1OfProduct self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_StepBasic_HArray1OfProduct self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_StepBasic_HArray1OfProduct self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_StepBasic_HArray1OfProduct self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_StepBasic_HArray1OfProduct self) -> NCollection_Array1< opencascade::handle< StepBasic_Product > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_StepBasic_HArray1OfProduct self, Handle_StepBasic_Product theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_StepBasic_HArray1OfProduct self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_StepBasic_HArray1OfProduct self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_StepBasic_HArray1OfProduct self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_StepBasic_HArray1OfProduct self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_StepBasic_HArray1OfProduct self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_StepBasic_HArray1OfProduct self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_StepBasic_HArray1OfProduct self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_StepBasic_HArray1OfProduct self, NCollection_Array1_Handle_StepBasic_Product theOther) -> NCollection_Array1_Handle_StepBasic_Product

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_StepBasic_HArray1OfProduct self, NCollection_Array1_Handle_StepBasic_Product theOther) -> NCollection_Array1_Handle_StepBasic_Product

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_StepBasic_HArray1OfProduct self) -> Handle_StepBasic_Product

        @return first element

        :rtype: TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_StepBasic_HArray1OfProduct self) -> Handle_StepBasic_Product

        @return last element

        :rtype: TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepBasic.Handle_StepBasic_HArray1OfProduct_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_StepBasic_HArray1OfProduct self, Standard_Integer const theIndex) -> Handle_StepBasic_Product

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepBasic_HArray1OfProduct self, Standard_Integer const theIndex, Handle_StepBasic_Product theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_StepBasic_HArray1OfProduct self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_HArray1OfProduct self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_HArray1OfProduct self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_HArray1OfProduct self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_HArray1OfProduct self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_HArray1OfProduct self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_HArray1OfProduct self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_HArray1OfProduct self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_HArray1OfProduct self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_HArray1OfProduct self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_HArray1OfProduct_DecrementRefCounter(self, *args)

Handle_StepBasic_HArray1OfProduct_swigregister = _StepBasic.Handle_StepBasic_HArray1OfProduct_swigregister
Handle_StepBasic_HArray1OfProduct_swigregister(Handle_StepBasic_HArray1OfProduct)

def Handle_StepBasic_HArray1OfProduct_DownCast(thing):
    return _StepBasic.Handle_StepBasic_HArray1OfProduct_DownCast(thing)
Handle_StepBasic_HArray1OfProduct_DownCast = _StepBasic.Handle_StepBasic_HArray1OfProduct_DownCast

class Handle_StepBasic_LengthMeasureWithUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepBasic_LengthMeasureWithUnit self)

        Nullify the handle


        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepBasic_LengthMeasureWithUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepBasic_LengthMeasureWithUnit self, StepBasic_LengthMeasureWithUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepBasic_LengthMeasureWithUnit self, Handle_StepBasic_LengthMeasureWithUnit theHandle) -> Handle_StepBasic_LengthMeasureWithUnit
        assign(Handle_StepBasic_LengthMeasureWithUnit self, StepBasic_LengthMeasureWithUnit thePtr) -> Handle_StepBasic_LengthMeasureWithUnit
        assign(Handle_StepBasic_LengthMeasureWithUnit self, Handle_StepBasic_LengthMeasureWithUnit theHandle) -> Handle_StepBasic_LengthMeasureWithUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepBasic_LengthMeasureWithUnit self) -> StepBasic_LengthMeasureWithUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepBasic_LengthMeasureWithUnit self) -> StepBasic_LengthMeasureWithUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepBasic_LengthMeasureWithUnit self) -> StepBasic_LengthMeasureWithUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit___ref__(self, *args)


    def __hash__(self):
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepBasic.new_Handle_StepBasic_LengthMeasureWithUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepBasic.Handle_StepBasic_LengthMeasureWithUnit_DownCast)
    __swig_destroy__ = _StepBasic.delete_Handle_StepBasic_LengthMeasureWithUnit

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepBasic_LengthMeasureWithUnit self) -> char const *

        :rtype: const char *

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepBasic_LengthMeasureWithUnit self, Handle_StepBasic_MeasureValueMember aValueComponent, StepBasic_Unit aUnitComponent)

        :type aValueComponent: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember
        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_Init(self, *args)


    def SetValueComponent(self, *args):
        """
        SetValueComponent(Handle_StepBasic_LengthMeasureWithUnit self, Standard_Real const aValueComponent)

        :type aValueComponent: float

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_SetValueComponent(self, *args)


    def ValueComponent(self, *args):
        """
        ValueComponent(Handle_StepBasic_LengthMeasureWithUnit self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_ValueComponent(self, *args)


    def ValueComponentMember(self, *args):
        """
        ValueComponentMember(Handle_StepBasic_LengthMeasureWithUnit self) -> Handle_StepBasic_MeasureValueMember

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_ValueComponentMember(self, *args)


    def SetValueComponentMember(self, *args):
        """
        SetValueComponentMember(Handle_StepBasic_LengthMeasureWithUnit self, Handle_StepBasic_MeasureValueMember val)

        :type val: OCC.wrapper.StepBasic.Handle_StepBasic_MeasureValueMember

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_SetValueComponentMember(self, *args)


    def SetUnitComponent(self, *args):
        """
        SetUnitComponent(Handle_StepBasic_LengthMeasureWithUnit self, StepBasic_Unit aUnitComponent)

        :type aUnitComponent: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_SetUnitComponent(self, *args)


    def UnitComponent(self, *args):
        """
        UnitComponent(Handle_StepBasic_LengthMeasureWithUnit self) -> StepBasic_Unit

        :rtype: OCC.wrapper.StepBasic.StepBasic_Unit

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_UnitComponent(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepBasic_LengthMeasureWithUnit self)

        Memory deallocator for transient classes


        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepBasic_LengthMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepBasic_LengthMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepBasic_LengthMeasureWithUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepBasic_LengthMeasureWithUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepBasic_LengthMeasureWithUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepBasic_LengthMeasureWithUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepBasic_LengthMeasureWithUnit self)

        Increments the reference counter of this object


        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepBasic_LengthMeasureWithUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_DecrementRefCounter(self, *args)

Handle_StepBasic_LengthMeasureWithUnit_swigregister = _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_swigregister
Handle_StepBasic_LengthMeasureWithUnit_swigregister(Handle_StepBasic_LengthMeasureWithUnit)

def Handle_StepBasic_LengthMeasureWithUnit_DownCast(thing):
    return _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_DownCast(thing)
Handle_StepBasic_LengthMeasureWithUnit_DownCast = _StepBasic.Handle_StepBasic_LengthMeasureWithUnit_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Convert')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Convert')
    _Convert = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Convert', [dirname(__file__)])
        except ImportError:
            import _Convert
            return _Convert
        try:
            _mod = imp.load_module('_Convert', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Convert = swig_import_helper()
    del swig_import_helper
else:
    import _Convert
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Convert.delete_SwigPyIterator

    def value(self):
        return _Convert.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Convert.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Convert.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Convert.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Convert.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Convert.SwigPyIterator_copy(self)

    def next(self):
        return _Convert.SwigPyIterator_next(self)

    def __next__(self):
        return _Convert.SwigPyIterator___next__(self)

    def previous(self):
        return _Convert.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Convert.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Convert.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Convert.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Convert.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Convert.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Convert.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Convert.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Convert.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Convert.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Convert.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Convert.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Convert.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Convert.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Convert.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Convert.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Convert.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Convert.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Convert.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Convert.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Convert.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Convert.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Convert.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Convert.ptr_to_number(item)
ptr_to_number = _Convert.ptr_to_number

def HashCode(*args):
    return _Convert.HashCode(*args)
HashCode = _Convert.HashCode

def ptr_equal(a, b):
    return _Convert.ptr_equal(a, b)
ptr_equal = _Convert.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
Convert_TgtThetaOver2 = _Convert.Convert_TgtThetaOver2
Convert_TgtThetaOver2_1 = _Convert.Convert_TgtThetaOver2_1
Convert_TgtThetaOver2_2 = _Convert.Convert_TgtThetaOver2_2
Convert_TgtThetaOver2_3 = _Convert.Convert_TgtThetaOver2_3
Convert_TgtThetaOver2_4 = _Convert.Convert_TgtThetaOver2_4
Convert_QuasiAngular = _Convert.Convert_QuasiAngular
Convert_RationalC1 = _Convert.Convert_RationalC1
Convert_Polynomial = _Convert.Convert_Polynomial
class Convert_ConicToBSplineCurve(object):
    """
    Root class for algorithms which convert a conic curve into
    a BSpline curve (CircleToBSplineCurve, EllipseToBSplineCurve,
    HyperbolaToBSplineCurve, ParabolaToBSplineCurve).
    These algorithms all work on 2D curves from the gp
    package and compute all the data needed to construct a
    BSpline curve equivalent to the conic curve. This data consists of:
    -   the degree of the curve,
    -   the periodic characteristics of the curve,
    -   a poles table with associated weights,
    -   a knots table with associated multiplicities.
    The abstract class ConicToBSplineCurve provides a
    framework for storing and consulting this computed data.
    The data may then be used to construct a
    Geom2d_BSplineCurve curvSuper class of the following classes :
    This abstract class implements the methods to get the geometric
    representation of the B-spline curve equivalent to the conic.
    The B-spline is computed at the creation time in the sub classes.
    The B-spline curve is defined with its degree, its control points
    (Poles), its weights, its knots and their multiplicity.
    All the geometric entities used in this package are defined in 2D
    space.
    KeyWords :
    Convert, Conic, BSplineCurve, 2D.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Degree(self, *args):
        """
        Degree(Convert_ConicToBSplineCurve self) -> Standard_Integer

        Returns the degree of the BSpline curve whose data is
        computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ConicToBSplineCurve_Degree(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Convert_ConicToBSplineCurve self) -> Standard_Integer

        Returns the number of poles of the BSpline curve whose
        data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ConicToBSplineCurve_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Convert_ConicToBSplineCurve self) -> Standard_Integer

        Returns the number of knots of the BSpline curve whose
        data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ConicToBSplineCurve_NbKnots(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Convert_ConicToBSplineCurve self) -> Standard_Boolean

        Returns true if the BSpline curve whose data is computed in
        this framework is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Convert.Convert_ConicToBSplineCurve_IsPeriodic(self, *args)


    def Pole(self, *args):
        """
        Pole(Convert_ConicToBSplineCurve self, Standard_Integer const Index) -> gp_Pnt2d

        Returns the pole of index Index to the poles table of the
        BSpline curve whose data is computed in this framework.
        Exceptions
        Standard_OutOfRange if Index is outside the bounds of
        the poles table of the BSpline curve whose data is computed in this framework.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Convert.Convert_ConicToBSplineCurve_Pole(self, *args)


    def Weight(self, *args):
        """
        Weight(Convert_ConicToBSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of index Index to the poles
        table of the BSpline curve whose data is computed in this framework.
        Exceptions
        Standard_OutOfRange if Index is outside the bounds of
        the poles table of the BSpline curve whose data is computed in this framework.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Convert.Convert_ConicToBSplineCurve_Weight(self, *args)


    def Knot(self, *args):
        """
        Knot(Convert_ConicToBSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of index Index to the knots table of the
        BSpline curve whose data is computed in this framework.
        Exceptions
        Standard_OutOfRange if Index is outside the bounds of
        the knots table of the BSpline curve whose data is computed in this framework.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Convert.Convert_ConicToBSplineCurve_Knot(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Convert_ConicToBSplineCurve self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knot of index Index to the
        knots table of the BSpline curve whose data is computed in this framework.
        Exceptions
        Standard_OutOfRange if Index is outside the bounds of
        the knots table of the BSpline curve whose data is computed in this framework.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ConicToBSplineCurve_Multiplicity(self, *args)


    def BuildCosAndSin(self, *args):
        """
        BuildCosAndSin(Convert_ConicToBSplineCurve self, Convert_ParameterisationType const Parametrisation, Handle_TColStd_HArray1OfReal CosNumerator, Handle_TColStd_HArray1OfReal SinNumerator, Handle_TColStd_HArray1OfReal Denominator, Handle_TColStd_HArray1OfReal Knots, Handle_TColStd_HArray1OfInteger Mults)
        BuildCosAndSin(Convert_ConicToBSplineCurve self, Convert_ParameterisationType const Parametrisation, Standard_Real const UFirst, Standard_Real const ULast, Handle_TColStd_HArray1OfReal CosNumerator, Handle_TColStd_HArray1OfReal SinNumerator, Handle_TColStd_HArray1OfReal Denominator, Handle_TColStd_HArray1OfReal Knots, Handle_TColStd_HArray1OfInteger Mults)

        :type Parametrisation: OCC.wrapper.Convert.Convert_ParameterisationType
        :type UFirst: float
        :type ULast: float
        :type CosNumerator: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type SinNumerator: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Denominator: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Degree: int
        :type Knots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Mults: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _Convert.Convert_ConicToBSplineCurve_BuildCosAndSin(self, *args)

    __swig_destroy__ = _Convert.delete_Convert_ConicToBSplineCurve
Convert_ConicToBSplineCurve_swigregister = _Convert.Convert_ConicToBSplineCurve_swigregister
Convert_ConicToBSplineCurve_swigregister(Convert_ConicToBSplineCurve)

class Convert_ElementarySurfaceToBSplineSurface(object):
    """
    Root class for algorithms which convert an elementary
    surface (cylinder, cone, sphere or torus) into a BSpline
    surface (CylinderToBSplineSurface, ConeToBSplineSurface,
    SphereToBSplineSurface, TorusToBSplineSurface).
    These algorithms all work on elementary surfaces from
    the gp package and compute all the data needed to
    construct a BSpline surface equivalent to the cylinder,
    cone, sphere or torus. This data consists of the following:
    -   degrees in the u and v parametric directions,
    -   periodic characteristics in the u and v parametric directions,
    -   a poles table with associated weights,
    -   a knots table (for the u and v parametric directions)
    with associated multiplicities.
    The abstract class
    ElementarySurfaceToBSplineSurface provides a
    framework for storing and consulting this computed data.
    This data may then be used to construct a
    Geom_BSplineSurface surface, for example.
    All those classes define algorithmes to convert an
    ElementarySurface into a B-spline surface.
    This abstract class implements the methods to get
    the geometric representation of the B-spline surface.
    The B-spline representation is computed at the creation
    time in the sub classes.
    The B-spline surface is defined with its degree in the
    parametric U and V directions, its control points (Poles),
    its weights, its knots and their multiplicity.
    KeyWords :
    Convert, ElementarySurface, BSplineSurface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def UDegree(self, *args):
        """
        UDegree(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Integer

        Returns the degree for the u or v parametric direction of
        the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VDegree(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbUPoles(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Integer

        Returns the number of poles for the u or v parametric
        direction of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbVPoles(self, *args)


    def NbUKnots(self, *args):
        """
        NbUKnots(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbUKnots(self, *args)


    def NbVKnots(self, *args):
        """
        NbVKnots(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Integer

        Returns the number of knots for the u or v parametric
        direction of the BSpline surface whose data is computed in this framework .

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_NbVKnots(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Convert_ElementarySurfaceToBSplineSurface self) -> Standard_Boolean

        Returns true if the BSpline surface whose data is computed
        in this framework is periodic in the u or v parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_IsVPeriodic(self, *args)


    def Pole(self, *args):
        """
        Pole(Convert_ElementarySurfaceToBSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> gp_Pnt

        Returns the pole of index (UIndex,VIndex) to the poles
        table of the BSpline surface whose data is computed in this framework.
        Exceptions
        Standard_OutOfRange if, for the BSpline surface whose
        data is computed in this framework:
        -   UIndex is outside the bounds of the poles table in the u
        parametric direction, or
        -   VIndex is outside the bounds of the poles table in the v
        parametric direction.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_Pole(self, *args)


    def Weight(self, *args):
        """
        Weight(Convert_ElementarySurfaceToBSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> Standard_Real

        Returns the weight of the pole of index (UIndex,VIndex) to
        the poles table of the BSpline surface whose data is computed in this framework.
        Exceptions
        Standard_OutOfRange if, for the BSpline surface whose
        data is computed in this framework:
        -   UIndex is outside the bounds of the poles table in the u
        parametric direction, or
        -   VIndex is outside the bounds of the poles table in the v
        parametric direction.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_Weight(self, *args)


    def UKnot(self, *args):
        """
        UKnot(Convert_ElementarySurfaceToBSplineSurface self, Standard_Integer const UIndex) -> Standard_Real

        Returns the U-knot of range UIndex.
        Raised if UIndex < 1 or UIndex > NbUKnots.

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UKnot(self, *args)


    def VKnot(self, *args):
        """
        VKnot(Convert_ElementarySurfaceToBSplineSurface self, Standard_Integer const UIndex) -> Standard_Real

        Returns the V-knot of range VIndex.
        Raised if VIndex < 1 or VIndex > NbVKnots.

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VKnot(self, *args)


    def UMultiplicity(self, *args):
        """
        UMultiplicity(Convert_ElementarySurfaceToBSplineSurface self, Standard_Integer const UIndex) -> Standard_Integer

        Returns the multiplicity of the U-knot of range UIndex.
        Raised if UIndex < 1 or UIndex > NbUKnots.

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_UMultiplicity(self, *args)


    def VMultiplicity(self, *args):
        """
        VMultiplicity(Convert_ElementarySurfaceToBSplineSurface self, Standard_Integer const VIndex) -> Standard_Integer

        Returns the multiplicity of the V-knot of range VIndex.
        Raised if VIndex < 1 or VIndex > NbVKnots.

        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_ElementarySurfaceToBSplineSurface_VMultiplicity(self, *args)

    __swig_destroy__ = _Convert.delete_Convert_ElementarySurfaceToBSplineSurface
Convert_ElementarySurfaceToBSplineSurface_swigregister = _Convert.Convert_ElementarySurfaceToBSplineSurface_swigregister
Convert_ElementarySurfaceToBSplineSurface_swigregister(Convert_ElementarySurfaceToBSplineSurface)

class Convert_ParabolaToBSplineCurve(Convert_ConicToBSplineCurve):
    """
    This algorithm converts a parabola into a non rational B-spline
    curve.
    The parabola is a Parab2d from package gp with the parametrization
    P (U) = Loc + F * (U*U * Xdir + 2 * U * Ydir) where Loc is the
    apex of the parabola, Xdir is the normalized direction of the
    symmetry axis of the parabola, Ydir is the normalized direction of
    the directrix and F is the focal length.
    KeyWords :
    Convert, Parabola, BSplineCurve, 2D .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_ParabolaToBSplineCurve self, gp_Parab2d Prb, Standard_Real const U1, Standard_Real const U2) -> Convert_ParabolaToBSplineCurve

        The parabola Prb is limited between the parametric values U1, U2
        and the equivalent B-spline curve as the same orientation as the
        parabola Prb.

        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :type U1: float
        :type U2: float

        """
        this = _Convert.new_Convert_ParabolaToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_ParabolaToBSplineCurve
Convert_ParabolaToBSplineCurve_swigregister = _Convert.Convert_ParabolaToBSplineCurve_swigregister
Convert_ParabolaToBSplineCurve_swigregister(Convert_ParabolaToBSplineCurve)

class Convert_CompPolynomialToPoles(object):
    """
    Convert a serie of Polynomial N-Dimensional Curves
    that are have continuity CM to an N-Dimensional Bspline Curve
    that has continuity CM.
    (to convert an function (curve) polynomial by span in a BSpline)
    This class uses the following arguments :
    NumCurves :  the number of Polynomial Curves
    Continuity:  the requested continuity for the n-dimensional Spline
    Dimension :  the dimension of the Spline
    MaxDegree :  maximum allowed degree for each composite
    polynomial segment.
    NumCoeffPerCurve : the number of coefficient per segments = degree - 1
    Coefficients  :  the coefficients organized in the following way
    [1..<myNumPolynomials>][1..myMaxDegree +1][1..myDimension]
    that is : index [n,d,i] is at slot
    (n-1) * (myMaxDegree + 1) * myDimension + (d-1) * myDimension + i
    PolynomialIntervals :  nth polynomial represents a polynomial between
    myPolynomialIntervals->Value(n,0) and
    myPolynomialIntervals->Value(n,1)
    TrueIntervals : the nth polynomial has to be mapped linearly to be
    defined on the following interval :
    myTrueIntervals->Value(n) and myTrueIntervals->Value(n+1)
    so that it represent adequatly the function with the
    required continuity
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_CompPolynomialToPoles self, Standard_Integer const NumCurves, Standard_Integer const Continuity, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Handle_TColStd_HArray1OfInteger NumCoeffPerCurve, Handle_TColStd_HArray1OfReal Coefficients, Handle_TColStd_HArray2OfReal PolynomialIntervals, Handle_TColStd_HArray1OfReal TrueIntervals) -> Convert_CompPolynomialToPoles
        __init__(Convert_CompPolynomialToPoles self, Standard_Integer const NumCurves, Standard_Integer const Dimension, Standard_Integer const MaxDegree, NCollection_Array1_Standard_Integer Continuity, NCollection_Array1_Standard_Integer NumCoeffPerCurve, NCollection_Array1_Standard_Real Coefficients, NCollection_Array2_Standard_Real PolynomialIntervals, NCollection_Array1_Standard_Real TrueIntervals) -> Convert_CompPolynomialToPoles
        __init__(Convert_CompPolynomialToPoles self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Integer const Degree, NCollection_Array1_Standard_Real Coefficients, NCollection_Array1_Standard_Real PolynomialIntervals, NCollection_Array1_Standard_Real TrueIntervals) -> Convert_CompPolynomialToPoles

        To Convert only one span.

        :type Dimension: int
        :type MaxDegree: int
        :type Degree: int
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type PolynomialIntervals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TrueIntervals: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _Convert.new_Convert_CompPolynomialToPoles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbPoles(self, *args):
        """
        NbPoles(Convert_CompPolynomialToPoles self) -> Standard_Integer

        number of poles of the n-dimensional BSpline

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompPolynomialToPoles_NbPoles(self, *args)


    def Poles(self, *args):
        """
        Poles(Convert_CompPolynomialToPoles self, Handle_TColStd_HArray2OfReal Poles)

        returns the poles of the n-dimensional BSpline
        in the following format :
        [1..NumPoles][1..Dimension]

        :type Poles: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfReal

        """
        return _Convert.Convert_CompPolynomialToPoles_Poles(self, *args)


    def Degree(self, *args):
        """
        Degree(Convert_CompPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompPolynomialToPoles_Degree(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Convert_CompPolynomialToPoles self) -> Standard_Integer

        Degree of the n-dimensional Bspline

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompPolynomialToPoles_NbKnots(self, *args)


    def Knots(self, *args):
        """
        Knots(Convert_CompPolynomialToPoles self, Handle_TColStd_HArray1OfReal K)

        Knots of the n-dimensional Bspline

        :type K: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Convert.Convert_CompPolynomialToPoles_Knots(self, *args)


    def Multiplicities(self, *args):
        """
        Multiplicities(Convert_CompPolynomialToPoles self, Handle_TColStd_HArray1OfInteger M)

        Multiplicities of the knots in the BSpline

        :type M: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _Convert.Convert_CompPolynomialToPoles_Multiplicities(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Convert_CompPolynomialToPoles self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Convert.Convert_CompPolynomialToPoles_IsDone(self, *args)

    __swig_destroy__ = _Convert.delete_Convert_CompPolynomialToPoles
Convert_CompPolynomialToPoles_swigregister = _Convert.Convert_CompPolynomialToPoles_swigregister
Convert_CompPolynomialToPoles_swigregister(Convert_CompPolynomialToPoles)

class Convert_HyperbolaToBSplineCurve(Convert_ConicToBSplineCurve):
    """
    This algorithm converts a hyperbola into a rational B-spline curve.
    The hyperbola is an Hypr2d from package gp with the
    parametrization :
    P (U) =
    Loc + (MajorRadius * Cosh(U) * Xdir + MinorRadius * Sinh(U) * Ydir)
    where Loc is the location point of the hyperbola, Xdir and Ydir are
    the normalized directions of the local cartesian coordinate system
    of the hyperbola.
    KeyWords :
    Convert, Hyperbola, BSplineCurve, 2D .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_HyperbolaToBSplineCurve self, gp_Hypr2d H, Standard_Real const U1, Standard_Real const U2) -> Convert_HyperbolaToBSplineCurve

        The hyperbola H is limited between the parametric values U1, U2
        and the equivalent B-spline curve has the same orientation as the
        hyperbola.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type U1: float
        :type U2: float

        """
        this = _Convert.new_Convert_HyperbolaToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_HyperbolaToBSplineCurve
Convert_HyperbolaToBSplineCurve_swigregister = _Convert.Convert_HyperbolaToBSplineCurve_swigregister
Convert_HyperbolaToBSplineCurve_swigregister(Convert_HyperbolaToBSplineCurve)

class Convert_CompBezierCurvesToBSplineCurve(object):
    """
    An algorithm to convert a sequence of adjacent
    non-rational Bezier curves into a BSpline curve.
    A CompBezierCurvesToBSplineCurve object provides a framework for:
    -   defining the sequence of adjacent non-rational Bezier
    curves to be converted into a BSpline curve,
    -   implementing the computation algorithm, and
    -   consulting the results.
    Warning
    Do not attempt to convert rational Bezier curves using this type of algorithm.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_CompBezierCurvesToBSplineCurve self, Standard_Real const AngularTolerance=1.0e-4) -> Convert_CompBezierCurvesToBSplineCurve

        Constructs a framework for converting a sequence of
        adjacent non-rational Bezier curves into a BSpline curve.
        Knots will be created on the computed BSpline curve at
        each junction point of two consecutive Bezier curves. The
        degree of continuity of the BSpline curve will be increased at
        the junction point of two consecutive Bezier curves if their
        tangent vectors at this point are parallel. AngularTolerance
        (given in radians, and defaulted to 1.0 e-4) will be used
        to check the parallelism of the two tangent vectors.
        Use the following functions:
        -   AddCurve to define in sequence the adjacent Bezier
        curves to be converted,
        -   Perform to compute the data needed to build the BSpline curve,
        -   and the available consultation functions to access the
        computed data. This data may be used to construct the BSpline curve.

        :type AngularTolerance: float

        """
        this = _Convert.new_Convert_CompBezierCurvesToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCurve(self, *args):
        """
        AddCurve(Convert_CompBezierCurvesToBSplineCurve self, NCollection_Array1_gp_Pnt Poles)

        Adds the Bezier curve defined by the table of poles Poles, to
        the sequence (still contained in this framework) of adjacent
        Bezier curves to be converted into a BSpline curve.
        Only polynomial (i.e. non-rational) Bezier curves are
        converted using this framework.
        If this is not the first call to the function (i.e. if this framework
        still contains data in its Bezier curve sequence), the degree
        of continuity of the BSpline curve will be increased at the
        time of computation at the first point of the added Bezier
        curve (i.e. the first point of the Poles table). This will be the
        case if the tangent vector of the curve at this point is
        parallel to the tangent vector at the end point of the
        preceding Bezier curve in the Bezier curve sequence still
        contained in this framework. An angular tolerance given at
        the time of construction of this framework will be used to
        check the parallelism of the two tangent vectors. This
        checking procedure and all related computations will be
        performed by the Perform function.
        When the adjacent Bezier curve sequence is complete, use
        the following functions:
        -   Perform to compute the data needed to build the BSpline curve,
        -   and the available consultation functions to access the
        computed data. This data may be used to construct the BSpline curve.
        Warning
        The Bezier curve sequence treated by this framework is
        automatically initialized with the first Bezier curve when the
        function is first called. During subsequent use of this function,
        ensure that the first point of the added Bezier curve (i.e. the
        first point of the Poles table) is coincident with the last point
        of the Bezier curve sequence (i.e. the last point of the
        preceding Bezier curve in the sequence) still contained in
        this framework. An error may occur at the time of
        computation if this condition is not satisfied. Particular care
        must be taken with respect to the above, as this condition is
        not checked either when defining the Bezier curve
        sequence or at the time of computation.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_AddCurve(self, *args)


    def Perform(self, *args):
        """
        Perform(Convert_CompBezierCurvesToBSplineCurve self)

        Computes all the data needed to build a BSpline curve
        equivalent to the adjacent Bezier curve sequence still
        contained in this framework.
        A knot is inserted on the computed BSpline curve at the
        junction point of two consecutive Bezier curves. The
        degree of continuity of the BSpline curve will be increased
        at the junction point of two consecutive Bezier curves if
        their tangent vectors at this point are parallel. An angular
        tolerance given at the time of construction of this
        framework is used to check the parallelism of the two
        tangent vectors.
        Use the available consultation functions to access the
        computed data. This data may then be used to construct
        the BSpline curve.
        Warning
        Make sure that the curves in the Bezier curve sequence
        contained in this framework are adjacent. An error may
        occur at the time of computation if this condition is not
        satisfied. Particular care must be taken with respect to the
        above as this condition is not checked, either when
        defining the Bezier curve sequence or at the time of computation.


        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Perform(self, *args)


    def Degree(self, *args):
        """
        Degree(Convert_CompBezierCurvesToBSplineCurve self) -> Standard_Integer

        Returns the degree of the BSpline curve whose data is
        computed in this framework.
        Warning
        Take particular care not to use this function before the
        computation is performed (Perform function), as this
        condition is not checked and an error may  therefore occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Degree(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Convert_CompBezierCurvesToBSplineCurve self) -> Standard_Integer

        Returns the number of poles of the BSpline curve whose
        data is computed in this framework.
        Warning
        Take particular care not to use this function before the
        computation is performed (Perform function), as this
        condition is not checked and an error may therefore occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_NbPoles(self, *args)


    def Poles(self, *args):
        """
        Poles(Convert_CompBezierCurvesToBSplineCurve self, NCollection_Array1_gp_Pnt Poles)

        Loads the Poles table with the poles of the BSpline curve
        whose data is computed in this framework.
        Warning
        -   Do not use this function before the computation is
        performed (Perform function).
        -   The length of the Poles array must be equal to the
        number of poles of the BSpline curve whose data is
        computed in this framework.
        Particular care must be taken with respect to the above, as
        these conditions are not checked, and an error may occur.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_Poles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Convert_CompBezierCurvesToBSplineCurve self) -> Standard_Integer

        Returns the number of knots of the BSpline curve whose
        data is computed in this framework.
        Warning
        Take particular care not to use this function before the
        computation is performed (Perform function), as this
        condition is not checked and an error may therefore occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_NbKnots(self, *args)


    def KnotsAndMults(self, *args):
        """
        KnotsAndMults(Convert_CompBezierCurvesToBSplineCurve self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        -   loads the Knots table with the knots,
        -   and loads the Mults table with the corresponding multiplicities
        of the BSpline curve whose data is computed in this framework.
        Warning
        -   Do not use this function before the computation is
        performed (Perform function).
        -   The length of the Knots and Mults arrays must be equal
        to the number of knots in the BSpline curve whose data is
        computed in this framework.
        Particular care must be taken with respect to the above as
        these conditions are not checked, and an error may occur.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Convert.Convert_CompBezierCurvesToBSplineCurve_KnotsAndMults(self, *args)

    __swig_destroy__ = _Convert.delete_Convert_CompBezierCurvesToBSplineCurve
Convert_CompBezierCurvesToBSplineCurve_swigregister = _Convert.Convert_CompBezierCurvesToBSplineCurve_swigregister
Convert_CompBezierCurvesToBSplineCurve_swigregister(Convert_CompBezierCurvesToBSplineCurve)

class Convert_CylinderToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    """
    This algorithm converts a bounded cylinder into a rational
    B-spline surface. The cylinder is a Cylinder from package gp.
    The parametrization of the cylinder is  :
    P (U, V) = Loc + V * Zdir + Radius * (Xdir*Cos(U) + Ydir*Sin(U))
    where Loc is the location point of the cylinder, Xdir, Ydir and
    Zdir are the normalized directions of the local cartesian
    coordinate system of the cylinder (Zdir is the direction of the
    cylinder's axis). The U parametrization range is U [0, 2PI].
    KeyWords :
    Convert, Cylinder, BSplineSurface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_CylinderToBSplineSurface self, gp_Cylinder Cyl, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2) -> Convert_CylinderToBSplineSurface
        __init__(Convert_CylinderToBSplineSurface self, gp_Cylinder Cyl, Standard_Real const V1, Standard_Real const V2) -> Convert_CylinderToBSplineSurface

        The equivalent B-splineSurface as the same orientation as the
        cylinder in the U and V parametric directions.

        Raised if V1 = V2.

        :type Cyl: OCC.wrapper.gp.gp_Cylinder
        :type V1: float
        :type V2: float

        """
        this = _Convert.new_Convert_CylinderToBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_CylinderToBSplineSurface
Convert_CylinderToBSplineSurface_swigregister = _Convert.Convert_CylinderToBSplineSurface_swigregister
Convert_CylinderToBSplineSurface_swigregister(Convert_CylinderToBSplineSurface)

class Convert_ConeToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    """
    This algorithm converts a bounded Cone into a rational
    B-spline  surface.
    The cone a Cone from package gp. Its parametrization is :
    P (U, V) =  Loc + V * Zdir +
    (R + V*Tan(Ang)) * (Cos(U)*Xdir + Sin(U)*Ydir)
    where Loc is the location point of the cone, Xdir, Ydir and Zdir
    are the normalized directions of the local cartesian coordinate
    system of the cone (Zdir is the direction of the Cone's axis) ,
    Ang is the cone semi-angle.  The U parametrization range is
    [0, 2PI].
    KeyWords :
    Convert, Cone, BSplineSurface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_ConeToBSplineSurface self, gp_Cone C, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2) -> Convert_ConeToBSplineSurface
        __init__(Convert_ConeToBSplineSurface self, gp_Cone C, Standard_Real const V1, Standard_Real const V2) -> Convert_ConeToBSplineSurface

        The equivalent B-spline surface as the same orientation as the
        Cone in the U and V parametric directions.

        Raised if V1 = V2.

        :type C: OCC.wrapper.gp.gp_Cone
        :type V1: float
        :type V2: float

        """
        this = _Convert.new_Convert_ConeToBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_ConeToBSplineSurface
Convert_ConeToBSplineSurface_swigregister = _Convert.Convert_ConeToBSplineSurface_swigregister
Convert_ConeToBSplineSurface_swigregister(Convert_ConeToBSplineSurface)

class Convert_GridPolynomialToPoles(object):
    """
    Convert a grid of Polynomial Surfaces
    that are have continuity CM to an
    Bspline Surface that has continuity
    CM
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_GridPolynomialToPoles self, Standard_Integer const MaxUDegree, Standard_Integer const MaxVDegree, Handle_TColStd_HArray1OfInteger NumCoeff, Handle_TColStd_HArray1OfReal Coefficients, Handle_TColStd_HArray1OfReal PolynomialUIntervals, Handle_TColStd_HArray1OfReal PolynomialVIntervals) -> Convert_GridPolynomialToPoles
        __init__(Convert_GridPolynomialToPoles self, Standard_Integer const NbUSurfaces, Standard_Integer const NBVSurfaces, Standard_Integer const UContinuity, Standard_Integer const VContinuity, Standard_Integer const MaxUDegree, Standard_Integer const MaxVDegree, Handle_TColStd_HArray2OfInteger NumCoeffPerSurface, Handle_TColStd_HArray1OfReal Coefficients, Handle_TColStd_HArray1OfReal PolynomialUIntervals, Handle_TColStd_HArray1OfReal PolynomialVIntervals, Handle_TColStd_HArray1OfReal TrueUIntervals, Handle_TColStd_HArray1OfReal TrueVIntervals) -> Convert_GridPolynomialToPoles

        To one grid of polynomial Surface.
        Warning!
        Continuity in each parametric direction can be at MOST the
        maximum degree of the polynomial functions.

        <TrueUIntervals>, <TrueVIntervals> :
        this is the true parameterisation for the composite surface

        Coefficients :
        The Coefficients have to be formated than an "C array"
        [NbVSurfaces] [NBUSurfaces] [MaxUDegree+1] [MaxVDegree+1] [3]
        raises DomainError    if <NumCoeffPerSurface> is not a
        [1, NbVSurfaces*NbUSurfaces, 1,2] array.
        if <Coefficients> is not a

        :type NbUSurfaces: int
        :type NBVSurfaces: int
        :type UContinuity: int
        :type VContinuity: int
        :type MaxUDegree: int
        :type MaxVDegree: int
        :type NumCoeffPerSurface: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfInteger
        :type Coefficients: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PolynomialUIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PolynomialVIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type TrueUIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type TrueVIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        this = _Convert.new_Convert_GridPolynomialToPoles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Convert_GridPolynomialToPoles self, Standard_Integer const UContinuity, Standard_Integer const VContinuity, Standard_Integer const MaxUDegree, Standard_Integer const MaxVDegree, Handle_TColStd_HArray2OfInteger NumCoeffPerSurface, Handle_TColStd_HArray1OfReal Coefficients, Handle_TColStd_HArray1OfReal PolynomialUIntervals, Handle_TColStd_HArray1OfReal PolynomialVIntervals, Handle_TColStd_HArray1OfReal TrueUIntervals, Handle_TColStd_HArray1OfReal TrueVIntervals)

        :type UContinuity: int
        :type VContinuity: int
        :type MaxUDegree: int
        :type MaxVDegree: int
        :type NumCoeffPerSurface: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfInteger
        :type Coefficients: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PolynomialUIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PolynomialVIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type TrueUIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type TrueVIntervals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Convert.Convert_GridPolynomialToPoles_Perform(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(Convert_GridPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_GridPolynomialToPoles_NbUPoles(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(Convert_GridPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_GridPolynomialToPoles_NbVPoles(self, *args)


    def Poles(self, *args):
        """
        returns the poles of the BSpline Surface

        :rtype: OCC.wrapper.TColgp.Handle_TColgp_HArray2OfPnt

        """
        res = _Convert.Convert_GridPolynomialToPoles_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UDegree(self, *args):
        """
        UDegree(Convert_GridPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_GridPolynomialToPoles_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(Convert_GridPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_GridPolynomialToPoles_VDegree(self, *args)


    def NbUKnots(self, *args):
        """
        NbUKnots(Convert_GridPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_GridPolynomialToPoles_NbUKnots(self, *args)


    def NbVKnots(self, *args):
        """
        NbVKnots(Convert_GridPolynomialToPoles self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_GridPolynomialToPoles_NbVKnots(self, *args)


    def UKnots(self, *args):
        """
        Knots in the U direction

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _Convert.Convert_GridPolynomialToPoles_UKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VKnots(self, *args):
        """
        Knots in the V direction

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _Convert.Convert_GridPolynomialToPoles_VKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UMultiplicities(self, *args):
        """
        Multiplicities of the knots in the U direction

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _Convert.Convert_GridPolynomialToPoles_UMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VMultiplicities(self, *args):
        """
        Multiplicities of the knots in the V direction

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _Convert.Convert_GridPolynomialToPoles_VMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(Convert_GridPolynomialToPoles self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Convert.Convert_GridPolynomialToPoles_IsDone(self, *args)

    __swig_destroy__ = _Convert.delete_Convert_GridPolynomialToPoles
Convert_GridPolynomialToPoles_swigregister = _Convert.Convert_GridPolynomialToPoles_swigregister
Convert_GridPolynomialToPoles_swigregister(Convert_GridPolynomialToPoles)

class Convert_CompBezierCurves2dToBSplineCurve2d(object):
    """
    Converts a list  of connecting Bezier Curves 2d to  a
    BSplineCurve 2d.
    if possible, the continuity of the BSpline will be
    increased to more than C0.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_CompBezierCurves2dToBSplineCurve2d self, Standard_Real const AngularTolerance=1.0e-4) -> Convert_CompBezierCurves2dToBSplineCurve2d

        Constructs a framework for converting a sequence of
        adjacent non-rational Bezier curves into a BSpline curve.
        Knots will be created on the computed BSpline curve at
        each junction point of two consecutive Bezier curves. The
        degree of continuity of the BSpline curve will be increased at
        the junction point of two consecutive Bezier curves if their
        tangent vectors at this point are parallel. AngularTolerance
        (given in radians, and defaulted to 1.0 e-4) will be used
        to check the parallelism of the two tangent vectors.
        Use the following functions:
        -   AddCurve to define in sequence the adjacent Bezier
        curves to be converted,
        -   Perform to compute the data needed to build the BSpline curve,
        -   and the available consultation functions to access the
        computed data. This data may be used to construct the BSpline curve.

        :type AngularTolerance: float

        """
        this = _Convert.new_Convert_CompBezierCurves2dToBSplineCurve2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCurve(self, *args):
        """
        AddCurve(Convert_CompBezierCurves2dToBSplineCurve2d self, NCollection_Array1_gp_Pnt2d Poles)

        Adds the Bezier curve defined by the table of poles Poles, to
        the sequence (still contained in this framework) of adjacent
        Bezier curves to be converted into a BSpline curve.
        Only polynomial (i.e. non-rational) Bezier curves are
        converted using this framework.
        If this is not the first call to the function (i.e. if this framework
        still contains data in its sequence of Bezier curves), the
        degree of continuity of the BSpline curve will be increased at
        the time of computation at the first point of the added Bezier
        curve (i.e. the first point of the Poles table). This will be the
        case if the tangent vector of the curve at this point is
        parallel to the tangent vector at the end point of the
        preceding Bezier curve in the sequence of Bezier curves still
        contained in this framework. An angular tolerance given at
        the time of construction of this framework, will be used to
        check the parallelism of the two tangent vectors. This
        checking procedure, and all the relative computations will be
        performed by the function Perform.
        When the sequence of adjacent Bezier curves is complete,
        use the following functions:
        -   Perform to compute the data needed to build the BSpline curve,
        -   and the available consultation functions to access the
        computed data. This data may be used to construct the BSpline curve.
        Warning
        The sequence of Bezier curves treated by this framework is
        automatically initialized with the first Bezier curve when the
        function is first called. During subsequent use of this function,
        ensure that the first point of the added Bezier curve (i.e. the
        first point of the Poles table) is coincident with the last point
        of the sequence (i.e. the last point of the preceding Bezier
        curve in the sequence) of Bezier curves still contained in
        this framework. An error may occur at the time of
        computation if this condition is not satisfied. Particular care
        must be taken with respect to the above, as this condition is
        not checked either when defining the sequence of Bezier
        curves or at the time of computation.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_AddCurve(self, *args)


    def Perform(self, *args):
        """
        Perform(Convert_CompBezierCurves2dToBSplineCurve2d self)

        Computes all the data needed to build a BSpline curve
        equivalent to the sequence of adjacent Bezier curves still
        contained in this framework.
        A knot is inserted on the computed BSpline curve at the
        junction point of two consecutive Bezier curves. The
        degree of continuity of the BSpline curve will be increased
        at the junction point of two consecutive Bezier curves if
        their tangent vectors at this point are parallel. An angular
        tolerance given at the time of construction of this
        framework is used to check the parallelism of the two
        tangent vectors.
        Use the available consultation functions to access the
        computed data. This data may then be used to construct
        the BSpline curve.
        Warning
        Ensure that the curves in the sequence of Bezier curves
        contained in this framework are adjacent. An error may
        occur at the time of computation if this condition is not
        satisfied. Particular care must be taken with respect to the
        above as this condition is not checked, either when
        defining the Bezier curve sequence or at the time of computation.


        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Perform(self, *args)


    def Degree(self, *args):
        """
        Degree(Convert_CompBezierCurves2dToBSplineCurve2d self) -> Standard_Integer

        Returns the degree of the BSpline curve whose data is
        computed in this framework.
        Warning
        Take particular care not to use this function before the
        computation is performed (Perform function), as this
        condition is not checked and an error may therefore occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Degree(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Convert_CompBezierCurves2dToBSplineCurve2d self) -> Standard_Integer

        Returns the number of poles of the BSpline curve whose
        data is computed in this framework.
        Warning
        Take particular care not to use this function before the
        computation is performed (Perform function), as this
        condition is not checked and an error may therefore occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbPoles(self, *args)


    def Poles(self, *args):
        """
        Poles(Convert_CompBezierCurves2dToBSplineCurve2d self, NCollection_Array1_gp_Pnt2d Poles)

        Loads the Poles table with the poles of the BSpline curve
        whose data is computed in this framework.
        Warning
        -   Do not use this function before the computation is
        performed (Perform function).
        -   The length of the Poles array must be equal to the
        number of poles of the BSpline curve whose data is
        computed in this framework.
        Particular care must be taken with respect to the above, as
        these conditions are not checked, and an error may occur.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_Poles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Convert_CompBezierCurves2dToBSplineCurve2d self) -> Standard_Integer

        Returns the number of knots of the BSpline curve whose
        data is computed in this framework.
        Warning
        Take particular care not to use this function before the
        computation is performed (Perform function), as this
        condition is not checked and an error may therefore occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_NbKnots(self, *args)


    def KnotsAndMults(self, *args):
        """
        KnotsAndMults(Convert_CompBezierCurves2dToBSplineCurve2d self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        Loads the Knots table with the knots
        and the Mults table with the corresponding multiplicities
        of the BSpline curve whose data is computed in this framework.
        Warning
        -   Do not use this function before the computation is
        performed (Perform function).
        -   The length of the Knots and Mults arrays must be equal
        to the number of knots in the BSpline curve whose data is
        computed in this framework.
        Particular care must be taken with respect to the above as
        these conditions are not checked, and an error may occur.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_KnotsAndMults(self, *args)

    __swig_destroy__ = _Convert.delete_Convert_CompBezierCurves2dToBSplineCurve2d
Convert_CompBezierCurves2dToBSplineCurve2d_swigregister = _Convert.Convert_CompBezierCurves2dToBSplineCurve2d_swigregister
Convert_CompBezierCurves2dToBSplineCurve2d_swigregister(Convert_CompBezierCurves2dToBSplineCurve2d)

class Convert_SphereToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    """
    This algorithm converts a bounded Sphere into a rational
    B-spline surface. The sphere is a Sphere from package gp.
    The parametrization of the sphere is
    P (U, V) = Loc  + Radius * Sin(V) * Zdir +
    Radius * Cos(V) * (Cos(U)*Xdir + Sin(U)*Ydir)
    where Loc is the center of the sphere Xdir, Ydir and Zdir are the
    normalized directions of the local cartesian coordinate system of
    the sphere. The parametrization range is U [0, 2PI] and
    V [-PI/2, PI/2].
    KeyWords :
    Convert, Sphere, BSplineSurface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_SphereToBSplineSurface self, gp_Sphere Sph, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2) -> Convert_SphereToBSplineSurface
        __init__(Convert_SphereToBSplineSurface self, gp_Sphere Sph, Standard_Real const Param1, Standard_Real const Param2, Standard_Boolean const UTrim) -> Convert_SphereToBSplineSurface
        __init__(Convert_SphereToBSplineSurface self, gp_Sphere Sph) -> Convert_SphereToBSplineSurface

        The equivalent B-spline surface as the same orientation
        as the sphere in the U and V parametric directions.

        :type Sph: OCC.wrapper.gp.gp_Sphere

        """
        this = _Convert.new_Convert_SphereToBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_SphereToBSplineSurface
Convert_SphereToBSplineSurface_swigregister = _Convert.Convert_SphereToBSplineSurface_swigregister
Convert_SphereToBSplineSurface_swigregister(Convert_SphereToBSplineSurface)

class Convert_EllipseToBSplineCurve(Convert_ConicToBSplineCurve):
    """
    This algorithm converts a ellipse into a rational B-spline curve.
    The ellipse is represented an Elips2d from package gp with
    the parametrization :
    P (U) =
    Loc + (MajorRadius * Cos(U) * Xdir + MinorRadius * Sin(U) * Ydir)
    where Loc is the center of the ellipse, Xdir and Ydir are the
    normalized directions of the local cartesian coordinate system of
    the ellipse. The parametrization range is U [0, 2PI].
    KeyWords :
    Convert, Ellipse, BSplineCurve, 2D .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_EllipseToBSplineCurve self, gp_Elips2d E, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Convert_EllipseToBSplineCurve
        __init__(Convert_EllipseToBSplineCurve self, gp_Elips2d E, Standard_Real const U1, Standard_Real const U2, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Convert_EllipseToBSplineCurve

        The ellipse E is limited between the parametric values U1, U2.
        The equivalent B-spline curve is oriented from U1 to U2 and has
        the same orientation as E.

        Raised if U1 = U2 or U1 = U2 + 2.0 * Pi

        :type E: OCC.wrapper.gp.gp_Elips2d
        :type U1: float
        :type U2: float
        :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType

        """
        this = _Convert.new_Convert_EllipseToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_EllipseToBSplineCurve
Convert_EllipseToBSplineCurve_swigregister = _Convert.Convert_EllipseToBSplineCurve_swigregister
Convert_EllipseToBSplineCurve_swigregister(Convert_EllipseToBSplineCurve)

class Convert_CircleToBSplineCurve(Convert_ConicToBSplineCurve):
    """
    This algorithm converts a circle into a rational B-spline curve.
    The circle is a Circ2d from package gp and its parametrization is :
    P (U) = Loc + R * (Cos(U) * Xdir + Sin(U) * YDir) where Loc is the
    center of the circle Xdir and Ydir are the normalized directions
    of the local cartesian coordinate system of the circle.
    The parametrization range for the circle is U [0, 2Pi].

    Warnings :
    The parametrization range for the B-spline curve is not [0, 2Pi].

    KeyWords :
    Convert, Circle, BSplineCurve, 2D .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_CircleToBSplineCurve self, gp_Circ2d C, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Convert_CircleToBSplineCurve
        __init__(Convert_CircleToBSplineCurve self, gp_Circ2d C, Standard_Real const U1, Standard_Real const U2, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Convert_CircleToBSplineCurve

        The circle C is limited between the parametric values U1, U2
        in radians. U1 and U2 [0.0, 2*Pi] .
        The equivalent B-spline curve is oriented from U1 to U2 and has
        the same orientation as the circle C.

        Raised if U1 = U2 or U1 = U2 + 2.0 * Pi

        :type C: OCC.wrapper.gp.gp_Circ2d
        :type U1: float
        :type U2: float
        :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType

        """
        this = _Convert.new_Convert_CircleToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_CircleToBSplineCurve
Convert_CircleToBSplineCurve_swigregister = _Convert.Convert_CircleToBSplineCurve_swigregister
Convert_CircleToBSplineCurve_swigregister(Convert_CircleToBSplineCurve)

class Convert_TorusToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    """
    This algorithm converts a bounded Torus into a rational
    B-spline surface. The torus is a Torus from package gp.
    The parametrization of the torus is :
    P (U, V) =
    Loc  +  MinorRadius * Sin(V) * Zdir +
    (MajorRadius+MinorRadius*Cos(V)) *  (Cos(U)*Xdir + Sin(U)*Ydir)
    where Loc is the center of the torus, Xdir, Ydir and Zdir are the
    normalized directions of the local cartesian coordinate system of
    the Torus. The parametrization range is U [0, 2PI], V [0, 2PI].
    KeyWords :
    Convert, Torus, BSplineSurface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Convert_TorusToBSplineSurface self, gp_Torus T, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2) -> Convert_TorusToBSplineSurface
        __init__(Convert_TorusToBSplineSurface self, gp_Torus T, Standard_Real const Param1, Standard_Real const Param2, Standard_Boolean const UTrim) -> Convert_TorusToBSplineSurface
        __init__(Convert_TorusToBSplineSurface self, gp_Torus T) -> Convert_TorusToBSplineSurface

        The equivalent B-spline surface as the same orientation as the
        torus in the U and V parametric directions.

        :type T: OCC.wrapper.gp.gp_Torus

        """
        this = _Convert.new_Convert_TorusToBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_Convert_TorusToBSplineSurface
Convert_TorusToBSplineSurface_swigregister = _Convert.Convert_TorusToBSplineSurface_swigregister
Convert_TorusToBSplineSurface_swigregister(Convert_TorusToBSplineSurface)

class NCollection_Sequence_Handle_TColgp_HArray1OfPnt(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> NCollection_Sequence< opencascade::handle< TColgp_HArray1OfPnt > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> NCollection_Sequence< opencascade::handle< TColgp_HArray1OfPnt > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> NCollection_Sequence< opencascade::handle< TColgp_HArray1OfPnt > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> NCollection_Sequence< opencascade::handle< TColgp_HArray1OfPnt > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Convert.new_NCollection_Sequence_Handle_TColgp_HArray1OfPnt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self)

        Reverse sequence


        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theOther) -> NCollection_Sequence_Handle_TColgp_HArray1OfPnt

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theOther) -> NCollection_Sequence_Handle_TColgp_HArray1OfPnt

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, NCollection_Sequence< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem)
        Append(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem)
        Prepend(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex, Handle_TColgp_HArray1OfPnt theItem)
        InsertBefore(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, NCollection_Sequence< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & thePosition, Handle_TColgp_HArray1OfPnt theItem)
        InsertAfter(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theSeq)
        InsertAfter(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex, Handle_TColgp_HArray1OfPnt theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TColgp_HArray1OfPnt theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Handle_TColgp_HArray1OfPnt

        First item access

        :rtype: TheItemType &

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self) -> Handle_TColgp_HArray1OfPnt

        Last item access

        :rtype: TheItemType &

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex) -> Handle_TColgp_HArray1OfPnt

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TColgp_HArray1OfPnt self, Standard_Integer const theIndex, Handle_TColgp_HArray1OfPnt theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_SetValue(self, *args)


    def __iter__(self):
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt___iter__(self)
    __swig_destroy__ = _Convert.delete_NCollection_Sequence_Handle_TColgp_HArray1OfPnt
NCollection_Sequence_Handle_TColgp_HArray1OfPnt_swigregister = _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_swigregister
NCollection_Sequence_Handle_TColgp_HArray1OfPnt_swigregister(NCollection_Sequence_Handle_TColgp_HArray1OfPnt)

def NCollection_Sequence_Handle_TColgp_HArray1OfPnt_delNode(*args):
    """
    NCollection_Sequence_Handle_TColgp_HArray1OfPnt_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_delNode(*args)

class NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Convert.new_NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Convert.delete_NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper

    def __next__(self):
        return _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper_swigregister = _Convert.NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper_swigregister
NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper_swigregister(NCollection_Sequence_Handle_TColgp_HArray1OfPnt_IteratorHelper)


try:
	Convert_SequenceOfArray1OfPoles = NCollection_Sequence_Handle_TColgp_HArray1OfPnt
except NameError:
	pass # does not exist, probably ignored




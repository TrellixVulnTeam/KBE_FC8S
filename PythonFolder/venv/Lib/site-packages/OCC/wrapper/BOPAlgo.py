# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BOPAlgo')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BOPAlgo')
    _BOPAlgo = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BOPAlgo', [dirname(__file__)])
        except ImportError:
            import _BOPAlgo
            return _BOPAlgo
        try:
            _mod = imp.load_module('_BOPAlgo', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BOPAlgo = swig_import_helper()
    del swig_import_helper
else:
    import _BOPAlgo
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BOPAlgo.delete_SwigPyIterator

    def value(self):
        return _BOPAlgo.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BOPAlgo.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BOPAlgo.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BOPAlgo.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BOPAlgo.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BOPAlgo.SwigPyIterator_copy(self)

    def next(self):
        return _BOPAlgo.SwigPyIterator_next(self)

    def __next__(self):
        return _BOPAlgo.SwigPyIterator___next__(self)

    def previous(self):
        return _BOPAlgo.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BOPAlgo.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BOPAlgo.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BOPAlgo.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BOPAlgo.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BOPAlgo.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BOPAlgo.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BOPAlgo.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BOPAlgo.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BOPAlgo.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BOPAlgo.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BOPAlgo.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BOPAlgo.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPAlgo.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BOPAlgo.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BOPAlgo.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BOPAlgo.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BOPAlgo.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BOPAlgo.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BOPAlgo.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BOPAlgo.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPAlgo.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BOPAlgo.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BOPAlgo.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BOPAlgo.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BOPAlgo.ptr_to_number(item)
ptr_to_number = _BOPAlgo.ptr_to_number

def HashCode(*args):
    return _BOPAlgo.HashCode(*args)
HashCode = _BOPAlgo.HashCode

def ptr_equal(a, b):
    return _BOPAlgo.ptr_equal(a, b)
ptr_equal = _BOPAlgo.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPTools
else:
    import BOPTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
BOPAlgo_COMMON = _BOPAlgo.BOPAlgo_COMMON
BOPAlgo_FUSE = _BOPAlgo.BOPAlgo_FUSE
BOPAlgo_CUT = _BOPAlgo.BOPAlgo_CUT
BOPAlgo_CUT21 = _BOPAlgo.BOPAlgo_CUT21
BOPAlgo_SECTION = _BOPAlgo.BOPAlgo_SECTION
BOPAlgo_UNKNOWN = _BOPAlgo.BOPAlgo_UNKNOWN
BOPAlgo_CheckUnknown = _BOPAlgo.BOPAlgo_CheckUnknown
BOPAlgo_BadType = _BOPAlgo.BOPAlgo_BadType
BOPAlgo_SelfIntersect = _BOPAlgo.BOPAlgo_SelfIntersect
BOPAlgo_TooSmallEdge = _BOPAlgo.BOPAlgo_TooSmallEdge
BOPAlgo_NonRecoverableFace = _BOPAlgo.BOPAlgo_NonRecoverableFace
BOPAlgo_IncompatibilityOfVertex = _BOPAlgo.BOPAlgo_IncompatibilityOfVertex
BOPAlgo_IncompatibilityOfEdge = _BOPAlgo.BOPAlgo_IncompatibilityOfEdge
BOPAlgo_IncompatibilityOfFace = _BOPAlgo.BOPAlgo_IncompatibilityOfFace
BOPAlgo_OperationAborted = _BOPAlgo.BOPAlgo_OperationAborted
BOPAlgo_GeomAbs_C0 = _BOPAlgo.BOPAlgo_GeomAbs_C0
BOPAlgo_InvalidCurveOnSurface = _BOPAlgo.BOPAlgo_InvalidCurveOnSurface
BOPAlgo_NotValid = _BOPAlgo.BOPAlgo_NotValid
BOPAlgo_GlueOff = _BOPAlgo.BOPAlgo_GlueOff
BOPAlgo_GlueShift = _BOPAlgo.BOPAlgo_GlueShift
BOPAlgo_GlueFull = _BOPAlgo.BOPAlgo_GlueFull
class BOPAlgo_Options(object):
    """
    The class provides the following options for the algorithms in Boolean Component:
    - *Memory allocation tool* - tool for memory allocations;
    - *Error and warning reporting* - allows recording warnings and errors occurred 
    during the operation.
    Error means that the algorithm has failed.
    - *Parallel processing mode* - provides the possibility to perform operation in parallel mode;
    - *Fuzzy tolerance* - additional tolerance for the operation to detect
    touching or coinciding cases;
    - *Progress indicator* - provides interface to track the progress of
    operation and stop the operation by user's break.
    - *Using the Oriented Bounding Boxes* - Allows using the Oriented Bounding Boxes of the shapes
    for filtering the intersections.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_Options self) -> BOPAlgo_Options
        __init__(BOPAlgo_Options self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_Options

        Constructor with allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_Options(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Allocator(self, *args):
        """
        Returns allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _BOPAlgo.BOPAlgo_Options_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(BOPAlgo_Options self)

        Clears all warnings and errors, and any data cached by the algorithm.
        User defined options are not cleared.


        """
        return _BOPAlgo.BOPAlgo_Options_Clear(self, *args)


    def AddError(self, *args):
        """
        AddError(BOPAlgo_Options self, Handle_Message_Alert theAlert)

        Adds the alert as error (fail)

        :type theAlert: OCC.wrapper.Message.Handle_Message_Alert

        """
        return _BOPAlgo.BOPAlgo_Options_AddError(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(BOPAlgo_Options self, Handle_Message_Alert theAlert)

        Adds the alert as warning

        :type theAlert: OCC.wrapper.Message.Handle_Message_Alert

        """
        return _BOPAlgo.BOPAlgo_Options_AddWarning(self, *args)


    def HasErrors(self, *args):
        """
        HasErrors(BOPAlgo_Options self) -> Standard_Boolean

        Returns true if algorithm has failed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_HasErrors(self, *args)


    def HasError(self, *args):
        """
        HasError(BOPAlgo_Options self, Handle_Standard_Type theType) -> Standard_Boolean

        Returns true if algorithm has generated error of specified type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_HasError(self, *args)


    def HasWarnings(self, *args):
        """
        HasWarnings(BOPAlgo_Options self) -> Standard_Boolean

        Returns true if algorithm has generated some warning alerts

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_HasWarnings(self, *args)


    def HasWarning(self, *args):
        """
        HasWarning(BOPAlgo_Options self, Handle_Standard_Type theType) -> Standard_Boolean

        Returns true if algorithm has generated warning of specified type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_HasWarning(self, *args)


    def GetReport(self, *args):
        """
        Returns report collecting all errors and warnings

        :rtype: OCC.wrapper.Message.Handle_Message_Report

        """
        res = _BOPAlgo.BOPAlgo_Options_GetReport(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DumpErrors(self, *args):
        """
        DumpErrors(BOPAlgo_Options self, Standard_OStream & theOS)

        Dumps the error status into the given stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BOPAlgo.BOPAlgo_Options_DumpErrors(self, *args)


    def DumpWarnings(self, *args):
        """
        DumpWarnings(BOPAlgo_Options self, Standard_OStream & theOS)

        Dumps the warning statuses into the given stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BOPAlgo.BOPAlgo_Options_DumpWarnings(self, *args)


    def ClearWarnings(self, *args):
        """
        ClearWarnings(BOPAlgo_Options self)

        Clears the warnings of the algorithm


        """
        return _BOPAlgo.BOPAlgo_Options_ClearWarnings(self, *args)


    def GetParallelMode(*args):
        """
        GetParallelMode() -> Standard_Boolean

        Gets the global parallel mode

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_GetParallelMode(*args)

    GetParallelMode = staticmethod(GetParallelMode)

    def SetParallelMode(*args):
        """
        SetParallelMode(Standard_Boolean const theNewMode)

        Sets the global parallel mode

        :type theNewMode: bool

        """
        return _BOPAlgo.BOPAlgo_Options_SetParallelMode(*args)

    SetParallelMode = staticmethod(SetParallelMode)

    def SetRunParallel(self, *args):
        """
        SetRunParallel(BOPAlgo_Options self, Standard_Boolean const theFlag)

        Set the flag of parallel processing
        if <theFlag> is true  the parallel processing is switched on
        if <theFlag> is false the parallel processing is switched off

        :type theFlag: bool

        """
        return _BOPAlgo.BOPAlgo_Options_SetRunParallel(self, *args)


    def RunParallel(self, *args):
        """
        RunParallel(BOPAlgo_Options self) -> Standard_Boolean

        Returns the flag of parallel processing

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_RunParallel(self, *args)


    def SetFuzzyValue(self, *args):
        """
        SetFuzzyValue(BOPAlgo_Options self, Standard_Real const theFuzz)

        Sets the additional tolerance

        :type theFuzz: float

        """
        return _BOPAlgo.BOPAlgo_Options_SetFuzzyValue(self, *args)


    def FuzzyValue(self, *args):
        """
        FuzzyValue(BOPAlgo_Options self) -> Standard_Real

        Returns the additional tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPAlgo.BOPAlgo_Options_FuzzyValue(self, *args)


    def SetProgressIndicator(self, *args):
        """
        SetProgressIndicator(BOPAlgo_Options self, Handle_Message_ProgressIndicator theObj)

        Set the Progress Indicator object.

        :type theObj: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _BOPAlgo.BOPAlgo_Options_SetProgressIndicator(self, *args)


    def SetUseOBB(self, *args):
        """
        SetUseOBB(BOPAlgo_Options self, Standard_Boolean const theUseOBB)

        Enables/Disables the usage of OBB

        :type theUseOBB: bool

        """
        return _BOPAlgo.BOPAlgo_Options_SetUseOBB(self, *args)


    def UseOBB(self, *args):
        """
        UseOBB(BOPAlgo_Options self) -> Standard_Boolean

        Returns the flag defining usage of OBB

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Options_UseOBB(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_Options
BOPAlgo_Options_swigregister = _BOPAlgo.BOPAlgo_Options_swigregister
BOPAlgo_Options_swigregister(BOPAlgo_Options)

def BOPAlgo_Options_GetParallelMode(*args):
    """
    BOPAlgo_Options_GetParallelMode() -> Standard_Boolean

    Gets the global parallel mode

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPAlgo.BOPAlgo_Options_GetParallelMode(*args)

def BOPAlgo_Options_SetParallelMode(*args):
    """
    BOPAlgo_Options_SetParallelMode(Standard_Boolean const theNewMode)

    Sets the global parallel mode

    :type theNewMode: bool

    """
    return _BOPAlgo.BOPAlgo_Options_SetParallelMode(*args)

class BOPAlgo_Algo(BOPAlgo_Options):
    """The class provides the root interface for the algorithms in Boolean Component.<br>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Perform(self, *args):
        """Perform(BOPAlgo_Algo self)"""
        return _BOPAlgo.BOPAlgo_Algo_Perform(self, *args)

BOPAlgo_Algo_swigregister = _BOPAlgo.BOPAlgo_Algo_swigregister
BOPAlgo_Algo_swigregister(BOPAlgo_Algo)

class BOPAlgo_PaveFiller(BOPAlgo_Algo):
    """
    The class represents the Intersection phase of the
    Boolean Operations algorithm.<br>
    It performs the pairwise intersection of the sub-shapes of
    the arguments in the following order:<br>
    1. Vertex/Vertex;<br>
    2. Vertex/Edge;<br>
    3. Edge/Edge;<br>
    4. Vertex/Face;<br>
    5. Edge/Face;<br>
    6. Face/Face.<br>

    The results of intersection are stored into the Data Structure
    of the algorithm.<br>

    Additionally to the options provided by the parent class,
    the algorithm has the following options:<br>
    - *Section attributes* - allows to customize the intersection of the faces
    (avoid approximation or building 2d curves);<br>
    - *Safe processing mode* - allows to avoid modification of the input
    shapes during the operation (by default it is off);<br>
    - *Gluing options* - allows to speed up the calculation on the special
    cases, in which some sub-shapes are coincide.<br>

    The algorithm returns the following Warning statuses:
    - *BOPAlgo_AlertSelfInterferingShape* - in case some of the argument shapes are self-interfering shapes;
    - *BOPAlgo_AlertTooSmallEdge* - in case some edges of the input shapes have no valid range;
    - *BOPAlgo_AlertNotSplittableEdge* - in case some edges of the input shapes has such a small
    valid range so it cannot be split;
    - *BOPAlgo_AlertBadPositioning* - in case the positioning of the input shapes leads to creation
    of small edges;
    - *BOPAlgo_AlertIntersectionOfPairOfShapesFailed* - in case intersection of some of the
    sub-shapes has failed;
    - *BOPAlgo_AlertAcquiredSelfIntersection* - in case some sub-shapes of the argument become connected
    through other shapes;
    - *BOPAlgo_AlertBuildingPCurveFailed* - in case building 2D curve for some of the edges
    on the faces has failed.

    The algorithm returns the following Error alerts:
    - *BOPAlgo_AlertTooFewArguments* - in case there are no enough arguments to
    perform the operation;<br>
    - *BOPAlgo_AlertIntersectionFailed* - in case some unexpected error occurred;<br>
    - *BOPAlgo_AlertNullInputShapes* - in case some of the arguments are null shapes.<br>

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_PaveFiller self) -> BOPAlgo_PaveFiller
        __init__(BOPAlgo_PaveFiller self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_PaveFiller

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_PaveFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DS(self, *args):
        """
        DS(BOPAlgo_PaveFiller self) -> BOPDS_DS

        :rtype: OCC.wrapper.BOPDS.BOPDS_DS

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_DS(self, *args)


    def PDS(self, *args):
        """
        PDS(BOPAlgo_PaveFiller self) -> BOPDS_DS

        :rtype: OCC.wrapper.BOPDS.BOPDS_PDS

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_PDS(self, *args)


    def SetArguments(self, *args):
        """
        SetArguments(BOPAlgo_PaveFiller self, NCollection_List_TopoDS_Shape theLS)

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_SetArguments(self, *args)


    def Arguments(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_PaveFiller_Arguments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Context(self, *args):
        """
        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _BOPAlgo.BOPAlgo_PaveFiller_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSectionAttribute(self, *args):
        """
        SetSectionAttribute(BOPAlgo_PaveFiller self, BOPAlgo_SectionAttribute theSecAttr)

        :type theSecAttr: OCC.wrapper.BOPAlgo.BOPAlgo_SectionAttribute

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_SetSectionAttribute(self, *args)


    def SetNonDestructive(self, *args):
        """
        SetNonDestructive(BOPAlgo_PaveFiller self, Standard_Boolean const theFlag)

        Sets the flag that defines the mode of treatment.
        In non-destructive mode the argument shapes are not modified. Instead
        a copy of a sub-shape is created in the result if it is needed to be updated.

        :type theFlag: bool

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_SetNonDestructive(self, *args)


    def NonDestructive(self, *args):
        """
        NonDestructive(BOPAlgo_PaveFiller self) -> Standard_Boolean

        Returns the flag that defines the mode of treatment.
        In non-destructive mode the argument shapes are not modified. Instead
        a copy of a sub-shape is created in the result if it is needed to be updated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_NonDestructive(self, *args)


    def Perform(self, *args):
        """Perform(BOPAlgo_PaveFiller self)"""
        return _BOPAlgo.BOPAlgo_PaveFiller_Perform(self, *args)


    def SetGlue(self, *args):
        """
        SetGlue(BOPAlgo_PaveFiller self, BOPAlgo_GlueEnum const theGlue)

        Sets the glue option for the algorithm

        :type theGlue: OCC.wrapper.BOPAlgo.BOPAlgo_GlueEnum

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_SetGlue(self, *args)


    def Glue(self, *args):
        """
        Glue(BOPAlgo_PaveFiller self) -> BOPAlgo_GlueEnum

        Returns the glue option of the algorithm

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_GlueEnum

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_Glue(self, *args)


    def SetAvoidBuildPCurve(self, *args):
        """
        SetAvoidBuildPCurve(BOPAlgo_PaveFiller self, Standard_Boolean const theValue)

        Sets the flag to avoid building of p-curves of edges on faces

        :type theValue: bool

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_SetAvoidBuildPCurve(self, *args)


    def IsAvoidBuildPCurve(self, *args):
        """
        IsAvoidBuildPCurve(BOPAlgo_PaveFiller self) -> Standard_Boolean

        Returns the flag to avoid building of p-curves of edges on faces

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_PaveFiller_IsAvoidBuildPCurve(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_PaveFiller
BOPAlgo_PaveFiller_swigregister = _BOPAlgo.BOPAlgo_PaveFiller_swigregister
BOPAlgo_PaveFiller_swigregister(BOPAlgo_PaveFiller)

class BOPAlgo_BuilderShape(BOPAlgo_Algo):
    """
    Root class for algorithms that has shape as result.<br>
    The class provides the History mechanism, which allows
    tracking the modification of the input shapes during
    the operation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Shape(self, *args):
        """
        Returns the result of algorithm

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_BuilderShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns the list of shapes generated from the
        shape theS.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_BuilderShape_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list of shapes modified from the
        shape theS.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_BuilderShape_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BOPAlgo_BuilderShape self, TopoDS_Shape theS) -> Standard_Boolean

        Returns true if the shape theS has been deleted.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_BuilderShape_IsDeleted(self, *args)


    def HasDeleted(self, *args):
        """
        HasDeleted(BOPAlgo_BuilderShape self) -> Standard_Boolean

        Returns true if the at least one shape(or subshape)
        of arguments has been deleted.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_BuilderShape_HasDeleted(self, *args)


    def HasGenerated(self, *args):
        """
        HasGenerated(BOPAlgo_BuilderShape self) -> Standard_Boolean

        Returns true if the at least one shape(or subshape)
        of arguments has generated shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_BuilderShape_HasGenerated(self, *args)


    def HasModified(self, *args):
        """
        HasModified(BOPAlgo_BuilderShape self) -> Standard_Boolean

        Returns true if the at least one shape(or subshape)
        of arguments has modified shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_BuilderShape_HasModified(self, *args)


    def ImagesResult(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        res = _BOPAlgo.BOPAlgo_BuilderShape_ImagesResult(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


BOPAlgo_BuilderShape_swigregister = _BOPAlgo.BOPAlgo_BuilderShape_swigregister
BOPAlgo_BuilderShape_swigregister(BOPAlgo_BuilderShape)

class BOPAlgo_BuilderArea(BOPAlgo_Algo):
    """
    The root class for algorithms to build
    faces/solids from set of edges/faces
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetContext(self, *args):
        """
        SetContext(BOPAlgo_BuilderArea self, Handle_IntTools_Context theContext)

        Sets the context for the algorithms

        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPAlgo.BOPAlgo_BuilderArea_SetContext(self, *args)


    def Shapes(self, *args):
        """
        Returns the input shapes

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_BuilderArea_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShapes(self, *args):
        """
        SetShapes(BOPAlgo_BuilderArea self, NCollection_List_TopoDS_Shape theLS)

        Sets the shapes for building areas

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_BuilderArea_SetShapes(self, *args)


    def Loops(self, *args):
        """
        Returns the found loops

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_BuilderArea_Loops(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Areas(self, *args):
        """
        Returns the found areas

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_BuilderArea_Areas(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAvoidInternalShapes(self, *args):
        """
        SetAvoidInternalShapes(BOPAlgo_BuilderArea self, Standard_Boolean const theAvoidInternal)

        Defines the preventing of addition of internal parts into result.
        The default value is FALSE, i.e. the internal parts are added into result.

        :type theAvoidInternal: bool

        """
        return _BOPAlgo.BOPAlgo_BuilderArea_SetAvoidInternalShapes(self, *args)


    def IsAvoidInternalShapes(self, *args):
        """
        IsAvoidInternalShapes(BOPAlgo_BuilderArea self) -> Standard_Boolean

        Returns the AvoidInternalShapes flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_BuilderArea_IsAvoidInternalShapes(self, *args)

BOPAlgo_BuilderArea_swigregister = _BOPAlgo.BOPAlgo_BuilderArea_swigregister
BOPAlgo_BuilderArea_swigregister(BOPAlgo_BuilderArea)

class BOPAlgo_Builder(BOPAlgo_BuilderShape):
    """
    The class is a General Fuse algorithm - base algorithm for the
    algorithms in the Boolean Component. Its main purpose is to build
    the split parts of the argument shapes from which the result of
    the operations is combined.<br>
    The result of the General Fuse algorithm itself is a compound
    containing all split parts of the arguments. <br>

    Additionally to the options of the base classes, the algorithm has
    the following options:<br>
    - *Safe processing mode* - allows to avoid modification of the input
    shapes during the operation (by default it is off);<br>
    - *Gluing options* - allows to speed up the calculation of the intersections
    on the special cases, in which some sub-shapes are coinciding.<br>
    - *Disabling the check for inverted solids* - Disables/Enables the check of the input solids
    for inverted status (holes in the space). The default value is TRUE,
    i.e. the check is performed. Setting this flag to FALSE for inverted solids,
    most likely will lead to incorrect results.

    The algorithm returns the following warnings:
    - *BOPAlgo_AlertUnableToOrientTheShape* - in case the check on the orientation of the split shape
    to match the orientation of the original shape has failed.

    The algorithm returns the following Error statuses:
    - *BOPAlgo_AlertTooFewArguments* - in case there are no enough arguments to perform the operation;
    - *BOPAlgo_AlertNoFiller* - in case the intersection tool has not been created;
    - *BOPAlgo_AlertIntersectionFailed* - in case the intersection of the arguments has failed;
    - *BOPAlgo_AlertBuilderFailed* - in case building splits of arguments has failed with some unexpected error.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_Builder self) -> BOPAlgo_Builder
        __init__(BOPAlgo_Builder self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_Builder

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_Builder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPAlgo_Builder self)

        Clears the content of the algorithm.


        """
        return _BOPAlgo.BOPAlgo_Builder_Clear(self, *args)


    def PPaveFiller(self, *args):
        """
        PPaveFiller(BOPAlgo_Builder self) -> BOPAlgo_PaveFiller

        Returns the PaveFiller, algorithm for sub-shapes intersection.

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_PPaveFiller

        """
        return _BOPAlgo.BOPAlgo_Builder_PPaveFiller(self, *args)


    def PDS(self, *args):
        """
        PDS(BOPAlgo_Builder self) -> BOPDS_DS

        Returns the Data Structure, holder of intersection information.

        :rtype: OCC.wrapper.BOPDS.BOPDS_PDS

        """
        return _BOPAlgo.BOPAlgo_Builder_PDS(self, *args)


    def Context(self, *args):
        """
        Context(BOPAlgo_Builder self) -> Handle_IntTools_Context

        Returns the Context, tool for cashing heavy algorithms.

        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPAlgo.BOPAlgo_Builder_Context(self, *args)


    def AddArgument(self, *args):
        """
        AddArgument(BOPAlgo_Builder self, TopoDS_Shape theShape)

        Adds the argument to the operation.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_Builder_AddArgument(self, *args)


    def SetArguments(self, *args):
        """
        SetArguments(BOPAlgo_Builder self, NCollection_List_TopoDS_Shape theLS)

        Sets the list of arguments for the operation.

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_Builder_SetArguments(self, *args)


    def Arguments(self, *args):
        """
        Returns the list of arguments.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_Builder_Arguments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNonDestructive(self, *args):
        """
        SetNonDestructive(BOPAlgo_Builder self, Standard_Boolean const theFlag)

        Sets the flag that defines the mode of treatment.
        In non-destructive mode the argument shapes are not modified. Instead
        a copy of a sub-shape is created in the result if it is needed to be updated.
        This flag is taken into account if internal PaveFiller is used only.
        In the case of calling PerformWithFiller the corresponding flag of that PaveFiller
        is in force.

        :type theFlag: bool

        """
        return _BOPAlgo.BOPAlgo_Builder_SetNonDestructive(self, *args)


    def NonDestructive(self, *args):
        """
        NonDestructive(BOPAlgo_Builder self) -> Standard_Boolean

        Returns the flag that defines the mode of treatment.
        In non-destructive mode the argument shapes are not modified. Instead
        a copy of a sub-shape is created in the result if it is needed to be updated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Builder_NonDestructive(self, *args)


    def SetGlue(self, *args):
        """
        SetGlue(BOPAlgo_Builder self, BOPAlgo_GlueEnum const theGlue)

        Sets the glue option for the algorithm

        :type theGlue: OCC.wrapper.BOPAlgo.BOPAlgo_GlueEnum

        """
        return _BOPAlgo.BOPAlgo_Builder_SetGlue(self, *args)


    def Glue(self, *args):
        """
        Glue(BOPAlgo_Builder self) -> BOPAlgo_GlueEnum

        Returns the glue option of the algorithm

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_GlueEnum

        """
        return _BOPAlgo.BOPAlgo_Builder_Glue(self, *args)


    def SetCheckInverted(self, *args):
        """
        SetCheckInverted(BOPAlgo_Builder self, Standard_Boolean const theCheck)

        Enables/Disables the check of the input solids for inverted status

        :type theCheck: bool

        """
        return _BOPAlgo.BOPAlgo_Builder_SetCheckInverted(self, *args)


    def CheckInverted(self, *args):
        """
        CheckInverted(BOPAlgo_Builder self) -> Standard_Boolean

        Returns the flag defining whether the check for input solids on inverted status
        should be performed or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Builder_CheckInverted(self, *args)


    def Perform(self, *args):
        """
        Perform(BOPAlgo_Builder self)

        Performs the operation.
        The intersection will be performed also.


        """
        return _BOPAlgo.BOPAlgo_Builder_Perform(self, *args)


    def PerformWithFiller(self, *args):
        """
        PerformWithFiller(BOPAlgo_Builder self, BOPAlgo_PaveFiller theFiller)

        Performs the operation with the prepared filler.
        The intersection will not be performed in this case.

        :type theFiller: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller

        """
        return _BOPAlgo.BOPAlgo_Builder_PerformWithFiller(self, *args)


    def Generated(self, *args):
        """
        Returns the  list of shapes generated from the shape theS.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_Builder_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list of shapes modified from the shape theS.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_Builder_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BOPAlgo_Builder self, TopoDS_Shape theS) -> Standard_Boolean

        Returns true if the shape theS has been deleted.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Builder_IsDeleted(self, *args)


    def Images(self, *args):
        """
        Returns the map of images.

        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _BOPAlgo.BOPAlgo_Builder_Images(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Origins(self, *args):
        """
        Returns the map of origins.

        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _BOPAlgo.BOPAlgo_Builder_Origins(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapesSD(self, *args):
        """
        Returns the map of Same Domain (SD) shapes - coinciding shapes
        from different arguments.

        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        res = _BOPAlgo.BOPAlgo_Builder_ShapesSD(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_Builder
BOPAlgo_Builder_swigregister = _BOPAlgo.BOPAlgo_Builder_swigregister
BOPAlgo_Builder_swigregister(BOPAlgo_Builder)

class BOPAlgo_AlertNotSplittableEdge(TopoDS.TopoDS_AlertWithShape):
    """Some edges are very small and have such a small valid range, that they cannot be split"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertNotSplittableEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertNotSplittableEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertNotSplittableEdge self, TopoDS_Shape theShape) -> BOPAlgo_AlertNotSplittableEdge

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertNotSplittableEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertNotSplittableEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertNotSplittableEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertNotSplittableEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertNotSplittableEdge
BOPAlgo_AlertNotSplittableEdge_swigregister = _BOPAlgo.BOPAlgo_AlertNotSplittableEdge_swigregister
BOPAlgo_AlertNotSplittableEdge_swigregister(BOPAlgo_AlertNotSplittableEdge)

def BOPAlgo_AlertNotSplittableEdge_get_type_name(*args):
    """
    BOPAlgo_AlertNotSplittableEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertNotSplittableEdge_get_type_name(*args)

def BOPAlgo_AlertNotSplittableEdge_get_type_descriptor(*args):
    """
    BOPAlgo_AlertNotSplittableEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertNotSplittableEdge_get_type_descriptor(*args)

class BOPAlgo_WireEdgeSet(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_WireEdgeSet self) -> BOPAlgo_WireEdgeSet
        __init__(BOPAlgo_WireEdgeSet self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_WireEdgeSet

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_WireEdgeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """Clear(BOPAlgo_WireEdgeSet self)"""
        return _BOPAlgo.BOPAlgo_WireEdgeSet_Clear(self, *args)


    def SetFace(self, *args):
        """
        SetFace(BOPAlgo_WireEdgeSet self, TopoDS_Face aF)

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BOPAlgo.BOPAlgo_WireEdgeSet_SetFace(self, *args)


    def Face(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BOPAlgo.BOPAlgo_WireEdgeSet_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddStartElement(self, *args):
        """
        AddStartElement(BOPAlgo_WireEdgeSet self, TopoDS_Shape sS)

        :type sS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_WireEdgeSet_AddStartElement(self, *args)


    def StartElements(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_WireEdgeSet_StartElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddShape(self, *args):
        """
        AddShape(BOPAlgo_WireEdgeSet self, TopoDS_Shape sS)

        :type sS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_WireEdgeSet_AddShape(self, *args)


    def Shapes(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_WireEdgeSet_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_WireEdgeSet
BOPAlgo_WireEdgeSet_swigregister = _BOPAlgo.BOPAlgo_WireEdgeSet_swigregister
BOPAlgo_WireEdgeSet_swigregister(BOPAlgo_WireEdgeSet)

class BOPAlgo_AlertUnableToOrientTheShape(TopoDS.TopoDS_AlertWithShape):
    """Unable to orient the shape correctly"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertUnableToOrientTheShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertUnableToOrientTheShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertUnableToOrientTheShape self, TopoDS_Shape theShape) -> BOPAlgo_AlertUnableToOrientTheShape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertUnableToOrientTheShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertUnableToOrientTheShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertUnableToOrientTheShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertUnableToOrientTheShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertUnableToOrientTheShape
BOPAlgo_AlertUnableToOrientTheShape_swigregister = _BOPAlgo.BOPAlgo_AlertUnableToOrientTheShape_swigregister
BOPAlgo_AlertUnableToOrientTheShape_swigregister(BOPAlgo_AlertUnableToOrientTheShape)

def BOPAlgo_AlertUnableToOrientTheShape_get_type_name(*args):
    """
    BOPAlgo_AlertUnableToOrientTheShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertUnableToOrientTheShape_get_type_name(*args)

def BOPAlgo_AlertUnableToOrientTheShape_get_type_descriptor(*args):
    """
    BOPAlgo_AlertUnableToOrientTheShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertUnableToOrientTheShape_get_type_descriptor(*args)

class BOPAlgo_AlertNoFiller(Message.Message_Alert):
    """The Pave Filler (the intersection tool) has not been created"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertNoFiller
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertNoFiller(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertNoFiller_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertNoFiller_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertNoFiller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """The Pave Filler (the intersection tool) has not been created"""
        this = _BOPAlgo.new_BOPAlgo_AlertNoFiller()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertNoFiller
BOPAlgo_AlertNoFiller_swigregister = _BOPAlgo.BOPAlgo_AlertNoFiller_swigregister
BOPAlgo_AlertNoFiller_swigregister(BOPAlgo_AlertNoFiller)

def BOPAlgo_AlertNoFiller_get_type_name(*args):
    """
    BOPAlgo_AlertNoFiller_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertNoFiller_get_type_name(*args)

def BOPAlgo_AlertNoFiller_get_type_descriptor(*args):
    """
    BOPAlgo_AlertNoFiller_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertNoFiller_get_type_descriptor(*args)

class BOPAlgo_WireSplitter(BOPAlgo_Algo):
    """
    The class is to build loops from the given set of edges.

    It returns the following Error statuses
    - *BOPAlgo_AlertNullInputShapes* - in case there no input edges to build the loops.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_WireSplitter self) -> BOPAlgo_WireSplitter
        __init__(BOPAlgo_WireSplitter self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_WireSplitter

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_WireSplitter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetWES(self, *args):
        """
        SetWES(BOPAlgo_WireSplitter self, BOPAlgo_WireEdgeSet theWES)

        :type theWES: OCC.wrapper.BOPAlgo.BOPAlgo_WireEdgeSet

        """
        return _BOPAlgo.BOPAlgo_WireSplitter_SetWES(self, *args)


    def WES(self, *args):
        """
        WES(BOPAlgo_WireSplitter self) -> BOPAlgo_WireEdgeSet

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_WireEdgeSet

        """
        return _BOPAlgo.BOPAlgo_WireSplitter_WES(self, *args)


    def SetContext(self, *args):
        """
        SetContext(BOPAlgo_WireSplitter self, Handle_IntTools_Context theContext)

        Sets the context for the algorithm

        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPAlgo.BOPAlgo_WireSplitter_SetContext(self, *args)


    def Context(self, *args):
        """
        Returns the context

        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _BOPAlgo.BOPAlgo_WireSplitter_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(BOPAlgo_WireSplitter self)"""
        return _BOPAlgo.BOPAlgo_WireSplitter_Perform(self, *args)


    def MakeWire(*args):
        """
        MakeWire(NCollection_List_TopoDS_Shape theLE, TopoDS_Wire theW)

        :type theLE: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theW: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BOPAlgo.BOPAlgo_WireSplitter_MakeWire(*args)

    MakeWire = staticmethod(MakeWire)

    def SplitBlock(*args):
        """
        SplitBlock(TopoDS_Face theF, BOPTools_ConnexityBlock theCB, Handle_IntTools_Context theContext)

        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theCB: OCC.wrapper.BOPTools.BOPTools_ConnexityBlock
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPAlgo.BOPAlgo_WireSplitter_SplitBlock(*args)

    SplitBlock = staticmethod(SplitBlock)
    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_WireSplitter
BOPAlgo_WireSplitter_swigregister = _BOPAlgo.BOPAlgo_WireSplitter_swigregister
BOPAlgo_WireSplitter_swigregister(BOPAlgo_WireSplitter)

def BOPAlgo_WireSplitter_MakeWire(*args):
    """
    BOPAlgo_WireSplitter_MakeWire(NCollection_List_TopoDS_Shape theLE, TopoDS_Wire theW)

    :type theLE: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theW: OCC.wrapper.TopoDS.TopoDS_Wire

    """
    return _BOPAlgo.BOPAlgo_WireSplitter_MakeWire(*args)

def BOPAlgo_WireSplitter_SplitBlock(*args):
    """
    BOPAlgo_WireSplitter_SplitBlock(TopoDS_Face theF, BOPTools_ConnexityBlock theCB, Handle_IntTools_Context theContext)

    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type theCB: OCC.wrapper.BOPTools.BOPTools_ConnexityBlock
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPAlgo.BOPAlgo_WireSplitter_SplitBlock(*args)

class BOPAlgo_AlertNullInputShapes(Message.Message_Alert):
    """Null input shapes"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertNullInputShapes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertNullInputShapes(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertNullInputShapes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertNullInputShapes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertNullInputShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """Null input shapes"""
        this = _BOPAlgo.new_BOPAlgo_AlertNullInputShapes()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertNullInputShapes
BOPAlgo_AlertNullInputShapes_swigregister = _BOPAlgo.BOPAlgo_AlertNullInputShapes_swigregister
BOPAlgo_AlertNullInputShapes_swigregister(BOPAlgo_AlertNullInputShapes)

def BOPAlgo_AlertNullInputShapes_get_type_name(*args):
    """
    BOPAlgo_AlertNullInputShapes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertNullInputShapes_get_type_name(*args)

def BOPAlgo_AlertNullInputShapes_get_type_descriptor(*args):
    """
    BOPAlgo_AlertNullInputShapes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertNullInputShapes_get_type_descriptor(*args)

class BOPAlgo_RemoveFeatures(BOPAlgo_Options):
    """
    The RemoveFeatures algorithm is intended for reconstruction of
    the shape by removal of the unwanted parts from it. These parts can
    be holes, protrusions, spikes, fillets etc.
    The shape itself is not modified, the new shape is built in
    the result.

    Currently, only the shapes of type SOLID, COMPSOLID, and
    COMPOUND of Solids are supported. And only the FACEs can be
    removed from the shape.

    On the input the algorithm accepts the shape itself and the
    faces which have to be removed. It does not matter how the faces
    are given. It could be the separate faces or the collections of faces.
    The faces should belong to the initial shape, and those that
    do not belong will be ignored.
    Before reconstructing the shape, the algorithm will sort all
    the given faces on the connected blocks (features).

    The features will be removed from the shape one by one.
    It will allow removing all possible features even if there
    were problems with the removal of some of them.

    The removed feature is filled by the extension of the faces adjacent
    to the feature. In general, the algorithm of removing of the single
    feature from the shape looks as follows:
    - Find the faces adjacent to the feature;
    - Extend the adjacent faces to cover the feature;
    - Trim the extended faces by the bounds of original face
    (except for bounds common with the feature), so it will cover
    the feature only;
    - Rebuild the solids with reconstructed adjacent faces
    avoiding the faces from the feature.

    If the removal is successful, the result is overwritten with the
    new shape and the next feature is treated. Otherwise, the warning
    will be given.

    The algorithm has the following options:
    - History support;

    and the options available from base class:
    - Error/Warning reporting system;
    - Parallel processing mode.

    Please note that the other options of the base class are not supported
    here and will have no effect.

    <b>History support</b> allows tracking modification of the input shape
    in terms of Modified, IsDeleted and Generated. The history is
    available through the methods of the history tool *BRepTools_History*,
    which can be accessed here through the method *History()*.
    By default, the history is collected, but it is possible to disable it
    using the method *TrackHistory(false)*;

    <b>Error/Warning reporting system</b> - allows obtaining the extended overview
    of the Errors/Warnings occurred during the operation. As soon as any error
    appears the algorithm stops working. The warnings allow continuing the job,
    informing the user that something went wrong.
    The algorithm returns the following errors/warnings:
    - *BOPAlgo_AlertTooFewArguments* - the error alert is given if the input
    shape does not contain any solids;
    - *BOPAlgo_AlertUnsupportedType* - the warning alert is given if the input
    shape contains not only solids, but also other shapes;
    - *BOPAlgo_AlertNoFacesToRemove* - the error alert is given in case
    there are no faces to remove from the shape (nothing to do);
    - *BOPAlgo_AlertUnableToRemoveTheFeature* - the warning alert is given to
    inform the user the removal of the feature is not possible. The algorithm
    will still try to remove the other features;
    - *BOPAlgo_AlertRemoveFeaturesFailed* - the error alert is given in case if
    the operation was aborted by the unknown reason.

    <b>Parallel processing mode</b> - allows running the algorithm in parallel mode
    obtaining the result faster.

    The algorithm has certain limitations:
    - Intersection of the connected faces adjacent to the feature should not be empty.
    It means, that such faces should not be tangent to each other.
    If the intersection of the adjacent faces will be empty, the algorithm will
    be unable to trim the faces correctly and, most likely, the feature will not be removed.
    - The algorithm does not process the INTERNAL parts of the solids, they are simply
    removed during reconstruction.

    Note that for successful removal of the feature, the extended faces adjacent
    to the feature should cover the feature completely, otherwise the solids will
    not be rebuild.

    Here is the example of usage of the algorithm:
    ~~~~
    TopoDS_Shape aSolid = ...;              // Input shape to remove the features from
    TopTools_ListOfShape aFaces = ...;      // Faces to remove from the shape
    Standard_Boolean bRunParallel = ...;    // Parallel processing mode
    Standard_Boolean isHistoryNeeded = ...; // History support

    BOPAlgo_RemoveFeatures aRF;             // Feature removal algorithm
    aRF.SetShape(aSolid);                   // Set the shape
    aRF.AddFacesToRemove(aFaces);           // Add faces to remove
    aRF.SetRunParallel(bRunParallel);       // Define the processing mode (parallel or single)
    aRF.TrackHistory(isHistoryNeeded);      // Define whether to track the shapes modifications
    aRF.Perform();                          // Perform the operation
    if (aRF.HasErrors())                    // Check for the errors
    {
    // error treatment
    return;
    }
    if (aRF.HasWarnings())                  // Check for the warnings
    {
    // warnings treatment
    }
    const TopoDS_Shape& aResult = aRF.Shape(); // Result shape
    ~~~~

    The algorithm preserves the type of the input shape in the result shape. Thus,
    if the input shape is a COMPSOLID, the resulting solids will also be put into a COMPSOLID.

    When all possible features are removed, the shape is simplified by
    removing extra edges and vertices, created during operation, from the result shape.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_RemoveFeatures self) -> BOPAlgo_RemoveFeatures

        Empty constructor


        """
        this = _BOPAlgo.new_BOPAlgo_RemoveFeatures(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape(self, *args):
        """
        SetShape(BOPAlgo_RemoveFeatures self, TopoDS_Shape theShape)

        Sets the shape for processing.
        @param theShape [in] The shape to remove the faces from.
        It should either be the SOLID, COMPSOLID or COMPOUND of Solids.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_SetShape(self, *args)


    def InputShape(self, *args):
        """
        Returns the input shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_RemoveFeatures_InputShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFaceToRemove(self, *args):
        """
        AddFaceToRemove(BOPAlgo_RemoveFeatures self, TopoDS_Shape theFace)

        Adds the face to remove from the input shape.
        @param theFace [in] The shape to extract the faces for removal.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_AddFaceToRemove(self, *args)


    def AddFacesToRemove(self, *args):
        """
        AddFacesToRemove(BOPAlgo_RemoveFeatures self, NCollection_List_TopoDS_Shape theFaces)

        Adds the faces to remove from the input shape.
        @param theFaces [in] The list of shapes to extract the faces for removal.

        :type theFaces: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_AddFacesToRemove(self, *args)


    def FacesToRemove(self, *args):
        """
        Returns the list of faces which have been requested for removal
        from the input shape.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_RemoveFeatures_FacesToRemove(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(BOPAlgo_RemoveFeatures self)

        Performs the operation


        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_Perform(self, *args)


    def Clear(self, *args):
        """
        Clear(BOPAlgo_RemoveFeatures self)

        Clears the contents of the algorithm from previous run,
        allowing reusing it for following removals.


        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_Clear(self, *args)


    def TrackHistory(self, *args):
        """
        TrackHistory(BOPAlgo_RemoveFeatures self, Standard_Boolean const theFlag)

        Defines whether to track the modification of the shapes or not

        :type theFlag: bool

        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_TrackHistory(self, *args)


    def History(self, *args):
        """
        History(BOPAlgo_RemoveFeatures self) -> Handle_BRepTools_History

        Gets the History object

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_History

        """
        return _BOPAlgo.BOPAlgo_RemoveFeatures_History(self, *args)


    def Shape(self, *args):
        """
        Returns the resulting shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_RemoveFeatures_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_RemoveFeatures
BOPAlgo_RemoveFeatures_swigregister = _BOPAlgo.BOPAlgo_RemoveFeatures_swigregister
BOPAlgo_RemoveFeatures_swigregister(BOPAlgo_RemoveFeatures)

class BOPAlgo_AlertTooSmallEdge(TopoDS.TopoDS_AlertWithShape):
    """Some edges are too small and have no valid range"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertTooSmallEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertTooSmallEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertTooSmallEdge self, TopoDS_Shape theShape) -> BOPAlgo_AlertTooSmallEdge

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertTooSmallEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertTooSmallEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertTooSmallEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertTooSmallEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertTooSmallEdge
BOPAlgo_AlertTooSmallEdge_swigregister = _BOPAlgo.BOPAlgo_AlertTooSmallEdge_swigregister
BOPAlgo_AlertTooSmallEdge_swigregister(BOPAlgo_AlertTooSmallEdge)

def BOPAlgo_AlertTooSmallEdge_get_type_name(*args):
    """
    BOPAlgo_AlertTooSmallEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertTooSmallEdge_get_type_name(*args)

def BOPAlgo_AlertTooSmallEdge_get_type_descriptor(*args):
    """
    BOPAlgo_AlertTooSmallEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertTooSmallEdge_get_type_descriptor(*args)

class BOPAlgo_AlertBuilderFailed(Message.Message_Alert):
    """Building of the result shape has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertBuilderFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertBuilderFailed(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertBuilderFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertBuilderFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertBuilderFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """Building of the result shape has failed"""
        this = _BOPAlgo.new_BOPAlgo_AlertBuilderFailed()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertBuilderFailed
BOPAlgo_AlertBuilderFailed_swigregister = _BOPAlgo.BOPAlgo_AlertBuilderFailed_swigregister
BOPAlgo_AlertBuilderFailed_swigregister(BOPAlgo_AlertBuilderFailed)

def BOPAlgo_AlertBuilderFailed_get_type_name(*args):
    """
    BOPAlgo_AlertBuilderFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertBuilderFailed_get_type_name(*args)

def BOPAlgo_AlertBuilderFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertBuilderFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertBuilderFailed_get_type_descriptor(*args)

class BOPAlgo_Section(BOPAlgo_Builder):
    """
    The algorithm to build a Section between the arguments.
    The Section consists of vertices and edges.
    The Section contains:
    1. new vertices that are subjects of V/V, E/E, E/F, F/F interferences
    2. vertices that are subjects of V/E, V/F interferences
    3. new edges that are subjects of F/F interferences
    4. edges that are Common Blocks
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_Section self) -> BOPAlgo_Section
        __init__(BOPAlgo_Section self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_Section

        Constructor with allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_Section(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_Section
BOPAlgo_Section_swigregister = _BOPAlgo.BOPAlgo_Section_swigregister
BOPAlgo_Section_swigregister(BOPAlgo_Section)

class BOPAlgo_AlertIntersectionFailed(Message.Message_Alert):
    """The intersection of the arguments has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertIntersectionFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertIntersectionFailed(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertIntersectionFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertIntersectionFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertIntersectionFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """The intersection of the arguments has failed"""
        this = _BOPAlgo.new_BOPAlgo_AlertIntersectionFailed()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertIntersectionFailed
BOPAlgo_AlertIntersectionFailed_swigregister = _BOPAlgo.BOPAlgo_AlertIntersectionFailed_swigregister
BOPAlgo_AlertIntersectionFailed_swigregister(BOPAlgo_AlertIntersectionFailed)

def BOPAlgo_AlertIntersectionFailed_get_type_name(*args):
    """
    BOPAlgo_AlertIntersectionFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertIntersectionFailed_get_type_name(*args)

def BOPAlgo_AlertIntersectionFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertIntersectionFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertIntersectionFailed_get_type_descriptor(*args)

class BOPAlgo_ToolsProvider(BOPAlgo_Builder):
    """Auxiliary class providing API to operate tool arguments."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_ToolsProvider self) -> BOPAlgo_ToolsProvider
        __init__(BOPAlgo_ToolsProvider self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_ToolsProvider

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_ToolsProvider(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPAlgo_ToolsProvider self)

        Clears internal fields and arguments


        """
        return _BOPAlgo.BOPAlgo_ToolsProvider_Clear(self, *args)


    def AddTool(self, *args):
        """
        AddTool(BOPAlgo_ToolsProvider self, TopoDS_Shape theShape)

        Adds Tool argument of the operation

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_ToolsProvider_AddTool(self, *args)


    def SetTools(self, *args):
        """
        SetTools(BOPAlgo_ToolsProvider self, NCollection_List_TopoDS_Shape theShapes)

        Adds the Tool arguments of the operation

        :type theShapes: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_ToolsProvider_SetTools(self, *args)


    def Tools(self, *args):
        """
        Returns the Tool arguments of the operation

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_ToolsProvider_Tools(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_ToolsProvider
BOPAlgo_ToolsProvider_swigregister = _BOPAlgo.BOPAlgo_ToolsProvider_swigregister
BOPAlgo_ToolsProvider_swigregister(BOPAlgo_ToolsProvider)

class BOPAlgo_CheckResult(object):
    """
    contains information about faulty shapes and faulty types
    can't be processed by Boolean Operations
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_CheckResult self) -> BOPAlgo_CheckResult

        empty constructor


        """
        this = _BOPAlgo.new_BOPAlgo_CheckResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape1(self, *args):
        """
        SetShape1(BOPAlgo_CheckResult self, TopoDS_Shape TheShape)

        sets ancestor shape (object) for faulty sub-shapes

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetShape1(self, *args)


    def AddFaultyShape1(self, *args):
        """
        AddFaultyShape1(BOPAlgo_CheckResult self, TopoDS_Shape TheShape)

        adds faulty sub-shapes from object to a list

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_CheckResult_AddFaultyShape1(self, *args)


    def SetShape2(self, *args):
        """
        SetShape2(BOPAlgo_CheckResult self, TopoDS_Shape TheShape)

        sets ancestor shape (tool) for faulty sub-shapes

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetShape2(self, *args)


    def AddFaultyShape2(self, *args):
        """
        AddFaultyShape2(BOPAlgo_CheckResult self, TopoDS_Shape TheShape)

        adds faulty sub-shapes from tool to a list

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_CheckResult_AddFaultyShape2(self, *args)


    def GetShape1(self, *args):
        """
        returns ancestor shape (object) for faulties

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_CheckResult_GetShape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetShape2(self, *args):
        """
        returns ancestor shape (tool) for faulties

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_CheckResult_GetShape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFaultyShapes1(self, *args):
        """
        returns list of faulty shapes for object

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_CheckResult_GetFaultyShapes1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFaultyShapes2(self, *args):
        """
        returns list of faulty shapes for tool

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_CheckResult_GetFaultyShapes2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCheckStatus(self, *args):
        """
        SetCheckStatus(BOPAlgo_CheckResult self, BOPAlgo_CheckStatus const TheStatus)

        set status of faulty

        :type TheStatus: OCC.wrapper.BOPAlgo.BOPAlgo_CheckStatus

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetCheckStatus(self, *args)


    def GetCheckStatus(self, *args):
        """
        GetCheckStatus(BOPAlgo_CheckResult self) -> BOPAlgo_CheckStatus

        gets status of faulty

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_CheckStatus

        """
        return _BOPAlgo.BOPAlgo_CheckResult_GetCheckStatus(self, *args)


    def SetMaxDistance1(self, *args):
        """
        SetMaxDistance1(BOPAlgo_CheckResult self, Standard_Real const theDist)

        Sets max distance for the first shape

        :type theDist: float

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetMaxDistance1(self, *args)


    def SetMaxDistance2(self, *args):
        """
        SetMaxDistance2(BOPAlgo_CheckResult self, Standard_Real const theDist)

        Sets max distance for the second shape

        :type theDist: float

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetMaxDistance2(self, *args)


    def SetMaxParameter1(self, *args):
        """
        SetMaxParameter1(BOPAlgo_CheckResult self, Standard_Real const thePar)

        Sets the parameter for the first shape

        :type thePar: float

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetMaxParameter1(self, *args)


    def SetMaxParameter2(self, *args):
        """
        SetMaxParameter2(BOPAlgo_CheckResult self, Standard_Real const thePar)

        Sets the parameter for the second shape

        :type thePar: float

        """
        return _BOPAlgo.BOPAlgo_CheckResult_SetMaxParameter2(self, *args)


    def GetMaxDistance1(self, *args):
        """
        GetMaxDistance1(BOPAlgo_CheckResult self) -> Standard_Real

        Returns the distance for the first shape

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPAlgo.BOPAlgo_CheckResult_GetMaxDistance1(self, *args)


    def GetMaxDistance2(self, *args):
        """
        GetMaxDistance2(BOPAlgo_CheckResult self) -> Standard_Real

        Returns the distance for the second shape

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPAlgo.BOPAlgo_CheckResult_GetMaxDistance2(self, *args)


    def GetMaxParameter1(self, *args):
        """
        GetMaxParameter1(BOPAlgo_CheckResult self) -> Standard_Real

        Returns the parameter for the fircst shape

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPAlgo.BOPAlgo_CheckResult_GetMaxParameter1(self, *args)


    def GetMaxParameter2(self, *args):
        """
        GetMaxParameter2(BOPAlgo_CheckResult self) -> Standard_Real

        Returns the parameter for the second shape

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPAlgo.BOPAlgo_CheckResult_GetMaxParameter2(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_CheckResult
BOPAlgo_CheckResult_swigregister = _BOPAlgo.BOPAlgo_CheckResult_swigregister
BOPAlgo_CheckResult_swigregister(BOPAlgo_CheckResult)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class BOPAlgo_AlertPostTreatFF(Message.Message_Alert):
    """Cannot connect face intersection curves"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertPostTreatFF
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertPostTreatFF(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertPostTreatFF_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertPostTreatFF_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertPostTreatFF_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """Cannot connect face intersection curves"""
        this = _BOPAlgo.new_BOPAlgo_AlertPostTreatFF()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertPostTreatFF
BOPAlgo_AlertPostTreatFF_swigregister = _BOPAlgo.BOPAlgo_AlertPostTreatFF_swigregister
BOPAlgo_AlertPostTreatFF_swigregister(BOPAlgo_AlertPostTreatFF)

def BOPAlgo_AlertPostTreatFF_get_type_name(*args):
    """
    BOPAlgo_AlertPostTreatFF_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertPostTreatFF_get_type_name(*args)

def BOPAlgo_AlertPostTreatFF_get_type_descriptor(*args):
    """
    BOPAlgo_AlertPostTreatFF_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertPostTreatFF_get_type_descriptor(*args)

class BOPAlgo_CellsBuilder(BOPAlgo_Builder):
    """
    The algorithm is based on the General Fuse algorithm (GFA). The result of
    GFA is all split parts of the Arguments.<br>

    The purpose of this algorithm is to provide the result with the content of:<br>
    1. Cells (parts) defined by the user;<br>
    2. Internal boundaries defined by the user.<br>

    In other words the algorithm should provide the possibility for the user
    to add or remove any part to (from) result and remove any internal boundaries
    between parts.<br>

    Requirements for the Data:<br>
    All the requirements of GFA for the DATA are inherited in this algorithm -
    The arguments could be of any type (dimension) and should be valid in terms of
    BRepCheck_Analyzer and BOPAlgo_ArgumentAnalyzer.<br>

    Results:<br>
    The result of the algorithm is compound containing selected parts of
    the basic types (VERTEX, EDGE, FACE or SOLID). The default result
    is empty compound. It is possible to add any split part to the result
    by using the methods AddToRessult() and AddAllToResult().
    It is also possible to remove any part from the result by using methods
    RemoveFromResult() and RemoveAllFromResult().
    The method RemoveAllFromResult() is also suitable for clearing the result.<br>

    To remove Internal boundaries it is necessary to set the same material to the
    parts between which the boundaries should be removed and call the method
    RemoveInternalBoundaries(). The material should not be equal to 0, as this is
    default material value. The boundaries between parts with this value
    will not be removed.
    One part cannot be added with the different materials.
    It is also possible to remove the boundaries during combining the result.
    To do this it is necessary to set the material for parts (not equal to 0)
    and set the flag bUpdate to TRUE.
    For the arguments of the types FACE or EDGE it is recommended
    to remove the boundaries in the end when the result is completely built.
    It will help to avoid self-intersections in the result.<br>
    Note, that if the result contains the parts with same material but of different
    dimension the boundaries between such parts will not be removed. Currently,
    the removal of the internal boundaries between multi-dimensional shapes is not supported.<br>

    It is possible to create typed Containers from the parts added to result by using
    method MakeContainers(). The type of the containers will depend on the type of
    the arguments: WIRES for EEDGE, SHELLS for FACES and COMPSOLIDS for SOLIDS.
    The result will be compound containing containers.
    Adding of the parts to such result will not update containers. The result
    compound will contain the containers and new added parts (of basic type).
    Removing of the parts from such result may affect some containers if
    the parts that should be removed is in container. In this case this container
    will be rebuilt without that part.<br>

    History:<br>
    The algorithm supports history information for basic types of the shapes -
    VERTEX, EDGE, FACE. This information available through the methods
    IsDeleted() and Modified().<br>
    In DRAW Test Harness it is available through the same
    commands as for Boolean Operations (bmodified, bgenerated and bisdeleted).<br>

    The algorithm can return the following Error Statuses:
    - Error status acquired in the General Fuse algorithm.
    The Error status can be checked with HasErrors() method.
    If the Error status is not equal to zero, the result cannot be trustworthy.

    The algorithm can set the following Warning Statuses:
    - Warning status acquired in the General Fuse algorithm;
    - BOPAlgo_AlertRemovalOfIBForMDimShapes
    - BOPAlgo_AlertRemovalOfIBForFacesFailed
    - BOPAlgo_AlertRemovalOfIBForEdgesFailed
    - BOPAlgo_AlertRemovalOfIBForSolidsFailed

    The Warning status can be checked with HasWarnings() method or
    printed with the DumpWarnings() method. If warnings are recorded,
    the result may be not as expected.<br>

    Examples:<br>
    1. API<br>
    BOPAlgo_CellsBuilder aCBuilder;<br>
    TopTools_ListOfShape aLS = ...; // arguments<br>
    /* parallel or single mode (the default value is FALSE)*/<br>
    Standard_Boolean bRunParallel = Standard_False;<br>
    /* fuzzy option (default value is 0)*/<br>
    Standard_Real aTol = 0.0;<br>
    //<br>
    aCBuilder.SetArguments(aLS);<br>
    aCBuilder.SetRunParallel(bRunParallel);<br>
    aCBuilder.SetFuzzyValue(aTol);<br>
    //<br>
    aCBuilder.Perform();<br>
    if (aCBuilder.HasErrors()) { // check error status<br>
    return;<br>
    }<br>
    /* empty compound, as nothing has been added yet */<br>
    const TopoDS_Shape& aRes = aCBuilder.Shape();<br>
    /* all split parts */<br>
    const TopoDS_Shape& aRes = aCBuilder.GetAllParts();<br>
    //<br>
    TopTools_ListOfShape aLSToTake = ...; // parts of these arguments will be taken into result<br>
    TopTools_ListOfShape aLSToAvoid = ...; // parts of these arguments will not be taken into result<br>
    //<br>
    /* defines the material common for the cells, i.e. 
    the boundaries between cells with the same material
    will be removed.<br>
    By default it is set to 0. Thus, to remove some boundary
    the value of this variable should not be equal to 0 */<br>
    Standard_Integer iMaterial = ...;<br>
    /* defines whether to update the result right now or not */<br>
    Standard_Boolean bUpdate = ...;<br>
    // adding to result<br>
    aCBuilder.AddToResult(aLSToTake, aLSToAvoid, iMaterial, bUpdate);<br>
    aR = aCBuilder.Shape(); // the result<br>
    // removing of the boundaries (should be called only if bUpdate is false)<br>
    aCBuilder.RemoveInternalBoundaries();<br>
    //<br>
    // removing from result<br>
    aCBuilder.AddAllToResult();<br>
    aCBuilder.RemoveFromResult(aLSToTake, aLSToAvoid);<br>
    aR = aCBuilder.Shape(); // the result<br>
    <br>

    2. DRAW Test Harness<br>
    psphere s1 15<br>
    psphere s2 15<br>
    psphere s3 15<br>
    ttranslate s1 0 0 10<br>
    ttranslate s2 20 0 10<br>
    ttranslate s3 10 0 0<br>
    \# adding arguments<br>
    bclearobjects; bcleartools<br>
    baddobjects s1 s2 s3<br>
    \# intersection<br>
    bfillds<br>
    \# rx will contain all split parts<br>
    bcbuild rx<br>
    \# add to result the part that is common for all three spheres<br>
    bcadd res s1 1 s2 1 s3 1 -m 1<br>
    \# add to result the part that is common only for first and third spheres<br>
    bcadd res s1 1 s2 0 s3 1 -m 1<br>
    \# remove internal boundaries<br>
    bcremoveint res<br>

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_CellsBuilder self) -> BOPAlgo_CellsBuilder
        __init__(BOPAlgo_CellsBuilder self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_CellsBuilder

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_CellsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPAlgo_CellsBuilder self)

        Redefined method Clear - clears the contents.


        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_Clear(self, *args)


    def AddToResult(self, *args):
        """
        AddToResult(BOPAlgo_CellsBuilder self, NCollection_List_TopoDS_Shape theLSToTake, NCollection_List_TopoDS_Shape theLSToAvoid, Standard_Integer const theMaterial=0, Standard_Boolean const theUpdate)

        Adding the parts to result.<br>
        The parts are defined by two lists of shapes:<br>
        <theLSToTake> defines the arguments which parts should be taken into result;<br>
        <theLSToAvoid> defines the arguments which parts should not be taken into result;<br>
        To be taken into result the part must be IN for all shapes from the list
        <theLSToTake> and must be OUT of all shapes from the list <theLSToAvoid>.<br>

        To remove internal boundaries between any cells in the result
        <theMaterial> variable should be used. The boundaries between
        cells with the same material will be removed. Default value is 0.<br>
        Thus, to remove any boundary the value of this variable should not be equal to 0.<br>
        <theUpdate> parameter defines whether to remove boundaries now or not.

        :type theLSToTake: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theLSToAvoid: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theMaterial: int
        :type theUpdate: bool

        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_AddToResult(self, *args)


    def AddAllToResult(self, *args):
        """
        AddAllToResult(BOPAlgo_CellsBuilder self, Standard_Integer const theMaterial=0, Standard_Boolean const theUpdate)

        Add all split parts to result.<br>
        <theMaterial> defines the removal of internal boundaries;<br>
        <theUpdate> parameter defines whether to remove boundaries now or not.

        :type theMaterial: int
        :type theUpdate: bool

        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_AddAllToResult(self, *args)


    def RemoveFromResult(self, *args):
        """
        RemoveFromResult(BOPAlgo_CellsBuilder self, NCollection_List_TopoDS_Shape theLSToTake, NCollection_List_TopoDS_Shape theLSToAvoid)

        Removing the parts from result.<br>
        The parts are defined by two lists of shapes:<br>
        <theLSToTake> defines the arguments which parts should be removed from result;<br>
        <theLSToAvoid> defines the arguments which parts should not be removed from result.<br>
        To be removed from the result the part must be IN for all shapes from the list
        <theLSToTake> and must be OUT of all shapes from the list <theLSToAvoid>.

        :type theLSToTake: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theLSToAvoid: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_RemoveFromResult(self, *args)


    def RemoveAllFromResult(self, *args):
        """
        RemoveAllFromResult(BOPAlgo_CellsBuilder self)

        Remove all parts from result.


        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_RemoveAllFromResult(self, *args)


    def RemoveInternalBoundaries(self, *args):
        """
        RemoveInternalBoundaries(BOPAlgo_CellsBuilder self)

        Removes internal boundaries between cells with the same material.<br>
        If the result contains the cells with same material but of different dimension
        the removal of internal boundaries between these cells will not be performed.<br>
        In case of some errors during the removal the method will set the appropriate warning 
        status - use GetReport() to access them.


        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_RemoveInternalBoundaries(self, *args)


    def GetAllParts(self, *args):
        """
        Get all split parts.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_CellsBuilder_GetAllParts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MakeContainers(self, *args):
        """
        MakeContainers(BOPAlgo_CellsBuilder self)

        Makes the Containers of proper type from the parts added to result.


        """
        return _BOPAlgo.BOPAlgo_CellsBuilder_MakeContainers(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_CellsBuilder
BOPAlgo_CellsBuilder_swigregister = _BOPAlgo.BOPAlgo_CellsBuilder_swigregister
BOPAlgo_CellsBuilder_swigregister(BOPAlgo_CellsBuilder)

class BOPAlgo_AlertMultipleArguments(Message.Message_Alert):
    """The type of Boolean Operation is not set"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertMultipleArguments
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertMultipleArguments(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertMultipleArguments_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertMultipleArguments_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertMultipleArguments_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """The type of Boolean Operation is not set"""
        this = _BOPAlgo.new_BOPAlgo_AlertMultipleArguments()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertMultipleArguments
BOPAlgo_AlertMultipleArguments_swigregister = _BOPAlgo.BOPAlgo_AlertMultipleArguments_swigregister
BOPAlgo_AlertMultipleArguments_swigregister(BOPAlgo_AlertMultipleArguments)

def BOPAlgo_AlertMultipleArguments_get_type_name(*args):
    """
    BOPAlgo_AlertMultipleArguments_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertMultipleArguments_get_type_name(*args)

def BOPAlgo_AlertMultipleArguments_get_type_descriptor(*args):
    """
    BOPAlgo_AlertMultipleArguments_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertMultipleArguments_get_type_descriptor(*args)

class BOPAlgo_BuilderSolid(BOPAlgo_BuilderArea):
    """
    Solid Builder is the algorithm for building solids from set of faces.
    The given faces should be non-intersecting, i.e. all coinciding parts
    of the faces should be shared among them.

    The algorithm performs the following steps to build the solids:
    1. Find:
    - faces orientated INTERNAL;
    - alone faces given twice with different orientation;
    2. Build all possible closed shells from the rest of the faces
    (*BOPAlgo_ShellSplitter* is used for that);
    3. Classify the obtained shells on the Holes and Growths;
    4. Build solids from the Growth shells, put Hole shells into closest Growth solids;
    5. Classify all unused faces relatively created solids and put them as internal
    shells into the closest solids;
    6. Find all unclassified faces, i.e. faces outside of all created solids,
    make internal shells from them and put these shells into a warning.

    It is possible to avoid all internal shells in the resulting solids.
    For that it is necessary to use the method SetAvoidInternalShapes(true)
    of the base class. In this case the steps 5 and 6 will not be performed at all.

    The algorithm may return the following warnings:
    - *BOPAlgo_AlertShellSplitterFailed* in case the ShellSplitter algorithm has failed;
    - *BOPAlgo_AlertSolidBuilderUnusedFaces* in case there are some faces outside of
    created solids left.

    Example of usage of the algorithm:
    ~~~~
    const TopTools_ListOfShape& aFaces = ...;     // Faces to build the solids
    Standard_Boolean isAvoidInternals = ...;      // Flag which defines whether to create the internal shells or not
    BOPAlgo_BuilderSolid aBS;                     // Solid Builder tool
    aBS.SetShapes(aFaces);                        // Set the faces
    aBS.SetAvoidInternalShapes(isAvoidInternals); // Set the AvoidInternalShapesFlag
    aBS.Perform();                                // Perform the operation
    if (!aBS.IsDone())                            // Check for the errors
    {
    // error treatment
    Standard_SStream aSStream;
    aBS.DumpErrors(aSStream);
    return;
    }
    if (aBS.HasWarnings())                        // Check for the warnings
    {
    // warnings treatment
    Standard_SStream aSStream;
    aBS.DumpWarnings(aSStream);
    }

    const TopTools_ListOfShape& aSolids = aBS.Areas(); // Obtaining the result solids
    ~~~~

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_BuilderSolid self) -> BOPAlgo_BuilderSolid
        __init__(BOPAlgo_BuilderSolid self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_BuilderSolid

        Constructor with allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_BuilderSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BOPAlgo_BuilderSolid self)

        Performs the construction of the solids from the given faces


        """
        return _BOPAlgo.BOPAlgo_BuilderSolid_Perform(self, *args)


    def GetBoxesMap(self, *args):
        """
        For classification purposes the algorithm builds the bounding boxes
        for all created solids. This method returns the data map of solid - box pairs.

        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeBox

        """
        res = _BOPAlgo.BOPAlgo_BuilderSolid_GetBoxesMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_BuilderSolid
BOPAlgo_BuilderSolid_swigregister = _BOPAlgo.BOPAlgo_BuilderSolid_swigregister
BOPAlgo_BuilderSolid_swigregister(BOPAlgo_BuilderSolid)

class BOPAlgo_CheckerSI(BOPAlgo_PaveFiller):
    """
    Checks the shape on self-interference.

    The algorithm can set the following errors:
    - *BOPAlgo_AlertMultipleArguments* - The number of the input arguments is not one;
    - *BOPALgo_ErrorIntersectionFailed* - The check has been aborted during intersection of sub-shapes.
    In case the error has occurred during intersection of sub-shapes, i.e.
    in BOPAlgo_PaveFiller::PerformInternal() method, the errors from this method
    directly will be returned.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_CheckerSI self) -> BOPAlgo_CheckerSI

        Checks the shape on self-interference.

        The algorithm can set the following errors:
        - *BOPAlgo_AlertMultipleArguments* - The number of the input arguments is not one;
        - *BOPALgo_ErrorIntersectionFailed* - The check has been aborted during intersection of sub-shapes.
        In case the error has occurred during intersection of sub-shapes, i.e.
        in BOPAlgo_PaveFiller::PerformInternal() method, the errors from this method
        directly will be returned.
        """
        this = _BOPAlgo.new_BOPAlgo_CheckerSI(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(BOPAlgo_CheckerSI self)"""
        return _BOPAlgo.BOPAlgo_CheckerSI_Perform(self, *args)


    def SetLevelOfCheck(self, *args):
        """
        SetLevelOfCheck(BOPAlgo_CheckerSI self, Standard_Integer const theLevel)

        Sets the level of checking shape on self-interference.<br>
        It defines which interferences will be checked:<br>
        0 - only V/V;<br>
        1 - V/V and V/E;<br>
        2 - V/V, V/E and E/E;<br>
        3 - V/V, V/E, E/E and V/F;<br>
        4 - V/V, V/E, E/E, V/F and E/F;<br>
        5 - V/V, V/E, E/E, V/F, E/F and F/F;<br>
        6 - V/V, V/E, E/E, V/F, E/F, F/F and V/S;<br>
        7 - V/V, V/E, E/E, V/F, E/F, F/F, V/S and E/S;<br>
        8 - V/V, V/E, E/E, V/F, E/F, F/F, V/S, E/S and F/S;<br>
        9 - V/V, V/E, E/E, V/F, E/F, F/F, V/S, E/S, F/S and S/S - all interferences (Default value)

        :type theLevel: int

        """
        return _BOPAlgo.BOPAlgo_CheckerSI_SetLevelOfCheck(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_CheckerSI
BOPAlgo_CheckerSI_swigregister = _BOPAlgo.BOPAlgo_CheckerSI_swigregister
BOPAlgo_CheckerSI_swigregister(BOPAlgo_CheckerSI)

class BOPAlgo_AlertSolidBuilderFailed(Message.Message_Alert):
    """The BuilderSolid algorithm has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertSolidBuilderFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertSolidBuilderFailed(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertSolidBuilderFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertSolidBuilderFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertSolidBuilderFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """The BuilderSolid algorithm has failed"""
        this = _BOPAlgo.new_BOPAlgo_AlertSolidBuilderFailed()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertSolidBuilderFailed
BOPAlgo_AlertSolidBuilderFailed_swigregister = _BOPAlgo.BOPAlgo_AlertSolidBuilderFailed_swigregister
BOPAlgo_AlertSolidBuilderFailed_swigregister(BOPAlgo_AlertSolidBuilderFailed)

def BOPAlgo_AlertSolidBuilderFailed_get_type_name(*args):
    """
    BOPAlgo_AlertSolidBuilderFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertSolidBuilderFailed_get_type_name(*args)

def BOPAlgo_AlertSolidBuilderFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertSolidBuilderFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertSolidBuilderFailed_get_type_descriptor(*args)

class BOPAlgo_AlertRemovalOfIBForFacesFailed(TopoDS.TopoDS_AlertWithShape):
    """Removal of internal boundaries among Faces has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertRemovalOfIBForFacesFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertRemovalOfIBForFacesFailed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertRemovalOfIBForFacesFailed self, TopoDS_Shape theShape) -> BOPAlgo_AlertRemovalOfIBForFacesFailed

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertRemovalOfIBForFacesFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForFacesFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertRemovalOfIBForFacesFailed
BOPAlgo_AlertRemovalOfIBForFacesFailed_swigregister = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForFacesFailed_swigregister
BOPAlgo_AlertRemovalOfIBForFacesFailed_swigregister(BOPAlgo_AlertRemovalOfIBForFacesFailed)

def BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_name(*args):
    """
    BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_name(*args)

def BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForFacesFailed_get_type_descriptor(*args)

class BOPAlgo_AlertRemovalOfIBForSolidsFailed(TopoDS.TopoDS_AlertWithShape):
    """Removal of internal boundaries among Solids has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertRemovalOfIBForSolidsFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertRemovalOfIBForSolidsFailed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertRemovalOfIBForSolidsFailed self, TopoDS_Shape theShape) -> BOPAlgo_AlertRemovalOfIBForSolidsFailed

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertRemovalOfIBForSolidsFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForSolidsFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertRemovalOfIBForSolidsFailed
BOPAlgo_AlertRemovalOfIBForSolidsFailed_swigregister = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForSolidsFailed_swigregister
BOPAlgo_AlertRemovalOfIBForSolidsFailed_swigregister(BOPAlgo_AlertRemovalOfIBForSolidsFailed)

def BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_name(*args):
    """
    BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_name(*args)

def BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForSolidsFailed_get_type_descriptor(*args)

class BOPAlgo_AlertRemovalOfIBForMDimShapes(TopoDS.TopoDS_AlertWithShape):
    """Removal of internal boundaries among the multi-dimensional shapes is not supported yet"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertRemovalOfIBForMDimShapes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertRemovalOfIBForMDimShapes(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertRemovalOfIBForMDimShapes self, TopoDS_Shape theShape) -> BOPAlgo_AlertRemovalOfIBForMDimShapes

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertRemovalOfIBForMDimShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForMDimShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertRemovalOfIBForMDimShapes
BOPAlgo_AlertRemovalOfIBForMDimShapes_swigregister = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForMDimShapes_swigregister
BOPAlgo_AlertRemovalOfIBForMDimShapes_swigregister(BOPAlgo_AlertRemovalOfIBForMDimShapes)

def BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_name(*args):
    """
    BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_name(*args)

def BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_descriptor(*args):
    """
    BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForMDimShapes_get_type_descriptor(*args)

class BOPAlgo_Splitter(BOPAlgo_ToolsProvider):
    """
    The **Splitter algorithm** is the algorithm for splitting a group of
    arbitrary shapes by the other group of arbitrary shapes.<br>
    The arguments of the operation are divided on two groups:<br>
    *Objects* - shapes that will be split;<br>
    *Tools*   - shapes by which the *Objects* will be split.<br>
    The result of the operation contains only the split parts
    of the shapes from the group of *Objects*.<br>
    The split parts of the shapes from the group of *Tools* are excluded
    from the result.<br>
    The shapes can be split by the other shapes from the same group
    (in case these shapes are interfering).

    The class is a General Fuse based algorithm. Thus, all options
    of the General Fuse algorithm such as Fuzzy mode, safe processing mode,
    parallel processing mode, gluing mode and history support are also
    available in this algorithm.<br>
    There is no requirement on the existence of the *Tools* shapes.
    And if there are no *Tools* shapes, the result of the splitting
    operation will be equivalent to the General Fuse result.

    The implementation of the algorithm is minimal - only the methods
    CheckData() and Perform() have been overridden.<br>
    The method BOPAlgo_Builder::BuildResult(), which adds the split parts of the arguments
    into result, does not have to be overridden, because its native implementation
    performs the necessary actions for the Splitter algorithm - it adds
    the split parts of only Objects into result, avoiding the split parts of Tools.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_Splitter self) -> BOPAlgo_Splitter
        __init__(BOPAlgo_Splitter self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_Splitter

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_Splitter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BOPAlgo_Splitter self)

        Performs the operation


        """
        return _BOPAlgo.BOPAlgo_Splitter_Perform(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_Splitter
BOPAlgo_Splitter_swigregister = _BOPAlgo.BOPAlgo_Splitter_swigregister
BOPAlgo_Splitter_swigregister(BOPAlgo_Splitter)

class BOPAlgo_AlertUnableToRemoveTheFeature(TopoDS.TopoDS_AlertWithShape):
    """Unable to remove the feature"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertUnableToRemoveTheFeature
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertUnableToRemoveTheFeature(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertUnableToRemoveTheFeature self, TopoDS_Shape theShape) -> BOPAlgo_AlertUnableToRemoveTheFeature

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertUnableToRemoveTheFeature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertUnableToRemoveTheFeature_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertUnableToRemoveTheFeature_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertUnableToRemoveTheFeature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertUnableToRemoveTheFeature
BOPAlgo_AlertUnableToRemoveTheFeature_swigregister = _BOPAlgo.BOPAlgo_AlertUnableToRemoveTheFeature_swigregister
BOPAlgo_AlertUnableToRemoveTheFeature_swigregister(BOPAlgo_AlertUnableToRemoveTheFeature)

def BOPAlgo_AlertUnableToRemoveTheFeature_get_type_name(*args):
    """
    BOPAlgo_AlertUnableToRemoveTheFeature_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertUnableToRemoveTheFeature_get_type_name(*args)

def BOPAlgo_AlertUnableToRemoveTheFeature_get_type_descriptor(*args):
    """
    BOPAlgo_AlertUnableToRemoveTheFeature_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertUnableToRemoveTheFeature_get_type_descriptor(*args)

class BOPAlgo_AlertBOPNotSet(Message.Message_Alert):
    """The type of Boolean Operation is not set"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertBOPNotSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertBOPNotSet(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertBOPNotSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertBOPNotSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertBOPNotSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """The type of Boolean Operation is not set"""
        this = _BOPAlgo.new_BOPAlgo_AlertBOPNotSet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertBOPNotSet
BOPAlgo_AlertBOPNotSet_swigregister = _BOPAlgo.BOPAlgo_AlertBOPNotSet_swigregister
BOPAlgo_AlertBOPNotSet_swigregister(BOPAlgo_AlertBOPNotSet)

def BOPAlgo_AlertBOPNotSet_get_type_name(*args):
    """
    BOPAlgo_AlertBOPNotSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertBOPNotSet_get_type_name(*args)

def BOPAlgo_AlertBOPNotSet_get_type_descriptor(*args):
    """
    BOPAlgo_AlertBOPNotSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertBOPNotSet_get_type_descriptor(*args)

class BOPAlgo_AlertShellSplitterFailed(TopoDS.TopoDS_AlertWithShape):
    """The positioning of the shapes leads to creation of the small edges without valid range"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertShellSplitterFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertShellSplitterFailed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertShellSplitterFailed self, TopoDS_Shape theShape) -> BOPAlgo_AlertShellSplitterFailed

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertShellSplitterFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertShellSplitterFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertShellSplitterFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertShellSplitterFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertShellSplitterFailed
BOPAlgo_AlertShellSplitterFailed_swigregister = _BOPAlgo.BOPAlgo_AlertShellSplitterFailed_swigregister
BOPAlgo_AlertShellSplitterFailed_swigregister(BOPAlgo_AlertShellSplitterFailed)

def BOPAlgo_AlertShellSplitterFailed_get_type_name(*args):
    """
    BOPAlgo_AlertShellSplitterFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertShellSplitterFailed_get_type_name(*args)

def BOPAlgo_AlertShellSplitterFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertShellSplitterFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertShellSplitterFailed_get_type_descriptor(*args)

class BOPAlgo_AlertRemovalOfIBForEdgesFailed(TopoDS.TopoDS_AlertWithShape):
    """Removal of internal boundaries among Edges has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertRemovalOfIBForEdgesFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertRemovalOfIBForEdgesFailed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertRemovalOfIBForEdgesFailed self, TopoDS_Shape theShape) -> BOPAlgo_AlertRemovalOfIBForEdgesFailed

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertRemovalOfIBForEdgesFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForEdgesFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertRemovalOfIBForEdgesFailed
BOPAlgo_AlertRemovalOfIBForEdgesFailed_swigregister = _BOPAlgo.BOPAlgo_AlertRemovalOfIBForEdgesFailed_swigregister
BOPAlgo_AlertRemovalOfIBForEdgesFailed_swigregister(BOPAlgo_AlertRemovalOfIBForEdgesFailed)

def BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_name(*args):
    """
    BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_name(*args)

def BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertRemovalOfIBForEdgesFailed_get_type_descriptor(*args)

class BOPAlgo_MakerVolume(BOPAlgo_Builder):
    """
    The algorithm is to build solids from set of shapes.
    It uses the BOPAlgo_Builder algorithm to intersect the given shapes
    and build the images of faces (if needed) and BOPAlgo_BuilderSolid
    algorithm to build the solids.

    Steps of the algorithm:
    1. Collect all faces: intersect the shapes if necessary and collect
    the images of faces, otherwise just collect the faces to the
    <myFaces> list;
    All faces on this step added twice, with orientation FORWARD
    and REVERSED;

    2. Create bounding box covering all the faces from <myFaces> and
    create solid box from corner points of that bounding box
    (myBBox, mySBox). Add faces from that box to <myFaces>;

    3. Build solids from <myFaces> using BOPAlgo_BuilderSolid algorithm;

    4. Treat the result: Eliminate solid containig faces from <mySBox>;

    5. Fill internal shapes: add internal vertices and edges into
    created solids;

    6. Prepare the history.

    Fields:
    <myIntersect> - boolean flag. It defines whether intersect shapes
    from <myArguments> (if set to TRUE) or not (FALSE).
    The default value is TRUE. By setting it to FALSE
    the user should guarantee that shapes in <myArguments>
    do not interfere with each other, otherwise the result
    is unpredictable.

    <myBBox>      - bounding box, covering all faces from <myFaces>.

    <mySBox>      - Solid box created from the corner points of <myBBox>.

    <myFaces>     - the list is to keep the "final" faces, that will be
    given to the BOPAlgo_BuilderSolid algorithm.
    If the shapes have been interfered it should contain
    the images of the source shapes, otherwise its just
    the original faces.
    It also contains the faces from <mySBox>.

    Fields inherited from BOPAlgo_Builder:

    <myArguments> - list of the source shapes. The source shapes can have
    any type, but each shape must not be self-interfered.

    <myShape>     - Result shape:
    - empty compound - if no solids were created;
    - solid - if created only one solid;
    - compound of solids - if created more than one solid.

    Fields inherited from BOPAlgo_Algo:

    <myRunParallel> - Defines whether the parallel processing is
    switched on or not.
    <myReport> - Error status of the operation. Additionally to the
    errors of the parent algorithm it can have the following values:
    - *BOPAlgo_AlertSolidBuilderFailed* - BOPAlgo_BuilderSolid algorithm has failed.

    Example:

    BOPAlgo_MakerVolume aMV;
    //
    aMV.SetArguments(aLS); //source shapes
    aMV.SetRunParallel(bRunParallel); //parallel or single mode
    aMV.SetIntersect(bIntersect); //intersect or not the shapes from <aLS>
    //
    aMV.Perform(); //perform the operation
    if (aMV.HasErrors()) { //check error status
    return;
    }
    //
    const TopoDS_Shape& aResult = aMV.Shape();  //result of the operation
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_MakerVolume self) -> BOPAlgo_MakerVolume
        __init__(BOPAlgo_MakerVolume self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_MakerVolume

        Empty contructor.

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_MakerVolume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPAlgo_MakerVolume self)

        Clears the data.


        """
        return _BOPAlgo.BOPAlgo_MakerVolume_Clear(self, *args)


    def SetIntersect(self, *args):
        """
        SetIntersect(BOPAlgo_MakerVolume self, Standard_Boolean const bIntersect)

        Sets the flag myIntersect:
        if <bIntersect> is TRUE the shapes from <myArguments> will be intersected.
        if <bIntersect> is FALSE no intersection will be done.

        :type bIntersect: bool

        """
        return _BOPAlgo.BOPAlgo_MakerVolume_SetIntersect(self, *args)


    def IsIntersect(self, *args):
        """
        IsIntersect(BOPAlgo_MakerVolume self) -> Standard_Boolean

        Returns the flag <myIntersect>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_MakerVolume_IsIntersect(self, *args)


    def Box(self, *args):
        """
        Returns the solid box <mySBox>.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        res = _BOPAlgo.BOPAlgo_MakerVolume_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Faces(self, *args):
        """
        Returns the processed faces <myFaces>.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_MakerVolume_Faces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAvoidInternalShapes(self, *args):
        """
        SetAvoidInternalShapes(BOPAlgo_MakerVolume self, Standard_Boolean const theAvoidInternal)

        Defines the preventing of addition of internal for solid parts into the result.
        By default the internal parts are added into result.

        :type theAvoidInternal: bool

        """
        return _BOPAlgo.BOPAlgo_MakerVolume_SetAvoidInternalShapes(self, *args)


    def IsAvoidInternalShapes(self, *args):
        """
        IsAvoidInternalShapes(BOPAlgo_MakerVolume self) -> Standard_Boolean

        Returns the AvoidInternalShapes flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_MakerVolume_IsAvoidInternalShapes(self, *args)


    def Perform(self, *args):
        """
        Perform(BOPAlgo_MakerVolume self)

        Performs the operation.


        """
        return _BOPAlgo.BOPAlgo_MakerVolume_Perform(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_MakerVolume
BOPAlgo_MakerVolume_swigregister = _BOPAlgo.BOPAlgo_MakerVolume_swigregister
BOPAlgo_MakerVolume_swigregister(BOPAlgo_MakerVolume)

class BOPAlgo_SectionAttribute(object):
    """
    Class is a container of the flags used
    by intersection algorithm
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_SectionAttribute self) -> BOPAlgo_SectionAttribute
        __init__(BOPAlgo_SectionAttribute self, Standard_Boolean const theAproximation, Standard_Boolean const thePCurveOnS1, Standard_Boolean const thePCurveOnS2) -> BOPAlgo_SectionAttribute

        Constructor

        :type theAproximation: bool
        :type thePCurveOnS1: bool
        :type thePCurveOnS2: bool

        """
        this = _BOPAlgo.new_BOPAlgo_SectionAttribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Approximation(self, *args):
        """
        Approximation(BOPAlgo_SectionAttribute self, Standard_Boolean const theApprox)
        Approximation(BOPAlgo_SectionAttribute self) -> Standard_Boolean

        Returns the Approximation flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_SectionAttribute_Approximation(self, *args)


    def PCurveOnS1(self, *args):
        """
        PCurveOnS1(BOPAlgo_SectionAttribute self, Standard_Boolean const thePCurveOnS1)
        PCurveOnS1(BOPAlgo_SectionAttribute self) -> Standard_Boolean

        Returns the PCurveOnS1 flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_SectionAttribute_PCurveOnS1(self, *args)


    def PCurveOnS2(self, *args):
        """
        PCurveOnS2(BOPAlgo_SectionAttribute self, Standard_Boolean const thePCurveOnS2)
        PCurveOnS2(BOPAlgo_SectionAttribute self) -> Standard_Boolean

        Returns the PCurveOnS2 flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_SectionAttribute_PCurveOnS2(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_SectionAttribute
BOPAlgo_SectionAttribute_swigregister = _BOPAlgo.BOPAlgo_SectionAttribute_swigregister
BOPAlgo_SectionAttribute_swigregister(BOPAlgo_SectionAttribute)

class BOPAlgo_AlertUnsupportedType(TopoDS.TopoDS_AlertWithShape):
    """Unsupported type of input shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertUnsupportedType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertUnsupportedType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertUnsupportedType self, TopoDS_Shape theShape) -> BOPAlgo_AlertUnsupportedType

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertUnsupportedType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertUnsupportedType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertUnsupportedType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertUnsupportedType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertUnsupportedType
BOPAlgo_AlertUnsupportedType_swigregister = _BOPAlgo.BOPAlgo_AlertUnsupportedType_swigregister
BOPAlgo_AlertUnsupportedType_swigregister(BOPAlgo_AlertUnsupportedType)

def BOPAlgo_AlertUnsupportedType_get_type_name(*args):
    """
    BOPAlgo_AlertUnsupportedType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertUnsupportedType_get_type_name(*args)

def BOPAlgo_AlertUnsupportedType_get_type_descriptor(*args):
    """
    BOPAlgo_AlertUnsupportedType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertUnsupportedType_get_type_descriptor(*args)

class BOPAlgo_AlertTooFewArguments(Message.Message_Alert):
    """There are no enough arguments to perform the operation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertTooFewArguments
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertTooFewArguments(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertTooFewArguments_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertTooFewArguments_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertTooFewArguments_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """There are no enough arguments to perform the operation"""
        this = _BOPAlgo.new_BOPAlgo_AlertTooFewArguments()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertTooFewArguments
BOPAlgo_AlertTooFewArguments_swigregister = _BOPAlgo.BOPAlgo_AlertTooFewArguments_swigregister
BOPAlgo_AlertTooFewArguments_swigregister(BOPAlgo_AlertTooFewArguments)

def BOPAlgo_AlertTooFewArguments_get_type_name(*args):
    """
    BOPAlgo_AlertTooFewArguments_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertTooFewArguments_get_type_name(*args)

def BOPAlgo_AlertTooFewArguments_get_type_descriptor(*args):
    """
    BOPAlgo_AlertTooFewArguments_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertTooFewArguments_get_type_descriptor(*args)

class BOPAlgo_AlertNoFacesToRemove(Message.Message_Alert):
    """No faces have been found for removal"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertNoFacesToRemove
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertNoFacesToRemove(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertNoFacesToRemove_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertNoFacesToRemove_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertNoFacesToRemove_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """No faces have been found for removal"""
        this = _BOPAlgo.new_BOPAlgo_AlertNoFacesToRemove()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertNoFacesToRemove
BOPAlgo_AlertNoFacesToRemove_swigregister = _BOPAlgo.BOPAlgo_AlertNoFacesToRemove_swigregister
BOPAlgo_AlertNoFacesToRemove_swigregister(BOPAlgo_AlertNoFacesToRemove)

def BOPAlgo_AlertNoFacesToRemove_get_type_name(*args):
    """
    BOPAlgo_AlertNoFacesToRemove_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertNoFacesToRemove_get_type_name(*args)

def BOPAlgo_AlertNoFacesToRemove_get_type_descriptor(*args):
    """
    BOPAlgo_AlertNoFacesToRemove_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertNoFacesToRemove_get_type_descriptor(*args)

class BOPAlgo_BOP(BOPAlgo_ToolsProvider):
    """
    The class represents the Building part of the Boolean Operations
    algorithm.<br>
    The arguments of the algorithms are divided in two groups - *Objects*
    and *Tools*.<br>
    The algorithm builds the splits of the given arguments using the intersection
    results and combines the result of Boolean Operation of given type:<br>
    - *FUSE* - union of two groups of objects;<br>
    - *COMMON* - intersection of two groups of objects;<br>
    - *CUT* - subtraction of one group from the other.<br>

    The rules for the arguments and type of the operation are the following:<br>
    - For Boolean operation *FUSE* all arguments should have equal dimensions;<br>
    - For Boolean operation *CUT* the minimal dimension of *Tools* should not be
    less than the maximal dimension of *Objects*;<br>
    - For Boolean operation *COMMON* the arguments can have any dimension.<br>

    The class is a General Fuse based algorithm. Thus, all options
    of the General Fuse algorithm such as Fuzzy mode, safe processing mode,
    parallel processing mode, gluing mode and history support are also
    available in this algorithm.<br>

    Additionally to the Warnings of the parent class the algorithm returns
    the following warnings:
    - *BOPAlgo_AlertEmptyShape* - in case some of the input shapes are empty shapes.

    Additionally to Errors of the parent class the algorithm returns
    the following Error statuses:
    - *BOPAlgo_AlertBOPIsNotSet* - in case the type of Boolean operation is not set;
    - *BOPAlgo_AlertBOPNotAllowed* - in case the operation of given type is not allowed on
    given inputs;
    - *BOPAlgo_AlertSolidBuilderFailed* - in case the BuilderSolid algorithm failed to
    produce the Fused solid.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_BOP self) -> BOPAlgo_BOP
        __init__(BOPAlgo_BOP self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_BOP

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_BOP(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPAlgo_BOP self)

        Clears internal fields and arguments


        """
        return _BOPAlgo.BOPAlgo_BOP_Clear(self, *args)


    def SetOperation(self, *args):
        """
        SetOperation(BOPAlgo_BOP self, BOPAlgo_Operation const theOperation)

        :type theOperation: OCC.wrapper.BOPAlgo.BOPAlgo_Operation

        """
        return _BOPAlgo.BOPAlgo_BOP_SetOperation(self, *args)


    def Operation(self, *args):
        """
        Operation(BOPAlgo_BOP self) -> BOPAlgo_Operation

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_Operation

        """
        return _BOPAlgo.BOPAlgo_BOP_Operation(self, *args)


    def Perform(self, *args):
        """
        Perform(BOPAlgo_BOP self)

        Performs the operation.
        The intersection will be performed also.


        """
        return _BOPAlgo.BOPAlgo_BOP_Perform(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_BOP
BOPAlgo_BOP_swigregister = _BOPAlgo.BOPAlgo_BOP_swigregister
BOPAlgo_BOP_swigregister(BOPAlgo_BOP)

class BOPAlgo_AlertSelfInterferingShape(TopoDS.TopoDS_AlertWithShape):
    """Some of the arguments are self-interfering shapes"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertSelfInterferingShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertSelfInterferingShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertSelfInterferingShape self, TopoDS_Shape theShape) -> BOPAlgo_AlertSelfInterferingShape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertSelfInterferingShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertSelfInterferingShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertSelfInterferingShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertSelfInterferingShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertSelfInterferingShape
BOPAlgo_AlertSelfInterferingShape_swigregister = _BOPAlgo.BOPAlgo_AlertSelfInterferingShape_swigregister
BOPAlgo_AlertSelfInterferingShape_swigregister(BOPAlgo_AlertSelfInterferingShape)

def BOPAlgo_AlertSelfInterferingShape_get_type_name(*args):
    """
    BOPAlgo_AlertSelfInterferingShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertSelfInterferingShape_get_type_name(*args)

def BOPAlgo_AlertSelfInterferingShape_get_type_descriptor(*args):
    """
    BOPAlgo_AlertSelfInterferingShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertSelfInterferingShape_get_type_descriptor(*args)

class BOPAlgo_AlertIntersectionOfPairOfShapesFailed(TopoDS.TopoDS_AlertWithShape):
    """Intersection of pair of shapes has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertIntersectionOfPairOfShapesFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertIntersectionOfPairOfShapesFailed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertIntersectionOfPairOfShapesFailed self, TopoDS_Shape theShape) -> BOPAlgo_AlertIntersectionOfPairOfShapesFailed

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertIntersectionOfPairOfShapesFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertIntersectionOfPairOfShapesFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertIntersectionOfPairOfShapesFailed
BOPAlgo_AlertIntersectionOfPairOfShapesFailed_swigregister = _BOPAlgo.BOPAlgo_AlertIntersectionOfPairOfShapesFailed_swigregister
BOPAlgo_AlertIntersectionOfPairOfShapesFailed_swigregister(BOPAlgo_AlertIntersectionOfPairOfShapesFailed)

def BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_name(*args):
    """
    BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_name(*args)

def BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertIntersectionOfPairOfShapesFailed_get_type_descriptor(*args)

class NCollection_List_BOPAlgo_CheckResult_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPAlgo.new_NCollection_List_BOPAlgo_CheckResult_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPAlgo.delete_NCollection_List_BOPAlgo_CheckResult_IteratorHelper

    def __next__(self):
        return _BOPAlgo.NCollection_List_BOPAlgo_CheckResult_IteratorHelper___next__(self)
NCollection_List_BOPAlgo_CheckResult_IteratorHelper_swigregister = _BOPAlgo.NCollection_List_BOPAlgo_CheckResult_IteratorHelper_swigregister
NCollection_List_BOPAlgo_CheckResult_IteratorHelper_swigregister(NCollection_List_BOPAlgo_CheckResult_IteratorHelper)


try:
	BOPAlgo_ListOfCheckResult = NCollection_List_BOPAlgo_CheckResult
except NameError:
	pass # does not exist, probably ignored

class BOPAlgo_ShellSplitter(BOPAlgo_Algo):
    """
    The class provides the splitting of the set of connected faces
    on separate loops
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_ShellSplitter self) -> BOPAlgo_ShellSplitter
        __init__(BOPAlgo_ShellSplitter self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_ShellSplitter

        constructor

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_ShellSplitter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddStartElement(self, *args):
        """
        AddStartElement(BOPAlgo_ShellSplitter self, TopoDS_Shape theS)

        adds a face <theS> to process

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_ShellSplitter_AddStartElement(self, *args)


    def StartElements(self, *args):
        """
        return the faces to process

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_ShellSplitter_StartElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(BOPAlgo_ShellSplitter self)

        performs the algorithm


        """
        return _BOPAlgo.BOPAlgo_ShellSplitter_Perform(self, *args)


    def Shells(self, *args):
        """
        returns the loops

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPAlgo.BOPAlgo_ShellSplitter_Shells(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SplitBlock(*args):
        """
        SplitBlock(BOPTools_ConnexityBlock theCB)

        :type theCB: OCC.wrapper.BOPTools.BOPTools_ConnexityBlock

        """
        return _BOPAlgo.BOPAlgo_ShellSplitter_SplitBlock(*args)

    SplitBlock = staticmethod(SplitBlock)
    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_ShellSplitter
BOPAlgo_ShellSplitter_swigregister = _BOPAlgo.BOPAlgo_ShellSplitter_swigregister
BOPAlgo_ShellSplitter_swigregister(BOPAlgo_ShellSplitter)

def BOPAlgo_ShellSplitter_SplitBlock(*args):
    """
    BOPAlgo_ShellSplitter_SplitBlock(BOPTools_ConnexityBlock theCB)

    :type theCB: OCC.wrapper.BOPTools.BOPTools_ConnexityBlock

    """
    return _BOPAlgo.BOPAlgo_ShellSplitter_SplitBlock(*args)

class BOPAlgo_AlertBuildingPCurveFailed(TopoDS.TopoDS_AlertWithShape):
    """Building 2D curve of edge on face has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertBuildingPCurveFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertBuildingPCurveFailed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertBuildingPCurveFailed self, TopoDS_Shape theShape) -> BOPAlgo_AlertBuildingPCurveFailed

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertBuildingPCurveFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertBuildingPCurveFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertBuildingPCurveFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertBuildingPCurveFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertBuildingPCurveFailed
BOPAlgo_AlertBuildingPCurveFailed_swigregister = _BOPAlgo.BOPAlgo_AlertBuildingPCurveFailed_swigregister
BOPAlgo_AlertBuildingPCurveFailed_swigregister(BOPAlgo_AlertBuildingPCurveFailed)

def BOPAlgo_AlertBuildingPCurveFailed_get_type_name(*args):
    """
    BOPAlgo_AlertBuildingPCurveFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertBuildingPCurveFailed_get_type_name(*args)

def BOPAlgo_AlertBuildingPCurveFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertBuildingPCurveFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertBuildingPCurveFailed_get_type_descriptor(*args)

class BOPAlgo_ArgumentAnalyzer(BOPAlgo_Algo):
    """check the validity of argument(s) for Boolean Operations"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_ArgumentAnalyzer self) -> BOPAlgo_ArgumentAnalyzer

        empty constructor


        """
        this = _BOPAlgo.new_BOPAlgo_ArgumentAnalyzer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape1(self, *args):
        """
        SetShape1(BOPAlgo_ArgumentAnalyzer self, TopoDS_Shape TheShape)

        sets object shape

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_SetShape1(self, *args)


    def SetShape2(self, *args):
        """
        SetShape2(BOPAlgo_ArgumentAnalyzer self, TopoDS_Shape TheShape)

        sets tool shape

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_SetShape2(self, *args)


    def GetShape1(self, *args):
        """
        returns object shape;

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_ArgumentAnalyzer_GetShape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetShape2(self, *args):
        """
        returns tool shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPAlgo.BOPAlgo_ArgumentAnalyzer_GetShape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OperationType(self, *args):
        """
        OperationType(BOPAlgo_ArgumentAnalyzer self) -> BOPAlgo_Operation &

        returns ref

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_Operation

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_OperationType(self, *args)


    def StopOnFirstFaulty(self, *args):
        """
        StopOnFirstFaulty(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        returns ref

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_StopOnFirstFaulty(self, *args)


    def ArgumentTypeMode(self, *args):
        """
        ArgumentTypeMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode
        that means checking types of shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_ArgumentTypeMode(self, *args)


    def SelfInterMode(self, *args):
        """
        SelfInterMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of self-intersection of shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_SelfInterMode(self, *args)


    def SmallEdgeMode(self, *args):
        """
        SmallEdgeMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of small edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_SmallEdgeMode(self, *args)


    def RebuildFaceMode(self, *args):
        """
        RebuildFaceMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of possibility to split or rebuild faces.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_RebuildFaceMode(self, *args)


    def TangentMode(self, *args):
        """
        TangentMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of tangency between subshapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_TangentMode(self, *args)


    def MergeVertexMode(self, *args):
        """
        MergeVertexMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of problem of merging vertices.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_MergeVertexMode(self, *args)


    def MergeEdgeMode(self, *args):
        """
        MergeEdgeMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of problem of merging edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_MergeEdgeMode(self, *args)


    def ContinuityMode(self, *args):
        """
        ContinuityMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of problem of continuity of the shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_ContinuityMode(self, *args)


    def CurveOnSurfaceMode(self, *args):
        """
        CurveOnSurfaceMode(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean &

        Returns (modifiable) mode that means
        checking of problem of invalid curve on surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_CurveOnSurfaceMode(self, *args)


    def Perform(self, *args):
        """
        Perform(BOPAlgo_ArgumentAnalyzer self)

        performs analysis


        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_Perform(self, *args)


    def HasFaulty(self, *args):
        """
        HasFaulty(BOPAlgo_ArgumentAnalyzer self) -> Standard_Boolean

        result of test

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_ArgumentAnalyzer_HasFaulty(self, *args)


    def GetCheckResult(self, *args):
        """
        returns a result of test

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_ListOfCheckResult

        """
        res = _BOPAlgo.BOPAlgo_ArgumentAnalyzer_GetCheckResult(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_ArgumentAnalyzer
BOPAlgo_ArgumentAnalyzer_swigregister = _BOPAlgo.BOPAlgo_ArgumentAnalyzer_swigregister
BOPAlgo_ArgumentAnalyzer_swigregister(BOPAlgo_ArgumentAnalyzer)

class BOPAlgo_BuilderFace(BOPAlgo_BuilderArea):
    """
    The algorithm to build new faces from the given faces and
    set of edges lying on this face.

    The algorithm returns the following Error statuses:
    - *BOPAlgo_AlertNullInputShapes* - in case the given face is a null shape.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPAlgo_BuilderFace self) -> BOPAlgo_BuilderFace
        __init__(BOPAlgo_BuilderFace self, Handle_NCollection_BaseAllocator theAllocator) -> BOPAlgo_BuilderFace

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPAlgo.new_BOPAlgo_BuilderFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFace(self, *args):
        """
        SetFace(BOPAlgo_BuilderFace self, TopoDS_Face theFace)

        Sets the face generatix

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BOPAlgo.BOPAlgo_BuilderFace_SetFace(self, *args)


    def Face(self, *args):
        """
        Returns the face generatix

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BOPAlgo.BOPAlgo_BuilderFace_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(BOPAlgo_BuilderFace self)

        Performs the algorithm


        """
        return _BOPAlgo.BOPAlgo_BuilderFace_Perform(self, *args)


    def Orientation(self, *args):
        """
        Orientation(BOPAlgo_BuilderFace self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _BOPAlgo.BOPAlgo_BuilderFace_Orientation(self, *args)

    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_BuilderFace
BOPAlgo_BuilderFace_swigregister = _BOPAlgo.BOPAlgo_BuilderFace_swigregister
BOPAlgo_BuilderFace_swigregister(BOPAlgo_BuilderFace)

class BOPAlgo_AlertBOPNotAllowed(Message.Message_Alert):
    """Boolean operation of given type is not allowed on the given inputs"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertBOPNotAllowed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertBOPNotAllowed(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertBOPNotAllowed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertBOPNotAllowed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertBOPNotAllowed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """Boolean operation of given type is not allowed on the given inputs"""
        this = _BOPAlgo.new_BOPAlgo_AlertBOPNotAllowed()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertBOPNotAllowed
BOPAlgo_AlertBOPNotAllowed_swigregister = _BOPAlgo.BOPAlgo_AlertBOPNotAllowed_swigregister
BOPAlgo_AlertBOPNotAllowed_swigregister(BOPAlgo_AlertBOPNotAllowed)

def BOPAlgo_AlertBOPNotAllowed_get_type_name(*args):
    """
    BOPAlgo_AlertBOPNotAllowed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertBOPNotAllowed_get_type_name(*args)

def BOPAlgo_AlertBOPNotAllowed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertBOPNotAllowed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertBOPNotAllowed_get_type_descriptor(*args)

class BOPAlgo_AlertRemoveFeaturesFailed(Message.Message_Alert):
    """The Feature Removal algorithm has failed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertRemoveFeaturesFailed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertRemoveFeaturesFailed(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertRemoveFeaturesFailed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertRemoveFeaturesFailed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertRemoveFeaturesFailed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """The Feature Removal algorithm has failed"""
        this = _BOPAlgo.new_BOPAlgo_AlertRemoveFeaturesFailed()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertRemoveFeaturesFailed
BOPAlgo_AlertRemoveFeaturesFailed_swigregister = _BOPAlgo.BOPAlgo_AlertRemoveFeaturesFailed_swigregister
BOPAlgo_AlertRemoveFeaturesFailed_swigregister(BOPAlgo_AlertRemoveFeaturesFailed)

def BOPAlgo_AlertRemoveFeaturesFailed_get_type_name(*args):
    """
    BOPAlgo_AlertRemoveFeaturesFailed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertRemoveFeaturesFailed_get_type_name(*args)

def BOPAlgo_AlertRemoveFeaturesFailed_get_type_descriptor(*args):
    """
    BOPAlgo_AlertRemoveFeaturesFailed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertRemoveFeaturesFailed_get_type_descriptor(*args)

class BOPAlgo_AlertBadPositioning(TopoDS.TopoDS_AlertWithShape):
    """The positioning of the shapes leads to creation of the small edges without valid range"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertBadPositioning
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertBadPositioning(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertBadPositioning self, TopoDS_Shape theShape) -> BOPAlgo_AlertBadPositioning

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertBadPositioning(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertBadPositioning_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertBadPositioning_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertBadPositioning_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertBadPositioning
BOPAlgo_AlertBadPositioning_swigregister = _BOPAlgo.BOPAlgo_AlertBadPositioning_swigregister
BOPAlgo_AlertBadPositioning_swigregister(BOPAlgo_AlertBadPositioning)

def BOPAlgo_AlertBadPositioning_get_type_name(*args):
    """
    BOPAlgo_AlertBadPositioning_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertBadPositioning_get_type_name(*args)

def BOPAlgo_AlertBadPositioning_get_type_descriptor(*args):
    """
    BOPAlgo_AlertBadPositioning_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertBadPositioning_get_type_descriptor(*args)

class BOPAlgo_AlertEmptyShape(TopoDS.TopoDS_AlertWithShape):
    """Some of the arguments are empty shapes"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertEmptyShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertEmptyShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertEmptyShape self, TopoDS_Shape theShape) -> BOPAlgo_AlertEmptyShape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertEmptyShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertEmptyShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertEmptyShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertEmptyShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertEmptyShape
BOPAlgo_AlertEmptyShape_swigregister = _BOPAlgo.BOPAlgo_AlertEmptyShape_swigregister
BOPAlgo_AlertEmptyShape_swigregister(BOPAlgo_AlertEmptyShape)

def BOPAlgo_AlertEmptyShape_get_type_name(*args):
    """
    BOPAlgo_AlertEmptyShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertEmptyShape_get_type_name(*args)

def BOPAlgo_AlertEmptyShape_get_type_descriptor(*args):
    """
    BOPAlgo_AlertEmptyShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertEmptyShape_get_type_descriptor(*args)

class BOPAlgo_AlertAcquiredSelfIntersection(TopoDS.TopoDS_AlertWithShape):
    """
    Some sub-shapes of some of the argument become connected through
    other shapes and the argument became self-interfered
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertAcquiredSelfIntersection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertAcquiredSelfIntersection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertAcquiredSelfIntersection self, TopoDS_Shape theShape) -> BOPAlgo_AlertAcquiredSelfIntersection

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertAcquiredSelfIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertAcquiredSelfIntersection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertAcquiredSelfIntersection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertAcquiredSelfIntersection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertAcquiredSelfIntersection
BOPAlgo_AlertAcquiredSelfIntersection_swigregister = _BOPAlgo.BOPAlgo_AlertAcquiredSelfIntersection_swigregister
BOPAlgo_AlertAcquiredSelfIntersection_swigregister(BOPAlgo_AlertAcquiredSelfIntersection)

def BOPAlgo_AlertAcquiredSelfIntersection_get_type_name(*args):
    """
    BOPAlgo_AlertAcquiredSelfIntersection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertAcquiredSelfIntersection_get_type_name(*args)

def BOPAlgo_AlertAcquiredSelfIntersection_get_type_descriptor(*args):
    """
    BOPAlgo_AlertAcquiredSelfIntersection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertAcquiredSelfIntersection_get_type_descriptor(*args)

class BOPAlgo_AlertSolidBuilderUnusedFaces(TopoDS.TopoDS_AlertWithShape):
    """
    Some of the faces passed to the Solid Builder algorithm have not been classified
    and not used for solids creation
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPAlgo_AlertSolidBuilderUnusedFaces
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPAlgo_AlertSolidBuilderUnusedFaces(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPAlgo_AlertSolidBuilderUnusedFaces self, TopoDS_Shape theShape) -> BOPAlgo_AlertSolidBuilderUnusedFaces

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BOPAlgo.new_BOPAlgo_AlertSolidBuilderUnusedFaces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPAlgo.BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPAlgo.BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPAlgo.BOPAlgo_AlertSolidBuilderUnusedFaces_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_AlertSolidBuilderUnusedFaces
BOPAlgo_AlertSolidBuilderUnusedFaces_swigregister = _BOPAlgo.BOPAlgo_AlertSolidBuilderUnusedFaces_swigregister
BOPAlgo_AlertSolidBuilderUnusedFaces_swigregister(BOPAlgo_AlertSolidBuilderUnusedFaces)

def BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_name(*args):
    """
    BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPAlgo.BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_name(*args)

def BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_descriptor(*args):
    """
    BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPAlgo.BOPAlgo_AlertSolidBuilderUnusedFaces_get_type_descriptor(*args)

class BOPAlgo_Tools(object):
    """Provides tools used in the intersection part of Boolean operations"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FillMap(*args):
        """
        FillMap(Handle_BOPDS_PaveBlock thePB1, Standard_Integer const theF, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theMILI, Handle_NCollection_BaseAllocator theAllocator)

        :type thePB1: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :type theF: int
        :type theMILI: OCC.wrapper.BOPDS.BOPDS_IndexedDataMapOfPaveBlockListOfInteger
        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPAlgo.BOPAlgo_Tools_FillMap(*args)

    FillMap = staticmethod(FillMap)

    def PerformCommonBlocks(*args):
        """
        PerformCommonBlocks(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theMBlocks, Handle_NCollection_BaseAllocator theAllocator, BOPDS_PDS & theDS)
        PerformCommonBlocks(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theMBlocks, Handle_NCollection_BaseAllocator theAllocator, BOPDS_PDS & pDS)

        :type theMBlocks: OCC.wrapper.BOPDS.BOPDS_IndexedDataMapOfPaveBlockListOfInteger
        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :type pDS: OCC.wrapper.BOPDS.BOPDS_PDS

        """
        return _BOPAlgo.BOPAlgo_Tools_PerformCommonBlocks(*args)

    PerformCommonBlocks = staticmethod(PerformCommonBlocks)

    def ComputeToleranceOfCB(*args):
        """
        ComputeToleranceOfCB(Handle_BOPDS_CommonBlock theCB, BOPDS_DS theDS, Handle_IntTools_Context theContext) -> Standard_Real

        :type theCB: OCC.wrapper.BOPDS.Handle_BOPDS_CommonBlock
        :type theDS: OCC.wrapper.BOPDS.BOPDS_PDS
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPAlgo.BOPAlgo_Tools_ComputeToleranceOfCB(*args)

    ComputeToleranceOfCB = staticmethod(ComputeToleranceOfCB)

    def EdgesToWires(*args):
        """
        EdgesToWires(TopoDS_Shape theEdges, TopoDS_Shape theWires, Standard_Boolean const theShared, Standard_Real const theAngTol=1.e-8) -> Standard_Integer

        Creates planar wires from the given edges.<br>
        The input edges are expected to be planar. And for the performance
        sake the method does not check if the edges are really planar.<br>
        Thus, the result wires will also be not planar if the input edges are not planar.<br>
        The edges may be not shared, but the resulting wires will be sharing the
        coinciding parts and intersecting parts.<br>
        The output wires may be non-manifold and contain free and multi-connected vertices.<br>
        Parameters:
        <theEdges> - input edges;<br>
        <theWires> - output wires;<br>
        <theShared> - boolean flag which defines whether the input edges are already
        shared or have to be intersected;<br>
        <theAngTol> - the angular tolerance which will be used for distinguishing
        the planes in which the edges are located. Default value is
        1.e-8 which is used for intersection of planes in IntTools_FaceFace.<br>
        Method returns the following error statuses:<br>
        0 - in case of success (at least one wire has been built);<br>
        1 - in case there are no edges in the given shape;<br>
        2 - sharing of the edges has failed.<br>

        :type theEdges: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theWires: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theShared: bool
        :type theAngTol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPAlgo.BOPAlgo_Tools_EdgesToWires(*args)

    EdgesToWires = staticmethod(EdgesToWires)

    def WiresToFaces(*args):
        """
        WiresToFaces(TopoDS_Shape theWires, TopoDS_Shape theFaces, Standard_Real const theAngTol=1.e-8) -> Standard_Boolean

        Creates planar faces from given planar wires.<br>
        The method does not check if the wires are really planar.<br>
        The input wires may be non-manifold but should be shared.<br>
        The wires located in the same planes and included into other wires will create
        holes in the faces built from outer wires.<br>
        The tolerance values of the input shapes may be modified during the operation
        due to projection of the edges on the planes for creation of 2D curves.<br>
        Parameters:
        <theWires> - the given wires;<br>
        <theFaces> - the output faces;<br>
        <theAngTol> - the angular tolerance for distinguishing the planes in which
        the wires are located. Default value is 1.e-8 which is used
        for intersection of planes in IntTools_FaceFace.<br>
        Method returns TRUE in case of success, i.e. at least one face has been built.<br>

        :type theWires: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theFaces: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theAngTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPAlgo.BOPAlgo_Tools_WiresToFaces(*args)

    WiresToFaces = staticmethod(WiresToFaces)

    def IntersectVertices(*args):
        """
        IntersectVertices(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theVertices, Standard_Boolean const theRunParallel, Standard_Real const theFuzzyValue, NCollection_List_TopTools_ListOfShape theChains)

        Finds chains of intersecting vertices

        :type theVertices: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeReal
        :type theRunParallel: bool
        :type theFuzzyValue: float
        :type theChains: OCC.wrapper.TopTools.TopTools_ListOfListOfShape

        """
        return _BOPAlgo.BOPAlgo_Tools_IntersectVertices(*args)

    IntersectVertices = staticmethod(IntersectVertices)

    def TreatCompound(*args):
        """
        TreatCompound(TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMFence, NCollection_List_TopoDS_Shape theLS)

        Collect in the output list recursively all non-compound subshapes of the first level
        of the given shape theS. If a shape presents in the map theMFence it is skipped.
        All shapes put in the output are also added into theMFence.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMFence: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPAlgo.BOPAlgo_Tools_TreatCompound(*args)

    TreatCompound = staticmethod(TreatCompound)

    def ClassifyFaces(*args):
        """
        ClassifyFaces(NCollection_List_TopoDS_Shape theFaces, NCollection_List_TopoDS_Shape theSolids, Standard_Boolean const theRunParallel, Handle_IntTools_Context theContext, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theInParts, NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theShapeBoxMap, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theSolidsIF)

        Classifies the faces <theFaces> relatively solids <theSolids>.
        The IN faces for solids are stored into output data map <theInParts>.

        The map <theSolidsIF> contains INTERNAL faces of the solids, to avoid
        their additional classification.

        Firstly, it checks the intersection of bounding boxes of the shapes.
        If the Box is not stored in the <theShapeBoxMap> map, it builds the box.
        If the bounding boxes of solid and face are interfering the classification is performed.

        It is assumed that all faces and solids are already intersected and
        do not have any geometrically coinciding parts without topological
        sharing of these parts

        :type theFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theSolids: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theRunParallel: bool
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theInParts: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
        :type theShapeBoxMap: OCC.wrapper.TopTools.TopTools_DataMapOfShapeBox
        :type theSolidsIF: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _BOPAlgo.BOPAlgo_Tools_ClassifyFaces(*args)

    ClassifyFaces = staticmethod(ClassifyFaces)

    def __init__(self):
        """Provides tools used in the intersection part of Boolean operations"""
        this = _BOPAlgo.new_BOPAlgo_Tools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPAlgo.delete_BOPAlgo_Tools
BOPAlgo_Tools_swigregister = _BOPAlgo.BOPAlgo_Tools_swigregister
BOPAlgo_Tools_swigregister(BOPAlgo_Tools)

def BOPAlgo_Tools_FillMap(*args):
    """
    BOPAlgo_Tools_FillMap(Handle_BOPDS_PaveBlock thePB1, Standard_Integer const theF, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theMILI, Handle_NCollection_BaseAllocator theAllocator)

    :type thePB1: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
    :type theF: int
    :type theMILI: OCC.wrapper.BOPDS.BOPDS_IndexedDataMapOfPaveBlockListOfInteger
    :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BOPAlgo.BOPAlgo_Tools_FillMap(*args)

def BOPAlgo_Tools_PerformCommonBlocks(*args):
    """
    PerformCommonBlocks(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theMBlocks, Handle_NCollection_BaseAllocator theAllocator, BOPDS_PDS & theDS)
    BOPAlgo_Tools_PerformCommonBlocks(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theMBlocks, Handle_NCollection_BaseAllocator theAllocator, BOPDS_PDS & pDS)

    :type theMBlocks: OCC.wrapper.BOPDS.BOPDS_IndexedDataMapOfPaveBlockListOfInteger
    :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
    :type pDS: OCC.wrapper.BOPDS.BOPDS_PDS

    """
    return _BOPAlgo.BOPAlgo_Tools_PerformCommonBlocks(*args)

def BOPAlgo_Tools_ComputeToleranceOfCB(*args):
    """
    BOPAlgo_Tools_ComputeToleranceOfCB(Handle_BOPDS_CommonBlock theCB, BOPDS_DS theDS, Handle_IntTools_Context theContext) -> Standard_Real

    :type theCB: OCC.wrapper.BOPDS.Handle_BOPDS_CommonBlock
    :type theDS: OCC.wrapper.BOPDS.BOPDS_PDS
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BOPAlgo.BOPAlgo_Tools_ComputeToleranceOfCB(*args)

def BOPAlgo_Tools_EdgesToWires(*args):
    """
    BOPAlgo_Tools_EdgesToWires(TopoDS_Shape theEdges, TopoDS_Shape theWires, Standard_Boolean const theShared, Standard_Real const theAngTol=1.e-8) -> Standard_Integer

    Creates planar wires from the given edges.<br>
    The input edges are expected to be planar. And for the performance
    sake the method does not check if the edges are really planar.<br>
    Thus, the result wires will also be not planar if the input edges are not planar.<br>
    The edges may be not shared, but the resulting wires will be sharing the
    coinciding parts and intersecting parts.<br>
    The output wires may be non-manifold and contain free and multi-connected vertices.<br>
    Parameters:
    <theEdges> - input edges;<br>
    <theWires> - output wires;<br>
    <theShared> - boolean flag which defines whether the input edges are already
    shared or have to be intersected;<br>
    <theAngTol> - the angular tolerance which will be used for distinguishing
    the planes in which the edges are located. Default value is
    1.e-8 which is used for intersection of planes in IntTools_FaceFace.<br>
    Method returns the following error statuses:<br>
    0 - in case of success (at least one wire has been built);<br>
    1 - in case there are no edges in the given shape;<br>
    2 - sharing of the edges has failed.<br>

    :type theEdges: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theWires: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theShared: bool
    :type theAngTol: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPAlgo.BOPAlgo_Tools_EdgesToWires(*args)

def BOPAlgo_Tools_WiresToFaces(*args):
    """
    BOPAlgo_Tools_WiresToFaces(TopoDS_Shape theWires, TopoDS_Shape theFaces, Standard_Real const theAngTol=1.e-8) -> Standard_Boolean

    Creates planar faces from given planar wires.<br>
    The method does not check if the wires are really planar.<br>
    The input wires may be non-manifold but should be shared.<br>
    The wires located in the same planes and included into other wires will create
    holes in the faces built from outer wires.<br>
    The tolerance values of the input shapes may be modified during the operation
    due to projection of the edges on the planes for creation of 2D curves.<br>
    Parameters:
    <theWires> - the given wires;<br>
    <theFaces> - the output faces;<br>
    <theAngTol> - the angular tolerance for distinguishing the planes in which
    the wires are located. Default value is 1.e-8 which is used
    for intersection of planes in IntTools_FaceFace.<br>
    Method returns TRUE in case of success, i.e. at least one face has been built.<br>

    :type theWires: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theFaces: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theAngTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPAlgo.BOPAlgo_Tools_WiresToFaces(*args)

def BOPAlgo_Tools_IntersectVertices(*args):
    """
    BOPAlgo_Tools_IntersectVertices(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theVertices, Standard_Boolean const theRunParallel, Standard_Real const theFuzzyValue, NCollection_List_TopTools_ListOfShape theChains)

    Finds chains of intersecting vertices

    :type theVertices: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeReal
    :type theRunParallel: bool
    :type theFuzzyValue: float
    :type theChains: OCC.wrapper.TopTools.TopTools_ListOfListOfShape

    """
    return _BOPAlgo.BOPAlgo_Tools_IntersectVertices(*args)

def BOPAlgo_Tools_TreatCompound(*args):
    """
    BOPAlgo_Tools_TreatCompound(TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMFence, NCollection_List_TopoDS_Shape theLS)

    Collect in the output list recursively all non-compound subshapes of the first level
    of the given shape theS. If a shape presents in the map theMFence it is skipped.
    All shapes put in the output are also added into theMFence.

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theMFence: OCC.wrapper.TopTools.TopTools_MapOfShape
    :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

    """
    return _BOPAlgo.BOPAlgo_Tools_TreatCompound(*args)

def BOPAlgo_Tools_ClassifyFaces(*args):
    """
    BOPAlgo_Tools_ClassifyFaces(NCollection_List_TopoDS_Shape theFaces, NCollection_List_TopoDS_Shape theSolids, Standard_Boolean const theRunParallel, Handle_IntTools_Context theContext, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theInParts, NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theShapeBoxMap, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theSolidsIF)

    Classifies the faces <theFaces> relatively solids <theSolids>.
    The IN faces for solids are stored into output data map <theInParts>.

    The map <theSolidsIF> contains INTERNAL faces of the solids, to avoid
    their additional classification.

    Firstly, it checks the intersection of bounding boxes of the shapes.
    If the Box is not stored in the <theShapeBoxMap> map, it builds the box.
    If the bounding boxes of solid and face are interfering the classification is performed.

    It is assumed that all faces and solids are already intersected and
    do not have any geometrically coinciding parts without topological
    sharing of these parts

    :type theFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theSolids: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theRunParallel: bool
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :type theInParts: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
    :type theShapeBoxMap: OCC.wrapper.TopTools.TopTools_DataMapOfShapeBox
    :type theSolidsIF: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

    """
    return _BOPAlgo.BOPAlgo_Tools_ClassifyFaces(*args)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IFSelect')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IFSelect')
    _IFSelect = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IFSelect', [dirname(__file__)])
        except ImportError:
            import _IFSelect
            return _IFSelect
        try:
            _mod = imp.load_module('_IFSelect', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IFSelect = swig_import_helper()
    del swig_import_helper
else:
    import _IFSelect
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IFSelect.delete_SwigPyIterator

    def value(self):
        return _IFSelect.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IFSelect.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IFSelect.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IFSelect.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IFSelect.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IFSelect.SwigPyIterator_copy(self)

    def next(self):
        return _IFSelect.SwigPyIterator_next(self)

    def __next__(self):
        return _IFSelect.SwigPyIterator___next__(self)

    def previous(self):
        return _IFSelect.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IFSelect.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IFSelect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IFSelect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IFSelect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IFSelect.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IFSelect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IFSelect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IFSelect.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IFSelect.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IFSelect.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IFSelect.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IFSelect.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IFSelect.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IFSelect.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IFSelect.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IFSelect.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IFSelect.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IFSelect.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IFSelect.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IFSelect.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IFSelect.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IFSelect.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IFSelect.ptr_to_number(item)
ptr_to_number = _IFSelect.ptr_to_number

def HashCode(*args):
    return _IFSelect.HashCode(*args)
HashCode = _IFSelect.HashCode

def ptr_equal(a, b):
    return _IFSelect.ptr_equal(a, b)
ptr_equal = _IFSelect.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
IFSelect_RetVoid = _IFSelect.IFSelect_RetVoid
IFSelect_RetDone = _IFSelect.IFSelect_RetDone
IFSelect_RetError = _IFSelect.IFSelect_RetError
IFSelect_RetFail = _IFSelect.IFSelect_RetFail
IFSelect_RetStop = _IFSelect.IFSelect_RetStop
IFSelect_ItemsByEntity = _IFSelect.IFSelect_ItemsByEntity
IFSelect_CountByItem = _IFSelect.IFSelect_CountByItem
IFSelect_ShortByItem = _IFSelect.IFSelect_ShortByItem
IFSelect_ListByItem = _IFSelect.IFSelect_ListByItem
IFSelect_EntitiesByItem = _IFSelect.IFSelect_EntitiesByItem
IFSelect_CountSummary = _IFSelect.IFSelect_CountSummary
IFSelect_GeneralInfo = _IFSelect.IFSelect_GeneralInfo
IFSelect_Mapping = _IFSelect.IFSelect_Mapping
IFSelect_ResultCount = _IFSelect.IFSelect_ResultCount
IFSelect_Optional = _IFSelect.IFSelect_Optional
IFSelect_Editable = _IFSelect.IFSelect_Editable
IFSelect_EditProtected = _IFSelect.IFSelect_EditProtected
IFSelect_EditComputed = _IFSelect.IFSelect_EditComputed
IFSelect_EditRead = _IFSelect.IFSelect_EditRead
IFSelect_EditDynamic = _IFSelect.IFSelect_EditDynamic
IFSelect_FailOnly = _IFSelect.IFSelect_FailOnly
IFSelect_FailAndWarn = _IFSelect.IFSelect_FailAndWarn
IFSelect_RemainForget = _IFSelect.IFSelect_RemainForget
IFSelect_RemainCompute = _IFSelect.IFSelect_RemainCompute
IFSelect_RemainDisplay = _IFSelect.IFSelect_RemainDisplay
IFSelect_RemainUndo = _IFSelect.IFSelect_RemainUndo
class IFSelect_GeneralModifier(Standard.Standard_Transient):
    """
    This class gives a frame for Actions which modify the effect
    of a Dispatch, i.e. :
    By Selections and Dispatches, an original Model can be
    splitted into one or more "target" Models : these Models
    contain Entities copied from the original one (that is, a
    part of it). Basically, these dispatched Entities are copied
    as identical to their original counterparts. Also the copied
    Models reproduce the Header of the original one.

    Modifiers allow to change this copied content : this is the
    way to be used for any kind of alterations, adaptations ...
    They are exploited by a ModelCopier, which firstly performs
    the copy operation described by Dispatches, then invokes the
    Modifiers to work on the result.

    Each GeneralModifier can be attached to :
    - all the Models produced
    - a Dispatch (it will be applied to all the Models obtained
    from this Dispatch) designated by its Ident in a ShareOut
    - in addition, to a Selection (facultative) : this adds a
    criterium, the Modifier is invoked on a produced Model only
    if this Model contains an Entity copied from one of the
    Entities designated by this Selection.
    (for special Modifiers from IFAdapt, while they must work on
    definite Entities, this Selection is mandatory to run)

    Remark : this class has no action attached, it only provides
    a frame to work on criteria. Then, sub-classes will define
    their kind of action, which can be applied at a precise step
    of the production of a File : see Modifier, and in the
    package IFAdapt, EntityModifier and EntityCopier
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_GeneralModifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_GeneralModifier(self) 
            return h


    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(IFSelect_GeneralModifier self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_GeneralModifier_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(IFSelect_GeneralModifier self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.IFSelect_GeneralModifier_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(IFSelect_GeneralModifier self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.IFSelect_GeneralModifier_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(IFSelect_GeneralModifier self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_GeneralModifier_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(IFSelect_GeneralModifier self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_GeneralModifier_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(IFSelect_GeneralModifier self)

        Resets the Selection : this criterium is not longer active


        """
        return _IFSelect.IFSelect_GeneralModifier_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(IFSelect_GeneralModifier self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_GeneralModifier_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(IFSelect_GeneralModifier self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_GeneralModifier_Selection(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_GeneralModifier self) -> TCollection_AsciiString

        Returns a short text which defines the operation performed

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_GeneralModifier_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_GeneralModifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_GeneralModifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_GeneralModifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_GeneralModifier
IFSelect_GeneralModifier_swigregister = _IFSelect.IFSelect_GeneralModifier_swigregister
IFSelect_GeneralModifier_swigregister(IFSelect_GeneralModifier)

def IFSelect_GeneralModifier_get_type_name(*args):
    """
    IFSelect_GeneralModifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_GeneralModifier_get_type_name(*args)

def IFSelect_GeneralModifier_get_type_descriptor(*args):
    """
    IFSelect_GeneralModifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_GeneralModifier_get_type_descriptor(*args)

class IFSelect_Selection(Standard.Standard_Transient):
    """
    A Selection allows to define a set of Interface Entities.
    Entities to be put on an output file should be identified in
    a way as independant from such or such execution as possible.
    This permits to handle comprehensive criteria, and to replay
    them when a new variant of an input file has to be processed.

    Its input can be, either an Interface Model (the very source),
    or another-other Selection(s) or any other ouput. All list
    computations start from an input Graph (from IFGraph)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Selection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Selection(self) 
            return h


    def RootResult(self, *args):
        """
        RootResult(IFSelect_Selection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, computed from Input
        given as a Graph. Specific to each class of Selection
        Note that uniqueness of each entity is not required here
        This method can raise an exception as necessary

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Selection_RootResult(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(IFSelect_Selection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Selection_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(IFSelect_Selection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Selection_CompleteResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(IFSelect_Selection self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        (there can be zero, or one, or a list).
        Specific to each class of Selection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_Selection_FillIterator(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_Selection self) -> TCollection_AsciiString

        Returns a text which defines the criterium applied by a
        Selection (can be used to be printed, displayed ...)
        Specific to each class

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Selection_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Selection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Selection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Selection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Selection
IFSelect_Selection_swigregister = _IFSelect.IFSelect_Selection_swigregister
IFSelect_Selection_swigregister(IFSelect_Selection)

def IFSelect_Selection_get_type_name(*args):
    """
    IFSelect_Selection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Selection_get_type_name(*args)

def IFSelect_Selection_get_type_descriptor(*args):
    """
    IFSelect_Selection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Selection_get_type_descriptor(*args)

class IFSelect_SelectDeduct(IFSelect_Selection):
    """
    A SelectDeduct determines a list of Entities from an Input
    Selection, by a computation : Output list is not obliged to be
    a sub-list of Input list
    (for more specific, see SelectExtract for filtered sub-lists,
    and SelectExplore for recurcive exploration)

    A SelectDeduct may use an alternate input for one shot
    This allows to use an already existing definition, by
    overloading the input selection by an alternate list,
    already defined, for one use :
    If this alternate list is set, InputResult queries it instead
    of calling the input selection, then clears it immediately
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectDeduct
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectDeduct(self) 
            return h


    def SetInput(self, *args):
        """
        SetInput(IFSelect_SelectDeduct self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectDeduct_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(IFSelect_SelectDeduct self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectDeduct_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(IFSelect_SelectDeduct self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectDeduct_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(IFSelect_SelectDeduct self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectDeduct_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(IFSelect_SelectDeduct self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.IFSelect_SelectDeduct_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(IFSelect_SelectDeduct self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectDeduct_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(IFSelect_SelectDeduct self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_SelectDeduct_FillIterator(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectDeduct_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectDeduct_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectDeduct_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectDeduct
IFSelect_SelectDeduct_swigregister = _IFSelect.IFSelect_SelectDeduct_swigregister
IFSelect_SelectDeduct_swigregister(IFSelect_SelectDeduct)

def IFSelect_SelectDeduct_get_type_name(*args):
    """
    IFSelect_SelectDeduct_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectDeduct_get_type_name(*args)

def IFSelect_SelectDeduct_get_type_descriptor(*args):
    """
    IFSelect_SelectDeduct_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectDeduct_get_type_descriptor(*args)

class IFSelect_SignatureList(Standard.Standard_Transient):
    """
    A SignatureList is given as result from a Counter (any kind)
    It gives access to a list of signatures, with counts, and
    optionally with list of corresponding entities

    It can also be used only to give a signature, through SignOnly
    Mode. This can be useful for a specific counter (used in a
    Selection), while it remains better to use a Signature
    whenever possible
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignatureList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignatureList(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignatureList self, Standard_Boolean const withlist) -> IFSelect_SignatureList

        Creates a SignatureList. If <withlist> is True, entities will
        be not only counted per signature, but also listed.

        :type withlist: bool

        """
        this = _IFSelect.new_IFSelect_SignatureList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetList(self, *args):
        """
        SetList(IFSelect_SignatureList self, Standard_Boolean const withlist)

        Changes the record-list status. The list is not cleared but
        its use changes

        :type withlist: bool

        """
        return _IFSelect.IFSelect_SignatureList_SetList(self, *args)


    def ModeSignOnly(self, *args):
        """
        ModeSignOnly(IFSelect_SignatureList self) -> Standard_Boolean &

        Returns modifiable the SignOnly Mode
        If False (D), the counter normally counts
        If True, the counting work is turned off, Add only fills the
        LastValue, which can be used as signature, when a counter
        works from data which are not available from a Signature

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SignatureList_ModeSignOnly(self, *args)


    def Clear(self, *args):
        """Clear(IFSelect_SignatureList self)"""
        return _IFSelect.IFSelect_SignatureList_Clear(self, *args)


    def Add(self, *args):
        """
        Add(IFSelect_SignatureList self, Handle_Standard_Transient ent, Standard_CString const sign)

        Adds an entity with its signature, i.e. :
        - counts an item more for <sign>
        - if record-list status is set, records the entity
        Accepts a null entity (the signature is then for the global
        model). But if the string is empty, counts a Null item.

        If SignOnly Mode is set, this work is replaced by just
        setting LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sign: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignatureList_Add(self, *args)


    def LastValue(self, *args):
        """
        LastValue(IFSelect_SignatureList self) -> Standard_CString

        Returns the last value recorded by Add (only if SignMode set)
        Cleared by Clear or Init

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignatureList_LastValue(self, *args)


    def Init(self, *args):
        """
        Init(IFSelect_SignatureList self, Standard_CString const name, NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer > const & count, NCollection_IndexedDataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & list, Standard_Integer const nbnuls)

        Aknowledges the list in once. Name identifies the Signature

        :type name: OCC.wrapper.Standard.Standard_CString
        :type count: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer
        :type list: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Handle_Standard_Transient
        :type nbnuls: int

        """
        return _IFSelect.IFSelect_SignatureList_Init(self, *args)


    def List(self, *args):
        """
        List(IFSelect_SignatureList self, Standard_CString const root) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of signatures, as a sequence of strings
        (but without their respective counts). It is ordered.
        By default, for all the signatures.
        If <root> is given non empty, for the signatures which
        begin by <root>

        :type root: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_SignatureList_List(self, *args)


    def HasEntities(self, *args):
        """
        HasEntities(IFSelect_SignatureList self) -> Standard_Boolean

        Returns True if the list of Entities is aknowledged, else
        the method Entities will always return a Null Handle

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SignatureList_HasEntities(self, *args)


    def NbNulls(self, *args):
        """
        NbNulls(IFSelect_SignatureList self) -> Standard_Integer

        Returns the count of null entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SignatureList_NbNulls(self, *args)


    def NbTimes(self, *args):
        """
        NbTimes(IFSelect_SignatureList self, Standard_CString const sign) -> Standard_Integer

        Returns the number of times a signature was counted,
        0 if it has not been recorded at all

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SignatureList_NbTimes(self, *args)


    def Entities(self, *args):
        """
        Entities(IFSelect_SignatureList self, Standard_CString const sign) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities attached to a signature
        It is empty if <sign> has not been recorded
        It is a Null Handle if the list of entities is not known

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_SignatureList_Entities(self, *args)


    def SetName(self, *args):
        """
        SetName(IFSelect_SignatureList self, Standard_CString const name)

        Defines a name for a SignatureList (used to print it)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignatureList_SetName(self, *args)


    def Name(self, *args):
        """
        Name(IFSelect_SignatureList self) -> Standard_CString

        Returns the recorded Name.
        Remark : default is "..." (no SetName called)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignatureList_Name(self, *args)


    def PrintCount(self, *args):
        """
        PrintCount(IFSelect_SignatureList self, Handle_Message_Messenger S)

        Prints the counts of items (not the list)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_SignatureList_PrintCount(self, *args)


    def PrintList(self, *args):
        """
        PrintList(IFSelect_SignatureList self, Handle_Message_Messenger S, Handle_Interface_InterfaceModel model, IFSelect_PrintCount const mod=IFSelect_ListByItem)

        Prints the lists of items, if they are present (else, prints
        a message "no list available")
        Uses <model> to determine for each entity to be listed, its
        number, and its specific identifier (by PrintLabel)
        <mod> gives a mode for printing :
        - CountByItem : just count (as PrintCount)
        - ShortByItem : minimum i.e. count plus 5 first entity numbers
        - ShortByItem(D) complete list of entity numbers (0: "Global")
        - EntitiesByItem : list of (entity number/PrintLabel from the model)
        other modes are ignored

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type mod: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.IFSelect_SignatureList_PrintList(self, *args)


    def PrintSum(self, *args):
        """
        PrintSum(IFSelect_SignatureList self, Handle_Message_Messenger S)

        Prints a summary
        Item which has the greatest count of entities
        For items which are numeric values : their count, maximum,
        minimum values, cumul, average

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_SignatureList_PrintSum(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignatureList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignatureList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignatureList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignatureList
IFSelect_SignatureList_swigregister = _IFSelect.IFSelect_SignatureList_swigregister
IFSelect_SignatureList_swigregister(IFSelect_SignatureList)

def IFSelect_SignatureList_get_type_name(*args):
    """
    IFSelect_SignatureList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignatureList_get_type_name(*args)

def IFSelect_SignatureList_get_type_descriptor(*args):
    """
    IFSelect_SignatureList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignatureList_get_type_descriptor(*args)

class IFSelect_Modifier(IFSelect_GeneralModifier):
    """
    This class gives a frame for Actions which can work globally
    on a File once completely defined (i.e. afterwards)

    Remark : if no Selection is set as criterium, the Modifier is
    set to work and should consider all the content of the Model
    produced.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Modifier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Modifier(self) 
            return h


    def Perform(self, *args):
        """
        Perform(IFSelect_Modifier self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        This deferred method defines the action specific to each class
        of Modifier. It is called by a ModelCopier, once the Model
        generated and filled. ModelCopier has already checked the
        criteria (Dispatch, Model Rank, Selection) before calling it.

        <ctx> detains informations about original data and selection.
        The result of copying, on which modifications are to be done,
        is <target>.
        <TC> allows to run additional copies as required

        In case of Error, use methods CCheck from the ContextModif
        to aknowledge an entity Check or a Global Check with messages

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _IFSelect.IFSelect_Modifier_Perform(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Modifier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Modifier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Modifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Modifier
IFSelect_Modifier_swigregister = _IFSelect.IFSelect_Modifier_swigregister
IFSelect_Modifier_swigregister(IFSelect_Modifier)

def IFSelect_Modifier_get_type_name(*args):
    """
    IFSelect_Modifier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Modifier_get_type_name(*args)

def IFSelect_Modifier_get_type_descriptor(*args):
    """
    IFSelect_Modifier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Modifier_get_type_descriptor(*args)

class IFSelect_SelectExtract(IFSelect_SelectDeduct):
    """
    A SelectExtract determines a list of Entities from an Input
    Selection, as a sub-list of the Input Result
    It works by applying a sort criterium on each Entity of the
    Input. This criterium can be applied Direct to Pick Items
    (default case) or Reverse to Remove Item

    Basic features (the unique Input) are inherited from SelectDeduct
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectExtract
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectExtract(self) 
            return h


    def IsDirect(self, *args):
        """
        IsDirect(IFSelect_SelectExtract self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectExtract_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(IFSelect_SelectExtract self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.IFSelect_SelectExtract_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectExtract self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectExtract_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectExtract self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity if it satisfies the Sort criterium
        It receives :
        - <rank>, the rank of the Entity in the Iteration,
        - <ent> , the Entity itself, and
        - <model>, the Starting Model
        Hence, the Entity to check is "model->Value(num)" (but an
        InterfaceModel allows other checks)
        This method is specific to each class of SelectExtract

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectExtract_Sort(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(IFSelect_SelectExtract self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectExtract_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectExtract self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectExtract_Label(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectExtract self) -> TCollection_AsciiString

        Returns a text defining the criterium for extraction

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectExtract_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectExtract_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectExtract_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectExtract_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectExtract
IFSelect_SelectExtract_swigregister = _IFSelect.IFSelect_SelectExtract_swigregister
IFSelect_SelectExtract_swigregister(IFSelect_SelectExtract)

def IFSelect_SelectExtract_get_type_name(*args):
    """
    IFSelect_SelectExtract_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectExtract_get_type_name(*args)

def IFSelect_SelectExtract_get_type_descriptor(*args):
    """
    IFSelect_SelectExtract_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectExtract_get_type_descriptor(*args)

class IFSelect_Dispatch(Standard.Standard_Transient):
    """
    This class allows to describe how a set of Entities has to be
    dispatched into resulting Packets : a Packet is a sub-set of
    the initial set of entities.

    Thus, it can generate zero, one, or more Packets according
    input set and criterium of dispatching. And it can let apart
    some entities : it is the Remainder, which can be recovered
    by a specific Selection (RemainderFromDispatch).

    Depending of sub-classes, a Dispatch can potentially generate
    a limited or not count of packet, and a remainder or none.

    The input set is read from a specified Selection, attached to
    the Dispatch : the Final Selection of the Dispatch. The input
    is the Unique Root Entities list of the Final Selection
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Dispatch
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Dispatch(self) 
            return h


    def SetRootName(self, *args):
        """
        SetRootName(IFSelect_Dispatch self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_Dispatch_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(IFSelect_Dispatch self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Dispatch_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.IFSelect_Dispatch_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(IFSelect_Dispatch self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_Dispatch_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(IFSelect_Dispatch self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_Dispatch_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(IFSelect_Dispatch self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_Dispatch_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(IFSelect_Dispatch self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Dispatch_CanHaveRemainder(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(IFSelect_Dispatch self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True if a Dispatch generates a count of Packets always
        less than or equal to a maximum value : it can be computed
        from the total count of Entities to be dispatched : <nbent>.
        If answer is False, no limited maximum is expected for account
        If answer is True, expected maximum is given in argument <max>
        Default answer given here is False (can be redefined)

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Dispatch_LimitedMax(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_Dispatch self) -> TCollection_AsciiString

        Returns a text which defines the way a Dispatch produces
        packets (which will become files) from its Input

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Dispatch_Label(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(IFSelect_Dispatch self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Dispatch_GetEntities(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_Dispatch self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Returns the list of produced Packets into argument <pack>.
        Each Packet corresponds to a Part, the Entities listed are the
        Roots given by the Selection. Input is given as a Graph.
        Thus, to create a file from a packet, it suffices to take the
        entities listed in a Part of Packets (that is, a Packet)
        without worrying about Shared entities
        This method can raise an Exception if data are not coherent

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.IFSelect_Dispatch_Packets(self, *args)


    def Packeted(self, *args):
        """
        Packeted(IFSelect_Dispatch self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Dispatch_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(IFSelect_Dispatch self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Dispatch_Remainder(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Dispatch_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Dispatch_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Dispatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Dispatch
IFSelect_Dispatch_swigregister = _IFSelect.IFSelect_Dispatch_swigregister
IFSelect_Dispatch_swigregister(IFSelect_Dispatch)

def IFSelect_Dispatch_get_type_name(*args):
    """
    IFSelect_Dispatch_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Dispatch_get_type_name(*args)

def IFSelect_Dispatch_get_type_descriptor(*args):
    """
    IFSelect_Dispatch_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Dispatch_get_type_descriptor(*args)

class IFSelect_SelectAnyList(IFSelect_SelectDeduct):
    """
    A SelectAnyList kind Selection selects a List of an Entity, as
    well as this Entity contains some. A List contains sub-entities
    as one per Item, or several (for instance if an Entity binds
    couples of sub-entities, each item is one of these couples).
    Remark that only Entities are taken into account (neither
    Reals, nor Strings, etc...)

    To define the list on which to work, SelectAnyList has two
    deferred methods : NbItems (which gives the length of the
    list), FillResult (which fills an EntityIterator). They are
    intended to get a List in an Entity of the required Type (and
    consider that list is empty if Entity has not required Type)

    In addition, remark that some types of Entity define more than
    one list in each instance : a given sub-class of SelectAnyList
    must be attached to one list

    SelectAnyList keeps or rejects a sub-set of the list,
    that is the Items of which rank in the list is in a given
    range (for instance form 2nd to 6th, etc...)
    Range is defined by two Integer values. In order to allow
    external control of them, these values are not directly
    defined as fields, but accessed through IntParams, that is,
    referenced as Transient (Handle) objects

    Warning : the Input can be any kind of Selection, BUT its
    RootResult must have zero (empty) or one Entity maximum
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectAnyList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectAnyList(self) 
            return h


    def KeepInputEntity(self, *args):
        """
        KeepInputEntity(IFSelect_SelectAnyList self, Interface_EntityIterator iter)

        Keeps Input Entity, as having required type. It works by
        keeping in <iter>, only suitable Entities (SelectType can be
        used). Called by RootResult (which waits for ONE ENTITY MAX)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectAnyList_KeepInputEntity(self, *args)


    def NbItems(self, *args):
        """
        NbItems(IFSelect_SelectAnyList self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns count of Items in the list in the Entity <ent>
        If <ent> has not required type, returned value must be Zero

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectAnyList_NbItems(self, *args)


    def SetRange(self, *args):
        """
        SetRange(IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rankfrom, Handle_IFSelect_IntParam rankto)

        Sets a Range for numbers, with a lower and a upper limits

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectAnyList_SetRange(self, *args)


    def SetOne(self, *args):
        """
        SetOne(IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rank)

        Sets a unique number (only one Entity will be sorted as True)

        :type rank: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectAnyList_SetOne(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rankfrom)

        Sets a Lower limit but no upper limit

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectAnyList_SetFrom(self, *args)


    def SetUntil(self, *args):
        """
        SetUntil(IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rankto)

        Sets an Upper limit but no lower limit (equivalent to lower 1)

        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectAnyList_SetUntil(self, *args)


    def HasLower(self, *args):
        """
        HasLower(IFSelect_SelectAnyList self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectAnyList_HasLower(self, *args)


    def Lower(self, *args):
        """
        Lower(IFSelect_SelectAnyList self) -> Handle_IFSelect_IntParam

        Returns Lower limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectAnyList_Lower(self, *args)


    def LowerValue(self, *args):
        """
        LowerValue(IFSelect_SelectAnyList self) -> Standard_Integer

        Returns Integer Value of Lower Limit (0 if none)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectAnyList_LowerValue(self, *args)


    def HasUpper(self, *args):
        """
        HasUpper(IFSelect_SelectAnyList self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectAnyList_HasUpper(self, *args)


    def Upper(self, *args):
        """
        Upper(IFSelect_SelectAnyList self) -> Handle_IFSelect_IntParam

        Returns Upper limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectAnyList_Upper(self, *args)


    def UpperValue(self, *args):
        """
        UpperValue(IFSelect_SelectAnyList self) -> Standard_Integer

        Returns Integer Value of Upper Limit (0 if none)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectAnyList_UpperValue(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectAnyList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        complying with rank criterium)
        Error if the input list has more than one Item

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectAnyList_RootResult(self, *args)


    def FillResult(self, *args):
        """
        FillResult(IFSelect_SelectAnyList self, Standard_Integer const n1, Standard_Integer const n2, Handle_Standard_Transient ent, Interface_EntityIterator res)

        Puts into <res>, the sub-entities of the list, from n1 to
        n2 included. Remark that adequation with Entity's type and
        length of list has already been made at this stage
        Called by RootResult

        :type n1: int
        :type n2: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectAnyList_FillResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectAnyList self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Componants of List "
        then Specific List Label, then, following cases :
        " From .. Until .." or "From .." or "Until .." or "Rank no .."
        Specific type is given by deferred method ListLabel

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectAnyList_Label(self, *args)


    def ListLabel(self, *args):
        """
        ListLabel(IFSelect_SelectAnyList self) -> TCollection_AsciiString

        Returns the specific label for the list, which is included as
        a part of Label

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectAnyList_ListLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectAnyList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectAnyList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectAnyList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectAnyList
IFSelect_SelectAnyList_swigregister = _IFSelect.IFSelect_SelectAnyList_swigregister
IFSelect_SelectAnyList_swigregister(IFSelect_SelectAnyList)

def IFSelect_SelectAnyList_get_type_name(*args):
    """
    IFSelect_SelectAnyList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectAnyList_get_type_name(*args)

def IFSelect_SelectAnyList_get_type_descriptor(*args):
    """
    IFSelect_SelectAnyList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectAnyList_get_type_descriptor(*args)

class IFSelect_SelectBase(IFSelect_Selection):
    """
    SelectBase works directly from an InterfaceModel : it is the
    first base for other Selections.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectBase
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectBase(self) 
            return h


    def FillIterator(self, *args):
        """
        FillIterator(IFSelect_SelectBase self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list is empty for all SelectBase type Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_SelectBase_FillIterator(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectBase_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectBase_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectBase_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectBase
IFSelect_SelectBase_swigregister = _IFSelect.IFSelect_SelectBase_swigregister
IFSelect_SelectBase_swigregister(IFSelect_SelectBase)

def IFSelect_SelectBase_get_type_name(*args):
    """
    IFSelect_SelectBase_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectBase_get_type_name(*args)

def IFSelect_SelectBase_get_type_descriptor(*args):
    """
    IFSelect_SelectBase_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectBase_get_type_descriptor(*args)

class IFSelect_Activator(Standard.Standard_Transient):
    """
    Defines the general frame for working with a SessionPilot.
    Each Activator treats a set of Commands. Commands are given as
    alphanumeric strings. They can be of two main forms :
    - classic, to list, evaluate, enrich the session (by itself) :
    no specific remark, its complete execution must be described
    - creation of a new item : instead of creatinf it plus adding
    it to the session (which is a classic way), it is possible
    to create it and make it recorded by the SessionPilot :
    then, the Pilot will add it to the session; this way allows
    the Pilot to manage itself named items

    In order to make easier the use of Activator, this class
    provides a simple way to Select an Actor for a Command :
    each sub-class of SectionActor defines the command titles it
    recognizes, plus attaches a Number, unique for this sub-class,
    to each distinct command title.

    Each time an action is required, the corresponding Number
    can then be given to help the selection of the action to do.

    The result of an Execution must indicate if it is worth to be
    recorded or not : see method Do
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Activator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Activator(self) 
            return h


    def Adding(*args):
        """
        Adding(Handle_IFSelect_Activator actor, Standard_Integer const number, Standard_CString const command, Standard_Integer const mode)

        Records, in a Dictionary available for all the Activators,
        the command title an Activator can process, attached with
        its number, proper for this Activator
        <mode> allows to distinguish various execution modes
        0: default mode; 1 : for xset

        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :type mode: int

        """
        return _IFSelect.IFSelect_Activator_Adding(*args)

    Adding = staticmethod(Adding)

    def Add(self, *args):
        """
        Add(IFSelect_Activator self, Standard_Integer const number, Standard_CString const command)

        Allows a self-definition by an Activator of the Commands it
        processes, call the class method Adding (mode 0)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_Add(self, *args)


    def AddSet(self, *args):
        """
        AddSet(IFSelect_Activator self, Standard_Integer const number, Standard_CString const command)

        Same as Add but specifies that this command is candidate for
        xset (creation of items, xset : named items; mode 1)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_AddSet(self, *args)


    def Remove(*args):
        """
        Remove(Standard_CString const command)

        Removes a Command, if it is recorded (else, does nothing)

        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_Remove(*args)

    Remove = staticmethod(Remove)

    def Select(*args):
        """
        Select(Standard_CString const command, Handle_IFSelect_Activator actor) -> Standard_Boolean

        Selects, for a Command given by its title, an actor with its
        command number. Returns True if found, False else

        :type command: OCC.wrapper.Standard.Standard_CString
        :type number: int
        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Activator_Select(*args)

    Select = staticmethod(Select)

    def Mode(*args):
        """
        Mode(Standard_CString const command) -> Standard_Integer

        Returns mode recorded for a command. -1 if not found

        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_Activator_Mode(*args)

    Mode = staticmethod(Mode)

    def Commands(*args):
        """
        Commands(Standard_Integer const mode=-1, Standard_CString const command) -> Handle_TColStd_HSequenceOfAsciiString

        Returns, for a root of command title, the list of possible
        commands.
        <mode> : -1 (D) for all commands if <commands> is empty
        -1 + command : about a Group , >= 0 see Adding
        By default, it returns the whole list of known commands.

        :type mode: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.IFSelect_Activator_Commands(*args)

    Commands = staticmethod(Commands)

    def Do(self, *args):
        """
        Do(IFSelect_Activator self, Standard_Integer const number, Handle_IFSelect_SessionPilot pilot) -> IFSelect_ReturnStatus

        Tries to execute a Command Line. <number> is the number of the
        command for this Activator. It Must forecast to record the
        result of the execution, for need of Undo-Redo
        Must Returns : 0 for a void command (not to be recorded),
        1 if execution OK, -1 if command incorrect, -2 if error
        on execution

        :type number: int
        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_Activator_Do(self, *args)


    def Help(self, *args):
        """
        Help(IFSelect_Activator self, Standard_Integer const number) -> Standard_CString

        Sends a short help message for a given command identified by
        it number for this Activator (must take one line max)

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_Help(self, *args)


    def Group(self, *args):
        """
        Group(IFSelect_Activator self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_Group(self, *args)


    def File(self, *args):
        """
        File(IFSelect_Activator self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_File(self, *args)


    def SetForGroup(self, *args):
        """
        SetForGroup(IFSelect_Activator self, Standard_CString const group, Standard_CString const file)

        Group and SetGroup define a "Group of commands" which
        correspond to an Activator. Default is "XSTEP"
        Also a file may be attached

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Activator_SetForGroup(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Activator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Activator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Activator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Activator
IFSelect_Activator_swigregister = _IFSelect.IFSelect_Activator_swigregister
IFSelect_Activator_swigregister(IFSelect_Activator)

def IFSelect_Activator_Adding(*args):
    """
    IFSelect_Activator_Adding(Handle_IFSelect_Activator actor, Standard_Integer const number, Standard_CString const command, Standard_Integer const mode)

    Records, in a Dictionary available for all the Activators,
    the command title an Activator can process, attached with
    its number, proper for this Activator
    <mode> allows to distinguish various execution modes
    0: default mode; 1 : for xset

    :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
    :type number: int
    :type command: OCC.wrapper.Standard.Standard_CString
    :type mode: int

    """
    return _IFSelect.IFSelect_Activator_Adding(*args)

def IFSelect_Activator_Remove(*args):
    """
    IFSelect_Activator_Remove(Standard_CString const command)

    Removes a Command, if it is recorded (else, does nothing)

    :type command: OCC.wrapper.Standard.Standard_CString

    """
    return _IFSelect.IFSelect_Activator_Remove(*args)

def IFSelect_Activator_Select(*args):
    """
    IFSelect_Activator_Select(Standard_CString const command, Handle_IFSelect_Activator actor) -> Standard_Boolean

    Selects, for a Command given by its title, an actor with its
    command number. Returns True if found, False else

    :type command: OCC.wrapper.Standard.Standard_CString
    :type number: int
    :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IFSelect.IFSelect_Activator_Select(*args)

def IFSelect_Activator_Mode(*args):
    """
    IFSelect_Activator_Mode(Standard_CString const command) -> Standard_Integer

    Returns mode recorded for a command. -1 if not found

    :type command: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IFSelect.IFSelect_Activator_Mode(*args)

def IFSelect_Activator_Commands(*args):
    """
    IFSelect_Activator_Commands(Standard_Integer const mode=-1, Standard_CString const command) -> Handle_TColStd_HSequenceOfAsciiString

    Returns, for a root of command title, the list of possible
    commands.
    <mode> : -1 (D) for all commands if <commands> is empty
    -1 + command : about a Group , >= 0 see Adding
    By default, it returns the whole list of known commands.

    :type mode: int
    :type command: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

    """
    return _IFSelect.IFSelect_Activator_Commands(*args)

def IFSelect_Activator_get_type_name(*args):
    """
    IFSelect_Activator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Activator_get_type_name(*args)

def IFSelect_Activator_get_type_descriptor(*args):
    """
    IFSelect_Activator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Activator_get_type_descriptor(*args)

class IFSelect_ModifReorder(IFSelect_Modifier):
    """
    This modifier reorders a whole model from its roots, i.e.
    according to <rootlast> status, it considers each of its
    roots, then it orders all its shared entities at any level,
    the result begins by the lower level entities ... ends by
    the roots.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_ModifReorder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_ModifReorder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_ModifReorder self, Standard_Boolean const rootlast) -> IFSelect_ModifReorder

        Creates a ModifReorder. It may change the graph (it does !)
        If <rootlast> is True (D), roots are set at the end of packets
        Else, they are set at beginning (as done by AddWithRefs)

        :type rootlast: bool

        """
        this = _IFSelect.new_IFSelect_ModifReorder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(IFSelect_ModifReorder self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        Acts by computing orders (by method All from ShareTool) then
        forcing them in the model. Remark that selection is ignored :
        ALL the model is processed in once

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _IFSelect.IFSelect_ModifReorder_Perform(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_ModifReorder self) -> TCollection_AsciiString

        Returns Label as "Reorder, Roots (last or first)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ModifReorder_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_ModifReorder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_ModifReorder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_ModifReorder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_ModifReorder
IFSelect_ModifReorder_swigregister = _IFSelect.IFSelect_ModifReorder_swigregister
IFSelect_ModifReorder_swigregister(IFSelect_ModifReorder)

def IFSelect_ModifReorder_get_type_name(*args):
    """
    IFSelect_ModifReorder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_ModifReorder_get_type_name(*args)

def IFSelect_ModifReorder_get_type_descriptor(*args):
    """
    IFSelect_ModifReorder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_ModifReorder_get_type_descriptor(*args)

class IFSelect_SignCounter(IFSelect_SignatureList):
    """
    SignCounter gives the frame to count signatures associated
    with entities, deducted from them. Ex.: their Dynamic Type.

    It can sort a set of Entities according a signature, i.e. :
    - list of different values found for this Signature
    - for each one, count and list of entities
    Results are returned as a SignatureList, which can be queried
    on the count (list of strings, count per signature, or list of
    entities per signature)

    A SignCounter can be filled, either directly from lists, or
    from the result of a Selection : hence, its content can be
    automatically recomputed as desired

    SignCounter works by using a Signature in its method AddSign

    Methods can be redefined to, either
    - directly compute the value without a Signature
    - compute the value in the context of a Graph
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignCounter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignCounter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignCounter self, Standard_Boolean const withmap, Standard_Boolean const withlist) -> IFSelect_SignCounter
        __init__(IFSelect_SignCounter self, Handle_IFSelect_Signature matcher, Standard_Boolean const withmap, Standard_Boolean const withlist) -> IFSelect_SignCounter

        Creates a SignCounter, with a predefined Signature
        Other arguments as for Create without Signature.

        :type matcher: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type withmap: bool
        :type withlist: bool

        """
        this = _IFSelect.new_IFSelect_SignCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Signature(self, *args):
        """
        Signature(IFSelect_SignCounter self) -> Handle_IFSelect_Signature

        Returns the Signature used to count entities. It can be null.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_SignCounter_Signature(self, *args)


    def SetMap(self, *args):
        """
        SetMap(IFSelect_SignCounter self, Standard_Boolean const withmap)

        Changes the control status. The map is not cleared, simply
        its use changes

        :type withmap: bool

        """
        return _IFSelect.IFSelect_SignCounter_SetMap(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(IFSelect_SignCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Adds an entity by considering its signature, which is given by
        call to method AddSign
        Returns True if added, False if already in the map (and
        map control status set)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SignCounter_AddEntity(self, *args)


    def AddSign(self, *args):
        """
        AddSign(IFSelect_SignCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model)

        Adds an entity (already filtered by Map) with its signature.
        This signature can be computed with the containing model.
        Its value is provided by the object Signature given at start,
        if no Signature is defined, it does nothing.

        Can be redefined (in this case, see also Sign)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_SignCounter_AddSign(self, *args)


    def AddList(self, *args):
        """
        AddList(IFSelect_SignCounter self, Handle_TColStd_HSequenceOfTransient list, Handle_Interface_InterfaceModel model)

        Adds a list of entities by adding each of the items

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_SignCounter_AddList(self, *args)


    def AddWithGraph(self, *args):
        """
        AddWithGraph(IFSelect_SignCounter self, Handle_TColStd_HSequenceOfTransient list, Interface_Graph graph)

        Adds a list of entities in the context given by the graph
        Default just call basic AddList
        Can be redefined to get a signature computed with the graph

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type graph: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.IFSelect_SignCounter_AddWithGraph(self, *args)


    def AddModel(self, *args):
        """
        AddModel(IFSelect_SignCounter self, Handle_Interface_InterfaceModel model)

        Adds all the entities contained in a Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_SignCounter_AddModel(self, *args)


    def AddFromSelection(self, *args):
        """
        AddFromSelection(IFSelect_SignCounter self, Handle_IFSelect_Selection sel, Interface_Graph G)

        Adds the result determined by a Selection from a Graph
        Remark : does not impact at all data from SetSelection & Co

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type G: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.IFSelect_SignCounter_AddFromSelection(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(IFSelect_SignCounter self, Handle_IFSelect_Selection sel)

        Sets a Selection as input : this causes content to be cleared
        then the Selection to be ready to compute (but not immediatly)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SignCounter_SetSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(IFSelect_SignCounter self) -> Handle_IFSelect_Selection

        Returns the selection, or a null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SignCounter_Selection(self, *args)


    def SetSelMode(self, *args):
        """
        SetSelMode(IFSelect_SignCounter self, Standard_Integer const selmode)

        Changes the mode of working with the selection :
        -1 just clears optimisation data and nothing else
        0 clears it   1 inhibits it for computing (but no clearing)
        2 sets it active for computing
        Default at creation is 0, after SetSelection (not null) is 2

        :type selmode: int

        """
        return _IFSelect.IFSelect_SignCounter_SetSelMode(self, *args)


    def SelMode(self, *args):
        """
        SelMode(IFSelect_SignCounter self) -> Standard_Integer

        Returns the mode of working with the selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SignCounter_SelMode(self, *args)


    def ComputeSelected(self, *args):
        """
        ComputeSelected(IFSelect_SignCounter self, Interface_Graph G, Standard_Boolean const forced) -> Standard_Boolean

        Computes from the selection result, if selection is active
        (mode 2). If selection is not defined (mode 0) or is inhibited
        (mode 1) does nothing.
        Returns True if computation is done (or optimised), False else
        This method is called by ComputeCounter from WorkSession

        If <forced> is True, recomputes systematically
        Else (D), if the counter was not cleared and if the former
        computed result started from the same total size of Graph and
        same count of selected entities : computation is not redone
        unless <forced> is given as True

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type forced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SignCounter_ComputeSelected(self, *args)


    def Sign(self, *args):
        """
        Sign(IFSelect_SignCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Handle_TCollection_HAsciiString

        Determines and returns the value of the signature for an
        entity as an HAsciiString. This method works exactly as
        AddSign, which is optimized

        Can be redefined, accorded with AddSign

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_SignCounter_Sign(self, *args)


    def ComputedSign(self, *args):
        """
        ComputedSign(IFSelect_SignCounter self, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_CString

        Applies AddWithGraph on one entity, and returns the Signature
        Value which has been recorded
        To do this, Add is called with SignOnly Mode True during the
        call, the returned value is LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignCounter_ComputedSign(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignCounter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignCounter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignCounter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignCounter
IFSelect_SignCounter_swigregister = _IFSelect.IFSelect_SignCounter_swigregister
IFSelect_SignCounter_swigregister(IFSelect_SignCounter)

def IFSelect_SignCounter_get_type_name(*args):
    """
    IFSelect_SignCounter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignCounter_get_type_name(*args)

def IFSelect_SignCounter_get_type_descriptor(*args):
    """
    IFSelect_SignCounter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignCounter_get_type_descriptor(*args)

class IFSelect_SelectCombine(IFSelect_Selection):
    """
    A SelectCombine type Selection defines algebraic operations
    between results of several Selections
    It is a deferred class : sub-classes will have to define
    precise what operator is to be applied
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectCombine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectCombine(self) 
            return h


    def NbInputs(self, *args):
        """
        NbInputs(IFSelect_SelectCombine self) -> Standard_Integer

        Returns the count of Input Selections

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectCombine_NbInputs(self, *args)


    def Input(self, *args):
        """
        Input(IFSelect_SelectCombine self, Standard_Integer const num) -> Handle_IFSelect_Selection

        Returns an Input Selection, given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectCombine_Input(self, *args)


    def InputRank(self, *args):
        """
        InputRank(IFSelect_SelectCombine self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the rank of an input Selection, 0 if not in the list.
        Most generally, its value is meaningless, except for testing
        the presence of an input Selection :
        - == 0  if <sel> is not an input for <me>
        - >  0  if <sel> is an input for <me>

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectCombine_InputRank(self, *args)


    def Add(self, *args):
        """
        Add(IFSelect_SelectCombine self, Handle_IFSelect_Selection sel, Standard_Integer const atnum=0)

        Adds a Selection to the filling list
        By default, adds it to the end of the list
        A Positive rank less then NbInputs gives an insertion rank
        (InsertBefore : the new <atnum>th item of the list is <sel>)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int

        """
        return _IFSelect.IFSelect_SelectCombine_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(IFSelect_SelectCombine self, Handle_IFSelect_Selection sel) -> Standard_Boolean
        Remove(IFSelect_SelectCombine self, Standard_Integer const num) -> Standard_Boolean

        Removes an input Selection, given its rank in the list
        Returns True if Done, False if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectCombine_Remove(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(IFSelect_SelectCombine self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_SelectCombine_FillIterator(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectCombine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectCombine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectCombine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectCombine
IFSelect_SelectCombine_swigregister = _IFSelect.IFSelect_SelectCombine_swigregister
IFSelect_SelectCombine_swigregister(IFSelect_SelectCombine)

def IFSelect_SelectCombine_get_type_name(*args):
    """
    IFSelect_SelectCombine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectCombine_get_type_name(*args)

def IFSelect_SelectCombine_get_type_descriptor(*args):
    """
    IFSelect_SelectCombine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectCombine_get_type_descriptor(*args)

class IFSelect_Editor(Standard.Standard_Transient):
    """
    An Editor defines a set of values and a way to edit them, on
    an entity or on the model (e.g. on its header)

    Each Value is controlled by a TypedValue, with a number (it is
    an Integer) and a name under two forms (complete and short)
    and an edit mode
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Editor
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Editor(self) 
            return h


    def SetValue(self, *args):
        """
        SetValue(IFSelect_Editor self, Standard_Integer const num, Handle_Interface_TypedValue typval, Standard_CString const shortname, IFSelect_EditValue const accessmode=IFSelect_Editable)

        Sets a Typed Value for a given ident and short name, with an
        Edit Mode

        :type num: int
        :type typval: OCC.wrapper.Interface.Handle_Interface_TypedValue
        :type shortname: OCC.wrapper.Standard.Standard_CString
        :type accessmode: OCC.wrapper.IFSelect.IFSelect_EditValue

        """
        return _IFSelect.IFSelect_Editor_SetValue(self, *args)


    def SetList(self, *args):
        """
        SetList(IFSelect_Editor self, Standard_Integer const num, Standard_Integer const max=0)

        Sets a parameter to be a List
        max < 0 : not for a list (set when starting)
        max = 0 : list with no length limit (default for SetList)
        max > 0 : list limited to <max> items

        :type num: int
        :type max: int

        """
        return _IFSelect.IFSelect_Editor_SetList(self, *args)


    def NbValues(self, *args):
        """
        NbValues(IFSelect_Editor self) -> Standard_Integer

        Returns the count of Typed Values

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_Editor_NbValues(self, *args)


    def TypedValue(self, *args):
        """
        TypedValue(IFSelect_Editor self, Standard_Integer const num) -> Handle_Interface_TypedValue

        Returns a Typed Value from its ident

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_TypedValue

        """
        return _IFSelect.IFSelect_Editor_TypedValue(self, *args)


    def IsList(self, *args):
        """
        IsList(IFSelect_Editor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a parameter is a list

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Editor_IsList(self, *args)


    def MaxList(self, *args):
        """
        MaxList(IFSelect_Editor self, Standard_Integer const num) -> Standard_Integer

        Returns max length allowed for a list
        = 0 means : list with no limit
        < 0 means : not a list

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_Editor_MaxList(self, *args)


    def Name(self, *args):
        """
        Name(IFSelect_Editor self, Standard_Integer const num, Standard_Boolean const isshort) -> Standard_CString

        Returns the name of a Value (complete or short) from its ident
        Short Name can be empty

        :type num: int
        :type isshort: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Editor_Name(self, *args)


    def EditMode(self, *args):
        """
        EditMode(IFSelect_Editor self, Standard_Integer const num) -> IFSelect_EditValue

        Returns the edit mode of a Value

        :type num: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_EditValue

        """
        return _IFSelect.IFSelect_Editor_EditMode(self, *args)


    def NameNumber(self, *args):
        """
        NameNumber(IFSelect_Editor self, Standard_CString const name) -> Standard_Integer

        Returns the number (ident) of a Value, from its name, short or
        complete. If not found, returns 0

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_Editor_NameNumber(self, *args)


    def PrintNames(self, *args):
        """
        PrintNames(IFSelect_Editor self, Handle_Message_Messenger S)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_Editor_PrintNames(self, *args)


    def PrintDefs(self, *args):
        """
        PrintDefs(IFSelect_Editor self, Handle_Message_Messenger S, Standard_Boolean const labels)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type labels: bool

        """
        return _IFSelect.IFSelect_Editor_PrintDefs(self, *args)


    def MaxNameLength(self, *args):
        """
        MaxNameLength(IFSelect_Editor self, Standard_Integer const what) -> Standard_Integer

        Returns the MaxLength of, according to what :
        <what> = -1 : length of short names
        <what> =  0 : length of complete names
        <what> =  1 : length of values labels

        :type what: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_Editor_MaxNameLength(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_Editor self) -> TCollection_AsciiString

        Returns the specific label

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Editor_Label(self, *args)


    def Form(self, *args):
        """
        Form(IFSelect_Editor self, Standard_Boolean const readonly, Standard_Boolean const undoable) -> Handle_IFSelect_EditForm

        Builds and Returns an EditForm, empty (no data yet)
        Can be redefined to return a specific type of EditForm

        :type readonly: bool
        :type undoable: bool
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm

        """
        return _IFSelect.IFSelect_Editor_Form(self, *args)


    def Recognize(self, *args):
        """
        Recognize(IFSelect_Editor self, Handle_IFSelect_EditForm form) -> Standard_Boolean

        Tells if this Editor can work on this EditForm and its content
        (model, entity ?)

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Editor_Recognize(self, *args)


    def StringValue(self, *args):
        """
        StringValue(IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns the value of an EditForm, for a given item
        (if not a list. for a list, a Null String may be returned)

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_Editor_StringValue(self, *args)


    def ListEditor(self, *args):
        """
        ListEditor(IFSelect_Editor self, Standard_Integer const num) -> Handle_IFSelect_ListEditor

        Returns a ListEditor for a parameter which is a List
        Default returns a basic ListEditor for a List, a Null Handle
        if <num> is not for a List. Can be redefined

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor

        """
        return _IFSelect.IFSelect_Editor_ListEditor(self, *args)


    def ListValue(self, *args):
        """
        ListValue(IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the value of an EditForm as a List, for a given item
        If not a list, a Null Handle should be returned
        Default returns a Null Handle, because many Editors have
        no list to edit. To be redefined as required

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_Editor_ListValue(self, *args)


    def Load(self, *args):
        """
        Load(IFSelect_Editor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Loads original values from some data, to an EditForm
        Remark: <ent> may be Null, this means all <model> is concerned
        Also <model> may be Null, if no context applies for <ent>
        And both <ent> and <model> may be Null, for a full static
        editor

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Editor_Load(self, *args)


    def Update(self, *args):
        """
        Update(IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num, Handle_TCollection_HAsciiString newval, Standard_Boolean const enforce) -> Standard_Boolean

        Updates the EditForm when a parameter is modified
        I.E.  default does nothing, can be redefined, as follows :
        Returns True when done (even if does nothing), False in case
        of refuse (for instance, if the new value is not suitable)
        <num> is the rank of the parameter for the EDITOR itself
        <enforce> True means that protected parameters can be touched

        If a parameter commands the value of other ones, when it is
        modified, it is necessary to touch them by Touch from EditForm

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Editor_Update(self, *args)


    def UpdateList(self, *args):
        """
        UpdateList(IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString newlist, Standard_Boolean const enforce) -> Standard_Boolean

        Acts as Update, but when the value is a list

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :type newlist: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Editor_UpdateList(self, *args)


    def Apply(self, *args):
        """
        Apply(IFSelect_Editor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Applies modified values of the EditForm with some data
        Remark: <ent> may be Null, this means all <model> is concerned
        Also <model> may be Null, if no context applies for <ent>
        And both <ent> and <model> may be Null, for a full static
        editor

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Editor_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Editor_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Editor_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Editor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Editor
IFSelect_Editor_swigregister = _IFSelect.IFSelect_Editor_swigregister
IFSelect_Editor_swigregister(IFSelect_Editor)

def IFSelect_Editor_get_type_name(*args):
    """
    IFSelect_Editor_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Editor_get_type_name(*args)

def IFSelect_Editor_get_type_descriptor(*args):
    """
    IFSelect_Editor_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Editor_get_type_descriptor(*args)

class IFSelect_Transformer(Standard.Standard_Transient):
    """
    A Transformer defines the way an InterfaceModel is transformed
    (without sending it to a file).
    In order to work, each type of Transformer defines it method
    Perform, it can be parametred as needed.

    It receives a Model (the data set) as input. It then can :
    - edit this Model on the spot (i.e. alter its content : by
    editing entities, or adding/replacing some ...)
    - produce a copied Model, which detains the needed changes
    (typically on the same type, but some or all entities beeing
    rebuilt or converted; or converted from a protocol to
    another one)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Transformer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Transformer(self) 
            return h


    def Perform(self, *args):
        """
        Perform(IFSelect_Transformer self, Interface_Graph G, Handle_Interface_Protocol protocol, Interface_CheckIterator checks, Handle_Interface_InterfaceModel newmod) -> Standard_Boolean

        Performs a Transformation (defined by each sub-class) :
        <G> gives the input data (especially the starting model) and
        can be used for queries (by Selections, etc...)
        <protocol> allows to work with General Services as necessary
        (it applies to input data)
        If the change corresponds to a conversion to a new protocol,
        see also the method ChangeProtocol
        <checks> stores produced checks messages if any
        <newmod> gives the result of the transformation :
        - if it is Null (i.e. has not been affected), the transformation
        has been made on the spot, it is assumed to cause no change
        to the graph of dependances
        - if it equates the starting Model, it has been transformed on
        the spot (possibiliy some entities were replaced inside it)
        - if it is new, it corresponds to a new data set which replaces
        the starting one

        <me> is mutable to allow results for ChangeProtocol to be
        memorized if needed, and to store informations useful for
        the method Updated

        Returns True if Done, False if an Error occured : in this case,
        if a new data set has been produced, the transformation
        is ignored, else data may be corrupted.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Transformer_Perform(self, *args)


    def ChangeProtocol(self, *args):
        """
        ChangeProtocol(IFSelect_Transformer self, Handle_Interface_Protocol newproto) -> Standard_Boolean

        This methods allows to declare that the Protocol applied to
        the new Model has changed. It applies to the last call to
        Perform.

        Returns True if the Protocol has changed, False else.
        The provided default keeps the starting Protocol. This method
        should be redefined as required by the effect of Perform.

        :type newproto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Transformer_ChangeProtocol(self, *args)


    def Updated(self, *args):
        """
        Updated(IFSelect_Transformer self, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto) -> Standard_Boolean

        This method allows to know what happened to a starting
        entity after the last Perform. If <entfrom> (from starting
        model) has one and only one known item which corresponds in
        the new produced model, this method must return True and
        fill the argument <entto>. Else, it returns False.

        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Transformer_Updated(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_Transformer self) -> TCollection_AsciiString

        Returns a text which defines the way a Transformer works
        (to identify the transformation it performs)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Transformer_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Transformer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Transformer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Transformer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Transformer
IFSelect_Transformer_swigregister = _IFSelect.IFSelect_Transformer_swigregister
IFSelect_Transformer_swigregister(IFSelect_Transformer)

def IFSelect_Transformer_get_type_name(*args):
    """
    IFSelect_Transformer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Transformer_get_type_name(*args)

def IFSelect_Transformer_get_type_descriptor(*args):
    """
    IFSelect_Transformer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Transformer_get_type_descriptor(*args)

class IFSelect_SelectInList(IFSelect_SelectAnyList):
    """
    A SelectInList kind Selection selects a List of an Entity,
    which is composed of single Entities
    To know the list on which to work, SelectInList has two
    deferred methods : NbItems (inherited from SelectAnyList) and
    ListedEntity (which gives an item as an Entity) which must be
    defined to get a List in an Entity of the required Type (and
    consider that list is empty if Entity has not required Type)

    As for SelectAnyList, if a type of Entity defines several
    lists, a given sub-class of SelectInList is attached on one
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectInList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectInList(self) 
            return h


    def ListedEntity(self, *args):
        """
        ListedEntity(IFSelect_SelectInList self, Standard_Integer const num, Handle_Standard_Transient ent) -> Handle_Standard_Transient

        Returns an Entity, given its rank in the list

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SelectInList_ListedEntity(self, *args)


    def FillResult(self, *args):
        """
        FillResult(IFSelect_SelectInList self, Standard_Integer const n1, Standard_Integer const n2, Handle_Standard_Transient ent, Interface_EntityIterator result)

        Puts into the result, the sub-entities of the list, from n1 to
        n2 included. Remark that adequation with Entity's type and
        length of list has already been made at this stage
        Called by RootResult; calls ListedEntity (see below)

        :type n1: int
        :type n2: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type result: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectInList_FillResult(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectInList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectInList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectInList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectInList
IFSelect_SelectInList_swigregister = _IFSelect.IFSelect_SelectInList_swigregister
IFSelect_SelectInList_swigregister(IFSelect_SelectInList)

def IFSelect_SelectInList_get_type_name(*args):
    """
    IFSelect_SelectInList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectInList_get_type_name(*args)

def IFSelect_SelectInList_get_type_descriptor(*args):
    """
    IFSelect_SelectInList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectInList_get_type_descriptor(*args)

class IFSelect_DispGlobal(IFSelect_Dispatch):
    """
    A DispGlobal gathers all the input Entities into only one
    global Packet
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_DispGlobal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_DispGlobal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_DispGlobal self) -> IFSelect_DispGlobal

        Creates a DispGlobal


        """
        this = _IFSelect.new_IFSelect_DispGlobal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Label(self, *args):
        """
        Label(IFSelect_DispGlobal self) -> TCollection_AsciiString

        Returns as Label, "One File for all Input"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_DispGlobal_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(IFSelect_DispGlobal self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True : maximum equates 1

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_DispGlobal_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_DispGlobal self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It is made of only ONE
        Packet, which gets the RootResult from the Final Selection.
        Remark : the inherited exception raising is never activated.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.IFSelect_DispGlobal_Packets(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_DispGlobal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_DispGlobal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_DispGlobal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_DispGlobal
IFSelect_DispGlobal_swigregister = _IFSelect.IFSelect_DispGlobal_swigregister
IFSelect_DispGlobal_swigregister(IFSelect_DispGlobal)

def IFSelect_DispGlobal_get_type_name(*args):
    """
    IFSelect_DispGlobal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_DispGlobal_get_type_name(*args)

def IFSelect_DispGlobal_get_type_descriptor(*args):
    """
    IFSelect_DispGlobal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_DispGlobal_get_type_descriptor(*args)

class IFSelect_DispPerOne(IFSelect_Dispatch):
    """
    A DispPerOne gathers all the input Entities into as many
    Packets as there Root Entities from the Final Selection,
    that is, one Packet per Entity
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_DispPerOne
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_DispPerOne(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_DispPerOne self) -> IFSelect_DispPerOne

        Creates a DispPerOne


        """
        this = _IFSelect.new_IFSelect_DispPerOne(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Label(self, *args):
        """
        Label(IFSelect_DispPerOne self) -> TCollection_AsciiString

        Returns as Label, "One File per Input Entity"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_DispPerOne_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(IFSelect_DispPerOne self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum limit is given as <nbent>

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_DispPerOne_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_DispPerOne self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Returns the list of produced Packets. It defines one Packet
        per Entity given by RootResult from the Final Selection.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.IFSelect_DispPerOne_Packets(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_DispPerOne_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_DispPerOne_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_DispPerOne_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerOne
IFSelect_DispPerOne_swigregister = _IFSelect.IFSelect_DispPerOne_swigregister
IFSelect_DispPerOne_swigregister(IFSelect_DispPerOne)

def IFSelect_DispPerOne_get_type_name(*args):
    """
    IFSelect_DispPerOne_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_DispPerOne_get_type_name(*args)

def IFSelect_DispPerOne_get_type_descriptor(*args):
    """
    IFSelect_DispPerOne_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_DispPerOne_get_type_descriptor(*args)

class IFSelect_Signature(Interface.Interface_SignType):
    """
    Signature provides the basic service used by the classes
    SelectSignature and Counter (i.e. Name, Value), which is :
    - for an entity in a model, give a characteristic string, its
    signature
    This string has not to be unique in the model, but gives a
    value for such or such important feature.
    Exemples : Dynamic Type; Category; etc
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Signature
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Signature(self) 
            return h


    def SetIntCase(self, *args):
        """
        SetIntCase(IFSelect_Signature self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.IFSelect_Signature_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(IFSelect_Signature self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Signature_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(IFSelect_Signature self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Signature_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(IFSelect_Signature self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.IFSelect_Signature_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(IFSelect_Signature self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Signature_Name(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_Signature self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Signature_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(IFSelect_Signature self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Signature_Matches(self, *args)


    def MatchValue(*args):
        """
        MatchValue(Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_Signature_MatchValue(*args)

    MatchValue = staticmethod(MatchValue)

    def IntValue(*args):
        """
        IntValue(Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Signature_IntValue(*args)

    IntValue = staticmethod(IntValue)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Signature_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Signature_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Signature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Signature
IFSelect_Signature_swigregister = _IFSelect.IFSelect_Signature_swigregister
IFSelect_Signature_swigregister(IFSelect_Signature)

def IFSelect_Signature_MatchValue(*args):
    """
    IFSelect_Signature_MatchValue(Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

    Default procedure to tell if a value <val> matches a text
    with a criterium <exact>. <exact> = True requires equality,
    else only contained (no reg-exp)

    :type val: OCC.wrapper.Standard.Standard_CString
    :type text: OCC.wrapper.TCollection.TCollection_AsciiString
    :type exact: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IFSelect.IFSelect_Signature_MatchValue(*args)

def IFSelect_Signature_IntValue(*args):
    """
    IFSelect_Signature_IntValue(Standard_Integer const val) -> Standard_CString

    This procedure converts an Integer to a CString
    It is a convenient way when the value of a signature has the
    form of a simple integer value
    The value is to be used immediately (one buffer only, no copy)

    :type val: int
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _IFSelect.IFSelect_Signature_IntValue(*args)

def IFSelect_Signature_get_type_name(*args):
    """
    IFSelect_Signature_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Signature_get_type_name(*args)

def IFSelect_Signature_get_type_descriptor(*args):
    """
    IFSelect_Signature_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Signature_get_type_descriptor(*args)

class IFSelect_GraphCounter(IFSelect_SignCounter):
    """
    A GraphCounter computes values to be sorted with the help of
    a Graph. I.E. not from a Signature

    The default GraphCounter works with an Applied Selection (a
    SelectDeduct), the value is the count of selected entities
    from each input entities)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_GraphCounter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_GraphCounter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_GraphCounter self, Standard_Boolean const withmap, Standard_Boolean const withlist) -> IFSelect_GraphCounter

        Creates a GraphCounter, without applied selection

        :type withmap: bool
        :type withlist: bool

        """
        this = _IFSelect.new_IFSelect_GraphCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Applied(self, *args):
        """
        Applied(IFSelect_GraphCounter self) -> Handle_IFSelect_SelectDeduct

        Returns the applied selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.IFSelect_GraphCounter_Applied(self, *args)


    def SetApplied(self, *args):
        """
        SetApplied(IFSelect_GraphCounter self, Handle_IFSelect_SelectDeduct sel)

        Sets a new applied selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.IFSelect_GraphCounter_SetApplied(self, *args)


    def AddWithGraph(self, *args):
        """
        AddWithGraph(IFSelect_GraphCounter self, Handle_TColStd_HSequenceOfTransient list, Interface_Graph graph)

        Adds a list of entities in the context given by the graph
        Default takes the count of entities selected by the applied
        selection, when it is given each entity of the list
        Can be redefined

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type graph: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.IFSelect_GraphCounter_AddWithGraph(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_GraphCounter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_GraphCounter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_GraphCounter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_GraphCounter
IFSelect_GraphCounter_swigregister = _IFSelect.IFSelect_GraphCounter_swigregister
IFSelect_GraphCounter_swigregister(IFSelect_GraphCounter)

def IFSelect_GraphCounter_get_type_name(*args):
    """
    IFSelect_GraphCounter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_GraphCounter_get_type_name(*args)

def IFSelect_GraphCounter_get_type_descriptor(*args):
    """
    IFSelect_GraphCounter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_GraphCounter_get_type_descriptor(*args)

class IFSelect_SelectSignature(IFSelect_SelectExtract):
    """
    A SelectSignature sorts the Entities on a Signature Matching.
    The signature to match is given at creation time. Also, the
    required match is given at creation time : exact (IsEqual) or
    contains (the Type's Name must contain the criterium Text)

    Remark that no more interpretation is done, it is an
    alpha-numeric signature : for instance, DynamicType is matched
    as such, super-types are not considered

    Also, numeric (integer) comparisons are supported : an item
    can be <val ou <=val or >val or >=val , val being an Integer

    A SelectSignature may also be created from a SignCounter,
    which then just gives its LastValue as SignatureValue
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectSignature
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectSignature(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectSignature self, Handle_IFSelect_Signature matcher, Standard_CString const signtext, Standard_Boolean const exact) -> IFSelect_SelectSignature
        __init__(IFSelect_SelectSignature self, Handle_IFSelect_Signature matcher, TCollection_AsciiString signtext, Standard_Boolean const exact) -> IFSelect_SelectSignature
        __init__(IFSelect_SelectSignature self, Handle_IFSelect_SignCounter matcher, Standard_CString const signtext, Standard_Boolean const exact) -> IFSelect_SelectSignature

        Creates a SelectSignature with a Counter, more precisely a
        SelectSignature. Which is used here to just give a Signature
        Value (by SignOnly Mode)
        Matching is the default provided by the class Signature

        :type matcher: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type signtext: OCC.wrapper.Standard.Standard_CString
        :type exact: bool

        """
        this = _IFSelect.new_IFSelect_SelectSignature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Signature(self, *args):
        """
        Signature(IFSelect_SelectSignature self) -> Handle_IFSelect_Signature

        Returns the used Signature, then it is possible to access it,
        modify it as required. Can be null, hence see Counter

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_SelectSignature_Signature(self, *args)


    def Counter(self, *args):
        """
        Counter(IFSelect_SelectSignature self) -> Handle_IFSelect_SignCounter

        Returns the used SignCounter. Can be used as alternative for
        Signature

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.IFSelect_SelectSignature_Counter(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(IFSelect_SelectSignature self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Returns True for an Entity (model->Value(num)) of which the
        signature matches the text given as creation time
        May also work with a Counter from the Graph

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignature_SortInGraph(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectSignature self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Not called, defined only to remove a deferred method here

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignature_Sort(self, *args)


    def SignatureText(self, *args):
        """
        Returns Text used to Sort Entity on its Signature or SignCounter

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SelectSignature_SignatureText(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsExact(self, *args):
        """
        IsExact(IFSelect_SelectSignature self) -> Standard_Boolean

        Returns True if match must be exact

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignature_IsExact(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectSignature self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (it refers to the text and exact flag to be matched, and is
        qualified by the Name provided by the Signature)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSignature_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectSignature_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectSignature_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectSignature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSignature
IFSelect_SelectSignature_swigregister = _IFSelect.IFSelect_SelectSignature_swigregister
IFSelect_SelectSignature_swigregister(IFSelect_SelectSignature)

def IFSelect_SelectSignature_get_type_name(*args):
    """
    IFSelect_SelectSignature_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectSignature_get_type_name(*args)

def IFSelect_SelectSignature_get_type_descriptor(*args):
    """
    IFSelect_SelectSignature_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectSignature_get_type_descriptor(*args)

class IFSelect_SignValidity(IFSelect_Signature):
    """
    This Signature returns the Validity Status of an entity, as
    deducted from data in the model : it can be
    "OK" "Unknown" "Unloaded" "Syntactic Fail"(but loaded)
    "Syntactic Warning" "Semantic Fail" "Semantic Warning" 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignValidity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignValidity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignValidity self) -> IFSelect_SignValidity

        Returns a SignValidity


        """
        this = _IFSelect.new_IFSelect_SignValidity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def CVal(*args):
        """
        CVal(Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as a validity
        deducted from data (reports) stored in the model.
        Class method, can be called by any one

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignValidity_CVal(*args)

    CVal = staticmethod(CVal)

    def Value(self, *args):
        """
        Value(IFSelect_SignValidity self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as a validity
        deducted from data (reports) stored in the model
        Calls the class method CVal

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignValidity_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignValidity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignValidity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignValidity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignValidity
IFSelect_SignValidity_swigregister = _IFSelect.IFSelect_SignValidity_swigregister
IFSelect_SignValidity_swigregister(IFSelect_SignValidity)

def IFSelect_SignValidity_CVal(*args):
    """
    IFSelect_SignValidity_CVal(Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

    Returns the Signature for a Transient object, as a validity
    deducted from data (reports) stored in the model.
    Class method, can be called by any one

    :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
    :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _IFSelect.IFSelect_SignValidity_CVal(*args)

def IFSelect_SignValidity_get_type_name(*args):
    """
    IFSelect_SignValidity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignValidity_get_type_name(*args)

def IFSelect_SignValidity_get_type_descriptor(*args):
    """
    IFSelect_SignValidity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignValidity_get_type_descriptor(*args)

class IFSelect_SelectFlag(IFSelect_SelectExtract):
    """
    A SelectFlag queries a flag noted in the bitmap of the Graph.
    The Flag is designated by its Name. Flag Names are defined
    by Work Session and, as necessary, other functional objects

    WorkSession from IFSelect defines flag "Incorrect"
    Objects which control application running define some others
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectFlag
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectFlag(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectFlag self, Standard_CString const flagname) -> IFSelect_SelectFlag

        Creates a Select Flag, to query a flag designated by its name

        :type flagname: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_SelectFlag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FlagName(self, *args):
        """
        FlagName(IFSelect_SelectFlag self) -> Standard_CString

        Returns the name of the flag

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SelectFlag_FlagName(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectFlag self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. It is redefined to
        work on the graph itself (not queried by sort)

        An entity is selected if its flag is True on Direct mode,
        False on Reversed mode

        If flag does not exist for the given name, returns an empty
        result, whatever the Direct/Reversed sense

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectFlag_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectFlag self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always False because RootResult has done the work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectFlag_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectFlag self) -> TCollection_AsciiString

        Returns a text defining the criterium, includes the flag name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectFlag_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectFlag_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectFlag_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectFlag_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectFlag
IFSelect_SelectFlag_swigregister = _IFSelect.IFSelect_SelectFlag_swigregister
IFSelect_SelectFlag_swigregister(IFSelect_SelectFlag)

def IFSelect_SelectFlag_get_type_name(*args):
    """
    IFSelect_SelectFlag_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectFlag_get_type_name(*args)

def IFSelect_SelectFlag_get_type_descriptor(*args):
    """
    IFSelect_SelectFlag_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectFlag_get_type_descriptor(*args)

class IFSelect_SelectExplore(IFSelect_SelectDeduct):
    """
    A SelectExplore determines from an input list of Entities,
    a list obtained by a way of exploration. This implies the
    possibility of recursive exploration : the output list is
    itself reused as input, etc...
    Examples : Shared Entities, can be considered at one level
    (immediate shared) or more, or max level

    Then, for each input entity, if it is not rejected, it can be
    either taken itself, or explored : it then produces a list.
    According to a level, either the produced lists or taken
    entities give the result (level one), or lists are themselves
    considered and for each item, is it taken or explored.

    Remark that rejection is just a safety : normally, an input
    entity is, either taken itself, or explored
    A maximum level can be specified. Else, the process continues
    until all entities have been either taken or rejected
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectExplore
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectExplore(self) 
            return h


    def Level(self, *args):
        """
        Level(IFSelect_SelectExplore self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectExplore_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectExplore self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectExplore_RootResult(self, *args)


    def Explore(self, *args):
        """
        Explore(IFSelect_SelectExplore self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Analyses and, if required, Explores an entity, as follows :
        The explored list starts as empty, it has to be filled by this
        method.
        If it returns False, <ent> is rejected for result (this is to
        be used only as safety)
        If it returns True and <explored> remains empty, <ent> is
        taken itself for result, not explored
        If it returns True and <explored> is not empty, the content
        of this list is considered :
        If maximum level is attained, it is taken for result
        Else (or no max), each of its entity will be itself explored

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectExplore_Explore(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectExplore self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectExplore_Label(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(IFSelect_SelectExplore self) -> TCollection_AsciiString

        Returns a text defining the way of exploration

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectExplore_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectExplore_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectExplore_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectExplore_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectExplore
IFSelect_SelectExplore_swigregister = _IFSelect.IFSelect_SelectExplore_swigregister
IFSelect_SelectExplore_swigregister(IFSelect_SelectExplore)

def IFSelect_SelectExplore_get_type_name(*args):
    """
    IFSelect_SelectExplore_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectExplore_get_type_name(*args)

def IFSelect_SelectExplore_get_type_descriptor(*args):
    """
    IFSelect_SelectExplore_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectExplore_get_type_descriptor(*args)

class IFSelect_SelectEntityNumber(IFSelect_SelectBase):
    """
    A SelectEntityNumber gets in an InterfaceModel (through a
    Graph), the Entity which has a specified Number (its rank of
    adding into the Model) : there can be zero (if none) or one.
    The Number is not directly defined as an Integer, but as a
    Parameter, which can be externally controled
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectEntityNumber
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectEntityNumber(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectEntityNumber self) -> IFSelect_SelectEntityNumber

        Creates a SelectEntityNumber, initially with no specified Number


        """
        this = _IFSelect.new_IFSelect_SelectEntityNumber(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetNumber(self, *args):
        """
        SetNumber(IFSelect_SelectEntityNumber self, Handle_IFSelect_IntParam num)

        Sets Entity Number to be taken (initially, none is set : 0)

        :type num: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectEntityNumber_SetNumber(self, *args)


    def Number(self, *args):
        """
        Number(IFSelect_SelectEntityNumber self) -> Handle_IFSelect_IntParam

        Returns specified Number (as a Parameter)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectEntityNumber_Number(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectEntityNumber self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : the Entity having the
        specified Number (this result assures naturally uniqueness)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectEntityNumber_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectEntityNumber self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Entity Number ..."

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectEntityNumber_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectEntityNumber_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectEntityNumber_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectEntityNumber_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectEntityNumber
IFSelect_SelectEntityNumber_swigregister = _IFSelect.IFSelect_SelectEntityNumber_swigregister
IFSelect_SelectEntityNumber_swigregister(IFSelect_SelectEntityNumber)

def IFSelect_SelectEntityNumber_get_type_name(*args):
    """
    IFSelect_SelectEntityNumber_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectEntityNumber_get_type_name(*args)

def IFSelect_SelectEntityNumber_get_type_descriptor(*args):
    """
    IFSelect_SelectEntityNumber_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectEntityNumber_get_type_descriptor(*args)

class IFSelect_Act(IFSelect_Activator):
    """
    Act gives a simple way to define and add functions to be ran
    from a SessionPilot, as follows :

    Define a function as
    static IFSelect_RetStatus myfunc
    (const Standard_CString name,
    const Handle(IFSelect_SessionPilot)& pilot)
    { ... }
    When ran, it receives the exact name (string) of the called
    function, and the SessionPilot which brings other infos

    Add it by
    IFSelect_Act::AddFunc (name,help,myfunc);
    for a normal function, or
    IFSelect_Act::AddFSet (name,help,myfunc);
    for a function which is intended to create a control item
    name and help are given as CString

    Then, it is available for run
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_Act
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_Act(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_Act self, Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func) -> IFSelect_Act

        Creates an Act with a name, help and a function
        mode (Add or AddSet) is given when recording

        :type name: OCC.wrapper.Standard.Standard_CString
        :type help: OCC.wrapper.Standard.Standard_CString
        :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

        """
        this = _IFSelect.new_IFSelect_Act(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Do(self, *args):
        """
        Do(IFSelect_Act self, Standard_Integer const number, Handle_IFSelect_SessionPilot pilot) -> IFSelect_ReturnStatus

        Execution of Command Line. remark that <number> is senseless
        because each Act brings one and only one function

        :type number: int
        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_Act_Do(self, *args)


    def Help(self, *args):
        """
        Help(IFSelect_Act self, Standard_Integer const number) -> Standard_CString

        Short Help for commands : returns the help given to create

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Act_Help(self, *args)


    def SetGroup(*args):
        """
        SetGroup(Standard_CString const group, Standard_CString const file)

        Changes the default group name for the following Acts
        group empty means to come back to default from Activator
        Also a file name can be precised (to query by getsource)

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_Act_SetGroup(*args)

    SetGroup = staticmethod(SetGroup)

    def AddFunc(*args):
        """
        AddFunc(Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func)

        Adds a function with its name and help : creates an Act then
        records it as normal function

        :type name: OCC.wrapper.Standard.Standard_CString
        :type help: OCC.wrapper.Standard.Standard_CString
        :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

        """
        return _IFSelect.IFSelect_Act_AddFunc(*args)

    AddFunc = staticmethod(AddFunc)

    def AddFSet(*args):
        """
        AddFSet(Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func)

        Adds a function with its name and help : creates an Act then
        records it as function for XSET (i.e. to create control item)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type help: OCC.wrapper.Standard.Standard_CString
        :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

        """
        return _IFSelect.IFSelect_Act_AddFSet(*args)

    AddFSet = staticmethod(AddFSet)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_Act_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_Act_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_Act_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_Act
IFSelect_Act_swigregister = _IFSelect.IFSelect_Act_swigregister
IFSelect_Act_swigregister(IFSelect_Act)

def IFSelect_Act_SetGroup(*args):
    """
    IFSelect_Act_SetGroup(Standard_CString const group, Standard_CString const file)

    Changes the default group name for the following Acts
    group empty means to come back to default from Activator
    Also a file name can be precised (to query by getsource)

    :type group: OCC.wrapper.Standard.Standard_CString
    :type file: OCC.wrapper.Standard.Standard_CString

    """
    return _IFSelect.IFSelect_Act_SetGroup(*args)

def IFSelect_Act_AddFunc(*args):
    """
    IFSelect_Act_AddFunc(Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func)

    Adds a function with its name and help : creates an Act then
    records it as normal function

    :type name: OCC.wrapper.Standard.Standard_CString
    :type help: OCC.wrapper.Standard.Standard_CString
    :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

    """
    return _IFSelect.IFSelect_Act_AddFunc(*args)

def IFSelect_Act_AddFSet(*args):
    """
    IFSelect_Act_AddFSet(Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func)

    Adds a function with its name and help : creates an Act then
    records it as function for XSET (i.e. to create control item)

    :type name: OCC.wrapper.Standard.Standard_CString
    :type help: OCC.wrapper.Standard.Standard_CString
    :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

    """
    return _IFSelect.IFSelect_Act_AddFSet(*args)

def IFSelect_Act_get_type_name(*args):
    """
    IFSelect_Act_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_Act_get_type_name(*args)

def IFSelect_Act_get_type_descriptor(*args):
    """
    IFSelect_Act_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_Act_get_type_descriptor(*args)

class IFSelect_ParamEditor(IFSelect_Editor):
    """
    A ParamEditor gives access for edition to a list of TypedValue
    (i.e. of Static too)
    Its definition is made of the TypedValue to edit themselves,
    and can add some constants, which can then be displayed but
    not changed (for instance, system name, processor version ...)

    I.E. it gives a way of editing or at least displaying
    parameters as global
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_ParamEditor
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_ParamEditor(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_ParamEditor self, Standard_Integer const nbmax=100, Standard_CString const label) -> IFSelect_ParamEditor

        Creates a ParamEditor, empty, with a maximum count of params
        (default is 100)
        And a label, by default it will be "Param Editor"

        :type nbmax: int
        :type label: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_ParamEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddValue(self, *args):
        """
        AddValue(IFSelect_ParamEditor self, Handle_Interface_TypedValue val, Standard_CString const shortname)

        Adds a TypedValue
        By default, its short name equates its complete name, it can
        be explicited

        :type val: OCC.wrapper.Interface.Handle_Interface_TypedValue
        :type shortname: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ParamEditor_AddValue(self, *args)


    def AddConstantText(self, *args):
        """
        AddConstantText(IFSelect_ParamEditor self, Standard_CString const val, Standard_CString const shortname, Standard_CString const completename)

        Adds a Constant Text, it will be Read Only
        By default, its long name equates its shortname

        :type val: OCC.wrapper.Standard.Standard_CString
        :type shortname: OCC.wrapper.Standard.Standard_CString
        :type completename: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ParamEditor_AddConstantText(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_ParamEditor self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ParamEditor_Label(self, *args)


    def Recognize(self, *args):
        """
        Recognize(IFSelect_ParamEditor self, Handle_IFSelect_EditForm form) -> Standard_Boolean

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ParamEditor_Recognize(self, *args)


    def StringValue(self, *args):
        """
        StringValue(IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ParamEditor_StringValue(self, *args)


    def Load(self, *args):
        """
        Load(IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ParamEditor_Load(self, *args)


    def Apply(self, *args):
        """
        Apply(IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ParamEditor_Apply(self, *args)


    def StaticEditor(*args):
        """
        StaticEditor(Handle_TColStd_HSequenceOfHAsciiString list, Standard_CString const label) -> Handle_IFSelect_ParamEditor

        Returns a ParamEditor to work on the Static Parameters of
        which names are listed in <list>
        Null Handle if <list> is null or empty

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type label: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ParamEditor

        """
        return _IFSelect.IFSelect_ParamEditor_StaticEditor(*args)

    StaticEditor = staticmethod(StaticEditor)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_ParamEditor_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_ParamEditor_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_ParamEditor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_ParamEditor
IFSelect_ParamEditor_swigregister = _IFSelect.IFSelect_ParamEditor_swigregister
IFSelect_ParamEditor_swigregister(IFSelect_ParamEditor)

def IFSelect_ParamEditor_StaticEditor(*args):
    """
    IFSelect_ParamEditor_StaticEditor(Handle_TColStd_HSequenceOfHAsciiString list, Standard_CString const label) -> Handle_IFSelect_ParamEditor

    Returns a ParamEditor to work on the Static Parameters of
    which names are listed in <list>
    Null Handle if <list> is null or empty

    :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
    :type label: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ParamEditor

    """
    return _IFSelect.IFSelect_ParamEditor_StaticEditor(*args)

def IFSelect_ParamEditor_get_type_name(*args):
    """
    IFSelect_ParamEditor_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_ParamEditor_get_type_name(*args)

def IFSelect_ParamEditor_get_type_descriptor(*args):
    """
    IFSelect_ParamEditor_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_ParamEditor_get_type_descriptor(*args)

class IFSelect_SelectAnyType(IFSelect_SelectExtract):
    """
    A SelectAnyType sorts the Entities of which the Type is Kind
    of a given Type : this Type for Match is specific of each
    class of SelectAnyType
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectAnyType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectAnyType(self) 
            return h


    def TypeForMatch(self, *args):
        """
        TypeForMatch(IFSelect_SelectAnyType self) -> Handle_Standard_Type

        Returns the Type which has to be matched for select

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectAnyType_TypeForMatch(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectAnyType self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity (model->Value(num)) which is kind
        of the choosen type, given by the method TypeForMatch.
        Criterium is IsKind.

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectAnyType_Sort(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectAnyType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectAnyType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectAnyType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectAnyType
IFSelect_SelectAnyType_swigregister = _IFSelect.IFSelect_SelectAnyType_swigregister
IFSelect_SelectAnyType_swigregister(IFSelect_SelectAnyType)

def IFSelect_SelectAnyType_get_type_name(*args):
    """
    IFSelect_SelectAnyType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectAnyType_get_type_name(*args)

def IFSelect_SelectAnyType_get_type_descriptor(*args):
    """
    IFSelect_SelectAnyType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectAnyType_get_type_descriptor(*args)

class IFSelect_HSeqOfSelection(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_HSeqOfSelection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_HSeqOfSelection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_HSeqOfSelection self) -> IFSelect_HSeqOfSelection
        __init__(IFSelect_HSeqOfSelection self, NCollection_Sequence_Handle_IFSelect_Selection theOther) -> IFSelect_HSeqOfSelection

        :type theOther: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        this = _IFSelect.new_IFSelect_HSeqOfSelection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        res = _IFSelect.IFSelect_HSeqOfSelection_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(IFSelect_HSeqOfSelection self, Handle_IFSelect_Selection theItem)
        Append(IFSelect_HSeqOfSelection self, NCollection_Sequence_Handle_IFSelect_Selection theSequence)

        :type theSequence: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        return _IFSelect.IFSelect_HSeqOfSelection_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(IFSelect_HSeqOfSelection self) -> NCollection_Sequence_Handle_IFSelect_Selection

        :rtype: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        return _IFSelect.IFSelect_HSeqOfSelection_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_HSeqOfSelection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_HSeqOfSelection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_HSeqOfSelection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_HSeqOfSelection
IFSelect_HSeqOfSelection_swigregister = _IFSelect.IFSelect_HSeqOfSelection_swigregister
IFSelect_HSeqOfSelection_swigregister(IFSelect_HSeqOfSelection)

def IFSelect_HSeqOfSelection_get_type_name(*args):
    """
    IFSelect_HSeqOfSelection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_HSeqOfSelection_get_type_name(*args)

def IFSelect_HSeqOfSelection_get_type_descriptor(*args):
    """
    IFSelect_HSeqOfSelection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_HSeqOfSelection_get_type_descriptor(*args)

class IFSelect_SelectRange(IFSelect_SelectExtract):
    """
    A SelectRange keeps or rejects a sub-set of the input set,
    that is the Entities of which rank in the iteration list
    is in a given range (for instance form 2nd to 6th, etc...)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectRange
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectRange(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectRange self) -> IFSelect_SelectRange

        Creates a SelectRange. Default is Take all the input list


        """
        this = _IFSelect.new_IFSelect_SelectRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetRange(self, *args):
        """
        SetRange(IFSelect_SelectRange self, Handle_IFSelect_IntParam rankfrom, Handle_IFSelect_IntParam rankto)

        Sets a Range for numbers, with a lower and a upper limits
        Error if rankto is lower then rankfrom

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectRange_SetRange(self, *args)


    def SetOne(self, *args):
        """
        SetOne(IFSelect_SelectRange self, Handle_IFSelect_IntParam rank)

        Sets a unique number (only one Entity will be sorted as True)

        :type rank: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectRange_SetOne(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(IFSelect_SelectRange self, Handle_IFSelect_IntParam rankfrom)

        Sets a Lower limit but no upper limit

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectRange_SetFrom(self, *args)


    def SetUntil(self, *args):
        """
        SetUntil(IFSelect_SelectRange self, Handle_IFSelect_IntParam rankto)

        Sets an Upper limit but no lower limit (equivalent to lower 1)

        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectRange_SetUntil(self, *args)


    def HasLower(self, *args):
        """
        HasLower(IFSelect_SelectRange self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectRange_HasLower(self, *args)


    def Lower(self, *args):
        """
        Lower(IFSelect_SelectRange self) -> Handle_IFSelect_IntParam

        Returns Lower limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectRange_Lower(self, *args)


    def LowerValue(self, *args):
        """
        LowerValue(IFSelect_SelectRange self) -> Standard_Integer

        Returns Value of Lower Limit (0 if none is defined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectRange_LowerValue(self, *args)


    def HasUpper(self, *args):
        """
        HasUpper(IFSelect_SelectRange self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectRange_HasUpper(self, *args)


    def Upper(self, *args):
        """
        Upper(IFSelect_SelectRange self) -> Handle_IFSelect_IntParam

        Returns Upper limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_SelectRange_Upper(self, *args)


    def UpperValue(self, *args):
        """
        UpperValue(IFSelect_SelectRange self) -> Standard_Integer

        Returns Value of Upper Limit (0 if none is defined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectRange_UpperValue(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectRange self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity of which occurence number in the
        iteration is inside the selected Range (considers <rank>)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectRange_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectRange self) -> TCollection_AsciiString

        Returns a text defining the criterium : following cases,
        " From .. Until .." or "From .." or "Until .." or "Rank no .."

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectRange_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectRange_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectRange_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectRange_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectRange
IFSelect_SelectRange_swigregister = _IFSelect.IFSelect_SelectRange_swigregister
IFSelect_SelectRange_swigregister(IFSelect_SelectRange)

def IFSelect_SelectRange_get_type_name(*args):
    """
    IFSelect_SelectRange_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectRange_get_type_name(*args)

def IFSelect_SelectRange_get_type_descriptor(*args):
    """
    IFSelect_SelectRange_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectRange_get_type_descriptor(*args)

class IFSelect_SelectPointed(IFSelect_SelectBase):
    """
    This type of Selection is intended to describe a direct
    selection without an explicit criterium, for instance the
    result of picking viewed entities on a graphic screen

    It can also be used to provide a list as internal alternate
    input : this use implies to clear the list once queried
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectPointed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectPointed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectPointed self) -> IFSelect_SelectPointed

        Creates a SelectPointed


        """
        this = _IFSelect.new_IFSelect_SelectPointed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(IFSelect_SelectPointed self)

        Clears the list of selected items
        Also says the list is unset
        All Add* methods and SetList say the list is set


        """
        return _IFSelect.IFSelect_SelectPointed_Clear(self, *args)


    def IsSet(self, *args):
        """
        IsSet(IFSelect_SelectPointed self) -> Standard_Boolean

        Tells if the list has been set. Even if empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_IsSet(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(IFSelect_SelectPointed self, Handle_Standard_Transient item)

        As SetList but with only one entity
        If <ent> is Null, the list is said as being set but is empty

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SelectPointed_SetEntity(self, *args)


    def SetList(self, *args):
        """
        SetList(IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list)

        Sets a given list to define the list of selected items
        <list> can be empty or null : in this case, the list is said
        as being set, but it is empty

        To use it as an alternate input, one shot :
        - SetList or SetEntity to define the input list
        - RootResult to get it
        - then Clear to drop it

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_SelectPointed_SetList(self, *args)


    def Add(self, *args):
        """
        Add(IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Boolean

        Adds an item. Returns True if Done, False if <item> is already
        in the selected list

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an item. Returns True if Done, False if <item> was not
        in the selected list

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_Remove(self, *args)


    def Toggle(self, *args):
        """
        Toggle(IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Boolean

        Toggles status of an item : adds it if not pointed or removes
        it if already pointed. Returns the new status (Pointed or not)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_Toggle(self, *args)


    def AddList(self, *args):
        """
        AddList(IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Boolean

        Adds all the items defined in a list. Returns True if at least
        one item has been added, False else

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_AddList(self, *args)


    def RemoveList(self, *args):
        """
        RemoveList(IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Boolean

        Removes all the items defined in a list. Returns True if at
        least one item has been removed, False else

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_RemoveList(self, *args)


    def ToggleList(self, *args):
        """
        ToggleList(IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Boolean

        Toggles status of all the items defined in a list : adds it if
        not pointed or removes it if already pointed.

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectPointed_ToggleList(self, *args)


    def Rank(self, *args):
        """
        Rank(IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Integer

        Returns the rank of an item in the selected list, or 0.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectPointed_Rank(self, *args)


    def NbItems(self, *args):
        """
        NbItems(IFSelect_SelectPointed self) -> Standard_Integer

        Returns the count of selected items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectPointed_NbItems(self, *args)


    def Item(self, *args):
        """
        Item(IFSelect_SelectPointed self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns an item given its rank, or a Null Handle

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SelectPointed_Item(self, *args)


    def Update(self, *args):
        """
        Update(IFSelect_SelectPointed self, Handle_Interface_CopyControl control)
        Update(IFSelect_SelectPointed self, Handle_IFSelect_Transformer trf)

        Rebuilds the selected list, by querying a Transformer
        (same principle as from a CopyControl)

        :type trf: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _IFSelect.IFSelect_SelectPointed_Update(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectPointed self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected items. Only the selected entities
        which are present in the graph are given (this result assures
        uniqueness).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectPointed_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectPointed self) -> TCollection_AsciiString

        Returns a text which identifies the type of selection made.
        It is "Pointed Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectPointed_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectPointed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectPointed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectPointed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectPointed
IFSelect_SelectPointed_swigregister = _IFSelect.IFSelect_SelectPointed_swigregister
IFSelect_SelectPointed_swigregister(IFSelect_SelectPointed)

def IFSelect_SelectPointed_get_type_name(*args):
    """
    IFSelect_SelectPointed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectPointed_get_type_name(*args)

def IFSelect_SelectPointed_get_type_descriptor(*args):
    """
    IFSelect_SelectPointed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectPointed_get_type_descriptor(*args)

class IFSelect_DispPerFiles(IFSelect_Dispatch):
    """
    A DispPerFiles produces a determined count of Packets from the
    input Entities. It divides, as equally as possible, the input
    list into a count of files. This count is the parameter of the
    DispPerFiles. If the input list has less than this count, of
    course there will be one packet per input entity.
    This count is a Parameter of the DispPerFiles, given as an
    IntParam, thus allowing external control of its Value
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_DispPerFiles
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_DispPerFiles(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_DispPerFiles self) -> IFSelect_DispPerFiles

        Creates a DispPerFiles with no Count (default value 1 file)


        """
        this = _IFSelect.new_IFSelect_DispPerFiles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Count(self, *args):
        """
        Count(IFSelect_DispPerFiles self) -> Handle_IFSelect_IntParam

        Returns the Count Parameter used for splitting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_DispPerFiles_Count(self, *args)


    def SetCount(self, *args):
        """
        SetCount(IFSelect_DispPerFiles self, Handle_IFSelect_IntParam count)

        Sets a new Parameter for Count

        :type count: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_DispPerFiles_SetCount(self, *args)


    def CountValue(self, *args):
        """
        CountValue(IFSelect_DispPerFiles self) -> Standard_Integer

        Returns the effective value of the count parameter
        (if Count Parameter not Set or value not positive, returns 1)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_DispPerFiles_CountValue(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_DispPerFiles self) -> TCollection_AsciiString

        Returns as Label, "Maximum <count> Files"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_DispPerFiles_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(IFSelect_DispPerFiles self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum count is given as CountValue

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_DispPerFiles_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_DispPerFiles self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It defines Packets in
        order to have <Count> Packets, except if the input count of
        Entities is lower. Entities are given by RootResult from the
        Final Selection.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.IFSelect_DispPerFiles_Packets(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_DispPerFiles_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_DispPerFiles_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_DispPerFiles_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerFiles
IFSelect_DispPerFiles_swigregister = _IFSelect.IFSelect_DispPerFiles_swigregister
IFSelect_DispPerFiles_swigregister(IFSelect_DispPerFiles)

def IFSelect_DispPerFiles_get_type_name(*args):
    """
    IFSelect_DispPerFiles_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_DispPerFiles_get_type_name(*args)

def IFSelect_DispPerFiles_get_type_descriptor(*args):
    """
    IFSelect_DispPerFiles_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_DispPerFiles_get_type_descriptor(*args)

class IFSelect_SessionDumper(Standard.Standard_Transient):
    """
    A SessionDumper is called by SessionFile. It takes into
    account a set of classes (such as Selections, Dispatches ...).
    SessionFile writes the Type (as defined by cdl) of each Item
    and its general Parameters. It manages the names of the Items.

    A SessionDumper must be able to Write the Parameters which are
    own of each Item it takes into account, given its Class, then
    to Recognize the Type and Read its Own Parameters to create
    an Item of this Type with these own Parameters.

    Then, there must be defined one sub-type of SessionDumper per
    consistent set of classes (e.g. a package).

    By Own Parameters, understand Parameters given at Creation Time
    if there are, or specific of a given class, apart from those
    defined at superclass levels (e.g. Final Selection for a
    Dispatch, Input Selection for a SelectExtract or SelectDeduct,
    Direct Status for a SelectExtract, etc...).

    The Parameters are those stored in a WorkSession, they can be
    of Types : IntParam, HAsciiString (for TextParam), Selection,
    Dispatch.

    SessionDumpers are organized in a Library which is used by
    SessionFile. They are put at Creation Time in this Library.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SessionDumper
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SessionDumper(self) 
            return h


    def First(*args):
        """
        First() -> Handle_IFSelect_SessionDumper

        Returns the First item of the Library of Dumper. The Next ones
        are then obtained by Next on the returned items

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

        """
        return _IFSelect.IFSelect_SessionDumper_First(*args)

    First = staticmethod(First)

    def Next(self, *args):
        """
        Next(IFSelect_SessionDumper self) -> Handle_IFSelect_SessionDumper

        Returns the Next SesionDumper in the Library. Returns a Null
        Handle at the End.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

        """
        return _IFSelect.IFSelect_SessionDumper_Next(self, *args)


    def WriteOwn(self, *args):
        """
        WriteOwn(IFSelect_SessionDumper self, IFSelect_SessionFile file, Handle_Standard_Transient item) -> Standard_Boolean

        Writes the Own Parameters of a given Item, if it forecast to
        manage its Type.
        Returns True if it has recognized the Type of the Item (in
        this case, it is assumed to have written the Own Parameters if
        there are some), False else : in that case, SessionFile will
        try another SessionDumper in the Library.
        WriteOwn can use these methods from SessionFile : SendVoid,
        SendItem, SendText, and if necessary, WorkSession.

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionDumper_WriteOwn(self, *args)


    def ReadOwn(self, *args):
        """
        ReadOwn(IFSelect_SessionDumper self, IFSelect_SessionFile file, TCollection_AsciiString type, Handle_Standard_Transient item) -> Standard_Boolean

        Recognizes a Type (given as <type>) then Creates an Item of
        this Type with the Own Parameter, as required.
        Returns True if it has recognized the Type (in this case, it
        is assumed to have created the Item, returned as <item>),
        False else : in that case, SessionFile will try another
        SessionDumper in the Library.
        ReadOwn can use these methods from SessionFile to access Own
        Parameters : NbOwnParams, IsVoid, IsText, TextValue, ItemValue

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type type: OCC.wrapper.TCollection.TCollection_AsciiString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionDumper_ReadOwn(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SessionDumper_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SessionDumper_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SessionDumper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SessionDumper
IFSelect_SessionDumper_swigregister = _IFSelect.IFSelect_SessionDumper_swigregister
IFSelect_SessionDumper_swigregister(IFSelect_SessionDumper)

def IFSelect_SessionDumper_First(*args):
    """
    IFSelect_SessionDumper_First() -> Handle_IFSelect_SessionDumper

    Returns the First item of the Library of Dumper. The Next ones
    are then obtained by Next on the returned items

    :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

    """
    return _IFSelect.IFSelect_SessionDumper_First(*args)

def IFSelect_SessionDumper_get_type_name(*args):
    """
    IFSelect_SessionDumper_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SessionDumper_get_type_name(*args)

def IFSelect_SessionDumper_get_type_descriptor(*args):
    """
    IFSelect_SessionDumper_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SessionDumper_get_type_descriptor(*args)

class IFSelect_SelectIncorrectEntities(IFSelect_SelectFlag):
    """
    A SelectIncorrectEntities sorts the Entities which have been
    noted as Incorrect in the Graph of the Session
    (flag "Incorrect")
    It can find a result only if ComputeCheck has formerly been
    called on the WorkSession. Else, its result will be empty.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectIncorrectEntities
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectIncorrectEntities(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectIncorrectEntities self) -> IFSelect_SelectIncorrectEntities

        Creates a SelectIncorrectEntities
        i.e. a SelectFlag("Incorrect")


        """
        this = _IFSelect.new_IFSelect_SelectIncorrectEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectIncorrectEntities_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectIncorrectEntities_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectIncorrectEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectIncorrectEntities
IFSelect_SelectIncorrectEntities_swigregister = _IFSelect.IFSelect_SelectIncorrectEntities_swigregister
IFSelect_SelectIncorrectEntities_swigregister(IFSelect_SelectIncorrectEntities)

def IFSelect_SelectIncorrectEntities_get_type_name(*args):
    """
    IFSelect_SelectIncorrectEntities_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectIncorrectEntities_get_type_name(*args)

def IFSelect_SelectIncorrectEntities_get_type_descriptor(*args):
    """
    IFSelect_SelectIncorrectEntities_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectIncorrectEntities_get_type_descriptor(*args)

class IFSelect_SignType(IFSelect_Signature):
    """
    This Signature returns the cdl Type of an entity, under two
    forms :
    - complete dynamic type (package and class)
    - class type, without package name
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignType self, Standard_Boolean const nopk) -> IFSelect_SignType

        Returns a SignType
        <nopk> false (D) : complete dynamic type (name = Dynamic Type)
        <nopk> true : class type without pk (name = Class Type)

        :type nopk: bool

        """
        this = _IFSelect.new_IFSelect_SignType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(IFSelect_SignType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its Dynamic
        Type, with or without package name, according starting option

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignType_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignType
IFSelect_SignType_swigregister = _IFSelect.IFSelect_SignType_swigregister
IFSelect_SignType_swigregister(IFSelect_SignType)

def IFSelect_SignType_get_type_name(*args):
    """
    IFSelect_SignType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignType_get_type_name(*args)

def IFSelect_SignType_get_type_descriptor(*args):
    """
    IFSelect_SignType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignType_get_type_descriptor(*args)

class IFSelect_PacketList(Standard.Standard_Transient):
    """
    This class gives a simple way to return then consult a
    list of packets, determined from the content of a Model,
    by various criteria.

    It allows to describe several lists with entities from a
    given model, possibly more than one list knowing every entity,
    and to determine the remaining list (entities in no lists) and
    the duplications (with their count).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_PacketList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_PacketList(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_PacketList self, Handle_Interface_InterfaceModel model) -> IFSelect_PacketList

        Creates a PackList, empty, ready to receive entities from a
        given Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        this = _IFSelect.new_IFSelect_PacketList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetName(self, *args):
        """
        SetName(IFSelect_PacketList self, Standard_CString const name)

        Sets a name to a packet list : this makes easier a general
        routine to print it. Default is "Packets"

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_PacketList_SetName(self, *args)


    def Name(self, *args):
        """
        Name(IFSelect_PacketList self) -> Standard_CString

        Returns the recorded name for a packet list

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_PacketList_Name(self, *args)


    def Model(self, *args):
        """
        Model(IFSelect_PacketList self) -> Handle_Interface_InterfaceModel

        Returns the Model of reference

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_PacketList_Model(self, *args)


    def AddPacket(self, *args):
        """
        AddPacket(IFSelect_PacketList self)

        Declares a new Packet, ready to be filled
        The entities to be added will be added to this Packet


        """
        return _IFSelect.IFSelect_PacketList_AddPacket(self, *args)


    def Add(self, *args):
        """
        Add(IFSelect_PacketList self, Handle_Standard_Transient ent)

        Adds an entity from the Model into the current packet for Add

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_PacketList_Add(self, *args)


    def AddList(self, *args):
        """
        AddList(IFSelect_PacketList self, Handle_TColStd_HSequenceOfTransient list)

        Adds an list of entities into the current packet for Add

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_PacketList_AddList(self, *args)


    def NbPackets(self, *args):
        """
        NbPackets(IFSelect_PacketList self) -> Standard_Integer

        Returns the count of non-empty packets

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_PacketList_NbPackets(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(IFSelect_PacketList self, Standard_Integer const numpack) -> Standard_Integer

        Returns the count of entities in a Packet given its rank, or 0

        :type numpack: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_PacketList_NbEntities(self, *args)


    def Entities(self, *args):
        """
        Entities(IFSelect_PacketList self, Standard_Integer const numpack) -> Interface_EntityIterator

        Returns the content of a Packet given its rank
        Null Handle if <numpack> is out of range

        :type numpack: int
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_PacketList_Entities(self, *args)


    def HighestDuplicationCount(self, *args):
        """
        HighestDuplicationCount(IFSelect_PacketList self) -> Standard_Integer

        Returns the highest number of packets which know a same entity
        For no duplication, should be one

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_PacketList_HighestDuplicationCount(self, *args)


    def NbDuplicated(self, *args):
        """
        NbDuplicated(IFSelect_PacketList self, Standard_Integer const count, Standard_Boolean const andmore) -> Standard_Integer

        Returns the count of entities duplicated :
        <count> times, if <andmore> is False, or
        <count> or more times, if <andmore> is True
        See Duplicated for more details

        :type count: int
        :type andmore: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_PacketList_NbDuplicated(self, *args)


    def Duplicated(self, *args):
        """
        Duplicated(IFSelect_PacketList self, Standard_Integer const count, Standard_Boolean const andmore) -> Interface_EntityIterator

        Returns a list of entities duplicated :
        <count> times, if <andmore> is False, or
        <count> or more times, if <andmore> is True
        Hence, count=2 & andmore=True gives all duplicated entities
        count=1 gives non-duplicated entities (in only one packet)
        count=0 gives remaining entities (in no packet at all)

        :type count: int
        :type andmore: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_PacketList_Duplicated(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_PacketList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_PacketList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_PacketList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_PacketList
IFSelect_PacketList_swigregister = _IFSelect.IFSelect_PacketList_swigregister
IFSelect_PacketList_swigregister(IFSelect_PacketList)

def IFSelect_PacketList_get_type_name(*args):
    """
    IFSelect_PacketList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_PacketList_get_type_name(*args)

def IFSelect_PacketList_get_type_descriptor(*args):
    """
    IFSelect_PacketList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_PacketList_get_type_descriptor(*args)

class IFSelect_SelectShared(IFSelect_SelectDeduct):
    """
    A SelectShared selects Entities which are directly Shared
    by the Entities of the Input list
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectShared
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectShared(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectShared self) -> IFSelect_SelectShared

        Creates a SelectShared;


        """
        this = _IFSelect.new_IFSelect_SelectShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        shared by those of input list)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectShared_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectShared self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Shared (one level)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectShared_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectShared_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectShared_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectShared_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectShared
IFSelect_SelectShared_swigregister = _IFSelect.IFSelect_SelectShared_swigregister
IFSelect_SelectShared_swigregister(IFSelect_SelectShared)

def IFSelect_SelectShared_get_type_name(*args):
    """
    IFSelect_SelectShared_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectShared_get_type_name(*args)

def IFSelect_SelectShared_get_type_descriptor(*args):
    """
    IFSelect_SelectShared_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectShared_get_type_descriptor(*args)

class IFSelect_TransformStandard(IFSelect_Transformer):
    """
    This class runs transformations made by Modifiers, as
    the ModelCopier does when it produces files (the same set
    of Modifiers can then be used, as to transform the starting
    Model, as at file sending time).

    First, considering the resulting model, two options :
    - modifications are made directly on the starting model
    (OnTheSpot option), or
    - data are copied by the standard service Copy, only the
    remaining (not yet sent in a file) entities are copied
    (StandardCopy option)

    If a Selection is set, it forces the list of Entities on which
    the Modifiers are applied. Else, each Modifier is considered
    its Selection. By default, it is for the whole Model

    Then, the Modifiers are sequentially applied
    If at least one Modifier "May Change Graph", or if the option
    StandardCopy is selected, the graph will be recomputed
    (by the WorkSession, see method RunTransformer)

    Remark that a TransformStandard with option StandardCopy
    and no Modifier at all has the effect of computing the
    remaining data (those not yet sent in any output file).
    Moreover, the Protocol is not changed
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_TransformStandard
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_TransformStandard(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_TransformStandard self) -> IFSelect_TransformStandard

        Creates a TransformStandard, option StandardCopy, no Modifier


        """
        this = _IFSelect.new_IFSelect_TransformStandard(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCopyOption(self, *args):
        """
        SetCopyOption(IFSelect_TransformStandard self, Standard_Boolean const option)

        Sets the Copy option to a new value :
        - True for StandardCopy  - False for OnTheSpot

        :type option: bool

        """
        return _IFSelect.IFSelect_TransformStandard_SetCopyOption(self, *args)


    def CopyOption(self, *args):
        """
        CopyOption(IFSelect_TransformStandard self) -> Standard_Boolean

        Returns the Copy option

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_TransformStandard_CopyOption(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(IFSelect_TransformStandard self, Handle_IFSelect_Selection sel)

        Sets a Selection (or unsets if Null)
        This Selection then defines the list of entities on which the
        Modifiers will be applied
        If it is set, it has priority on Selections of Modifiers
        Else, for each Modifier its Selection is evaluated
        By default, all the Model is taken

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_TransformStandard_SetSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(IFSelect_TransformStandard self) -> Handle_IFSelect_Selection

        Returns the Selection, Null by default

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_TransformStandard_Selection(self, *args)


    def NbModifiers(self, *args):
        """
        NbModifiers(IFSelect_TransformStandard self) -> Standard_Integer

        Returns the count of recorded Modifiers

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_TransformStandard_NbModifiers(self, *args)


    def Modifier(self, *args):
        """
        Modifier(IFSelect_TransformStandard self, Standard_Integer const num) -> Handle_IFSelect_Modifier

        Returns a Modifier given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _IFSelect.IFSelect_TransformStandard_Modifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(IFSelect_TransformStandard self, Handle_IFSelect_Modifier modif) -> Standard_Integer

        Returns the rank of a Modifier in the list, 0 if unknown

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_TransformStandard_ModifierRank(self, *args)


    def AddModifier(self, *args):
        """
        AddModifier(IFSelect_TransformStandard self, Handle_IFSelect_Modifier modif, Standard_Integer const atnum=0) -> Standard_Boolean

        Adds a Modifier to the list :
        - <atnum> = 0 (default) : at the end of the list
        - <atnum> > 0 : at rank <atnum>
        Returns True if done, False if <atnum> is out of range

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_TransformStandard_AddModifier(self, *args)


    def RemoveModifier(self, *args):
        """
        RemoveModifier(IFSelect_TransformStandard self, Handle_IFSelect_Modifier modif) -> Standard_Boolean
        RemoveModifier(IFSelect_TransformStandard self, Standard_Integer const num) -> Standard_Boolean

        Removes a Modifier from the list, given its rank
        Returns True if done, False if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_TransformStandard_RemoveModifier(self, *args)


    def Perform(self, *args):
        """
        Perform(IFSelect_TransformStandard self, Interface_Graph G, Handle_Interface_Protocol protocol, Interface_CheckIterator checks, Handle_Interface_InterfaceModel newmod) -> Standard_Boolean

        Performs the Standard Transformation, by calling Copy then
        ApplyModifiers (which can return an error status)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_TransformStandard_Perform(self, *args)


    def Copy(self, *args):
        """
        Copy(IFSelect_TransformStandard self, Interface_Graph G, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        This the first operation. It calls StandardCopy or OnTheSpot
        according the option

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_TransformStandard_Copy(self, *args)


    def StandardCopy(self, *args):
        """
        StandardCopy(IFSelect_TransformStandard self, Interface_Graph G, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        This is the standard action of Copy : its takes into account
        only the remaining entities (noted by Graph Status positive)
        and their proper dependances of course. Produces a new model.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_TransformStandard_StandardCopy(self, *args)


    def OnTheSpot(self, *args):
        """
        OnTheSpot(IFSelect_TransformStandard self, Interface_Graph G, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        This is the OnTheSpot action : each entity is bound with ...
        itself. The produced model is the same as the starting one.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_TransformStandard_OnTheSpot(self, *args)


    def ApplyModifiers(self, *args):
        """
        ApplyModifiers(IFSelect_TransformStandard self, Interface_Graph G, Handle_Interface_Protocol protocol, Interface_CopyTool TC, Interface_CheckIterator checks, Handle_Interface_InterfaceModel newmod) -> Standard_Boolean

        Applies the modifiers sequencially.
        For each one, prepares required data (if a Selection is
        associated as a filter).
        For the option OnTheSpot, it determines if the graph may be
        changed and updates <newmod> if required
        If a Modifier causes an error (check "HasFailed"),
        ApplyModifier stops : the following Modifiers are ignored

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_TransformStandard_ApplyModifiers(self, *args)


    def Updated(self, *args):
        """
        Updated(IFSelect_TransformStandard self, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto) -> Standard_Boolean

        This methods allows to know what happened to a starting
        entity after the last Perform. It reads result from the map
        which was filled by Perform.

        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_TransformStandard_Updated(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_TransformStandard self) -> TCollection_AsciiString

        Returns a text which defines the way a Transformer works :
        "On the spot edition" or "Standard Copy" followed by
        "<nn> Modifiers"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_TransformStandard_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_TransformStandard_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_TransformStandard_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_TransformStandard_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_TransformStandard
IFSelect_TransformStandard_swigregister = _IFSelect.IFSelect_TransformStandard_swigregister
IFSelect_TransformStandard_swigregister(IFSelect_TransformStandard)

def IFSelect_TransformStandard_get_type_name(*args):
    """
    IFSelect_TransformStandard_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_TransformStandard_get_type_name(*args)

def IFSelect_TransformStandard_get_type_descriptor(*args):
    """
    IFSelect_TransformStandard_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_TransformStandard_get_type_descriptor(*args)

class IFSelect_SelectUnion(IFSelect_SelectCombine):
    """
    A SelectUnion cumulates the Entities issued from several other
    Selections (union of results : "OR" operator)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectUnion
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectUnion(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectUnion self) -> IFSelect_SelectUnion

        Creates an empty SelectUnion


        """
        this = _IFSelect.new_IFSelect_SelectUnion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectUnion self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected Entities, which is the addition
        result from all input selections. Uniqueness is guaranteed.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectUnion_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectUnion self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Union (OR)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectUnion_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectUnion_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectUnion_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectUnion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectUnion
IFSelect_SelectUnion_swigregister = _IFSelect.IFSelect_SelectUnion_swigregister
IFSelect_SelectUnion_swigregister(IFSelect_SelectUnion)

def IFSelect_SelectUnion_get_type_name(*args):
    """
    IFSelect_SelectUnion_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectUnion_get_type_name(*args)

def IFSelect_SelectUnion_get_type_descriptor(*args):
    """
    IFSelect_SelectUnion_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectUnion_get_type_descriptor(*args)

class IFSelect_SelectControl(IFSelect_Selection):
    """
    A SelectControl kind Selection works with two input Selections
    in a dissymmetric way : the Main Input which gives an input
    list of Entities, to be processed, and the Second Input which
    gives another list, to be used to filter the main input.

    e.g. : SelectDiff retains the items of the Main Input which
    are not in the Control Input (which acts as Diff Input)
    or a specific selection which retains Entities from the Main
    Input if and only if they are concerned by an entity from
    the Control Input (such as Views in IGES, etc...)

    The way RootResult and Label are produced are at charge of
    each sub-class
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectControl
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectControl(self) 
            return h


    def MainInput(self, *args):
        """
        MainInput(IFSelect_SelectControl self) -> Handle_IFSelect_Selection

        Returns the Main Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectControl_MainInput(self, *args)


    def HasSecondInput(self, *args):
        """
        HasSecondInput(IFSelect_SelectControl self) -> Standard_Boolean

        Returns True if a Control Input is defined
        Thus, Result can be computed differently if there is a
        Control Input or if there is none

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectControl_HasSecondInput(self, *args)


    def SecondInput(self, *args):
        """
        SecondInput(IFSelect_SelectControl self) -> Handle_IFSelect_Selection

        Returns the Control Input Selection, or a Null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectControl_SecondInput(self, *args)


    def SetMainInput(self, *args):
        """
        SetMainInput(IFSelect_SelectControl self, Handle_IFSelect_Selection sel)

        Sets a Selection to be the Main Input

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectControl_SetMainInput(self, *args)


    def SetSecondInput(self, *args):
        """
        SetSecondInput(IFSelect_SelectControl self, Handle_IFSelect_Selection sel)

        Sets a Selection to be the Control Input

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectControl_SetSecondInput(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(IFSelect_SelectControl self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_SelectControl_FillIterator(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectControl_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectControl_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectControl_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectControl
IFSelect_SelectControl_swigregister = _IFSelect.IFSelect_SelectControl_swigregister
IFSelect_SelectControl_swigregister(IFSelect_SelectControl)

def IFSelect_SelectControl_get_type_name(*args):
    """
    IFSelect_SelectControl_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectControl_get_type_name(*args)

def IFSelect_SelectControl_get_type_descriptor(*args):
    """
    IFSelect_SelectControl_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectControl_get_type_descriptor(*args)

class IFSelect_WorkSession(Standard.Standard_Transient):
    """
    This class can be used to simply manage a process such as
    splitting a file, extracting a set of Entities ...
    It allows to manage different types of Variables : Integer or
    Text Parameters, Selections, Dispatches, in addition to a
    ShareOut. To each of these variables, a unique Integer
    Identifier is attached. A Name can be attached too as desired.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_WorkSession
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_WorkSession(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_WorkSession self) -> IFSelect_WorkSession

        Creates a Work Session
        It provides default, empty ShareOut and ModelCopier, which can
        be replaced (if required, should be done just after creation).


        """
        this = _IFSelect.new_IFSelect_WorkSession(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(IFSelect_WorkSession self, Standard_Boolean const toHandle)

        Changes the Error Handler status (by default, it is not set)

        :type toHandle: bool

        """
        return _IFSelect.IFSelect_WorkSession_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(IFSelect_WorkSession self) -> Standard_Boolean

        Returns the Error Handler status

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ErrorHandle(self, *args)


    def ShareOut(self, *args):
        """
        Returns the ShareOut defined at creation time

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        res = _IFSelect.IFSelect_WorkSession_ShareOut(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShareOut(self, *args):
        """
        SetShareOut(IFSelect_WorkSession self, Handle_IFSelect_ShareOut shareout)

        Sets a new ShareOut. Fills Items which its content
        Warning : data from the former ShareOut are lost

        :type shareout: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        return _IFSelect.IFSelect_WorkSession_SetShareOut(self, *args)


    def SetModeStat(self, *args):
        """
        SetModeStat(IFSelect_WorkSession self, Standard_Boolean const theMode)

        Set value of mode responsible for precence of selections after loading
        If mode set to true that different selections will be accessible after loading
        else selections will be not accessible after loading( for economy memory in applicatios)

        :type theMode: bool

        """
        return _IFSelect.IFSelect_WorkSession_SetModeStat(self, *args)


    def GetModeStat(self, *args):
        """
        GetModeStat(IFSelect_WorkSession self) -> Standard_Boolean

        Return value of mode defining of filling selection during loading

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_GetModeStat(self, *args)


    def SetLibrary(self, *args):
        """
        SetLibrary(IFSelect_WorkSession self, Handle_IFSelect_WorkLibrary theLib)

        Sets a WorkLibrary, which will be used to Read and Write Files

        :type theLib: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _IFSelect.IFSelect_WorkSession_SetLibrary(self, *args)


    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary. Null Handle if not yet set
        should be C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _IFSelect.IFSelect_WorkSession_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetProtocol(self, *args):
        """
        SetProtocol(IFSelect_WorkSession self, Handle_Interface_Protocol protocol)

        Sets a Protocol, which will be used to determine Graphs, to
        Read and to Write Files

        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _IFSelect.IFSelect_WorkSession_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol. Null Handle if not yet set
        should be C++ : return const &

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _IFSelect.IFSelect_WorkSession_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSignType(self, *args):
        """
        SetSignType(IFSelect_WorkSession self, Handle_IFSelect_Signature signtype)

        Sets a specific Signature to be the SignType, i.e. the
        Signature which will determine TypeName from the Model
        (basic function). It is recorded in the GTool
        This Signature is also set as "xst-sign-type" (reserved name)

        :type signtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_WorkSession_SetSignType(self, *args)


    def SignType(self, *args):
        """
        SignType(IFSelect_WorkSession self) -> Handle_IFSelect_Signature

        Returns the current SignType

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_WorkSession_SignType(self, *args)


    def HasModel(self, *args):
        """
        HasModel(IFSelect_WorkSession self) -> Standard_Boolean

        Returns True is a Model has been set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_HasModel(self, *args)


    def SetModel(self, *args):
        """
        SetModel(IFSelect_WorkSession self, Handle_Interface_InterfaceModel model, Standard_Boolean const clearpointed)

        Sets a Model as input : this will be the Model from which the
        ShareOut will work
        if <clearpointed> is True (default) all SelectPointed items
        are cleared, else they must be managed by the caller
        Remark : SetModel clears the Graph, recomputes it if a
        Protocol is set and if the Model is not empty, of course

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type clearpointed: bool

        """
        return _IFSelect.IFSelect_WorkSession_SetModel(self, *args)


    def Model(self, *args):
        """
        Returns the Model of the Work Session (Null Handle if none)
        should be C++ : return const &

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _IFSelect.IFSelect_WorkSession_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLoadedFile(self, *args):
        """
        SetLoadedFile(IFSelect_WorkSession self, Standard_CString const theFileName)

        Stores the filename used for read for setting the model
        It is cleared by SetModel and ClearData(1)

        :type theFileName: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_SetLoadedFile(self, *args)


    def LoadedFile(self, *args):
        """
        LoadedFile(IFSelect_WorkSession self) -> Standard_CString

        Returns the filename used to load current model
        empty if unknown

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_LoadedFile(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(IFSelect_WorkSession self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Reads a file with the WorkLibrary (sets Model and LoadedFile)
        Returns a integer status which can be :
        RetDone if OK,  RetVoid if no Protocol not defined,
        RetError for file not found, RetFail if fail during read

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_ReadFile(self, *args)


    def NbStartingEntities(self, *args):
        """
        NbStartingEntities(IFSelect_WorkSession self) -> Standard_Integer

        Returns the count of Entities stored in the Model, or 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NbStartingEntities(self, *args)


    def StartingEntity(self, *args):
        """
        StartingEntity(IFSelect_WorkSession self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns an  Entity stored in the Model of the WorkSession
        (Null Handle is no Model or num out of range)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_WorkSession_StartingEntity(self, *args)


    def StartingNumber(self, *args):
        """
        StartingNumber(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Number of an Entity in the Model
        (0 if no Model set or <ent> not in the Model)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_StartingNumber(self, *args)


    def NumberFromLabel(self, *args):
        """
        NumberFromLabel(IFSelect_WorkSession self, Standard_CString const val, Standard_Integer const afternum=0) -> Standard_Integer

        From a given label in Model, returns the corresponding number
        Starts from first entity by Default, may start after a given
        number : this number may be given negative, its absolute value
        is then considered. Hence a loop on NumberFromLabel may be
        programmed (stop test is : returned value positive or null)

        Returns 0 if not found, < 0 if more than one found (first
        found in negative).
        If <val> just gives an integer value, returns it

        :type val: OCC.wrapper.Standard.Standard_CString
        :type afternum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NumberFromLabel(self, *args)


    def EntityLabel(self, *args):
        """
        EntityLabel(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns the label for <ent>, as the Model does
        If <ent> is not in the Model or if no Model is loaded, a Null
        Handle is returned

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_EntityLabel(self, *args)


    def EntityName(self, *args):
        """
        EntityName(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns the Name of an Entity
        This Name is computed by the general service Name
        Returns a Null Handle if fails

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_EntityName(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Category Number determined for an entity
        it is computed by the class Category
        An unknown entity (number 0) gives a value -1

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_CategoryNumber(self, *args)


    def CategoryName(self, *args):
        """
        CategoryName(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Category Name determined for an entity
        it is computed by the class Category
        Remark : an unknown entity gives an empty string

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_CategoryName(self, *args)


    def ValidityName(self, *args):
        """
        ValidityName(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Validity Name determined for an entity
        it is computed by the class SignValidity
        Remark : an unknown entity gives an empty string

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_ValidityName(self, *args)


    def ClearData(self, *args):
        """
        ClearData(IFSelect_WorkSession self, Standard_Integer const mode)

        Clears recorded data (not the items) according mode :
        1 : all Data : Model, Graph, CheckList, + ClearData 4
        2 : Graph and CheckList (they will then be recomputed later)
        3 : CheckList (it will be recomputed by ComputeCheck)
        4 : just content of SelectPointed and Counters
        Plus 0 : does nothing but called by SetModel
        ClearData is virtual, hence it can be redefined to clear
        other data of a specialised Work Session

        :type mode: int

        """
        return _IFSelect.IFSelect_WorkSession_ClearData(self, *args)


    def ComputeGraph(self, *args):
        """
        ComputeGraph(IFSelect_WorkSession self, Standard_Boolean const enforce) -> Standard_Boolean

        Computes the Graph used for Selections, Displays ...
        If a HGraph is already set, with same model as given by method
        Model, does nothing. Else, computes a new Graph.
        If <enforce> is given True, computes a new Graph anyway.
        Remark that a call to ClearGraph will cause ComputeGraph to
        really compute a new Graph
        Returns True if Graph is OK, False else (i.e. if no Protocol
        is set, or if Model is absent or empty).

        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ComputeGraph(self, *args)


    def HGraph(self, *args):
        """
        HGraph(IFSelect_WorkSession self) -> Handle_Interface_HGraph

        Returns the Computed Graph as HGraph (Null Handle if not set)

        :rtype: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _IFSelect.IFSelect_WorkSession_HGraph(self, *args)


    def Graph(self, *args):
        """
        Returns the Computed Graph, for Read only

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _IFSelect.IFSelect_WorkSession_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shareds(self, *args):
        """
        Shareds(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities shared by <ent> (can be empty)
        Returns a null Handle if <ent> is unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_Shareds(self, *args)


    def Sharings(self, *args):
        """
        Sharings(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities sharing <ent> (can be empty)
        Returns a null Handle if <ent> is unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_Sharings(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(IFSelect_WorkSession self) -> Standard_Boolean

        Returns True if a Model is defined and really loaded (not
        empty), a Protocol is set and a Graph has been computed.
        In this case, the WorkSession can start to work

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_IsLoaded(self, *args)


    def ComputeCheck(self, *args):
        """
        ComputeCheck(IFSelect_WorkSession self, Standard_Boolean const enforce) -> Standard_Boolean

        Computes the CheckList for the Model currently loaded
        It can then be used for displays, querries ...
        Returns True if OK, False else (i.e. no Protocol set, or Model
        absent). If <enforce> is False, works only if not already done
        or if a new Model has been loaded from last call.
        Remark : computation is enforced by every call to
        SetModel or RunTransformer

        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ComputeCheck(self, *args)


    def ModelCheckList(self, *args):
        """
        ModelCheckList(IFSelect_WorkSession self, Standard_Boolean const complete) -> Interface_CheckIterator

        Returns the Check List for the Model currently loaded :
        <complete> = True  : complete (syntactic & semantic messages),
        computed if not yet done
        <complete> = False : only syntactic (check file form)

        :type complete: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_ModelCheckList(self, *args)


    def CheckOne(self, *args):
        """
        CheckOne(IFSelect_WorkSession self, Handle_Standard_Transient ent, Standard_Boolean const complete) -> Interface_CheckIterator

        Returns a Check for a single entity, under the form of a
        CheckIterator (this gives only one form for the user)
        if <ent> is Null or equates the current Model, it gives the
        Global Check, else the Check for the given entity
        <complete> as for ModelCheckList

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type complete: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_CheckOne(self, *args)


    def LastRunCheckList(self, *args):
        """
        LastRunCheckList(IFSelect_WorkSession self) -> Interface_CheckIterator

        Returns the Check List produced by the last execution of
        either : EvaluateFile(for Split), SendSplit, SendAll,
        SendSelected, RunTransformer-RunModifier
        Cleared by SetModel or ClearData(1)
        The field is protected, hence a specialized WorkSession may
        fill it

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_LastRunCheckList(self, *args)


    def MaxIdent(self, *args):
        """
        MaxIdent(IFSelect_WorkSession self) -> Standard_Integer

        Returns the Maximum Value for an Item Identifier. It can be
        greater to the count of known Items, because some can have
        been removed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_MaxIdent(self, *args)


    def Item(self, *args):
        """
        Item(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_Standard_Transient

        Returns an Item, given its Ident. Returns a Null Handle if
        no Item corresponds to this Ident.

        :type id: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_WorkSession_Item(self, *args)


    def ItemIdent(self, *args):
        """
        ItemIdent(IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Integer

        Returns the Ident attached to an Item in the WorkSession, or
        Zero if it is unknown

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_ItemIdent(self, *args)


    def NamedItem(self, *args):
        """
        NamedItem(IFSelect_WorkSession self, Standard_CString const name) -> Handle_Standard_Transient
        NamedItem(IFSelect_WorkSession self, Handle_TCollection_HAsciiString name) -> Handle_Standard_Transient

        Same as above, but <name> is given through a Handle
        Especially Usefull with methods SelectionNames, etc...

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_WorkSession_NamedItem(self, *args)


    def NameIdent(self, *args):
        """
        NameIdent(IFSelect_WorkSession self, Standard_CString const name) -> Standard_Integer

        Returns the Ident attached to a Name, 0 if name not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NameIdent(self, *args)


    def HasName(self, *args):
        """
        HasName(IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Returns True if an Item of the WorkSession has an attached Name

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_HasName(self, *args)


    def Name(self, *args):
        """
        Name(IFSelect_WorkSession self, Handle_Standard_Transient item) -> Handle_TCollection_HAsciiString

        Returns the Name attached to an Item as a Variable of this
        WorkSession. If <item> is Null or not recorded, returns an
        empty string.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_Name(self, *args)


    def AddItem(self, *args):
        """
        AddItem(IFSelect_WorkSession self, Handle_Standard_Transient item, Standard_Boolean const active) -> Standard_Integer

        Adds an Item and returns its attached Ident. Does nothing
        if <item> is already recorded (and returns its attached Ident)
        <active> if True commands call to SetActive (see below)
        Remark : the determined Ident is used if <item> is a Dispatch,
        to fill the ShareOut

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_AddItem(self, *args)


    def AddNamedItem(self, *args):
        """
        AddNamedItem(IFSelect_WorkSession self, Standard_CString const name, Handle_Standard_Transient item, Standard_Boolean const active) -> Standard_Integer

        Adds an Item with an attached Name. If the Name is already
        known in the WorkSession, the older item losts it
        Returns Ident if Done, 0 else, i.e. if <item> is null
        If <name> is empty, works as AddItem (i.e. with no name)
        If <item> is already known but with no attached Name, this
        method tries to attached a Name to it
        <active> if True commands call to SetActive (see below)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_AddNamedItem(self, *args)


    def SetActive(self, *args):
        """
        SetActive(IFSelect_WorkSession self, Handle_Standard_Transient item, Standard_Boolean const mode) -> Standard_Boolean

        Following the type of <item> :
        - Dispatch : Adds or Removes it in the ShareOut & FileNaming
        - GeneralModifier : Adds or Removes it for final sending
        (i.e. in the ModelCopier)
        Returns True if it did something, False else (state unchanged)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mode: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetActive(self, *args)


    def RemoveNamedItem(self, *args):
        """
        RemoveNamedItem(IFSelect_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Removes an Item from the Session, given its Name
        Returns True if Done, False else (Name not recorded)
        (Applies only on Item which are Named)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_RemoveNamedItem(self, *args)


    def RemoveName(self, *args):
        """
        RemoveName(IFSelect_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Removes a Name without removing the Item
        Returns True if Done, False else (Name not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_RemoveName(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an Item given its Ident. Returns False if <id> is
        attached to no Item in the WorkSession. For a Named Item,
        also removes its Name.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_RemoveItem(self, *args)


    def ClearItems(self, *args):
        """
        ClearItems(IFSelect_WorkSession self)

        Clears all the recorded Items : Selections, Dispatches,
        Modifiers, and Strings & IntParams, with their Idents & Names.
        Remark that if a Model has been loaded, it is not cleared.


        """
        return _IFSelect.IFSelect_WorkSession_ClearItems(self, *args)


    def ItemLabel(self, *args):
        """
        ItemLabel(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_TCollection_HAsciiString

        Returns a Label which illustrates the content of an Item,
        given its Ident. This Label is :
        - for a Text Parameter, "Text:<text value>"
        - for an Integer Parameter, "Integer:<integer value>"
        - for a Selection, a Dispatch or a Modifier, its Label
        (see these classes)
        - for any other kind of Variable, its cdl type

        :type id: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_ItemLabel(self, *args)


    def ItemIdents(self, *args):
        """
        ItemIdents(IFSelect_WorkSession self, Handle_Standard_Type type) -> Handle_TColStd_HSequenceOfInteger

        Fills a Sequence with the List of Idents attached to the Items
        of which Type complies with (IsKind) <type> (alphabetic order)
        Remark : <type> = TYPE(Standard_Transient) gives all the
        Idents which are suitable in the WorkSession

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.IFSelect_WorkSession_ItemIdents(self, *args)


    def ItemNames(self, *args):
        """
        ItemNames(IFSelect_WorkSession self, Handle_Standard_Type type) -> Handle_TColStd_HSequenceOfHAsciiString

        Fills a Sequence with the list of the Names attached to Items
        of which Type complies with (IsKind) <type> (alphabetic order)
        Remark : <type> = TYPE(Standard_Transient) gives all the Names

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_ItemNames(self, *args)


    def ItemNamesForLabel(self, *args):
        """
        ItemNamesForLabel(IFSelect_WorkSession self, Standard_CString const label) -> Handle_TColStd_HSequenceOfHAsciiString

        Fills a Sequence with the NAMES of the control items, of which
        the label matches <label> (contain it) : see NextIdentForLabel
        Search mode is fixed to "contained"
        If <label> is empty, returns all Names

        :type label: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_ItemNamesForLabel(self, *args)


    def NextIdentForLabel(self, *args):
        """
        NextIdentForLabel(IFSelect_WorkSession self, Standard_CString const label, Standard_Integer const id, Standard_Integer const mode=0) -> Standard_Integer

        For query by Label with possible iterations
        Searches the Ident of which Item has a Label which matches a
        given one, the search starts from an initial Ident.
        Returns the first found Ident which follows <id>, or ZERO

        The search must start with <id> = 0, it returns the next Ident
        which matches. To iterate, call again this method which this
        returned value as <id>. Once an Ident has been returned, the
        Item can be obtained by the method Item

        <mode> precises the required matching mode :
        - 0 (Default) : <label> must match exactly with the Item Label
        - 1 : <label> must match the exact beginning (the end is free)
        - 2 : <label> must be at least once wherever in the Item Label
        - other values are ignored

        :type label: OCC.wrapper.Standard.Standard_CString
        :type id: int
        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NextIdentForLabel(self, *args)


    def NewParamFromStatic(self, *args):
        """
        NewParamFromStatic(IFSelect_WorkSession self, Standard_CString const statname, Standard_CString const name) -> Handle_Standard_Transient

        Creates a parameter as being bound to a Static
        If the Static is Integer, this creates an IntParam bound to
        it by its name. Else this creates a String which is the value
        of the Static.
        Returns a null handle if <statname> is unknown as a Static

        :type statname: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_WorkSession_NewParamFromStatic(self, *args)


    def IntParam(self, *args):
        """
        IntParam(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_IntParam

        Returns an IntParam, given its Ident in the Session
        Null result if <id> is not suitable for an IntParam
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_WorkSession_IntParam(self, *args)


    def IntValue(self, *args):
        """
        IntValue(IFSelect_WorkSession self, Handle_IFSelect_IntParam it) -> Standard_Integer

        Returns Integer Value of an IntParam

        :type it: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_IntValue(self, *args)


    def NewIntParam(self, *args):
        """
        NewIntParam(IFSelect_WorkSession self, Standard_CString const name) -> Handle_IFSelect_IntParam

        Creates a new IntParam. A Name can be set (Optional)
        Returns the created IntParam, or a Null Handle in case of
        Failure (see AddItem/AddNamedItem)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_WorkSession_NewIntParam(self, *args)


    def SetIntValue(self, *args):
        """
        SetIntValue(IFSelect_WorkSession self, Handle_IFSelect_IntParam it, Standard_Integer const val) -> Standard_Boolean

        Changes the Integer Value of an IntParam
        Returns True if Done, False if <it> is not in the WorkSession

        :type it: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetIntValue(self, *args)


    def TextParam(self, *args):
        """
        TextParam(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_TCollection_HAsciiString

        Returns a TextParam, given its Ident in the Session
        Null result if <id> is not suitable for a TextParam
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_TextParam(self, *args)


    def TextValue(self, *args):
        """
        TextValue(IFSelect_WorkSession self, Handle_TCollection_HAsciiString par) -> TCollection_AsciiString

        Returns Text Value of a TextParam (a String)
        or an empty string if <it> is not in the WorkSession

        :type par: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_WorkSession_TextValue(self, *args)


    def NewTextParam(self, *args):
        """
        NewTextParam(IFSelect_WorkSession self, Standard_CString const name) -> Handle_TCollection_HAsciiString

        Creates a new (empty) TextParam. A Name can be set (Optional)
        Returns the created TextParam (as an HAsciiString), or a Null
        Handle in case of Failure (see AddItem/AddNamedItem)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_NewTextParam(self, *args)


    def SetTextValue(self, *args):
        """
        SetTextValue(IFSelect_WorkSession self, Handle_TCollection_HAsciiString par, Standard_CString const val) -> Standard_Boolean

        Changes the Text Value of a TextParam (an HAsciiString)
        Returns True if Done, False if <it> is not in the WorkSession

        :type par: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetTextValue(self, *args)


    def Signature(self, *args):
        """
        Signature(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Signature

        Returns a Signature, given its Ident in the Session
        Null result if <id> is not suitable for a Signature
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_WorkSession_Signature(self, *args)


    def SignValue(self, *args):
        """
        SignValue(IFSelect_WorkSession self, Handle_IFSelect_Signature sign, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Value computed by a Signature for an Entity
        Returns an empty string if the entity does not belong to the
        loaded model

        :type sign: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_SignValue(self, *args)


    def Selection(self, *args):
        """
        Selection(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Selection

        Returns a Selection, given its Ident in the Session
        Null result if <id> is not suitable for a Selection
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_Selection(self, *args)


    def EvalSelection(self, *args):
        """
        EvalSelection(IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Interface_EntityIterator

        Evaluates the effect of a Selection applied on the input Model
        Returned Result remains empty if no input Model has been set

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_WorkSession_EvalSelection(self, *args)


    def Sources(self, *args):
        """
        Sources(IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> IFSelect_SelectionIterator

        Returns the Selections which are source of Selection, given
        its rank in the List of Selections (see SelectionIterator)
        Returned value is empty if <num> is out of range or if
        <sel> is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_WorkSession_Sources(self, *args)


    def SelectionResult(self, *args):
        """
        SelectionResult(IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Handle_TColStd_HSequenceOfTransient

        Returns the result of a Selection, computed by EvalSelection
        (see above) under the form of a HSequence (hence, it can be
        used by a frontal-engine logic). It can be empty
        Returns a Null Handle if <sel> is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_SelectionResult(self, *args)


    def SelectionResultFromList(self, *args):
        """
        SelectionResultFromList(IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_TColStd_HSequenceOfTransient list) -> Handle_TColStd_HSequenceOfTransient

        Returns the result of a Selection, by forcing its input with
        a given list <list> (unless <list> is Null).
        RULES :
        <list> applies only for a SelectDeduct kind Selection :
        its Input is considered : if it is a SelectDeduct kind
        Selection, its Input is considered, etc... until an Input
        is not a Deduct/Extract : its result is replaced by <list>
        and all the chain of deductions is applied

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_SelectionResultFromList(self, *args)


    def SetItemSelection(self, *args):
        """
        SetItemSelection(IFSelect_WorkSession self, Handle_Standard_Transient item, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Sets a Selection as input for an item, according its type :
        if <item> is a Dispatch : as Final Selection
        if <item> is a GeneralModifier (i.e. any kind of Modifier) :
        as Selection used to filter entities to modify
        <sel>  Null  causes this Selection to be nullified
        Returns False if <item> is not of a suitable type, or
        <item> or <sel> is not in the WorkSession

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetItemSelection(self, *args)


    def ResetItemSelection(self, *args):
        """
        ResetItemSelection(IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Resets input Selection which was set by SetItemSelection
        Same conditions as for SetItemSelection
        Returns True if done, False if <item> is not in the WorkSession

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ResetItemSelection(self, *args)


    def ItemSelection(self, *args):
        """
        ItemSelection(IFSelect_WorkSession self, Handle_Standard_Transient item) -> Handle_IFSelect_Selection

        Returns the Selection of a Dispatch or a GeneralModifier.
        Returns a Null Handle if none is defined or <item> not good type

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_ItemSelection(self, *args)


    def SignCounter(self, *args):
        """
        SignCounter(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_SignCounter

        Returns a SignCounter from its ident in the Session
        Null result if <id> is not suitable for a SignCounter
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.IFSelect_WorkSession_SignCounter(self, *args)


    def ComputeCounter(self, *args):
        """
        ComputeCounter(IFSelect_WorkSession self, Handle_IFSelect_SignCounter counter, Standard_Boolean const forced) -> Standard_Boolean

        Computes the content of a SignCounter when it is defined with
        a Selection, then returns True
        Returns False if the SignCounter is not defined with a
        Selection, or if its Selection Mode is inhibited
        <forced> to work around optimisations

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type forced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ComputeCounter(self, *args)


    def ComputeCounterFromList(self, *args):
        """
        ComputeCounterFromList(IFSelect_WorkSession self, Handle_IFSelect_SignCounter counter, Handle_TColStd_HSequenceOfTransient list, Standard_Boolean const clear) -> Standard_Boolean

        Computes the content of a SignCounter from an input list
        If <list> is Null, uses internal definition of the Counter :
        a Selection, else the whole Model (recomputation forced)
        If <clear> is True (D), starts from scratch
        Else, cumulates computations

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type clear: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ComputeCounterFromList(self, *args)


    def AppliedDispatches(self, *args):
        """
        AppliedDispatches(IFSelect_WorkSession self) -> Handle_TColStd_HSequenceOfInteger

        Returns the ordered list of dispatches stored by the ShareOut

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.IFSelect_WorkSession_AppliedDispatches(self, *args)


    def ClearShareOut(self, *args):
        """
        ClearShareOut(IFSelect_WorkSession self, Standard_Boolean const onlydisp)

        Clears the list of Dispatches recorded by the ShareOut
        if <only> disp is True, tha's all. Else, clears also the lists
        of Modifiers recorded by the ShareOut

        :type onlydisp: bool

        """
        return _IFSelect.IFSelect_WorkSession_ClearShareOut(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Dispatch

        Returns a Dispatch, given its Ident in the Session
        Null result if <id> is not suitable for a Dispatch
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.IFSelect_WorkSession_Dispatch(self, *args)


    def DispatchRank(self, *args):
        """
        DispatchRank(IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp) -> Standard_Integer

        Returns the rank of a Dispatch in the ShareOut, or 0 if <disp>
        is not in the ShareOut or not in the WorkSession

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_DispatchRank(self, *args)


    def ModelCopier(self, *args):
        """
        Gives access to the complete ModelCopier

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ModelCopier

        """
        res = _IFSelect.IFSelect_WorkSession_ModelCopier(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetModelCopier(self, *args):
        """
        SetModelCopier(IFSelect_WorkSession self, Handle_IFSelect_ModelCopier copier)

        Sets a new ModelCopier. Fills Items which its content

        :type copier: OCC.wrapper.IFSelect.Handle_IFSelect_ModelCopier

        """
        return _IFSelect.IFSelect_WorkSession_SetModelCopier(self, *args)


    def NbFinalModifiers(self, *args):
        """
        NbFinalModifiers(IFSelect_WorkSession self, Standard_Boolean const formodel) -> Standard_Integer

        Returns the count of Modifiers applied to final sending
        Model Modifiers if <formodel> is True, File Modifiers else
        (i.e. Modifiers which apply once the Models have been filled)

        :type formodel: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NbFinalModifiers(self, *args)


    def FinalModifierIdents(self, *args):
        """
        FinalModifierIdents(IFSelect_WorkSession self, Standard_Boolean const formodel) -> Handle_TColStd_HSequenceOfInteger

        Fills a Sequence with a list of Idents, those attached to
        the Modifiers applied to final sending.
        Model Modifiers if <formodel> is True, File Modifiers else
        This list is given in the order in which they will be applied
        (which takes into account the Changes to Modifier Ranks)

        :type formodel: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.IFSelect_WorkSession_FinalModifierIdents(self, *args)


    def GeneralModifier(self, *args):
        """
        GeneralModifier(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_GeneralModifier

        Returns a Modifier, given its Ident in the Session
        Null result if <id> is not suitable for a Modifier
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _IFSelect.IFSelect_WorkSession_GeneralModifier(self, *args)


    def ModelModifier(self, *args):
        """
        ModelModifier(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Modifier

        Returns a Model Modifier, given its Ident in the Session,
        i.e. typed as a Modifier (not simply a GeneralModifier)
        Null result if <id> is not suitable for a Modifier
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _IFSelect.IFSelect_WorkSession_ModelModifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier item) -> Standard_Integer

        Returns the Rank of a Modifier given its Ident. Model or File
        Modifier according its type (ModelModifier or not)
        Remember that Modifiers are applied sequencially following
        their Rank : first Model Modifiers then File Modifiers
        Rank is given by rank of call to AddItem and can be
        changed by ChangeModifierRank

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_ModifierRank(self, *args)


    def ChangeModifierRank(self, *args):
        """
        ChangeModifierRank(IFSelect_WorkSession self, Standard_Boolean const formodel, Standard_Integer const before, Standard_Integer const after) -> Standard_Boolean

        Changes the Rank of a Modifier in the Session :
        Model Modifiers if <formodel> is True, File Modifiers else
        the Modifier n0 <before> is put to n0 <after>
        Return True if Done, False if <before> or <after> out of range

        :type formodel: bool
        :type before: int
        :type after: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ChangeModifierRank(self, *args)


    def ClearFinalModifiers(self, *args):
        """
        ClearFinalModifiers(IFSelect_WorkSession self)

        Removes all the Modifiers active in the ModelCopier : they
        become inactive and they are removed from the Session


        """
        return _IFSelect.IFSelect_WorkSession_ClearFinalModifiers(self, *args)


    def SetAppliedModifier(self, *args):
        """
        SetAppliedModifier(IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier modif, Handle_Standard_Transient item) -> Standard_Boolean

        Sets a GeneralModifier to be applied to an item :
        - item = ShareOut : applies for final sending (all dispatches)
        - item is a Dispatch : applies for this dispatch only
        Returns True if done, False if <modif> or <item> not in <me>

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetAppliedModifier(self, *args)


    def ResetAppliedModifier(self, *args):
        """
        ResetAppliedModifier(IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Resets a GeneralModifier to be applied
        Returns True if done, False if <modif> was not applied

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ResetAppliedModifier(self, *args)


    def UsesAppliedModifier(self, *args):
        """
        UsesAppliedModifier(IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier modif) -> Handle_Standard_Transient

        Returns the item on which a GeneralModifier is applied :
        the ShareOut, or a given Dispatch
        Returns a Null Handle if <modif> is not applied

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_WorkSession_UsesAppliedModifier(self, *args)


    def Transformer(self, *args):
        """
        Transformer(IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Transformer

        Returns a Transformer, given its Ident in the Session
        Null result if <id> is not suitable for a Transformer
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _IFSelect.IFSelect_WorkSession_Transformer(self, *args)


    def RunTransformer(self, *args):
        """
        RunTransformer(IFSelect_WorkSession self, Handle_IFSelect_Transformer transf) -> Standard_Integer

        Runs a Transformer on starting Model, which can then be edited
        or replaced by a new one. The Protocol can also be changed.
        Fills LastRunCheckList

        Returned status is 0 if nothing done (<transf> or model
        undefined), positive if OK, negative else :
        0  : Nothing done
        1  : OK, edition on the spot with no change to the graph
        of dependances (purely local)
        2  : OK, model edited on the spot (graph recomputed, may
        have changed), protocol unchanged
        3  : OK, new model produced, same protocol
        4  : OK, model edited on the spot (graph recomputed),
        but protocol has changed
        5  : OK, new model produced, protocol has changed
        -1 : Error on the spot (slight changes), data may be corrupted
        (remark : corruption should not be profound)
        -2 : Error on edition the spot, data may be corrupted
        (checking them is recommanded)
        -3 : Error with a new data set, transformation ignored
        -4 : OK as 4, but graph of dependances count not be recomputed
        (the former one is kept) : check the protocol

        :type transf: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_RunTransformer(self, *args)


    def RunModifier(self, *args):
        """
        RunModifier(IFSelect_WorkSession self, Handle_IFSelect_Modifier modif, Standard_Boolean const copy) -> Standard_Integer

        Runs a Modifier on Starting Model. It can modify entities, or
        add new ones. But the Model or the Protocol is unchanged.
        The Modifier is applied on each entity of the Model. See also
        RunModifierSelected
        Fills LastRunCheckList

        <copy> : if True, a new data set is produced which brings
        the modifications (Model + its Entities)
        if False, data are modified on the spot

        It works through a TransformStandard defined with <modif>
        Returned status as RunTransformer : 0 nothing done, >0 OK,
        <0 problem, but only between -3 and 3 (protocol unchanged)
        Remark : <copy> True will give <effect> = 3 or -3

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type copy: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_RunModifier(self, *args)


    def RunModifierSelected(self, *args):
        """
        RunModifierSelected(IFSelect_WorkSession self, Handle_IFSelect_Modifier modif, Handle_IFSelect_Selection sel, Standard_Boolean const copy) -> Standard_Integer

        Acts as RunModifier, but the Modifier is applied on the list
        determined by a Selection, rather than on the whole Model
        If the selection is a null handle, the whole model is taken

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type copy: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_RunModifierSelected(self, *args)


    def NewTransformStandard(self, *args):
        """
        NewTransformStandard(IFSelect_WorkSession self, Standard_Boolean const copy, Standard_CString const name) -> Handle_IFSelect_Transformer

        Creates and returns a TransformStandard, empty, with its
        Copy Option (True = Copy, False = On the Spot) and an
        optional name.
        To a TransformStandard, the method SetAppliedModifier applies

        :type copy: bool
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _IFSelect.IFSelect_WorkSession_NewTransformStandard(self, *args)


    def SetModelContent(self, *args):
        """
        SetModelContent(IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Standard_Boolean const keep) -> Standard_Boolean

        Defines a new content from the former one
        If <keep> is True, it is given by entities selected by
        Selection <sel>  (and all shared entities)
        Else, it is given by all the former content but entities
        selected by the Selection <sel> (and properly shared ones)
        Returns True if done. Returns False if the selected list
        (from <sel>) is empty, hence nothing is done

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type keep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetModelContent(self, *args)


    def FilePrefix(self, *args):
        """
        FilePrefix(IFSelect_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined File Prefix. Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_FilePrefix(self, *args)


    def DefaultFileRoot(self, *args):
        """
        DefaultFileRoot(IFSelect_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined Default File Root. It is used for
        Dispatches which have no specific root attached.
        Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_DefaultFileRoot(self, *args)


    def FileExtension(self, *args):
        """
        FileExtension(IFSelect_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined File Extension. Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_FileExtension(self, *args)


    def FileRoot(self, *args):
        """
        FileRoot(IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp) -> Handle_TCollection_HAsciiString

        Returns the File Root defined for a Dispatch. Null if no
        Root Name is defined for it (hence, no File will be produced)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_FileRoot(self, *args)


    def SetFilePrefix(self, *args):
        """
        SetFilePrefix(IFSelect_WorkSession self, Standard_CString const name)

        Defines a File Prefix

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_SetFilePrefix(self, *args)


    def SetDefaultFileRoot(self, *args):
        """
        SetDefaultFileRoot(IFSelect_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Defines a Default File Root Name. Clears it is <name> = ""
        Returns True if OK, False if <name> already set for a Dispatch

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetDefaultFileRoot(self, *args)


    def SetFileExtension(self, *args):
        """
        SetFileExtension(IFSelect_WorkSession self, Standard_CString const name)

        Defines a File Extension

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_SetFileExtension(self, *args)


    def SetFileRoot(self, *args):
        """
        SetFileRoot(IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp, Standard_CString const name) -> Standard_Boolean

        Defines a Root for a Dispatch
        If <name> is empty, clears Root Name
        This has as effect to inhibit the production of File by <disp>
        Returns False if <disp> is not in the WorkSession or if a
        root name is already defined for it

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetFileRoot(self, *args)


    def GiveFileRoot(self, *args):
        """
        GiveFileRoot(IFSelect_WorkSession self, Standard_CString const file) -> Standard_CString

        Extracts File Root Name from a given complete file name
        (uses OSD_Path)

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_GiveFileRoot(self, *args)


    def GiveFileComplete(self, *args):
        """
        GiveFileComplete(IFSelect_WorkSession self, Standard_CString const file) -> Standard_CString

        Completes a file name as required, with Prefix and Extension
        (if defined; for a non-defined item, completes nothing)

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_GiveFileComplete(self, *args)


    def ClearFile(self, *args):
        """
        ClearFile(IFSelect_WorkSession self)

        Erases all stored data from the File Evaluation
        (i.e. ALL former naming informations are lost)


        """
        return _IFSelect.IFSelect_WorkSession_ClearFile(self, *args)


    def EvaluateFile(self, *args):
        """
        EvaluateFile(IFSelect_WorkSession self)

        Performs and stores a File Evaluation. The Results are a List
        of produced Models and a List of names (Strings), in parallel
        Fills LastRunCheckList


        """
        return _IFSelect.IFSelect_WorkSession_EvaluateFile(self, *args)


    def NbFiles(self, *args):
        """
        NbFiles(IFSelect_WorkSession self) -> Standard_Integer

        Returns the count of produced Models

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NbFiles(self, *args)


    def FileModel(self, *args):
        """
        FileModel(IFSelect_WorkSession self, Standard_Integer const num) -> Handle_Interface_InterfaceModel

        Returns a Model, given its rank in the Evaluation List

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_WorkSession_FileModel(self, *args)


    def FileName(self, *args):
        """
        FileName(IFSelect_WorkSession self, Standard_Integer const num) -> TCollection_AsciiString

        Returns the name of a file corresponding to a produced Model,
        given its rank in the Evaluation List

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_WorkSession_FileName(self, *args)


    def BeginSentFiles(self, *args):
        """
        BeginSentFiles(IFSelect_WorkSession self, Standard_Boolean const record)

        Commands file sending to clear the list of already sent files,
        commands to record a new one if <record> is True
        This list is managed by the ModelCopier when SendSplit is called
        It allows a global exploitation of the set of sent files

        :type record: bool

        """
        return _IFSelect.IFSelect_WorkSession_BeginSentFiles(self, *args)


    def SentFiles(self, *args):
        """
        SentFiles(IFSelect_WorkSession self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of recorded sent files, or a Null Handle is
        recording has not been enabled

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_WorkSession_SentFiles(self, *args)


    def SendSplit(self, *args):
        """
        SendSplit(IFSelect_WorkSession self) -> Standard_Boolean

        Performs creation of derived files from the input Model
        Takes its data (sub-models and names), from result EvaluateFile
        if active, else by dynamic Evaluation (not stored)
        After SendSplit, result of EvaluateFile is Cleared
        Fills LastRunCheckList

        Works with the WorkLibrary which acts on specific type of Model
        and can work with File Modifiers (managed by the Model Copier)
        and a ModelCopier, which can work with Model Modifiers
        Returns False if, either WorkLibrary has failed on at least
        one sub-file, or the Work Session is badly conditionned
        (no Model defined, or FileNaming not in phase with ShareOut)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SendSplit(self, *args)


    def EvalSplit(self, *args):
        """
        EvalSplit(IFSelect_WorkSession self) -> Handle_IFSelect_PacketList

        Returns an Evaluation of the whole ShareOut definition : i.e.
        how the entities of the starting model are forecast to be sent
        to various files :  list of packets according the dispatches,
        effective lists of roots for each packet (which determine the
        content of the corresponding file); plus evaluation of which
        entities are : forgotten (sent into no file), duplicated (sent
        into more than one file), sent into a given file.
        See the class PacketList for more details.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_PacketList

        """
        return _IFSelect.IFSelect_WorkSession_EvalSplit(self, *args)


    def SentList(self, *args):
        """
        SentList(IFSelect_WorkSession self, Standard_Integer const count=-1) -> Interface_EntityIterator

        Returns the list of Entities sent in files, accourding the
        count of files each one has been sent (these counts are reset
        by SetModel or SetRemaining(Forget) ) stored in Graph Status
        <count> = -1 (default) is for ENtities sent at least once
        <count> = 0 is for the Remaining List (entities not yet sent)
        <count> = 1 is for entities sent in one and only one file
        (the ideal case)
        Remaining Data are computed on each Sending/Copying output
        files (see methods EvaluateFile and SendSplit)
        Graph Status is 0 for Remaining Entity, <count> for Sent into
        <count> files
        This status is set to 0 (not yet sent) for all by SetModel
        and by SetRemaining(mode=Forget,Display)

        :type count: int
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_WorkSession_SentList(self, *args)


    def MaxSendingCount(self, *args):
        """
        MaxSendingCount(IFSelect_WorkSession self) -> Standard_Integer

        Returns the greater count of different files in which any of
        the starting entities could be sent.
        Before any file output, this count is 0.
        Ideal count is 1. More than 1 means that duplications occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_MaxSendingCount(self, *args)


    def SetRemaining(self, *args):
        """
        SetRemaining(IFSelect_WorkSession self, IFSelect_RemainMode const mode) -> Standard_Boolean

        Processes Remaining data (after having sent files), mode :
        Forget  : forget remaining info (i.e. clear all "Sent" status)
        Compute : compute and keep remaining (does nothing if :
        remaining is empty or if no files has been sent)
        Display : display entities recorded as remaining
        Undo    : restore former state of data (after Remaining(1) )
        Returns True if OK, False else (i.e. mode = 2 and Remaining
        List is either empty or takes all the entities, or mode = 3
        and no former computation of remaining data was done)

        :type mode: OCC.wrapper.IFSelect.IFSelect_RemainMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetRemaining(self, *args)


    def SendAll(self, *args):
        """
        SendAll(IFSelect_WorkSession self, Standard_CString const filename, Standard_Boolean const computegraph) -> IFSelect_ReturnStatus

        Sends the starting Model into one file, without splitting,
        managing remaining data or anything else.
        <computegraph> true commands the Graph to be recomputed before
        sending : required when a Model is filled in several steps

        The Model and File Modifiers recorded to be applied on sending
        files are.
        Returns a status of execution :
        Done if OK,
        Void if no data available,
        Error if errors occured (work library is not defined), errors
        during translation
        Fail if exception during translation is raised
        Stop if no disk space or disk, file is write protected
        Fills LastRunCheckList

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type computegraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_SendAll(self, *args)


    def SendSelected(self, *args):
        """
        SendSelected(IFSelect_WorkSession self, Standard_CString const filename, Handle_IFSelect_Selection sel, Standard_Boolean const computegraph) -> IFSelect_ReturnStatus

        Sends a part of the starting Model into one file, without
        splitting. But remaining data are managed.
        <computegraph> true commands the Graph to be recomputed before
        sending : required when a Model is filled in several steps

        The Model and File Modifiers recorded to be applied on sending
        files are.
        Returns a status : Done if OK,  Fail if error during send,
        Error : WorkLibrary not defined, Void : selection list empty
        Fills LastRunCheckList

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type computegraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_SendSelected(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(IFSelect_WorkSession self, Standard_CString const filename) -> IFSelect_ReturnStatus
        WriteFile(IFSelect_WorkSession self, Standard_CString const filename, Handle_IFSelect_Selection sel) -> IFSelect_ReturnStatus

        Writes a sub-part of the current Interface Model to a File,
        as defined by a Selection <sel>, recomputes the Graph, and
        returns a write status which can be :
        Done OK, Fail file could not be written, Error no norm is selected
        Remark  : It is a simple, one-file writing, other operations are
        available (such as splitting ...) which calls SendSelected

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_WriteFile(self, *args)


    def NbSources(self, *args):
        """
        NbSources(IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the count of Input Selections known for a Selection,
        or 0 if <sel> not in the WorkSession. This count is one for a
        SelectDeduct / SelectExtract kind, two for SelectControl kind,
        variable for a SelectCombine (Union/Intersection), zero else

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_NbSources(self, *args)


    def Source(self, *args):
        """
        Source(IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Standard_Integer const num=1) -> Handle_IFSelect_Selection

        Returns the <num>th Input Selection of a Selection
        (see NbSources).
        Returns a Null Handle if <sel> is not in the WorkSession or if
        <num> is out of the range <1-NbSources>
        To obtain more details, see the method Sources

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_Source(self, *args)


    def IsReversedSelectExtract(self, *args):
        """
        IsReversedSelectExtract(IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Returns True if <sel> a Reversed SelectExtract, False else

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_IsReversedSelectExtract(self, *args)


    def ToggleSelectExtract(self, *args):
        """
        ToggleSelectExtract(IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Toggles the Sense (Direct <-> Reversed) of a SelectExtract
        Returns True if Done, False if <sel> is not a SelectExtract or
        is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_ToggleSelectExtract(self, *args)


    def SetInputSelection(self, *args):
        """
        SetInputSelection(IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_IFSelect_Selection input) -> Standard_Boolean

        Sets an Input Selection (as <input>) to a SelectExtract or
        a SelectDeduct (as <sel>).
        Returns True if Done, False if <sel> is neither a
        SelectExtract nor a SelectDeduct, or not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type input: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetInputSelection(self, *args)


    def SetControl(self, *args):
        """
        SetControl(IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_IFSelect_Selection sc, Standard_Boolean const formain) -> Standard_Boolean

        Sets an Input Selection, Main if <formain> is True, Second else
        (as <sc>) to a SelectControl (as <sel>). Returns True if Done,
        False if <sel> is not a SelectControl, or <sc> or <sel> is not
        in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type sc: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type formain: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetControl(self, *args)


    def CombineAdd(self, *args):
        """
        CombineAdd(IFSelect_WorkSession self, Handle_IFSelect_Selection selcomb, Handle_IFSelect_Selection seladd, Standard_Integer const atnum=0) -> Standard_Integer

        Adds an input selection to a SelectCombine (Union or Inters.).
        Returns new count of inputs for this SelectCombine if Done or
        0 if <sel> is not kind of SelectCombine, or if <seladd> or
        <sel> is not in the WorkSession
        By default, adding is done at the end of the list
        Else, it is an insertion to rank <atnum> (usefull for Un-ReDo)

        :type selcomb: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type seladd: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_CombineAdd(self, *args)


    def CombineRemove(self, *args):
        """
        CombineRemove(IFSelect_WorkSession self, Handle_IFSelect_Selection selcomb, Handle_IFSelect_Selection selrem) -> Standard_Boolean

        Removes an input selection from a SelectCombine (Union or
        Intersection). Returns True if done, False if <selcomb> is not
        kind of SelectCombine or <selrem> is not source of <selcomb>

        :type selcomb: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type selrem: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_CombineRemove(self, *args)


    def NewSelectPointed(self, *args):
        """
        NewSelectPointed(IFSelect_WorkSession self, Handle_TColStd_HSequenceOfTransient list, Standard_CString const name) -> Handle_IFSelect_Selection

        Creates a new Selection, of type SelectPointed, its content
        starts with <list>. A name must be given (can be empty)

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_NewSelectPointed(self, *args)


    def SetSelectPointed(self, *args):
        """
        SetSelectPointed(IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_TColStd_HSequenceOfTransient list, Standard_Integer const mode) -> Standard_Boolean

        Changes the content of a Selection of type SelectPointed
        According <mode> : 0  set <list> as new content (clear former)
        1  : adds <list> to actual content
        -1  : removes <list> from actual content
        Returns True if done, False if <sel> is not a SelectPointed

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkSession_SetSelectPointed(self, *args)


    def GiveSelection(self, *args):
        """
        GiveSelection(IFSelect_WorkSession self, Standard_CString const selname) -> Handle_IFSelect_Selection

        Returns a Selection from a Name :
        - the name of a Selection : this Selection
        - the name of a Signature + criteria between (..) : a new
        Selection from this Signature
        - an entity or a list of entities : a new SelectPointed
        Else, returns a Null Handle

        :type selname: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_GiveSelection(self, *args)


    def GiveList(self, *args):
        """
        GiveList(IFSelect_WorkSession self, Handle_Standard_Transient obj) -> Handle_TColStd_HSequenceOfTransient
        GiveList(IFSelect_WorkSession self, Standard_CString const first, Standard_CString const second) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from two alphanums,
        first and second, as follows :
        if <first> is a Number or Label of an entity : this entity
        if <first> is a list of Numbers/Labels : the list of entities
        if <first> is the name of a Selection in <WS>, and <second>
        not defined, the standard result of this Selection
        else, let's consider "first second" : this whole phrase is
        splitted by blanks, as follows (RECURSIVE CALL) :
        - the leftest term is the final selection
        - the other terms define the result of the selection
        - and so on (the "leftest minus one" is a selection, of which
        the input is given by the remaining ...)

        :type first: OCC.wrapper.Standard.Standard_CString
        :type second: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_GiveList(self, *args)


    def GiveListFromList(self, *args):
        """
        GiveListFromList(IFSelect_WorkSession self, Standard_CString const selname, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from the model as follows
        <first> beeing a Selection or a combination of Selections,
        <ent> beeing an entity or a list
        of entities (as a HSequenceOfTransient) :
        the standard result of this selection applied to this list
        if <ent> is Null, the standard definition of the selection is
        used (which contains a default input selection)
        if <selname> is erroneous, a null handle is returned

        REMARK : selname is processed as <first second> of preceeding
        GiveList

        :type selname: OCC.wrapper.Standard.Standard_CString
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_GiveListFromList(self, *args)


    def GiveListCombined(self, *args):
        """
        GiveListCombined(IFSelect_WorkSession self, Handle_TColStd_HSequenceOfTransient l1, Handle_TColStd_HSequenceOfTransient l2, Standard_Integer const mode) -> Handle_TColStd_HSequenceOfTransient

        Combines two lists and returns the result, according to mode :
        <mode> < 0 : entities in <l1> AND NOT in <l2>
        <mode> = 0 : entities in <l1> AND in <l2>
        <mode> > 0 : entities in <l1> OR  in <l2>

        :type l1: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type l2: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type mode: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_WorkSession_GiveListCombined(self, *args)


    def QueryCheckList(self, *args):
        """
        QueryCheckList(IFSelect_WorkSession self, Interface_CheckIterator chl)

        Loads data from a check iterator to query status on it

        :type chl: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_QueryCheckList(self, *args)


    def QueryCheckStatus(self, *args):
        """
        QueryCheckStatus(IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Determines check status for an entity regarding last call to
        QueryCheckList :
        -1 : <ent> unknown in the model, ignored
        0 : no check at all, immediate or inherited thru Graph
        1 : immediate warning (no fail), no inherited check
        2 : immediate fail, no inherited check
        +10 : idem but some inherited warning (no fail)
        +20 : idem but some inherited fail

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_QueryCheckStatus(self, *args)


    def QueryParent(self, *args):
        """
        QueryParent(IFSelect_WorkSession self, Handle_Standard_Transient entdad, Handle_Standard_Transient entson) -> Standard_Integer

        Determines if <entdad> is parent of <entson> (in the graph),
        returns : -1 if no; 0 if <entdad> = <entson>
        1 if immediate parent, > 1 if parent, gives count of steps

        :type entdad: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entson: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_QueryParent(self, *args)


    def SetParams(self, *args):
        """
        SetParams(IFSelect_WorkSession self, NCollection_Vector< opencascade::handle< Standard_Transient > > const & params, NCollection_Vector< Standard_Integer > const & uselist)

        Sets a list of Parameters, i.e. TypedValue, to be handled
        through an Editor
        The two lists are parallel, if <params> is longer than <uses>,
        surnumeral parameters are for general use

        EditForms are created to handle these parameters (list, edit)
        on the basis of a ParamEditor  xst-params-edit

        A use number dispatches the parameter to a given EditForm
        EditForms are defined as follows
        Name                Use   Means
        xst-params          all   All Parameters (complete list)
        xst-params-general  1     Generals
        xst-params-load     2     LoadFile (no Transfer)
        xst-params-send     3     SendFile (Write, no Transfer)
        xst-params-split    4     Split
        xst-param-read      5     Transfer on Reading
        xst-param-write     6     Transfer on Writing

        :type params: OCC.wrapper.IFSelect.NCollection_Vector_Handle_Standard_Transient
        :type uselist: OCC.wrapper.IFSelect.NCollection_Vector_Standard_Integer

        """
        return _IFSelect.IFSelect_WorkSession_SetParams(self, *args)


    def TraceStatics(self, *args):
        """
        TraceStatics(IFSelect_WorkSession self, Standard_Integer const use, Standard_Integer const mode=0)

        Traces the Statics attached to a given use number
        If <use> is given positive (normal), the trace is embedded
        with a header and a trailer
        If <use> is negative, just values are printed
        (this allows to make compositions)
        Remark : use number  5 commands use -2 to be traced
        Remark : use numbers 4 and 6 command use -3 to be traced

        :type use: int
        :type mode: int

        """
        return _IFSelect.IFSelect_WorkSession_TraceStatics(self, *args)


    def DumpShare(self, *args):
        """
        DumpShare(IFSelect_WorkSession self)

        Dumps contents of the ShareOut (on "cout")


        """
        return _IFSelect.IFSelect_WorkSession_DumpShare(self, *args)


    def ListItems(self, *args):
        """
        ListItems(IFSelect_WorkSession self, Standard_CString const label)

        Lists the Labels of all Items of the WorkSession
        If <label> is defined, lists labels which contain it

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkSession_ListItems(self, *args)


    def ListFinalModifiers(self, *args):
        """
        ListFinalModifiers(IFSelect_WorkSession self, Standard_Boolean const formodel)

        Lists the Modifiers of the session (for each one, displays
        its Label). Listing is done following Ranks (Modifiers are
        invoked following their ranks)
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool

        """
        return _IFSelect.IFSelect_WorkSession_ListFinalModifiers(self, *args)


    def DumpSelection(self, *args):
        """
        DumpSelection(IFSelect_WorkSession self, Handle_IFSelect_Selection sel)

        Lists a Selection and its Sources (see SelectionIterator),
        given its rank in the list

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_DumpSelection(self, *args)


    def DumpModel(self, *args):
        """
        DumpModel(IFSelect_WorkSession self, Standard_Integer const level, Handle_Message_Messenger S)

        Lists the content of the Input Model (if there is one)
        According level : 0 -> gives only count of Entities and Roots
        1 -> Lists also Roots;  2 -> Lists all Entities (by TraceType)
        3 -> Performs a call to CheckList (Fails) and lists the result
        4 -> as 3 but all CheckList (Fails + Warnings)
        5,6,7  : as 3 but resp. Count,List,Labels by Fail
        8,9,10 : as 4 but resp. Count,List,Labels by message

        :type level: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_WorkSession_DumpModel(self, *args)


    def TraceDumpModel(self, *args):
        """
        TraceDumpModel(IFSelect_WorkSession self, Standard_Integer const mode)

        Dumps the current Model (as inherited DumpModel), on currently
        defined Default Trace File (default is standard output)

        :type mode: int

        """
        return _IFSelect.IFSelect_WorkSession_TraceDumpModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(IFSelect_WorkSession self, Handle_Standard_Transient ent, Standard_Integer const level, Handle_Message_Messenger S)

        Dumps a starting entity according to the current norm.
        To do this, it calls DumpEntity from WorkLibrary.
        <level> is to be interpreted for each norm : see specific
        classes of WorkLibrary for it. Generally, 0 if for very basic
        (only type ...), greater values give more and more details.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_WorkSession_DumpEntity(self, *args)


    def PrintEntityStatus(self, *args):
        """
        PrintEntityStatus(IFSelect_WorkSession self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints main informations about an entity : its number, type,
        validity (and checks if any), category, shareds and sharings..
        mutable because it can recompute checks as necessary

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_WorkSession_PrintEntityStatus(self, *args)


    def TraceDumpEntity(self, *args):
        """
        TraceDumpEntity(IFSelect_WorkSession self, Handle_Standard_Transient ent, Standard_Integer const level)

        Dumps an entity from the current Model as inherited DumpEntity
        on currently defined Default Trace File
        (<level> interpreted according to the Norm, see WorkLibrary)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int

        """
        return _IFSelect.IFSelect_WorkSession_TraceDumpEntity(self, *args)


    def PrintCheckList(self, *args):
        """
        PrintCheckList(IFSelect_WorkSession self, Interface_CheckIterator checklist, Standard_Boolean const failsonly, IFSelect_PrintCount const mode)

        Prints a CheckIterator to the current Trace File, controlled
        with the current Model
        complete or fails only, according to <failsonly>
        <mode> defines the mode of printing
        0 : sequential, according entities; else with a CheckCounter
        1 : according messages, count of entities
        2 : id but with list of entities, designated by their numbers
        3 : as 2 but with labels of entities

        :type checklist: OCC.wrapper.Interface.Interface_CheckIterator
        :type failsonly: bool
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.IFSelect_WorkSession_PrintCheckList(self, *args)


    def PrintSignatureList(self, *args):
        """
        PrintSignatureList(IFSelect_WorkSession self, Handle_IFSelect_SignatureList signlist, IFSelect_PrintCount const mode)

        Prints a SignatureList to the current Trace File, controlled
        with the current Model
        <mode> defines the mode of printing (see SignatureList)

        :type signlist: OCC.wrapper.IFSelect.Handle_IFSelect_SignatureList
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.IFSelect_WorkSession_PrintSignatureList(self, *args)


    def EvaluateSelection(self, *args):
        """
        EvaluateSelection(IFSelect_WorkSession self, Handle_IFSelect_Selection sel)

        Displays the list of Entities selected by a Selection (i.e.
        the result of EvalSelection).

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateSelection(self, *args)


    def EvaluateDispatch(self, *args):
        """
        EvaluateDispatch(IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp, Standard_Integer const mode=0)

        Displays the result of applying a Dispatch on the input Model
        (also shows Remainder if there is)
        <mode> = 0 (default), displays nothing else
        <mode> = 1 : displays also duplicated entities (because of
        this dispatch)
        <mode> = 2 : displays the entities of the starting Model
        which are not taken by this dispatch (forgotten entities)
        <mode> = 3 : displays both duplicated and forgotten entities
        Remark : EvaluateComplete displays these data evaluated for
        for all the dispatches, if there are several

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type mode: int

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateDispatch(self, *args)


    def EvaluateComplete(self, *args):
        """
        EvaluateComplete(IFSelect_WorkSession self, Standard_Integer const mode=0)

        Displays the effect of applying the ShareOut on the input
        Model.
        <mode> = 0 (default) : displays only roots for each packet,
        <mode> = 1 : displays all entities for each packet, plus
        duplicated entities
        <mode> = 2 : same as <mode> = 1, plus displays forgotten
        entities (which are in no packet at all)

        :type mode: int

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateComplete(self, *args)


    def ListEntities(self, *args):
        """
        ListEntities(IFSelect_WorkSession self, Interface_EntityIterator iter, Standard_Integer const mode)

        Internal method which displays an EntityIterator
        <mode> 0 gives short display (only entity numbers)
        1 gives a more complete trace (1 line per Entity)
        (can be used each time a trace has to be output from a list)
        2 gives a form suitable for givelist : (n1,n2,n3...)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type mode: int

        """
        return _IFSelect.IFSelect_WorkSession_ListEntities(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_WorkSession_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_WorkSession_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_WorkSession_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_WorkSession
IFSelect_WorkSession_swigregister = _IFSelect.IFSelect_WorkSession_swigregister
IFSelect_WorkSession_swigregister(IFSelect_WorkSession)

def IFSelect_WorkSession_get_type_name(*args):
    """
    IFSelect_WorkSession_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_WorkSession_get_type_name(*args)

def IFSelect_WorkSession_get_type_descriptor(*args):
    """
    IFSelect_WorkSession_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_WorkSession_get_type_descriptor(*args)

class IFSelect_SessionPilot(IFSelect_Activator):
    """
    A SessionPilot is intended to make easier the use of a
    WorkSession. It receives commands, under alphanumeric form,
    then calls a library of Activators to interprete and run them.

    Then, WorkSession just records data required to work :
    Rules for Selection, Dispatch ... ; File Data (InterfaceModel
    and results of Evaluations and Transfer as required).
    SessionPilot records and works with alphanumeric commands and
    their results (under a very simple form). It calls a list of
    Activators to perform the actions.

    A Command can have several forms :
    - classic execution, to list, evaluate, or enrich the session
    - command which creates a new item (a Selection for instance)
    such a command should not add it to the session, but make it
    recorded by the Pilot (method RecordItem). The Pilot will
    add the item in the session, with no name
    -> such a command may be called :
    - directly, it will add an item with no name
    - by command xset, in the following form :
    xset name command ...  calls the command and adds the item
    to the session under the specified name (if not yet known)

    Thus, to a specific Norm or way of working, only Activators
    change. A specific Initialisation can be done by starting
    with a specific set of commands.

    In addition, SessionPilot is a sub-type of Activator, to
    recognize some built-in commands : exit/x, help/?, control of
    command line, and commands xstep xset ... See method Do

    At least, empty lines and comment lines (beginning by '#')
    are skipped (comment lines are display if read from file)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SessionPilot
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SessionPilot(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SessionPilot self, Standard_CString const prompt) -> IFSelect_SessionPilot

        Creates an empty SessionPilot, with a prompt which will be
        displayed on querying commands. If not precised (""), this
        prompt is set to "Test-XSTEP>"

        :type prompt: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_SessionPilot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Session(self, *args):
        """
        Session(IFSelect_SessionPilot self) -> Handle_IFSelect_WorkSession

        Returns the WorkSession which is worked on

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession

        """
        return _IFSelect.IFSelect_SessionPilot_Session(self, *args)


    def Library(self, *args):
        """
        Library(IFSelect_SessionPilot self) -> Handle_IFSelect_WorkLibrary

        Returns the WorKlibrary (Null if not set). WorkLibrary is used
        to Read and Write Files, according to the Norm

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _IFSelect.IFSelect_SessionPilot_Library(self, *args)


    def RecordMode(self, *args):
        """
        RecordMode(IFSelect_SessionPilot self) -> Standard_Boolean

        Returns the Record Mode for Commands. Default is False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionPilot_RecordMode(self, *args)


    def SetSession(self, *args):
        """
        SetSession(IFSelect_SessionPilot self, Handle_IFSelect_WorkSession WS)

        Sets a WorkSession to be worked on

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession

        """
        return _IFSelect.IFSelect_SessionPilot_SetSession(self, *args)


    def SetLibrary(self, *args):
        """
        SetLibrary(IFSelect_SessionPilot self, Handle_IFSelect_WorkLibrary WL)

        Sets a WorkLibrary

        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _IFSelect.IFSelect_SessionPilot_SetLibrary(self, *args)


    def SetRecordMode(self, *args):
        """
        SetRecordMode(IFSelect_SessionPilot self, Standard_Boolean const mode)

        Changes the RecordMode.

        :type mode: bool

        """
        return _IFSelect.IFSelect_SessionPilot_SetRecordMode(self, *args)


    def SetCommandLine(self, *args):
        """
        SetCommandLine(IFSelect_SessionPilot self, TCollection_AsciiString command)

        Sets the value of the Command Line to be interpreted
        Also prepares the interpretation (splitting by blanks)

        :type command: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionPilot_SetCommandLine(self, *args)


    def CommandLine(self, *args):
        """
        Returns the Command Line to be interpreted

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SessionPilot_CommandLine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommandPart(self, *args):
        """
        CommandPart(IFSelect_SessionPilot self, Standard_Integer const numarg=0) -> Standard_CString

        Returns the part of the command line which begins at argument
        <numarg> between 0 and NbWords-1 (by default, all the line)
        Empty string if out of range

        :type numarg: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SessionPilot_CommandPart(self, *args)


    def NbWords(self, *args):
        """
        NbWords(IFSelect_SessionPilot self) -> Standard_Integer

        Returns the count of words of the Command Line, separated by
        blanks : 0 if empty, one if a command without args, else it
        gives the count of args minus one.
        Warning : limited to 10 (command title + 9 args)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionPilot_NbWords(self, *args)


    def Word(self, *args):
        """
        Returns a word given its rank in the Command Line. Begins at 0
        which is the Command Title, 1 is the 1st arg., etc...

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SessionPilot_Word(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Arg(self, *args):
        """
        Arg(IFSelect_SessionPilot self, Standard_Integer const num) -> Standard_CString

        Returns a word given its rank, as a CString.
        As for Word, begins at 0 (the command name), etc...

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SessionPilot_Arg(self, *args)


    def RemoveWord(self, *args):
        """
        RemoveWord(IFSelect_SessionPilot self, Standard_Integer const num) -> Standard_Boolean

        Removes a word given its rank. Returns True if Done, False if
        <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionPilot_RemoveWord(self, *args)


    def NbCommands(self, *args):
        """
        NbCommands(IFSelect_SessionPilot self) -> Standard_Integer

        Returns the count of recorded Commands

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionPilot_NbCommands(self, *args)


    def Command(self, *args):
        """
        Returns a recorded Command, given its rank (from 1)

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SessionPilot_Command(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RecordItem(self, *args):
        """
        RecordItem(IFSelect_SessionPilot self, Handle_Standard_Transient item) -> IFSelect_ReturnStatus

        Allows to associate a Transient Value with the last execution
        as a partial result
        Returns RetDone if item is not Null, RetFail if item is Null
        Remark : it is nullified for each Perform

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_RecordItem(self, *args)


    def RecordedItem(self, *args):
        """
        RecordedItem(IFSelect_SessionPilot self) -> Handle_Standard_Transient

        Returns the Transient Object which was recorded with the
        current Line Command. If none was, returns a Null Handle

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SessionPilot_RecordedItem(self, *args)


    def Clear(self, *args):
        """
        Clear(IFSelect_SessionPilot self)

        Clears the recorded informations (commands, objects)


        """
        return _IFSelect.IFSelect_SessionPilot_Clear(self, *args)


    def ReadScript(self, *args):
        """
        ReadScript(IFSelect_SessionPilot self, Standard_CString const file) -> IFSelect_ReturnStatus

        Reads commands from a Script File, named <file>. By default
        (file = ""), reads from standard input with a prompt
        Else (reading from a file), the read commands are displayed
        onto standard output. Allows nested reads. Reading is stopped
        either by command x or exit, or by reaching end of file
        Return Value follows the rules of Do : RetEnd for normal end,
        RetFail if script could not be opened

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_ReadScript(self, *args)


    def Perform(self, *args):
        """
        Perform(IFSelect_SessionPilot self) -> IFSelect_ReturnStatus

        Executes the Command, itself (for built-in commands, which
        have priority) or by using the list of Activators.
        The value returned is : RetVoid if nothing done (void command)
        RetDone if execution OK, RetEnd if END OF SESSION, RetError if
        command unknown or incorrect, RetFail if error on execution
        If execution is OK and RecordMode is set, this Command Line is
        recorded to the list (see below).

        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_Perform(self, *args)


    def ExecuteAlias(self, *args):
        """
        ExecuteAlias(IFSelect_SessionPilot self, TCollection_AsciiString aliasname) -> IFSelect_ReturnStatus

        Executes the Commands, except that the command name (word 0)
        is aliased. The rest of the command line is unchanged
        If <alias> is empty, Executes with no change

        Error status is returned if the alias is unknown as command

        :type aliasname: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_ExecuteAlias(self, *args)


    def Execute(self, *args):
        """
        Execute(IFSelect_SessionPilot self, TCollection_AsciiString command) -> IFSelect_ReturnStatus

        Sets the Command then tries to execute it. Return value :
        same as for Perform

        :type command: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_Execute(self, *args)


    def ExecuteCounter(self, *args):
        """
        ExecuteCounter(IFSelect_SessionPilot self, Handle_IFSelect_SignCounter counter, Standard_Integer const numword, IFSelect_PrintCount const mode=IFSelect_CountByItem) -> IFSelect_ReturnStatus

        Executes a Counter in a general way
        If <numword> is greater than count of command words, it counts
        all the model. Else it considers the word <numword> as the
        identifier of a Selection
        <mode> gives the mode of printing results, default is
        CountByItem

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type numword: int
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_ExecuteCounter(self, *args)


    def Number(self, *args):
        """
        Number(IFSelect_SessionPilot self, Standard_CString const val) -> Standard_Integer

        Interprets a string value as an entity number :
        if it gives an integer, returns its value
        else, considers it as ENtityLabel (preferably case sensitive)
        in case of failure, returns 0

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionPilot_Number(self, *args)


    def Do(self, *args):
        """
        Do(IFSelect_SessionPilot self, Standard_Integer const number, Handle_IFSelect_SessionPilot session) -> IFSelect_ReturnStatus

        Processes specific commands, which are :
        x or exit for end of session
        ? or help for help messages
        xcommand to control command lines (Record Mode, List, Clear,
        File Output ...)
        xsource to execute a command file (no nesting allowed),
        in case of error, source is stopped and keyword recovers
        xstep is a simple prefix (useful in a wider environment, to
        avoid conflicts on command names)
        xset control commands which create items with names

        :type number: int
        :type session: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_Do(self, *args)


    def Help(self, *args):
        """
        Help(IFSelect_SessionPilot self, Standard_Integer const number) -> Standard_CString

        Help for specific commands (apart from general command help)

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SessionPilot_Help(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SessionPilot_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SessionPilot_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SessionPilot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SessionPilot
IFSelect_SessionPilot_swigregister = _IFSelect.IFSelect_SessionPilot_swigregister
IFSelect_SessionPilot_swigregister(IFSelect_SessionPilot)

def IFSelect_SessionPilot_get_type_name(*args):
    """
    IFSelect_SessionPilot_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SessionPilot_get_type_name(*args)

def IFSelect_SessionPilot_get_type_descriptor(*args):
    """
    IFSelect_SessionPilot_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SessionPilot_get_type_descriptor(*args)

class IFSelect_SelectSent(IFSelect_SelectExtract):
    """
    This class returns entities according sending to a file
    Once a model has been loaded, further sendings are recorded
    as status in the graph (for each value, a count of sendings)

    Hence, it is possible to query entities : sent ones (at least
    once), non-sent (i.e. remaining) ones, duplicated ones, etc...

    This selection performs this query
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectSent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectSent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectSent self, Standard_Integer const sentcount=1, Standard_Boolean const atleast) -> IFSelect_SelectSent

        Creates a SelectSent :
        sentcount = 0 -> remaining (non-sent) entities
        sentcount = 1, atleast = True (D) -> sent (at least once)
        sentcount = 2, atleast = True -> duplicated (sent least twice)
        etc...
        sentcount = 1, atleast = False -> sent just once (non-dupl.d)
        sentcount = 2, atleast = False -> sent just twice
        etc...

        :type sentcount: int
        :type atleast: bool

        """
        this = _IFSelect.new_IFSelect_SelectSent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SentCount(self, *args):
        """
        SentCount(IFSelect_SelectSent self) -> Standard_Integer

        Returns the queried count of sending

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectSent_SentCount(self, *args)


    def AtLeast(self, *args):
        """
        AtLeast(IFSelect_SelectSent self) -> Standard_Boolean

        Returns the <atleast> status, True for sending at least the
        sending count, False for sending exactly the sending count
        Remark : if SentCount is 0, AtLeast is ignored

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSent_AtLeast(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectSent self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. It is redefined to
        work on the graph itself (not queried by sort)

        An entity is selected if its count complies to the query in
        Direct Mode, rejected in Reversed Mode

        Query works on the sending count recorded as status in Graph

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectSent_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectSent self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always False because RootResult has done the work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSent_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectSent self) -> TCollection_AsciiString

        Returns a text defining the criterium : query :
        SentCount = 0 -> "Remaining (non-sent) entities"
        SentCount = 1, AtLeast = True  -> "Sent entities"
        SentCount = 1, AtLeast = False -> "Sent once (no duplicated)"
        SentCount = 2, AtLeast = True  -> "Sent several times entities"
        SentCount = 2, AtLeast = False -> "Sent twice entities"
        SentCount > 2, AtLeast = True  -> "Sent at least <count> times entities"
        SentCount > 2, AtLeast = False -> "Sent <count> times entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSent_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectSent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectSent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectSent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSent
IFSelect_SelectSent_swigregister = _IFSelect.IFSelect_SelectSent_swigregister
IFSelect_SelectSent_swigregister(IFSelect_SelectSent)

def IFSelect_SelectSent_get_type_name(*args):
    """
    IFSelect_SelectSent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectSent_get_type_name(*args)

def IFSelect_SelectSent_get_type_descriptor(*args):
    """
    IFSelect_SelectSent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectSent_get_type_descriptor(*args)

class IFSelect_ListEditor(Standard.Standard_Transient):
    """
    A ListEditor is an auxiliary operator for Editor/EditForm
    I.E. it works on parameter values expressed as strings

    For a parameter which is a list, it may not be edited in once
    by just setting a new value (as a string)

    Firstly, a list can be long (and tedious to be accessed flat)
    then requires a better way of accessing

    Moreover, not only its VALUES may be changed (SetValue), but
    also its LENGTH : items may be added or removed ...

    Hence, the way of editing a parameter as a list is :
    - edit it separately, with the help of a ListEditor
    - it remains possible to prepare a new list of values apart
    - then give the new list in once to the EditForm

    An EditList is produced by the Editor, with a basic definition
    This definition (brought by this class) can be redefined
    Hence the Editor may produce a specific ListEditor as needed
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_ListEditor
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_ListEditor(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_ListEditor self) -> IFSelect_ListEditor
        __init__(IFSelect_ListEditor self, Handle_Interface_TypedValue arg2, Standard_Integer const max=0) -> IFSelect_ListEditor

        Creates a ListEditor, for which items of the list to edit are
        defined by <def>, and <max> describes max length :
        0 (D) means no limit
        value > 0 means : no more the <max> items are allowed

        :type def: OCC.wrapper.Interface.Handle_Interface_TypedValue
        :type max: int

        """
        this = _IFSelect.new_IFSelect_ListEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def LoadModel(self, *args):
        """
        LoadModel(IFSelect_ListEditor self, Handle_Interface_InterfaceModel model)

        Loads a Model. It is used to check items of type Entity(Ident)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_ListEditor_LoadModel(self, *args)


    def LoadValues(self, *args):
        """
        LoadValues(IFSelect_ListEditor self, Handle_TColStd_HSequenceOfHAsciiString vals)

        Loads the original values for the list
        Remark : If its length is mor then MaxLength, editions remain
        allowed, except Add

        :type vals: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_ListEditor_LoadValues(self, *args)


    def SetTouched(self, *args):
        """
        SetTouched(IFSelect_ListEditor self)

        Declares this ListEditor to have been touched (whatever action)


        """
        return _IFSelect.IFSelect_ListEditor_SetTouched(self, *args)


    def ClearEdit(self, *args):
        """
        ClearEdit(IFSelect_ListEditor self)

        Clears all editions already recorded


        """
        return _IFSelect.IFSelect_ListEditor_ClearEdit(self, *args)


    def LoadEdited(self, *args):
        """
        LoadEdited(IFSelect_ListEditor self, Handle_TColStd_HSequenceOfHAsciiString list) -> Standard_Boolean

        Loads a new list to replace the older one, in once !
        By default (can be redefined) checks the length of the list
        and the value of each item according to the def
        Items are all recorded as Modified

        If no def has been given at creation time, no check is done
        Returns True when done, False if checks have failed ... a
        specialisation may also lock it by returning always False ...

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_LoadEdited(self, *args)


    def SetValue(self, *args):
        """
        SetValue(IFSelect_ListEditor self, Standard_Integer const num, Handle_TCollection_HAsciiString val) -> Standard_Boolean

        Sets a new value for the item <num> (in edited list)
        <val> may be a Null Handle, then the value will be cleared but
        not removed
        Returns True when done. False if <num> is out of range or if
        <val> does not satisfy the definition

        :type num: int
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_SetValue(self, *args)


    def AddValue(self, *args):
        """
        AddValue(IFSelect_ListEditor self, Handle_TCollection_HAsciiString val, Standard_Integer const atnum=0) -> Standard_Boolean

        Adds a new item. By default appends (at the end of the list)
        Can insert before a given rank <num>, if positive
        Returns True when done. False if MaxLength may be overpassed
        or if <val> does not satisfy the definition

        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_AddValue(self, *args)


    def Remove(self, *args):
        """
        Remove(IFSelect_ListEditor self, Standard_Integer const num=0, Standard_Integer const howmany=1) -> Standard_Boolean

        Removes items from the list
        By default removes one item. Else, count given by <howmany>
        Remove from rank <num> included. By default, from the end
        Returns True when done, False (and does not work) if case of
        out of range of if <howmany> is greater than current length

        :type num: int
        :type howmany: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_Remove(self, *args)


    def OriginalValues(self, *args):
        """
        OriginalValues(IFSelect_ListEditor self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the value from which the edition started

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_ListEditor_OriginalValues(self, *args)


    def EditedValues(self, *args):
        """
        EditedValues(IFSelect_ListEditor self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the result of the edition

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_ListEditor_EditedValues(self, *args)


    def NbValues(self, *args):
        """
        NbValues(IFSelect_ListEditor self, Standard_Boolean const edited) -> Standard_Integer

        Returns count of values, edited (D) or original

        :type edited: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ListEditor_NbValues(self, *args)


    def Value(self, *args):
        """
        Value(IFSelect_ListEditor self, Standard_Integer const num, Standard_Boolean const edited) -> Handle_TCollection_HAsciiString

        Returns a value given its rank. Edited (D) or Original
        A Null String means the value is cleared but not removed

        :type num: int
        :type edited: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ListEditor_Value(self, *args)


    def IsChanged(self, *args):
        """
        IsChanged(IFSelect_ListEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a value (in edited list) has been changed, i.e.
        either modified-value, or added

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_IsChanged(self, *args)


    def IsModified(self, *args):
        """
        IsModified(IFSelect_ListEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a value (in edited list) has been modified-value
        (not added)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_IsModified(self, *args)


    def IsAdded(self, *args):
        """
        IsAdded(IFSelect_ListEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a value (in edited list) has been added (new one)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_IsAdded(self, *args)


    def IsTouched(self, *args):
        """
        IsTouched(IFSelect_ListEditor self) -> Standard_Boolean

        Tells if at least one edition (SetValue-AddValue-Remove) has
        been recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ListEditor_IsTouched(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_ListEditor_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_ListEditor_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_ListEditor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_ListEditor
IFSelect_ListEditor_swigregister = _IFSelect.IFSelect_ListEditor_swigregister
IFSelect_ListEditor_swigregister(IFSelect_ListEditor)

def IFSelect_ListEditor_get_type_name(*args):
    """
    IFSelect_ListEditor_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_ListEditor_get_type_name(*args)

def IFSelect_ListEditor_get_type_descriptor(*args):
    """
    IFSelect_ListEditor_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_ListEditor_get_type_descriptor(*args)

class IFSelect_SelectIntersection(IFSelect_SelectCombine):
    """
    A SelectIntersection filters the Entities issued from several
    other Selections as Intersection of results : "AND" operator
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectIntersection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectIntersection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectIntersection self) -> IFSelect_SelectIntersection

        Creates an empty SelectIntersection


        """
        this = _IFSelect.new_IFSelect_SelectIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectIntersection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected Entities, which is the common part
        of results from all input selections. Uniqueness is guaranteed.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectIntersection_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectIntersection self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Intersection (AND)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectIntersection_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectIntersection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectIntersection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectIntersection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectIntersection
IFSelect_SelectIntersection_swigregister = _IFSelect.IFSelect_SelectIntersection_swigregister
IFSelect_SelectIntersection_swigregister(IFSelect_SelectIntersection)

def IFSelect_SelectIntersection_get_type_name(*args):
    """
    IFSelect_SelectIntersection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectIntersection_get_type_name(*args)

def IFSelect_SelectIntersection_get_type_descriptor(*args):
    """
    IFSelect_SelectIntersection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectIntersection_get_type_descriptor(*args)

class IFSelect_AppliedModifiers(Standard.Standard_Transient):
    """
    This class allows to memorize and access to the modifiers
    which are to be applied to a file. To each modifier, is bound
    a list of integers (optionnal) : if this list is absent, the
    modifier applies to all the file. Else, it applies to the
    entities designated by these numbers in the produced file.

    To record a modifier, and a possible list of entity numbers
    to be applied on :
    AddModif (amodifier);
    loop on  AddNum (anumber);

    To query it,  Count gives the count of recorded modifiers,
    then for each one :
    Item (numodif, amodifier, entcount);
    IsForAll ()  -> can be called, if True, applies on the whole file

    for (i = 1; i <= entcount; i ++)
    nument = ItemNum (i);  -> return an entity number
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_AppliedModifiers
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_AppliedModifiers(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_AppliedModifiers self, Standard_Integer const nbmax, Standard_Integer const nbent) -> IFSelect_AppliedModifiers

        Creates an AppliedModifiers, ready to record up to <nbmax>
        modifiers, on a model of <nbent> entities

        :type nbmax: int
        :type nbent: int

        """
        this = _IFSelect.new_IFSelect_AppliedModifiers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddModif(self, *args):
        """
        AddModif(IFSelect_AppliedModifiers self, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Records a modifier. By default, it is to apply on all a
        produced file. Further calls to AddNum will restrict this.
        Returns True if done, False if too many modifiers are already
        recorded

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_AppliedModifiers_AddModif(self, *args)


    def AddNum(self, *args):
        """
        AddNum(IFSelect_AppliedModifiers self, Standard_Integer const nument) -> Standard_Boolean

        Adds a number of entity of the output file to be applied on.
        If a sequence of AddNum is called after AddModif, this
        Modifier will be applied on the list of designated entities.
        Else, it will be applied on all the file
        Returns True if done, False if no modifier has yet been added

        :type nument: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_AppliedModifiers_AddNum(self, *args)


    def Count(self, *args):
        """
        Count(IFSelect_AppliedModifiers self) -> Standard_Integer

        Returns the count of recorded modifiers

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_AppliedModifiers_Count(self, *args)


    def Item(self, *args):
        """
        Item(IFSelect_AppliedModifiers self, Standard_Integer const num, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Returns the description for applied modifier n0 <num> :
        the modifier itself, and the count of entities to be applied
        on. If no specific list of number has been defined, returns
        the total count of entities of the file
        If this count is zero, then the modifier applies to all
        the file (see below). Else, the numbers are then queried by
        calls to ItemNum between 1 and <entcount>
        Returns True if OK, False if <num> is out of range

        :type num: int
        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type entcount: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_AppliedModifiers_Item(self, *args)


    def ItemNum(self, *args):
        """
        ItemNum(IFSelect_AppliedModifiers self, Standard_Integer const nument) -> Standard_Integer

        Returns a numero of entity to be applied on, given its rank
        in the list. If no list is defined (i.e. for all the file),
        returns <nument> itself, to give all the entities of the file
        Returns 0 if <nument> out of range

        :type nument: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_AppliedModifiers_ItemNum(self, *args)


    def ItemList(self, *args):
        """
        ItemList(IFSelect_AppliedModifiers self) -> Handle_TColStd_HSequenceOfInteger

        Returns the list of entities to be applied on (see Item)
        as a HSequence (IsForAll produces the complete list of all
        the entity numbers of the file

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.IFSelect_AppliedModifiers_ItemList(self, *args)


    def IsForAll(self, *args):
        """
        IsForAll(IFSelect_AppliedModifiers self) -> Standard_Boolean

        Returns True if the applied modifier queried by last call to
        Item is to be applied to all the produced file.
        Else, <entcount> returned by Item gives the count of entity
        numbers, each one is queried by ItemNum

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_AppliedModifiers_IsForAll(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_AppliedModifiers_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_AppliedModifiers_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_AppliedModifiers_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_AppliedModifiers
IFSelect_AppliedModifiers_swigregister = _IFSelect.IFSelect_AppliedModifiers_swigregister
IFSelect_AppliedModifiers_swigregister(IFSelect_AppliedModifiers)

def IFSelect_AppliedModifiers_get_type_name(*args):
    """
    IFSelect_AppliedModifiers_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_AppliedModifiers_get_type_name(*args)

def IFSelect_AppliedModifiers_get_type_descriptor(*args):
    """
    IFSelect_AppliedModifiers_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_AppliedModifiers_get_type_descriptor(*args)

class IFSelect_CheckCounter(IFSelect_SignatureList):
    """
    A CheckCounter allows to see a CheckList (i.e. CheckIterator)
    not per entity, its messages, but per message, the entities
    attached (count and list). Because many messages can be
    repeated if they are due to systematic errors
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_CheckCounter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_CheckCounter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_CheckCounter self, Standard_Boolean const withlist) -> IFSelect_CheckCounter

        Creates a CheckCounter, empty ready to work

        :type withlist: bool

        """
        this = _IFSelect.new_IFSelect_CheckCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetSignature(self, *args):
        """
        SetSignature(IFSelect_CheckCounter self, Handle_MoniTool_SignText sign)

        Sets a specific signature
        Else, the current SignType (in the model) is used

        :type sign: OCC.wrapper.MoniTool.Handle_MoniTool_SignText

        """
        return _IFSelect.IFSelect_CheckCounter_SetSignature(self, *args)


    def Signature(self, *args):
        """
        Signature(IFSelect_CheckCounter self) -> Handle_MoniTool_SignText

        Returns the Signature;

        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_SignText

        """
        return _IFSelect.IFSelect_CheckCounter_Signature(self, *args)


    def Analyse(self, *args):
        """
        Analyse(IFSelect_CheckCounter self, Interface_CheckIterator list, Handle_Interface_InterfaceModel model, Standard_Boolean const original, Standard_Boolean const failsonly)

        Analyses a CheckIterator according a Model (which detains the
        entities for which the CheckIterator has messages), i.e.
        counts messages for entities
        If <original> is True, does not consider final messages but
        those before interpretation (such as inserting variables :
        integers, reals, strings)
        If <failsonly> is True, only Fails are considered
        Remark : global messages are recorded with a Null entity

        :type list: OCC.wrapper.Interface.Interface_CheckIterator
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type original: bool
        :type failsonly: bool

        """
        return _IFSelect.IFSelect_CheckCounter_Analyse(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_CheckCounter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_CheckCounter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_CheckCounter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_CheckCounter
IFSelect_CheckCounter_swigregister = _IFSelect.IFSelect_CheckCounter_swigregister
IFSelect_CheckCounter_swigregister(IFSelect_CheckCounter)

def IFSelect_CheckCounter_get_type_name(*args):
    """
    IFSelect_CheckCounter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_CheckCounter_get_type_name(*args)

def IFSelect_CheckCounter_get_type_descriptor(*args):
    """
    IFSelect_CheckCounter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_CheckCounter_get_type_descriptor(*args)

class IFSelect_WorkLibrary(Standard.Standard_Transient):
    """
    This class defines the (empty) frame which can be used to
    enrich a XSTEP set with new capabilities
    In particular, a specific WorkLibrary must give the way for
    Reading a File into a Model, and Writing a Model to a File
    Thus, it is possible to define several Work Libraries for each
    norm, but recommanded to define one general class for each one :
    this general class will define the Read and Write methods.

    Also a Dump service is provided, it can produce, according the
    norm, either a parcel of a file for an entity, or any other
    kind of informations relevant for the norm,
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_WorkLibrary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_WorkLibrary(self) 
            return h


    def ReadFile(self, *args):
        """
        ReadFile(IFSelect_WorkLibrary self, Standard_CString const name, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol) -> Standard_Integer

        Gives the way to Read a File and transfer it to a Model
        <mod> is the resulting Model, which has to be created by this
        method. In case of error, <mod> must be returned Null
        Return value is a status with free values.
        Simply, 0 is for "Execution OK"
        The Protocol can be used to work (e.g. create the Model, read
        and recognize the Entities)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_WorkLibrary_ReadFile(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(IFSelect_WorkLibrary self, IFSelect_ContextWrite ctx) -> Standard_Boolean

        Gives the way to Write a File from a Model.
        <ctx> contains all necessary informations : the model, the
        protocol, the file name, and the list of File Modifiers to be
        applied, also with restricted list of selected entities for
        each one, if required.
        In return, it brings the produced check-list

        The WorkLibrary has to query <applied> to get then run the
        ContextWrite by looping like this (example) :
        for (numap = 1; numap <= ctx.NbModifiers(); numap ++) {
        ctx.SetModifier (numap);
        cast ctx.FileModifier()  to specific type -> variable filemod
        if (!filemod.IsNull()) filemod->Perform (ctx,writer);
        filemod then works with ctx. It can, either act on the
        model itself (for instance on its header), or iterate
        on selected entities (Start/Next/More/Value)
        it can call AddFail or AddWarning, as necessary
        }

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkLibrary_WriteFile(self, *args)


    def CopyModel(self, *args):
        """
        CopyModel(IFSelect_WorkLibrary self, Handle_Interface_InterfaceModel original, Handle_Interface_InterfaceModel newmodel, Interface_EntityIterator list, Interface_CopyTool TC) -> Standard_Boolean

        Performs the copy of entities from an original model to a new
        one. It must also copy headers if any. Returns True when done.
        The provided default works by copying the individual entities
        designated in the list, by using the general service class
        CopyTool.
        It can be redefined for a norm which, either implements Copy
        by another way (do not forget to Bind each copied result with
        its original entity in TC) and returns True, or does not know
        how to copy and returns False

        :type original: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type newmodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type list: OCC.wrapper.Interface.Interface_EntityIterator
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_WorkLibrary_CopyModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(IFSelect_WorkLibrary self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol, Handle_Standard_Transient entity, Handle_Message_Messenger S, Standard_Integer const level)
        DumpEntity(IFSelect_WorkLibrary self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol, Handle_Standard_Transient entity, Handle_Message_Messenger S)

        Calls deferred DumpEntity with the recorded default level

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type entity: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_WorkLibrary_DumpEntity(self, *args)


    def SetDumpLevels(self, *args):
        """
        SetDumpLevels(IFSelect_WorkLibrary self, Standard_Integer const arg2, Standard_Integer const max)

        Records a default level and a maximum value for level
        level for DumpEntity can go between 0 and <max>
        default value will be <def>

        :type def: int
        :type max: int

        """
        return _IFSelect.IFSelect_WorkLibrary_SetDumpLevels(self, *args)


    def DumpLevels(self, *args):
        """
        DumpLevels(IFSelect_WorkLibrary self)

        Returns the recorded default and maximum dump levels
        If none was recorded, max is returned negative, def as zero

        :type def: int
        :type max: int

        """
        return _IFSelect.IFSelect_WorkLibrary_DumpLevels(self, *args)


    def SetDumpHelp(self, *args):
        """
        SetDumpHelp(IFSelect_WorkLibrary self, Standard_Integer const level, Standard_CString const help)

        Records a short line of help for a level (0 - max)

        :type level: int
        :type help: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkLibrary_SetDumpHelp(self, *args)


    def DumpHelp(self, *args):
        """
        DumpHelp(IFSelect_WorkLibrary self, Standard_Integer const level) -> Standard_CString

        Returns the help line recorded for <level>, or an empty string

        :type level: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_WorkLibrary_DumpHelp(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_WorkLibrary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_WorkLibrary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_WorkLibrary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_WorkLibrary
IFSelect_WorkLibrary_swigregister = _IFSelect.IFSelect_WorkLibrary_swigregister
IFSelect_WorkLibrary_swigregister(IFSelect_WorkLibrary)

def IFSelect_WorkLibrary_get_type_name(*args):
    """
    IFSelect_WorkLibrary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_WorkLibrary_get_type_name(*args)

def IFSelect_WorkLibrary_get_type_descriptor(*args):
    """
    IFSelect_WorkLibrary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_WorkLibrary_get_type_descriptor(*args)

class IFSelect_SelectUnknownEntities(IFSelect_SelectExtract):
    """
    A SelectUnknownEntities sorts the Entities which are qualified
    as "Unknown" (their Type has not been recognized)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectUnknownEntities
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectUnknownEntities(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectUnknownEntities self) -> IFSelect_SelectUnknownEntities

        Creates a SelectUnknownEntities


        """
        this = _IFSelect.new_IFSelect_SelectUnknownEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sort(self, *args):
        """
        Sort(IFSelect_SelectUnknownEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is qualified as "Unknown",
        i.e. if <model> known <ent> (through its Number) as Unknown

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectUnknownEntities_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectUnknownEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Recognized Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectUnknownEntities_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectUnknownEntities_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectUnknownEntities_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectUnknownEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectUnknownEntities
IFSelect_SelectUnknownEntities_swigregister = _IFSelect.IFSelect_SelectUnknownEntities_swigregister
IFSelect_SelectUnknownEntities_swigregister(IFSelect_SelectUnknownEntities)

def IFSelect_SelectUnknownEntities_get_type_name(*args):
    """
    IFSelect_SelectUnknownEntities_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectUnknownEntities_get_type_name(*args)

def IFSelect_SelectUnknownEntities_get_type_descriptor(*args):
    """
    IFSelect_SelectUnknownEntities_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectUnknownEntities_get_type_descriptor(*args)

class Handle_IFSelect_ParamEditor(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_ParamEditor self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_ParamEditor self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_ParamEditor self, IFSelect_ParamEditor thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_ParamEditor self, Handle_IFSelect_ParamEditor theHandle) -> Handle_IFSelect_ParamEditor
        assign(Handle_IFSelect_ParamEditor self, IFSelect_ParamEditor thePtr) -> Handle_IFSelect_ParamEditor
        assign(Handle_IFSelect_ParamEditor self, Handle_IFSelect_ParamEditor theHandle) -> Handle_IFSelect_ParamEditor

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_ParamEditor self) -> IFSelect_ParamEditor

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_ParamEditor self) -> IFSelect_ParamEditor

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ParamEditor___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_ParamEditor self) -> IFSelect_ParamEditor

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_ParamEditor___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_ParamEditor___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_ParamEditor___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_ParamEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_ParamEditor_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_ParamEditor

    def AddValue(self, *args):
        """
        AddValue(Handle_IFSelect_ParamEditor self, Handle_Interface_TypedValue val, Standard_CString const shortname)

        Adds a TypedValue
        By default, its short name equates its complete name, it can
        be explicited

        :type val: OCC.wrapper.Interface.Handle_Interface_TypedValue
        :type shortname: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_AddValue(self, *args)


    def AddConstantText(self, *args):
        """
        AddConstantText(Handle_IFSelect_ParamEditor self, Standard_CString const val, Standard_CString const shortname, Standard_CString const completename)

        Adds a Constant Text, it will be Read Only
        By default, its long name equates its shortname

        :type val: OCC.wrapper.Standard.Standard_CString
        :type shortname: OCC.wrapper.Standard.Standard_CString
        :type completename: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_AddConstantText(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_ParamEditor self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Label(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form) -> Standard_Boolean

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Recognize(self, *args)


    def StringValue(self, *args):
        """
        StringValue(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_StringValue(self, *args)


    def Load(self, *args):
        """
        Load(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Load(self, *args)


    def Apply(self, *args):
        """
        Apply(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Apply(self, *args)


    def StaticEditor(self, *args):
        """
        StaticEditor(Handle_IFSelect_ParamEditor self, Handle_TColStd_HSequenceOfHAsciiString list, Standard_CString const label) -> Handle_IFSelect_ParamEditor

        Returns a ParamEditor to work on the Static Parameters of
        which names are listed in <list>
        Null Handle if <list> is null or empty

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type label: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ParamEditor

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_StaticEditor(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_ParamEditor self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ParamEditor_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ParamEditor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Handle_IFSelect_ParamEditor self, Standard_Integer const num, Handle_Interface_TypedValue typval, Standard_CString const shortname, IFSelect_EditValue const accessmode=IFSelect_Editable)

        Sets a Typed Value for a given ident and short name, with an
        Edit Mode

        :type num: int
        :type typval: OCC.wrapper.Interface.Handle_Interface_TypedValue
        :type shortname: OCC.wrapper.Standard.Standard_CString
        :type accessmode: OCC.wrapper.IFSelect.IFSelect_EditValue

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_SetValue(self, *args)


    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_ParamEditor self, Standard_Integer const num, Standard_Integer const max=0)

        Sets a parameter to be a List
        max < 0 : not for a list (set when starting)
        max = 0 : list with no length limit (default for SetList)
        max > 0 : list limited to <max> items

        :type num: int
        :type max: int

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_SetList(self, *args)


    def NbValues(self, *args):
        """
        NbValues(Handle_IFSelect_ParamEditor self) -> Standard_Integer

        Returns the count of Typed Values

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_NbValues(self, *args)


    def TypedValue(self, *args):
        """
        TypedValue(Handle_IFSelect_ParamEditor self, Standard_Integer const num) -> Handle_Interface_TypedValue

        Returns a Typed Value from its ident

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_TypedValue

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_TypedValue(self, *args)


    def IsList(self, *args):
        """
        IsList(Handle_IFSelect_ParamEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a parameter is a list

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_IsList(self, *args)


    def MaxList(self, *args):
        """
        MaxList(Handle_IFSelect_ParamEditor self, Standard_Integer const num) -> Standard_Integer

        Returns max length allowed for a list
        = 0 means : list with no limit
        < 0 means : not a list

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_MaxList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_ParamEditor self, Standard_Integer const num, Standard_Boolean const isshort) -> Standard_CString

        Returns the name of a Value (complete or short) from its ident
        Short Name can be empty

        :type num: int
        :type isshort: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Name(self, *args)


    def EditMode(self, *args):
        """
        EditMode(Handle_IFSelect_ParamEditor self, Standard_Integer const num) -> IFSelect_EditValue

        Returns the edit mode of a Value

        :type num: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_EditValue

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_EditMode(self, *args)


    def NameNumber(self, *args):
        """
        NameNumber(Handle_IFSelect_ParamEditor self, Standard_CString const name) -> Standard_Integer

        Returns the number (ident) of a Value, from its name, short or
        complete. If not found, returns 0

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_NameNumber(self, *args)


    def PrintNames(self, *args):
        """
        PrintNames(Handle_IFSelect_ParamEditor self, Handle_Message_Messenger S)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_PrintNames(self, *args)


    def PrintDefs(self, *args):
        """
        PrintDefs(Handle_IFSelect_ParamEditor self, Handle_Message_Messenger S, Standard_Boolean const labels)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type labels: bool

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_PrintDefs(self, *args)


    def MaxNameLength(self, *args):
        """
        MaxNameLength(Handle_IFSelect_ParamEditor self, Standard_Integer const what) -> Standard_Integer

        Returns the MaxLength of, according to what :
        <what> = -1 : length of short names
        <what> =  0 : length of complete names
        <what> =  1 : length of values labels

        :type what: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_MaxNameLength(self, *args)


    def Form(self, *args):
        """
        Form(Handle_IFSelect_ParamEditor self, Standard_Boolean const readonly, Standard_Boolean const undoable) -> Handle_IFSelect_EditForm

        Builds and Returns an EditForm, empty (no data yet)
        Can be redefined to return a specific type of EditForm

        :type readonly: bool
        :type undoable: bool
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Form(self, *args)


    def ListEditor(self, *args):
        """
        ListEditor(Handle_IFSelect_ParamEditor self, Standard_Integer const num) -> Handle_IFSelect_ListEditor

        Returns a ListEditor for a parameter which is a List
        Default returns a basic ListEditor for a List, a Null Handle
        if <num> is not for a List. Can be redefined

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_ListEditor(self, *args)


    def ListValue(self, *args):
        """
        ListValue(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the value of an EditForm as a List, for a given item
        If not a list, a Null Handle should be returned
        Default returns a Null Handle, because many Editors have
        no list to edit. To be redefined as required

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_ListValue(self, *args)


    def Update(self, *args):
        """
        Update(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Standard_Integer const num, Handle_TCollection_HAsciiString newval, Standard_Boolean const enforce) -> Standard_Boolean

        Updates the EditForm when a parameter is modified
        I.E.  default does nothing, can be redefined, as follows :
        Returns True when done (even if does nothing), False in case
        of refuse (for instance, if the new value is not suitable)
        <num> is the rank of the parameter for the EDITOR itself
        <enforce> True means that protected parameters can be touched

        If a parameter commands the value of other ones, when it is
        modified, it is necessary to touch them by Touch from EditForm

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Update(self, *args)


    def UpdateList(self, *args):
        """
        UpdateList(Handle_IFSelect_ParamEditor self, Handle_IFSelect_EditForm form, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString newlist, Standard_Boolean const enforce) -> Standard_Boolean

        Acts as Update, but when the value is a list

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :type newlist: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_UpdateList(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_ParamEditor self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_ParamEditor_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_ParamEditor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_ParamEditor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_ParamEditor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_ParamEditor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_ParamEditor self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_ParamEditor self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_ParamEditor self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_ParamEditor_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_ParamEditor self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ParamEditor_DecrementRefCounter(self, *args)

Handle_IFSelect_ParamEditor_swigregister = _IFSelect.Handle_IFSelect_ParamEditor_swigregister
Handle_IFSelect_ParamEditor_swigregister(Handle_IFSelect_ParamEditor)

def Handle_IFSelect_ParamEditor_DownCast(thing):
    return _IFSelect.Handle_IFSelect_ParamEditor_DownCast(thing)
Handle_IFSelect_ParamEditor_DownCast = _IFSelect.Handle_IFSelect_ParamEditor_DownCast

class Handle_IFSelect_SignatureList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignatureList self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignatureList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignatureList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignatureList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignatureList self, IFSelect_SignatureList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignatureList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignatureList self, Handle_IFSelect_SignatureList theHandle) -> Handle_IFSelect_SignatureList
        assign(Handle_IFSelect_SignatureList self, IFSelect_SignatureList thePtr) -> Handle_IFSelect_SignatureList
        assign(Handle_IFSelect_SignatureList self, Handle_IFSelect_SignatureList theHandle) -> Handle_IFSelect_SignatureList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignatureList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignatureList self) -> IFSelect_SignatureList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignatureList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignatureList self) -> IFSelect_SignatureList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignatureList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignatureList self) -> IFSelect_SignatureList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignatureList___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignatureList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignatureList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignatureList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignatureList_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignatureList

    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_SignatureList self, Standard_Boolean const withlist)

        Changes the record-list status. The list is not cleared but
        its use changes

        :type withlist: bool

        """
        return _IFSelect.Handle_IFSelect_SignatureList_SetList(self, *args)


    def ModeSignOnly(self, *args):
        """
        ModeSignOnly(Handle_IFSelect_SignatureList self) -> Standard_Boolean &

        Returns modifiable the SignOnly Mode
        If False (D), the counter normally counts
        If True, the counting work is turned off, Add only fills the
        LastValue, which can be used as signature, when a counter
        works from data which are not available from a Signature

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignatureList_ModeSignOnly(self, *args)


    def Clear(self, *args):
        """Clear(Handle_IFSelect_SignatureList self)"""
        return _IFSelect.Handle_IFSelect_SignatureList_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SignatureList self, Handle_Standard_Transient ent, Standard_CString const sign)

        Adds an entity with its signature, i.e. :
        - counts an item more for <sign>
        - if record-list status is set, records the entity
        Accepts a null entity (the signature is then for the global
        model). But if the string is empty, counts a Null item.

        If SignOnly Mode is set, this work is replaced by just
        setting LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sign: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignatureList_Add(self, *args)


    def LastValue(self, *args):
        """
        LastValue(Handle_IFSelect_SignatureList self) -> Standard_CString

        Returns the last value recorded by Add (only if SignMode set)
        Cleared by Clear or Init

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignatureList_LastValue(self, *args)


    def Init(self, *args):
        """
        Init(Handle_IFSelect_SignatureList self, Standard_CString const name, NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer > const & count, NCollection_IndexedDataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & list, Standard_Integer const nbnuls)

        Aknowledges the list in once. Name identifies the Signature

        :type name: OCC.wrapper.Standard.Standard_CString
        :type count: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer
        :type list: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Handle_Standard_Transient
        :type nbnuls: int

        """
        return _IFSelect.Handle_IFSelect_SignatureList_Init(self, *args)


    def List(self, *args):
        """
        List(Handle_IFSelect_SignatureList self, Standard_CString const root) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of signatures, as a sequence of strings
        (but without their respective counts). It is ordered.
        By default, for all the signatures.
        If <root> is given non empty, for the signatures which
        begin by <root>

        :type root: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignatureList_List(self, *args)


    def HasEntities(self, *args):
        """
        HasEntities(Handle_IFSelect_SignatureList self) -> Standard_Boolean

        Returns True if the list of Entities is aknowledged, else
        the method Entities will always return a Null Handle

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignatureList_HasEntities(self, *args)


    def NbNulls(self, *args):
        """
        NbNulls(Handle_IFSelect_SignatureList self) -> Standard_Integer

        Returns the count of null entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignatureList_NbNulls(self, *args)


    def NbTimes(self, *args):
        """
        NbTimes(Handle_IFSelect_SignatureList self, Standard_CString const sign) -> Standard_Integer

        Returns the number of times a signature was counted,
        0 if it has not been recorded at all

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignatureList_NbTimes(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_IFSelect_SignatureList self, Standard_CString const sign) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities attached to a signature
        It is empty if <sign> has not been recorded
        It is a Null Handle if the list of entities is not known

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_SignatureList_Entities(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_IFSelect_SignatureList self, Standard_CString const name)

        Defines a name for a SignatureList (used to print it)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignatureList_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignatureList self) -> Standard_CString

        Returns the recorded Name.
        Remark : default is "..." (no SetName called)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignatureList_Name(self, *args)


    def PrintCount(self, *args):
        """
        PrintCount(Handle_IFSelect_SignatureList self, Handle_Message_Messenger S)

        Prints the counts of items (not the list)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_SignatureList_PrintCount(self, *args)


    def PrintList(self, *args):
        """
        PrintList(Handle_IFSelect_SignatureList self, Handle_Message_Messenger S, Handle_Interface_InterfaceModel model, IFSelect_PrintCount const mod=IFSelect_ListByItem)

        Prints the lists of items, if they are present (else, prints
        a message "no list available")
        Uses <model> to determine for each entity to be listed, its
        number, and its specific identifier (by PrintLabel)
        <mod> gives a mode for printing :
        - CountByItem : just count (as PrintCount)
        - ShortByItem : minimum i.e. count plus 5 first entity numbers
        - ShortByItem(D) complete list of entity numbers (0: "Global")
        - EntitiesByItem : list of (entity number/PrintLabel from the model)
        other modes are ignored

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type mod: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.Handle_IFSelect_SignatureList_PrintList(self, *args)


    def PrintSum(self, *args):
        """
        PrintSum(Handle_IFSelect_SignatureList self, Handle_Message_Messenger S)

        Prints a summary
        Item which has the greatest count of entities
        For items which are numeric values : their count, maximum,
        minimum values, cumul, average

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_SignatureList_PrintSum(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignatureList self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignatureList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignatureList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignatureList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignatureList self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignatureList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignatureList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignatureList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignatureList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignatureList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignatureList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignatureList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignatureList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignatureList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignatureList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignatureList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignatureList self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignatureList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignatureList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignatureList_DecrementRefCounter(self, *args)

Handle_IFSelect_SignatureList_swigregister = _IFSelect.Handle_IFSelect_SignatureList_swigregister
Handle_IFSelect_SignatureList_swigregister(Handle_IFSelect_SignatureList)

def Handle_IFSelect_SignatureList_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignatureList_DownCast(thing)
Handle_IFSelect_SignatureList_DownCast = _IFSelect.Handle_IFSelect_SignatureList_DownCast

class Handle_IFSelect_ModifReorder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_ModifReorder self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_ModifReorder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_ModifReorder self, IFSelect_ModifReorder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_ModifReorder self, Handle_IFSelect_ModifReorder theHandle) -> Handle_IFSelect_ModifReorder
        assign(Handle_IFSelect_ModifReorder self, IFSelect_ModifReorder thePtr) -> Handle_IFSelect_ModifReorder
        assign(Handle_IFSelect_ModifReorder self, Handle_IFSelect_ModifReorder theHandle) -> Handle_IFSelect_ModifReorder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_ModifReorder self) -> IFSelect_ModifReorder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_ModifReorder self) -> IFSelect_ModifReorder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ModifReorder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_ModifReorder self) -> IFSelect_ModifReorder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_ModifReorder___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_ModifReorder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_ModifReorder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_ModifReorder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_ModifReorder_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_ModifReorder

    def Perform(self, *args):
        """
        Perform(Handle_IFSelect_ModifReorder self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        Acts by computing orders (by method All from ShareTool) then
        forcing them in the model. Remark that selection is ignored :
        ALL the model is processed in once

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Perform(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_ModifReorder self) -> TCollection_AsciiString

        Returns Label as "Reorder, Roots (last or first)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_ModifReorder self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ModifReorder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ModifReorder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_IFSelect_ModifReorder self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_IFSelect_ModifReorder self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_IFSelect_ModifReorder self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_IFSelect_ModifReorder self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_ModifReorder self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_IFSelect_ModifReorder self)

        Resets the Selection : this criterium is not longer active


        """
        return _IFSelect.Handle_IFSelect_ModifReorder_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_IFSelect_ModifReorder self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_ModifReorder self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Selection(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_ModifReorder self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_ModifReorder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_ModifReorder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_ModifReorder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_ModifReorder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_ModifReorder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_ModifReorder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_ModifReorder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_ModifReorder self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_ModifReorder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_ModifReorder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModifReorder_DecrementRefCounter(self, *args)

Handle_IFSelect_ModifReorder_swigregister = _IFSelect.Handle_IFSelect_ModifReorder_swigregister
Handle_IFSelect_ModifReorder_swigregister(Handle_IFSelect_ModifReorder)

def Handle_IFSelect_ModifReorder_DownCast(thing):
    return _IFSelect.Handle_IFSelect_ModifReorder_DownCast(thing)
Handle_IFSelect_ModifReorder_DownCast = _IFSelect.Handle_IFSelect_ModifReorder_DownCast

class NCollection_Sequence_Handle_IFSelect_Selection(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_IFSelect_Selection self) -> NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_IFSelect_Selection self) -> NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_IFSelect_Selection self) -> NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_IFSelect_Selection self) -> NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_IFSelect_Selection self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_IFSelect_Selection self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_IFSelect_Selection self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_IFSelect_Selection self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_IFSelect_Selection self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_IFSelect_Selection self)

        Reverse sequence


        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_IFSelect_Selection self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_IFSelect_Selection self, NCollection_Sequence_Handle_IFSelect_Selection theOther) -> NCollection_Sequence_Handle_IFSelect_Selection

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_IFSelect_Selection self, NCollection_Sequence_Handle_IFSelect_Selection theOther) -> NCollection_Sequence_Handle_IFSelect_Selection

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_IFSelect_Selection self, NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_IFSelect_Selection self, Handle_IFSelect_Selection theItem)
        Append(NCollection_Sequence_Handle_IFSelect_Selection self, NCollection_Sequence_Handle_IFSelect_Selection theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_IFSelect_Selection self, Handle_IFSelect_Selection theItem)
        Prepend(NCollection_Sequence_Handle_IFSelect_Selection self, NCollection_Sequence_Handle_IFSelect_Selection theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex, Handle_IFSelect_Selection theItem)
        InsertBefore(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_Selection theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_IFSelect_Selection self, NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::Iterator & thePosition, Handle_IFSelect_Selection theItem)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_Selection theSeq)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex, Handle_IFSelect_Selection theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_Selection theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_IFSelect_Selection self) -> Handle_IFSelect_Selection

        First item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_IFSelect_Selection self) -> Handle_IFSelect_Selection

        Last item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex) -> Handle_IFSelect_Selection

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_IFSelect_Selection self, Standard_Integer const theIndex, Handle_IFSelect_Selection theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_SetValue(self, *args)


    def __iter__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection___iter__(self)
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_Selection
NCollection_Sequence_Handle_IFSelect_Selection_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_swigregister
NCollection_Sequence_Handle_IFSelect_Selection_swigregister(NCollection_Sequence_Handle_IFSelect_Selection)

def NCollection_Sequence_Handle_IFSelect_Selection_delNode(*args):
    """
    NCollection_Sequence_Handle_IFSelect_Selection_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_delNode(*args)

class NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper

    def __next__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper___next__(self)
NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper_swigregister
NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper_swigregister(NCollection_Sequence_Handle_IFSelect_Selection_IteratorHelper)


try:
	IFSelect_TSeqOfSelection = NCollection_Sequence_Handle_IFSelect_Selection
except NameError:
	pass # does not exist, probably ignored

class Handle_IFSelect_WorkLibrary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_WorkLibrary self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_WorkLibrary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_WorkLibrary self, IFSelect_WorkLibrary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_WorkLibrary self, Handle_IFSelect_WorkLibrary theHandle) -> Handle_IFSelect_WorkLibrary
        assign(Handle_IFSelect_WorkLibrary self, IFSelect_WorkLibrary thePtr) -> Handle_IFSelect_WorkLibrary
        assign(Handle_IFSelect_WorkLibrary self, Handle_IFSelect_WorkLibrary theHandle) -> Handle_IFSelect_WorkLibrary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_WorkLibrary self) -> IFSelect_WorkLibrary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_WorkLibrary self) -> IFSelect_WorkLibrary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_WorkLibrary self) -> IFSelect_WorkLibrary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_WorkLibrary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_WorkLibrary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_WorkLibrary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_WorkLibrary_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_WorkLibrary

    def ReadFile(self, *args):
        """
        ReadFile(Handle_IFSelect_WorkLibrary self, Standard_CString const name, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol) -> Standard_Integer

        Gives the way to Read a File and transfer it to a Model
        <mod> is the resulting Model, which has to be created by this
        method. In case of error, <mod> must be returned Null
        Return value is a status with free values.
        Simply, 0 is for "Execution OK"
        The Protocol can be used to work (e.g. create the Model, read
        and recognize the Entities)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_ReadFile(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(Handle_IFSelect_WorkLibrary self, IFSelect_ContextWrite ctx) -> Standard_Boolean

        Gives the way to Write a File from a Model.
        <ctx> contains all necessary informations : the model, the
        protocol, the file name, and the list of File Modifiers to be
        applied, also with restricted list of selected entities for
        each one, if required.
        In return, it brings the produced check-list

        The WorkLibrary has to query <applied> to get then run the
        ContextWrite by looping like this (example) :
        for (numap = 1; numap <= ctx.NbModifiers(); numap ++) {
        ctx.SetModifier (numap);
        cast ctx.FileModifier()  to specific type -> variable filemod
        if (!filemod.IsNull()) filemod->Perform (ctx,writer);
        filemod then works with ctx. It can, either act on the
        model itself (for instance on its header), or iterate
        on selected entities (Start/Next/More/Value)
        it can call AddFail or AddWarning, as necessary
        }

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextWrite
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_WriteFile(self, *args)


    def CopyModel(self, *args):
        """
        CopyModel(Handle_IFSelect_WorkLibrary self, Handle_Interface_InterfaceModel original, Handle_Interface_InterfaceModel newmodel, Interface_EntityIterator list, Interface_CopyTool TC) -> Standard_Boolean

        Performs the copy of entities from an original model to a new
        one. It must also copy headers if any. Returns True when done.
        The provided default works by copying the individual entities
        designated in the list, by using the general service class
        CopyTool.
        It can be redefined for a norm which, either implements Copy
        by another way (do not forget to Bind each copied result with
        its original entity in TC) and returns True, or does not know
        how to copy and returns False

        :type original: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type newmodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type list: OCC.wrapper.Interface.Interface_EntityIterator
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_CopyModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(Handle_IFSelect_WorkLibrary self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol, Handle_Standard_Transient entity, Handle_Message_Messenger S, Standard_Integer const level)
        DumpEntity(Handle_IFSelect_WorkLibrary self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol, Handle_Standard_Transient entity, Handle_Message_Messenger S)

        Calls deferred DumpEntity with the recorded default level

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type entity: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_DumpEntity(self, *args)


    def SetDumpLevels(self, *args):
        """
        SetDumpLevels(Handle_IFSelect_WorkLibrary self, Standard_Integer const arg2, Standard_Integer const max)

        Records a default level and a maximum value for level
        level for DumpEntity can go between 0 and <max>
        default value will be <def>

        :type def: int
        :type max: int

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_SetDumpLevels(self, *args)


    def DumpLevels(self, *args):
        """
        DumpLevels(Handle_IFSelect_WorkLibrary self)

        Returns the recorded default and maximum dump levels
        If none was recorded, max is returned negative, def as zero

        :type def: int
        :type max: int

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_DumpLevels(self, *args)


    def SetDumpHelp(self, *args):
        """
        SetDumpHelp(Handle_IFSelect_WorkLibrary self, Standard_Integer const level, Standard_CString const help)

        Records a short line of help for a level (0 - max)

        :type level: int
        :type help: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_SetDumpHelp(self, *args)


    def DumpHelp(self, *args):
        """
        DumpHelp(Handle_IFSelect_WorkLibrary self, Standard_Integer const level) -> Standard_CString

        Returns the help line recorded for <level>, or an empty string

        :type level: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_DumpHelp(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_WorkLibrary self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_WorkLibrary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_WorkLibrary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_WorkLibrary self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_WorkLibrary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_WorkLibrary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_WorkLibrary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_WorkLibrary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_WorkLibrary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_WorkLibrary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_WorkLibrary self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_WorkLibrary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkLibrary_DecrementRefCounter(self, *args)

Handle_IFSelect_WorkLibrary_swigregister = _IFSelect.Handle_IFSelect_WorkLibrary_swigregister
Handle_IFSelect_WorkLibrary_swigregister(Handle_IFSelect_WorkLibrary)

def Handle_IFSelect_WorkLibrary_DownCast(thing):
    return _IFSelect.Handle_IFSelect_WorkLibrary_DownCast(thing)
Handle_IFSelect_WorkLibrary_DownCast = _IFSelect.Handle_IFSelect_WorkLibrary_DownCast

class Handle_IFSelect_ListEditor(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_ListEditor self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_ListEditor_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_ListEditor self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_ListEditor self, IFSelect_ListEditor thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_ListEditor_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_ListEditor self, Handle_IFSelect_ListEditor theHandle) -> Handle_IFSelect_ListEditor
        assign(Handle_IFSelect_ListEditor self, IFSelect_ListEditor thePtr) -> Handle_IFSelect_ListEditor
        assign(Handle_IFSelect_ListEditor self, Handle_IFSelect_ListEditor theHandle) -> Handle_IFSelect_ListEditor

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_ListEditor_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_ListEditor self) -> IFSelect_ListEditor

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ListEditor_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_ListEditor self) -> IFSelect_ListEditor

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ListEditor___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_ListEditor self) -> IFSelect_ListEditor

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_ListEditor___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_ListEditor___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_ListEditor___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_ListEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_ListEditor_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_ListEditor

    def LoadModel(self, *args):
        """
        LoadModel(Handle_IFSelect_ListEditor self, Handle_Interface_InterfaceModel model)

        Loads a Model. It is used to check items of type Entity(Ident)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_ListEditor_LoadModel(self, *args)


    def LoadValues(self, *args):
        """
        LoadValues(Handle_IFSelect_ListEditor self, Handle_TColStd_HSequenceOfHAsciiString vals)

        Loads the original values for the list
        Remark : If its length is mor then MaxLength, editions remain
        allowed, except Add

        :type vals: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_ListEditor_LoadValues(self, *args)


    def SetTouched(self, *args):
        """
        SetTouched(Handle_IFSelect_ListEditor self)

        Declares this ListEditor to have been touched (whatever action)


        """
        return _IFSelect.Handle_IFSelect_ListEditor_SetTouched(self, *args)


    def ClearEdit(self, *args):
        """
        ClearEdit(Handle_IFSelect_ListEditor self)

        Clears all editions already recorded


        """
        return _IFSelect.Handle_IFSelect_ListEditor_ClearEdit(self, *args)


    def LoadEdited(self, *args):
        """
        LoadEdited(Handle_IFSelect_ListEditor self, Handle_TColStd_HSequenceOfHAsciiString list) -> Standard_Boolean

        Loads a new list to replace the older one, in once !
        By default (can be redefined) checks the length of the list
        and the value of each item according to the def
        Items are all recorded as Modified

        If no def has been given at creation time, no check is done
        Returns True when done, False if checks have failed ... a
        specialisation may also lock it by returning always False ...

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_LoadEdited(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_IFSelect_ListEditor self, Standard_Integer const num, Handle_TCollection_HAsciiString val) -> Standard_Boolean

        Sets a new value for the item <num> (in edited list)
        <val> may be a Null Handle, then the value will be cleared but
        not removed
        Returns True when done. False if <num> is out of range or if
        <val> does not satisfy the definition

        :type num: int
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_SetValue(self, *args)


    def AddValue(self, *args):
        """
        AddValue(Handle_IFSelect_ListEditor self, Handle_TCollection_HAsciiString val, Standard_Integer const atnum=0) -> Standard_Boolean

        Adds a new item. By default appends (at the end of the list)
        Can insert before a given rank <num>, if positive
        Returns True when done. False if MaxLength may be overpassed
        or if <val> does not satisfy the definition

        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_AddValue(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_ListEditor self, Standard_Integer const num=0, Standard_Integer const howmany=1) -> Standard_Boolean

        Removes items from the list
        By default removes one item. Else, count given by <howmany>
        Remove from rank <num> included. By default, from the end
        Returns True when done, False (and does not work) if case of
        out of range of if <howmany> is greater than current length

        :type num: int
        :type howmany: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_Remove(self, *args)


    def OriginalValues(self, *args):
        """
        OriginalValues(Handle_IFSelect_ListEditor self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the value from which the edition started

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_ListEditor_OriginalValues(self, *args)


    def EditedValues(self, *args):
        """
        EditedValues(Handle_IFSelect_ListEditor self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the result of the edition

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_ListEditor_EditedValues(self, *args)


    def NbValues(self, *args):
        """
        NbValues(Handle_IFSelect_ListEditor self, Standard_Boolean const edited) -> Standard_Integer

        Returns count of values, edited (D) or original

        :type edited: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ListEditor_NbValues(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IFSelect_ListEditor self, Standard_Integer const num, Standard_Boolean const edited) -> Handle_TCollection_HAsciiString

        Returns a value given its rank. Edited (D) or Original
        A Null String means the value is cleared but not removed

        :type num: int
        :type edited: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ListEditor_Value(self, *args)


    def IsChanged(self, *args):
        """
        IsChanged(Handle_IFSelect_ListEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a value (in edited list) has been changed, i.e.
        either modified-value, or added

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsChanged(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_IFSelect_ListEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a value (in edited list) has been modified-value
        (not added)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsModified(self, *args)


    def IsAdded(self, *args):
        """
        IsAdded(Handle_IFSelect_ListEditor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a value (in edited list) has been added (new one)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsAdded(self, *args)


    def IsTouched(self, *args):
        """
        IsTouched(Handle_IFSelect_ListEditor self) -> Standard_Boolean

        Tells if at least one edition (SetValue-AddValue-Remove) has
        been recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsTouched(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_ListEditor self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_ListEditor_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ListEditor_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ListEditor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_ListEditor self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_ListEditor_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_ListEditor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_ListEditor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_ListEditor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_ListEditor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ListEditor_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_ListEditor self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_ListEditor_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_ListEditor self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ListEditor_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_ListEditor self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_ListEditor_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_ListEditor self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ListEditor_DecrementRefCounter(self, *args)

Handle_IFSelect_ListEditor_swigregister = _IFSelect.Handle_IFSelect_ListEditor_swigregister
Handle_IFSelect_ListEditor_swigregister(Handle_IFSelect_ListEditor)

def Handle_IFSelect_ListEditor_DownCast(thing):
    return _IFSelect.Handle_IFSelect_ListEditor_DownCast(thing)
Handle_IFSelect_ListEditor_DownCast = _IFSelect.Handle_IFSelect_ListEditor_DownCast

class NCollection_Sequence_Handle_IFSelect_Dispatch(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_Dispatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_IFSelect_Dispatch self)

        Reverse sequence


        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_IFSelect_Dispatch self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_IFSelect_Dispatch self, NCollection_Sequence_Handle_IFSelect_Dispatch theOther) -> NCollection_Sequence_Handle_IFSelect_Dispatch

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_IFSelect_Dispatch self, NCollection_Sequence_Handle_IFSelect_Dispatch theOther) -> NCollection_Sequence_Handle_IFSelect_Dispatch

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_IFSelect_Dispatch self, NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_IFSelect_Dispatch self, Handle_IFSelect_Dispatch theItem)
        Append(NCollection_Sequence_Handle_IFSelect_Dispatch self, NCollection_Sequence_Handle_IFSelect_Dispatch theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_IFSelect_Dispatch self, Handle_IFSelect_Dispatch theItem)
        Prepend(NCollection_Sequence_Handle_IFSelect_Dispatch self, NCollection_Sequence_Handle_IFSelect_Dispatch theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex, Handle_IFSelect_Dispatch theItem)
        InsertBefore(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_Dispatch theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_IFSelect_Dispatch self, NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::Iterator & thePosition, Handle_IFSelect_Dispatch theItem)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_Dispatch theSeq)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex, Handle_IFSelect_Dispatch theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_Dispatch theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Handle_IFSelect_Dispatch

        First item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_IFSelect_Dispatch self) -> Handle_IFSelect_Dispatch

        Last item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex) -> Handle_IFSelect_Dispatch

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_IFSelect_Dispatch self, Standard_Integer const theIndex, Handle_IFSelect_Dispatch theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_SetValue(self, *args)


    def __iter__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch___iter__(self)
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_Dispatch
NCollection_Sequence_Handle_IFSelect_Dispatch_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_swigregister
NCollection_Sequence_Handle_IFSelect_Dispatch_swigregister(NCollection_Sequence_Handle_IFSelect_Dispatch)

def NCollection_Sequence_Handle_IFSelect_Dispatch_delNode(*args):
    """
    NCollection_Sequence_Handle_IFSelect_Dispatch_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_delNode(*args)

class NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper

    def __next__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper___next__(self)
NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper_swigregister
NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper_swigregister(NCollection_Sequence_Handle_IFSelect_Dispatch_IteratorHelper)


try:
	IFSelect_TSeqOfDispatch = NCollection_Sequence_Handle_IFSelect_Dispatch
except NameError:
	pass # does not exist, probably ignored

class IFSelect_ModifEditForm(IFSelect_Modifier):
    """This modifier applies an EditForm on the entities selected"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_ModifEditForm
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_ModifEditForm(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_ModifEditForm self, Handle_IFSelect_EditForm editform) -> IFSelect_ModifEditForm

        Creates a ModifEditForm. It may not change the graph

        :type editform: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm

        """
        this = _IFSelect.new_IFSelect_ModifEditForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def EditForm(self, *args):
        """
        EditForm(IFSelect_ModifEditForm self) -> Handle_IFSelect_EditForm

        Returns the EditForm

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm

        """
        return _IFSelect.IFSelect_ModifEditForm_EditForm(self, *args)


    def Perform(self, *args):
        """
        Perform(IFSelect_ModifEditForm self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        Acts by applying an EditForm to entities, selected or all model

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _IFSelect.IFSelect_ModifEditForm_Perform(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_ModifEditForm self) -> TCollection_AsciiString

        Returns Label as "Apply EditForm <+ label of EditForm>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ModifEditForm_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_ModifEditForm_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_ModifEditForm_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_ModifEditForm_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_ModifEditForm
IFSelect_ModifEditForm_swigregister = _IFSelect.IFSelect_ModifEditForm_swigregister
IFSelect_ModifEditForm_swigregister(IFSelect_ModifEditForm)

def IFSelect_ModifEditForm_get_type_name(*args):
    """
    IFSelect_ModifEditForm_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_ModifEditForm_get_type_name(*args)

def IFSelect_ModifEditForm_get_type_descriptor(*args):
    """
    IFSelect_ModifEditForm_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_ModifEditForm_get_type_descriptor(*args)

class IFSelect_SelectRootComps(IFSelect_SelectExtract):
    """
    A SelectRootComps sorts the Entities which are part of Strong
    Componants, local roots of a set of Entities : they can be
    Single Componants (containing one Entity) or Cycles
    This class gives a more secure result than SelectRoots (which
    considers only Single Componants) but is longer to work : it
    can be used when there can be or there are cycles in a Model
    For each cycle, one Entity is given arbitrarily
    Reject works as for SelectRoots : Strong Componants defined in
    the input list which are not local roots are given
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectRootComps
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectRootComps(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectRootComps self) -> IFSelect_SelectRootComps

        Creates a SelectRootComps


        """
        this = _IFSelect.new_IFSelect_SelectRootComps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectRootComps self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of local root strong componants, by one
        Entity par componant. It is redefined for a purpose of
        effeciency : calling a Sort routine for each Entity would
        cost more ressource than to work in once using a Map
        RootResult takes in account the Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectRootComps_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectRootComps self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always True, because RootResult has done work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectRootComps_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectRootComps self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Local Root Componants"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectRootComps_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectRootComps_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectRootComps_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectRootComps_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectRootComps
IFSelect_SelectRootComps_swigregister = _IFSelect.IFSelect_SelectRootComps_swigregister
IFSelect_SelectRootComps_swigregister(IFSelect_SelectRootComps)

def IFSelect_SelectRootComps_get_type_name(*args):
    """
    IFSelect_SelectRootComps_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectRootComps_get_type_name(*args)

def IFSelect_SelectRootComps_get_type_descriptor(*args):
    """
    IFSelect_SelectRootComps_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectRootComps_get_type_descriptor(*args)

class Handle_IFSelect_SelectFlag(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectFlag self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectFlag_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectFlag self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectFlag self, IFSelect_SelectFlag thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectFlag self, Handle_IFSelect_SelectFlag theHandle) -> Handle_IFSelect_SelectFlag
        assign(Handle_IFSelect_SelectFlag self, IFSelect_SelectFlag thePtr) -> Handle_IFSelect_SelectFlag
        assign(Handle_IFSelect_SelectFlag self, Handle_IFSelect_SelectFlag theHandle) -> Handle_IFSelect_SelectFlag

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectFlag self) -> IFSelect_SelectFlag

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectFlag self) -> IFSelect_SelectFlag

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectFlag___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectFlag self) -> IFSelect_SelectFlag

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectFlag___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectFlag___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectFlag___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectFlag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectFlag_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectFlag

    def FlagName(self, *args):
        """
        FlagName(Handle_IFSelect_SelectFlag self) -> Standard_CString

        Returns the name of the flag

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_FlagName(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectFlag self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. It is redefined to
        work on the graph itself (not queried by sort)

        An entity is selected if its flag is True on Direct mode,
        False on Reversed mode

        If flag does not exist for the given name, returns an empty
        result, whatever the Direct/Reversed sense

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectFlag self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always False because RootResult has done the work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectFlag self) -> TCollection_AsciiString

        Returns a text defining the criterium, includes the flag name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectFlag self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectFlag_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectFlag_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectFlag self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectFlag self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_SetDirect(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectFlag self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectFlag self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectFlag self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectFlag self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectFlag self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectFlag self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectFlag self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectFlag self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectFlag self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectFlag self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectFlag self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectFlag self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectFlag_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectFlag self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectFlag self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectFlag self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectFlag self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectFlag self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectFlag self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectFlag self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectFlag_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectFlag self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectFlag_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectFlag_swigregister = _IFSelect.Handle_IFSelect_SelectFlag_swigregister
Handle_IFSelect_SelectFlag_swigregister(Handle_IFSelect_SelectFlag)

def Handle_IFSelect_SelectFlag_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectFlag_DownCast(thing)
Handle_IFSelect_SelectFlag_DownCast = _IFSelect.Handle_IFSelect_SelectFlag_DownCast

class Handle_IFSelect_SelectRange(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectRange self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectRange_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectRange self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectRange_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectRange self, IFSelect_SelectRange thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRange_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectRange self, Handle_IFSelect_SelectRange theHandle) -> Handle_IFSelect_SelectRange
        assign(Handle_IFSelect_SelectRange self, IFSelect_SelectRange thePtr) -> Handle_IFSelect_SelectRange
        assign(Handle_IFSelect_SelectRange self, Handle_IFSelect_SelectRange theHandle) -> Handle_IFSelect_SelectRange

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectRange_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectRange self) -> IFSelect_SelectRange

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRange_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectRange self) -> IFSelect_SelectRange

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRange___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectRange self) -> IFSelect_SelectRange

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectRange___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectRange___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectRange___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectRange_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectRange

    def SetRange(self, *args):
        """
        SetRange(Handle_IFSelect_SelectRange self, Handle_IFSelect_IntParam rankfrom, Handle_IFSelect_IntParam rankto)

        Sets a Range for numbers, with a lower and a upper limits
        Error if rankto is lower then rankfrom

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SetRange(self, *args)


    def SetOne(self, *args):
        """
        SetOne(Handle_IFSelect_SelectRange self, Handle_IFSelect_IntParam rank)

        Sets a unique number (only one Entity will be sorted as True)

        :type rank: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SetOne(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(Handle_IFSelect_SelectRange self, Handle_IFSelect_IntParam rankfrom)

        Sets a Lower limit but no upper limit

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SetFrom(self, *args)


    def SetUntil(self, *args):
        """
        SetUntil(Handle_IFSelect_SelectRange self, Handle_IFSelect_IntParam rankto)

        Sets an Upper limit but no lower limit (equivalent to lower 1)

        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SetUntil(self, *args)


    def HasLower(self, *args):
        """
        HasLower(Handle_IFSelect_SelectRange self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_HasLower(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_IFSelect_SelectRange self) -> Handle_IFSelect_IntParam

        Returns Lower limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectRange_Lower(self, *args)


    def LowerValue(self, *args):
        """
        LowerValue(Handle_IFSelect_SelectRange self) -> Standard_Integer

        Returns Value of Lower Limit (0 if none is defined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRange_LowerValue(self, *args)


    def HasUpper(self, *args):
        """
        HasUpper(Handle_IFSelect_SelectRange self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_HasUpper(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_IFSelect_SelectRange self) -> Handle_IFSelect_IntParam

        Returns Upper limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectRange_Upper(self, *args)


    def UpperValue(self, *args):
        """
        UpperValue(Handle_IFSelect_SelectRange self) -> Standard_Integer

        Returns Value of Upper Limit (0 if none is defined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRange_UpperValue(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectRange self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity of which occurence number in the
        iteration is inside the selected Range (considers <rank>)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectRange self) -> TCollection_AsciiString

        Returns a text defining the criterium : following cases,
        " From .. Until .." or "From .." or "Until .." or "Rank no .."

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectRange_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectRange self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectRange_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectRange_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectRange_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectRange self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectRange self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectRange self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRange_RootResult(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectRange self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectRange self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectRange_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectRange self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectRange_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectRange self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectRange_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectRange self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectRange self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectRange self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectRange_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectRange self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRange_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectRange self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRange_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectRange self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRange_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectRange self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRange_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectRange self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectRange_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectRange self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectRange self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectRange self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectRange self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRange_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectRange self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectRange_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectRange self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRange_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectRange self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectRange_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectRange self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRange_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectRange_swigregister = _IFSelect.Handle_IFSelect_SelectRange_swigregister
Handle_IFSelect_SelectRange_swigregister(Handle_IFSelect_SelectRange)

def Handle_IFSelect_SelectRange_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectRange_DownCast(thing)
Handle_IFSelect_SelectRange_DownCast = _IFSelect.Handle_IFSelect_SelectRange_DownCast

class Handle_IFSelect_Signature(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Signature self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Signature_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Signature self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Signature_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Signature self, IFSelect_Signature thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Signature_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Signature self, Handle_IFSelect_Signature theHandle) -> Handle_IFSelect_Signature
        assign(Handle_IFSelect_Signature self, IFSelect_Signature thePtr) -> Handle_IFSelect_Signature
        assign(Handle_IFSelect_Signature self, Handle_IFSelect_Signature theHandle) -> Handle_IFSelect_Signature

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Signature_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Signature self) -> IFSelect_Signature

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Signature_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Signature self) -> IFSelect_Signature

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Signature___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Signature self) -> IFSelect_Signature

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Signature___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Signature___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Signature___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Signature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Signature_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Signature

    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_IFSelect_Signature self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.Handle_IFSelect_Signature_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_IFSelect_Signature self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Signature_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_IFSelect_Signature self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Signature_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_IFSelect_Signature self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_Signature_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_Signature self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Signature_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_Signature self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Signature_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_IFSelect_Signature self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Signature_Matches(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_IFSelect_Signature self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Signature_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_Signature self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Signature_IntValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Signature self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Signature_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Signature_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Signature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Text(self, *args):
        """
        Text(Handle_IFSelect_Signature self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Signature_Text(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IFSelect_Signature self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Signature_Value(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_IFSelect_Signature self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Signature_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_IFSelect_Signature self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Signature_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Signature self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Signature_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Signature self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Signature self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Signature_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Signature self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Signature self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Signature_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Signature self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Signature_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Signature self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Signature_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Signature self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Signature_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Signature self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Signature_DecrementRefCounter(self, *args)

Handle_IFSelect_Signature_swigregister = _IFSelect.Handle_IFSelect_Signature_swigregister
Handle_IFSelect_Signature_swigregister(Handle_IFSelect_Signature)

def Handle_IFSelect_Signature_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Signature_DownCast(thing)
Handle_IFSelect_Signature_DownCast = _IFSelect.Handle_IFSelect_Signature_DownCast

class IFSelect_SelectType(IFSelect_SelectAnyType):
    """
    A SelectType keeps or rejects Entities of which the Type
    is Kind of a given Cdl Type
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectType self) -> IFSelect_SelectType
        __init__(IFSelect_SelectType self, Handle_Standard_Type atype) -> IFSelect_SelectType

        Creates a SelectType for a given Type

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        this = _IFSelect.new_IFSelect_SelectType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetType(self, *args):
        """
        SetType(IFSelect_SelectType self, Handle_Standard_Type atype)

        Sets a TYpe for filter

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectType_SetType(self, *args)


    def TypeForMatch(self, *args):
        """
        TypeForMatch(IFSelect_SelectType self) -> Handle_Standard_Type

        Returns the Type to be matched for select : this is the type
        given at instantiation time

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectType_TypeForMatch(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectType self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (should by gotten from Type of Entity used for instantiation)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectType_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectType
IFSelect_SelectType_swigregister = _IFSelect.IFSelect_SelectType_swigregister
IFSelect_SelectType_swigregister(IFSelect_SelectType)

def IFSelect_SelectType_get_type_name(*args):
    """
    IFSelect_SelectType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectType_get_type_name(*args)

def IFSelect_SelectType_get_type_descriptor(*args):
    """
    IFSelect_SelectType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectType_get_type_descriptor(*args)

class Handle_IFSelect_DispPerFiles(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_DispPerFiles self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_DispPerFiles self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_DispPerFiles self, IFSelect_DispPerFiles thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_DispPerFiles self, Handle_IFSelect_DispPerFiles theHandle) -> Handle_IFSelect_DispPerFiles
        assign(Handle_IFSelect_DispPerFiles self, IFSelect_DispPerFiles thePtr) -> Handle_IFSelect_DispPerFiles
        assign(Handle_IFSelect_DispPerFiles self, Handle_IFSelect_DispPerFiles theHandle) -> Handle_IFSelect_DispPerFiles

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_DispPerFiles self) -> IFSelect_DispPerFiles

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_DispPerFiles self) -> IFSelect_DispPerFiles

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_DispPerFiles self) -> IFSelect_DispPerFiles

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_DispPerFiles___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_DispPerFiles___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_DispPerFiles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_DispPerFiles_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_DispPerFiles

    def Count(self, *args):
        """
        Count(Handle_IFSelect_DispPerFiles self) -> Handle_IFSelect_IntParam

        Returns the Count Parameter used for splitting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Count(self, *args)


    def SetCount(self, *args):
        """
        SetCount(Handle_IFSelect_DispPerFiles self, Handle_IFSelect_IntParam count)

        Sets a new Parameter for Count

        :type count: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_SetCount(self, *args)


    def CountValue(self, *args):
        """
        CountValue(Handle_IFSelect_DispPerFiles self) -> Standard_Integer

        Returns the effective value of the count parameter
        (if Count Parameter not Set or value not positive, returns 1)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_CountValue(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_DispPerFiles self) -> TCollection_AsciiString

        Returns as Label, "Maximum <count> Files"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(Handle_IFSelect_DispPerFiles self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum count is given as CountValue

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(Handle_IFSelect_DispPerFiles self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It defines Packets in
        order to have <Count> Packets, except if the input count of
        Entities is lower. Entities are given by RootResult from the
        Final Selection.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Packets(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_DispPerFiles self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerFiles_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerFiles_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_DispPerFiles self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_DispPerFiles self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.Handle_IFSelect_DispPerFiles_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(Handle_IFSelect_DispPerFiles self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(Handle_IFSelect_DispPerFiles self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(Handle_IFSelect_DispPerFiles self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(Handle_IFSelect_DispPerFiles self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_CanHaveRemainder(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(Handle_IFSelect_DispPerFiles self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_GetEntities(self, *args)


    def Packeted(self, *args):
        """
        Packeted(Handle_IFSelect_DispPerFiles self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(Handle_IFSelect_DispPerFiles self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Remainder(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_DispPerFiles self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_DispPerFiles self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_DispPerFiles self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_DispPerFiles self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_DispPerFiles self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_DispPerFiles self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_DispPerFiles self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_DispPerFiles self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_DispPerFiles self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerFiles_DecrementRefCounter(self, *args)

Handle_IFSelect_DispPerFiles_swigregister = _IFSelect.Handle_IFSelect_DispPerFiles_swigregister
Handle_IFSelect_DispPerFiles_swigregister(Handle_IFSelect_DispPerFiles)

def Handle_IFSelect_DispPerFiles_DownCast(thing):
    return _IFSelect.Handle_IFSelect_DispPerFiles_DownCast(thing)
Handle_IFSelect_DispPerFiles_DownCast = _IFSelect.Handle_IFSelect_DispPerFiles_DownCast

class Handle_IFSelect_ModifEditForm(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_ModifEditForm self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_ModifEditForm self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_ModifEditForm self, IFSelect_ModifEditForm thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_ModifEditForm self, Handle_IFSelect_ModifEditForm theHandle) -> Handle_IFSelect_ModifEditForm
        assign(Handle_IFSelect_ModifEditForm self, IFSelect_ModifEditForm thePtr) -> Handle_IFSelect_ModifEditForm
        assign(Handle_IFSelect_ModifEditForm self, Handle_IFSelect_ModifEditForm theHandle) -> Handle_IFSelect_ModifEditForm

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_ModifEditForm self) -> IFSelect_ModifEditForm

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_ModifEditForm self) -> IFSelect_ModifEditForm

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_ModifEditForm self) -> IFSelect_ModifEditForm

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_ModifEditForm___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_ModifEditForm___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_ModifEditForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_ModifEditForm_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_ModifEditForm

    def EditForm(self, *args):
        """
        EditForm(Handle_IFSelect_ModifEditForm self) -> Handle_IFSelect_EditForm

        Returns the EditForm

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_EditForm(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_IFSelect_ModifEditForm self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        Acts by applying an EditForm to entities, selected or all model

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Perform(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_ModifEditForm self) -> TCollection_AsciiString

        Returns Label as "Apply EditForm <+ label of EditForm>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_ModifEditForm self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ModifEditForm_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ModifEditForm_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_IFSelect_ModifEditForm self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_IFSelect_ModifEditForm self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_IFSelect_ModifEditForm self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_IFSelect_ModifEditForm self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_ModifEditForm self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_IFSelect_ModifEditForm self)

        Resets the Selection : this criterium is not longer active


        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_IFSelect_ModifEditForm self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_ModifEditForm self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Selection(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_ModifEditForm self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_ModifEditForm self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_ModifEditForm self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_ModifEditForm self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_ModifEditForm self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_ModifEditForm self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_ModifEditForm self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_ModifEditForm self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_ModifEditForm self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModifEditForm_DecrementRefCounter(self, *args)

Handle_IFSelect_ModifEditForm_swigregister = _IFSelect.Handle_IFSelect_ModifEditForm_swigregister
Handle_IFSelect_ModifEditForm_swigregister(Handle_IFSelect_ModifEditForm)

def Handle_IFSelect_ModifEditForm_DownCast(thing):
    return _IFSelect.Handle_IFSelect_ModifEditForm_DownCast(thing)
Handle_IFSelect_ModifEditForm_DownCast = _IFSelect.Handle_IFSelect_ModifEditForm_DownCast

class NCollection_Sequence_Handle_IFSelect_AppliedModifiers(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_AppliedModifiers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self)

        Reverse sequence


        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theOther) -> NCollection_Sequence_Handle_IFSelect_AppliedModifiers

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theOther) -> NCollection_Sequence_Handle_IFSelect_AppliedModifiers

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Handle_IFSelect_AppliedModifiers theItem)
        Append(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Handle_IFSelect_AppliedModifiers theItem)
        Prepend(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex, Handle_IFSelect_AppliedModifiers theItem)
        InsertBefore(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::Iterator & thePosition, Handle_IFSelect_AppliedModifiers theItem)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theSeq)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex, Handle_IFSelect_AppliedModifiers theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_AppliedModifiers theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Handle_IFSelect_AppliedModifiers

        First item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self) -> Handle_IFSelect_AppliedModifiers

        Last item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex) -> Handle_IFSelect_AppliedModifiers

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_IFSelect_AppliedModifiers self, Standard_Integer const theIndex, Handle_IFSelect_AppliedModifiers theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_SetValue(self, *args)


    def __iter__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers___iter__(self)
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_AppliedModifiers
NCollection_Sequence_Handle_IFSelect_AppliedModifiers_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_swigregister
NCollection_Sequence_Handle_IFSelect_AppliedModifiers_swigregister(NCollection_Sequence_Handle_IFSelect_AppliedModifiers)

def NCollection_Sequence_Handle_IFSelect_AppliedModifiers_delNode(*args):
    """
    NCollection_Sequence_Handle_IFSelect_AppliedModifiers_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_delNode(*args)

class NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper

    def __next__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper___next__(self)
NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper_swigregister
NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper_swigregister(NCollection_Sequence_Handle_IFSelect_AppliedModifiers_IteratorHelper)


try:
	IFSelect_SequenceOfAppliedModifiers = NCollection_Sequence_Handle_IFSelect_AppliedModifiers
except NameError:
	pass # does not exist, probably ignored

class IFSelect_DispPerCount(IFSelect_Dispatch):
    """
    A DispPerCount gathers all the input Entities into one or
    several Packets, each containing a defined count of Entity
    This count is a Parameter of the DispPerCount, given as an
    IntParam, thus allowing external control of its Value
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_DispPerCount
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_DispPerCount(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_DispPerCount self) -> IFSelect_DispPerCount

        Creates a DispPerCount with no Count (default value 1)


        """
        this = _IFSelect.new_IFSelect_DispPerCount(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Count(self, *args):
        """
        Count(IFSelect_DispPerCount self) -> Handle_IFSelect_IntParam

        Returns the Count Parameter used for splitting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_DispPerCount_Count(self, *args)


    def SetCount(self, *args):
        """
        SetCount(IFSelect_DispPerCount self, Handle_IFSelect_IntParam count)

        Sets a new Parameter for Count

        :type count: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.IFSelect_DispPerCount_SetCount(self, *args)


    def CountValue(self, *args):
        """
        CountValue(IFSelect_DispPerCount self) -> Standard_Integer

        Returns the effective value of the count parameter
        (if Count Parameter not Set or value not positive, returns 1)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_DispPerCount_CountValue(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_DispPerCount self) -> TCollection_AsciiString

        Returns as Label, "One File per <count> Input Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_DispPerCount_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(IFSelect_DispPerCount self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum count is given as <nbent>

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_DispPerCount_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_DispPerCount self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It defines Packets in
        order to have at most <Count> Entities per Packet, Entities
        are given by RootResult from the Final Selection.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.IFSelect_DispPerCount_Packets(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_DispPerCount_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_DispPerCount_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_DispPerCount_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerCount
IFSelect_DispPerCount_swigregister = _IFSelect.IFSelect_DispPerCount_swigregister
IFSelect_DispPerCount_swigregister(IFSelect_DispPerCount)

def IFSelect_DispPerCount_get_type_name(*args):
    """
    IFSelect_DispPerCount_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_DispPerCount_get_type_name(*args)

def IFSelect_DispPerCount_get_type_descriptor(*args):
    """
    IFSelect_DispPerCount_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_DispPerCount_get_type_descriptor(*args)

class Handle_IFSelect_SelectInList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectInList self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectInList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectInList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectInList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectInList self, IFSelect_SelectInList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectInList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectInList self, Handle_IFSelect_SelectInList theHandle) -> Handle_IFSelect_SelectInList
        assign(Handle_IFSelect_SelectInList self, IFSelect_SelectInList thePtr) -> Handle_IFSelect_SelectInList
        assign(Handle_IFSelect_SelectInList self, Handle_IFSelect_SelectInList theHandle) -> Handle_IFSelect_SelectInList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectInList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectInList self) -> IFSelect_SelectInList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectInList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectInList self) -> IFSelect_SelectInList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectInList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectInList self) -> IFSelect_SelectInList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectInList___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectInList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectInList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectInList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectInList_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectInList

    def ListedEntity(self, *args):
        """
        ListedEntity(Handle_IFSelect_SelectInList self, Standard_Integer const num, Handle_Standard_Transient ent) -> Handle_Standard_Transient

        Returns an Entity, given its rank in the list

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectInList_ListedEntity(self, *args)


    def FillResult(self, *args):
        """
        FillResult(Handle_IFSelect_SelectInList self, Standard_Integer const n1, Standard_Integer const n2, Handle_Standard_Transient ent, Interface_EntityIterator result)

        Puts into the result, the sub-entities of the list, from n1 to
        n2 included. Remark that adequation with Entity's type and
        length of list has already been made at this stage
        Called by RootResult; calls ListedEntity (see below)

        :type n1: int
        :type n2: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type result: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_FillResult(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectInList self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectInList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectInList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectInList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KeepInputEntity(self, *args):
        """
        KeepInputEntity(Handle_IFSelect_SelectInList self, Interface_EntityIterator iter)

        Keeps Input Entity, as having required type. It works by
        keeping in <iter>, only suitable Entities (SelectType can be
        used). Called by RootResult (which waits for ONE ENTITY MAX)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_KeepInputEntity(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_IFSelect_SelectInList self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns count of Items in the list in the Entity <ent>
        If <ent> has not required type, returned value must be Zero

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectInList_NbItems(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Handle_IFSelect_SelectInList self, Handle_IFSelect_IntParam rankfrom, Handle_IFSelect_IntParam rankto)

        Sets a Range for numbers, with a lower and a upper limits

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectInList_SetRange(self, *args)


    def SetOne(self, *args):
        """
        SetOne(Handle_IFSelect_SelectInList self, Handle_IFSelect_IntParam rank)

        Sets a unique number (only one Entity will be sorted as True)

        :type rank: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectInList_SetOne(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(Handle_IFSelect_SelectInList self, Handle_IFSelect_IntParam rankfrom)

        Sets a Lower limit but no upper limit

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectInList_SetFrom(self, *args)


    def SetUntil(self, *args):
        """
        SetUntil(Handle_IFSelect_SelectInList self, Handle_IFSelect_IntParam rankto)

        Sets an Upper limit but no lower limit (equivalent to lower 1)

        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectInList_SetUntil(self, *args)


    def HasLower(self, *args):
        """
        HasLower(Handle_IFSelect_SelectInList self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectInList_HasLower(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_IFSelect_SelectInList self) -> Handle_IFSelect_IntParam

        Returns Lower limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectInList_Lower(self, *args)


    def LowerValue(self, *args):
        """
        LowerValue(Handle_IFSelect_SelectInList self) -> Standard_Integer

        Returns Integer Value of Lower Limit (0 if none)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectInList_LowerValue(self, *args)


    def HasUpper(self, *args):
        """
        HasUpper(Handle_IFSelect_SelectInList self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectInList_HasUpper(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_IFSelect_SelectInList self) -> Handle_IFSelect_IntParam

        Returns Upper limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectInList_Upper(self, *args)


    def UpperValue(self, *args):
        """
        UpperValue(Handle_IFSelect_SelectInList self) -> Standard_Integer

        Returns Integer Value of Upper Limit (0 if none)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectInList_UpperValue(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectInList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        complying with rank criterium)
        Error if the input list has more than one Item

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectInList self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Componants of List "
        then Specific List Label, then, following cases :
        " From .. Until .." or "From .." or "Until .." or "Rank no .."
        Specific type is given by deferred method ListLabel

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectInList_Label(self, *args)


    def ListLabel(self, *args):
        """
        ListLabel(Handle_IFSelect_SelectInList self) -> TCollection_AsciiString

        Returns the specific label for the list, which is included as
        a part of Label

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectInList_ListLabel(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectInList self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectInList_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectInList self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectInList_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectInList self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectInList_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectInList self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectInList_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectInList self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectInList_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectInList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectInList self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectInList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectInList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectInList_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectInList self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectInList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectInList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectInList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectInList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectInList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectInList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectInList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectInList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectInList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectInList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectInList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectInList self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectInList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectInList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectInList_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectInList_swigregister = _IFSelect.Handle_IFSelect_SelectInList_swigregister
Handle_IFSelect_SelectInList_swigregister(Handle_IFSelect_SelectInList)

def Handle_IFSelect_SelectInList_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectInList_DownCast(thing)
Handle_IFSelect_SelectInList_DownCast = _IFSelect.Handle_IFSelect_SelectInList_DownCast

class IFSelect_ShareOutResult(object):
    """
    This class gives results computed from a ShareOut : simulation
    before transfer, helps to list entities ...
    Transfer itself will later be performed, either by a
    TransferCopy to simply divide up a file, or a TransferDispatch
    which can be parametred with more details
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFSelect_ShareOutResult self, Handle_IFSelect_ShareOut sho, Handle_Interface_InterfaceModel mod) -> IFSelect_ShareOutResult
        __init__(IFSelect_ShareOutResult self, Handle_IFSelect_ShareOut sho, Interface_Graph G) -> IFSelect_ShareOutResult
        __init__(IFSelect_ShareOutResult self, Handle_IFSelect_Dispatch disp, Handle_Interface_InterfaceModel mod) -> IFSelect_ShareOutResult
        __init__(IFSelect_ShareOutResult self, Handle_IFSelect_Dispatch disp, Interface_Graph G) -> IFSelect_ShareOutResult

        Creates a ShareOutResult from a unique Dispatch, to work on
        a Graph. As if it was a ShareOut with only one Dispatch
        Allows to compute the effect of a single Dispatch

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type G: OCC.wrapper.Interface.Interface_Graph

        """
        this = _IFSelect.new_IFSelect_ShareOutResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ShareOut(self, *args):
        """
        ShareOut(IFSelect_ShareOutResult self) -> Handle_IFSelect_ShareOut

        Returns the ShareOut used to create the ShareOutResult
        if creation from a Dispatch, returns a Null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        return _IFSelect.IFSelect_ShareOutResult_ShareOut(self, *args)


    def Graph(self, *args):
        """
        Returns the Graph used to create theShareOutResult

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _IFSelect.IFSelect_ShareOutResult_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reset(self, *args):
        """
        Reset(IFSelect_ShareOutResult self)

        Erases computed data, in order to command a new Evaluation


        """
        return _IFSelect.IFSelect_ShareOutResult_Reset(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFSelect_ShareOutResult self)

        Evaluates the result of a ShareOut : determines Entities to be
        forgotten by the ShareOut, Entities to be transferred several
        times (duplicated), prepares an iteration on the packets to be
        produced
        Called the first time anyone question is asked, or after a
        call to Reset. Works by calling the method Prepare.


        """
        return _IFSelect.IFSelect_ShareOutResult_Evaluate(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_ShareOutResult self, Standard_Boolean const complete) -> Handle_IFSelect_PacketList

        Returns the list of recorded Packets, under two modes :
        - <complete> = False, the strict definition of Packets, i.e.
        for each one, the Root Entities, to be explicitely sent
        - <complete> = True (Default), the completely evaluated list,
        i.e. which really gives the destination of each entity :
        this mode allows to evaluate duplications
        Remark that to send packets, iteration remains preferable
        (file names are managed)

        :type complete: bool
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_PacketList

        """
        return _IFSelect.IFSelect_ShareOutResult_Packets(self, *args)


    def NbPackets(self, *args):
        """
        NbPackets(IFSelect_ShareOutResult self) -> Standard_Integer

        Returns the total count of produced non empty packets
        (in out : calls Evaluate as necessary)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOutResult_NbPackets(self, *args)


    def Prepare(self, *args):
        """
        Prepare(IFSelect_ShareOutResult self)

        Prepares the iteration on the packets
        This method is called by Evaluate, but can be called anytime
        The iteration consists in taking each Dispatch of the ShareOut
        beginning by the first one, compute its packets, then iterate
        on these packets. Once all these packets are iterated, the
        iteration passes to the next Dispatch, or stops.
        For a creation from a unique Dispatch, same but with only
        this Dispatch.
        Each packet can be listed, or really transferred (producing
        a derived Model, from which a file can be generated)

        Prepare sets the iteration to the first Dispatch, first Packet


        """
        return _IFSelect.IFSelect_ShareOutResult_Prepare(self, *args)


    def More(self, *args):
        """
        More(IFSelect_ShareOutResult self) -> Standard_Boolean

        Returns True if there is more packets in the current Dispatch,
        else if there is more Dispatch in the ShareOut

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOutResult_More(self, *args)


    def Next(self, *args):
        """
        Next(IFSelect_ShareOutResult self)

        Passes to the next Packet in the current Dispatch, or if there
        is none, to the next Dispatch in the ShareOut


        """
        return _IFSelect.IFSelect_ShareOutResult_Next(self, *args)


    def NextDispatch(self, *args):
        """
        NextDispatch(IFSelect_ShareOutResult self)

        Passes to the next Dispatch, regardless about remaining packets


        """
        return _IFSelect.IFSelect_ShareOutResult_NextDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(IFSelect_ShareOutResult self) -> Handle_IFSelect_Dispatch

        Returns the current Dispatch

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.IFSelect_ShareOutResult_Dispatch(self, *args)


    def DispatchRank(self, *args):
        """
        DispatchRank(IFSelect_ShareOutResult self) -> Standard_Integer

        Returns the Rank of the current Dispatch in the ShareOut
        Returns Zero if there is none (iteration finished)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOutResult_DispatchRank(self, *args)


    def PacketsInDispatch(self, *args):
        """
        PacketsInDispatch(IFSelect_ShareOutResult self)

        Returns Number (rank) of current Packet in current Dispatch,
        and total count of Packets in current Dispatch, as arguments

        :type numpack: int
        :type nbpacks: int

        """
        return _IFSelect.IFSelect_ShareOutResult_PacketsInDispatch(self, *args)


    def PacketRoot(self, *args):
        """
        PacketRoot(IFSelect_ShareOutResult self) -> Interface_EntityIterator

        Returns the list of Roots of the current Packet (never empty)
        (i.e. the Entities to be themselves asked for transfer)
        Error if there is none (iteration finished)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ShareOutResult_PacketRoot(self, *args)


    def PacketContent(self, *args):
        """
        PacketContent(IFSelect_ShareOutResult self) -> Interface_EntityIterator

        Returns the complete content of the current Packet (i.e.
        with shared entities, which will also be put in the file)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ShareOutResult_PacketContent(self, *args)


    def FileName(self, *args):
        """
        FileName(IFSelect_ShareOutResult self) -> TCollection_AsciiString

        Returns the File Name which corresponds to current Packet
        (computed by ShareOut)
        If current Packet has no associated name (see ShareOut),
        the returned value is Null

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ShareOutResult_FileName(self, *args)

    __swig_destroy__ = _IFSelect.delete_IFSelect_ShareOutResult
IFSelect_ShareOutResult_swigregister = _IFSelect.IFSelect_ShareOutResult_swigregister
IFSelect_ShareOutResult_swigregister(IFSelect_ShareOutResult)

class Handle_IFSelect_SelectShared(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectShared self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectShared_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectShared self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectShared_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectShared self, IFSelect_SelectShared thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectShared_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectShared self, Handle_IFSelect_SelectShared theHandle) -> Handle_IFSelect_SelectShared
        assign(Handle_IFSelect_SelectShared self, IFSelect_SelectShared thePtr) -> Handle_IFSelect_SelectShared
        assign(Handle_IFSelect_SelectShared self, Handle_IFSelect_SelectShared theHandle) -> Handle_IFSelect_SelectShared

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectShared_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectShared self) -> IFSelect_SelectShared

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectShared_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectShared self) -> IFSelect_SelectShared

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectShared___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectShared self) -> IFSelect_SelectShared

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectShared___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectShared___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectShared___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectShared_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectShared

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        shared by those of input list)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectShared_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectShared self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Shared (one level)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectShared_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectShared self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectShared_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectShared_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectShared_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectShared self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectShared_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectShared self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectShared_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectShared self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectShared_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectShared self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectShared_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectShared self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectShared_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectShared_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectShared self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectShared_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectShared_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectShared_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectShared self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectShared_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectShared self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectShared self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectShared_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectShared self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectShared self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectShared_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectShared self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectShared_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectShared self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectShared_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectShared self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectShared_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectShared self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectShared_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectShared_swigregister = _IFSelect.Handle_IFSelect_SelectShared_swigregister
Handle_IFSelect_SelectShared_swigregister(Handle_IFSelect_SelectShared)

def Handle_IFSelect_SelectShared_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectShared_DownCast(thing)
Handle_IFSelect_SelectShared_DownCast = _IFSelect.Handle_IFSelect_SelectShared_DownCast

class Handle_IFSelect_GeneralModifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_GeneralModifier self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_GeneralModifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_GeneralModifier self, IFSelect_GeneralModifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_GeneralModifier self, Handle_IFSelect_GeneralModifier theHandle) -> Handle_IFSelect_GeneralModifier
        assign(Handle_IFSelect_GeneralModifier self, IFSelect_GeneralModifier thePtr) -> Handle_IFSelect_GeneralModifier
        assign(Handle_IFSelect_GeneralModifier self, Handle_IFSelect_GeneralModifier theHandle) -> Handle_IFSelect_GeneralModifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_GeneralModifier self) -> IFSelect_GeneralModifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_GeneralModifier self) -> IFSelect_GeneralModifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_GeneralModifier self) -> IFSelect_GeneralModifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_GeneralModifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_GeneralModifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_GeneralModifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_GeneralModifier_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_GeneralModifier

    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_IFSelect_GeneralModifier self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_IFSelect_GeneralModifier self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_IFSelect_GeneralModifier self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_IFSelect_GeneralModifier self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_GeneralModifier self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_IFSelect_GeneralModifier self)

        Resets the Selection : this criterium is not longer active


        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_IFSelect_GeneralModifier self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_GeneralModifier self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_Selection(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_GeneralModifier self) -> TCollection_AsciiString

        Returns a short text which defines the operation performed

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_GeneralModifier self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_GeneralModifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_GeneralModifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_GeneralModifier self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_GeneralModifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_GeneralModifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_GeneralModifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_GeneralModifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_GeneralModifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_GeneralModifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_GeneralModifier self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_GeneralModifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GeneralModifier_DecrementRefCounter(self, *args)

Handle_IFSelect_GeneralModifier_swigregister = _IFSelect.Handle_IFSelect_GeneralModifier_swigregister
Handle_IFSelect_GeneralModifier_swigregister(Handle_IFSelect_GeneralModifier)

def Handle_IFSelect_GeneralModifier_DownCast(thing):
    return _IFSelect.Handle_IFSelect_GeneralModifier_DownCast(thing)
Handle_IFSelect_GeneralModifier_DownCast = _IFSelect.Handle_IFSelect_GeneralModifier_DownCast

class Handle_IFSelect_GraphCounter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_GraphCounter self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_GraphCounter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_GraphCounter self, IFSelect_GraphCounter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_GraphCounter self, Handle_IFSelect_GraphCounter theHandle) -> Handle_IFSelect_GraphCounter
        assign(Handle_IFSelect_GraphCounter self, IFSelect_GraphCounter thePtr) -> Handle_IFSelect_GraphCounter
        assign(Handle_IFSelect_GraphCounter self, Handle_IFSelect_GraphCounter theHandle) -> Handle_IFSelect_GraphCounter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_GraphCounter self) -> IFSelect_GraphCounter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_GraphCounter self) -> IFSelect_GraphCounter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_GraphCounter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_GraphCounter self) -> IFSelect_GraphCounter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_GraphCounter___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_GraphCounter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_GraphCounter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_GraphCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_GraphCounter_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_GraphCounter

    def Applied(self, *args):
        """
        Applied(Handle_IFSelect_GraphCounter self) -> Handle_IFSelect_SelectDeduct

        Returns the applied selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Applied(self, *args)


    def SetApplied(self, *args):
        """
        SetApplied(Handle_IFSelect_GraphCounter self, Handle_IFSelect_SelectDeduct sel)

        Sets a new applied selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SetApplied(self, *args)


    def AddWithGraph(self, *args):
        """
        AddWithGraph(Handle_IFSelect_GraphCounter self, Handle_TColStd_HSequenceOfTransient list, Interface_Graph graph)

        Adds a list of entities in the context given by the graph
        Default takes the count of entities selected by the applied
        selection, when it is given each entity of the list
        Can be redefined

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type graph: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_AddWithGraph(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_GraphCounter self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_GraphCounter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_GraphCounter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_GraphCounter self) -> Handle_IFSelect_Signature

        Returns the Signature used to count entities. It can be null.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Signature(self, *args)


    def SetMap(self, *args):
        """
        SetMap(Handle_IFSelect_GraphCounter self, Standard_Boolean const withmap)

        Changes the control status. The map is not cleared, simply
        its use changes

        :type withmap: bool

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SetMap(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Handle_IFSelect_GraphCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Adds an entity by considering its signature, which is given by
        call to method AddSign
        Returns True if added, False if already in the map (and
        map control status set)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_AddEntity(self, *args)


    def AddSign(self, *args):
        """
        AddSign(Handle_IFSelect_GraphCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model)

        Adds an entity (already filtered by Map) with its signature.
        This signature can be computed with the containing model.
        Its value is provided by the object Signature given at start,
        if no Signature is defined, it does nothing.

        Can be redefined (in this case, see also Sign)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_AddSign(self, *args)


    def AddList(self, *args):
        """
        AddList(Handle_IFSelect_GraphCounter self, Handle_TColStd_HSequenceOfTransient list, Handle_Interface_InterfaceModel model)

        Adds a list of entities by adding each of the items

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_AddList(self, *args)


    def AddModel(self, *args):
        """
        AddModel(Handle_IFSelect_GraphCounter self, Handle_Interface_InterfaceModel model)

        Adds all the entities contained in a Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_AddModel(self, *args)


    def AddFromSelection(self, *args):
        """
        AddFromSelection(Handle_IFSelect_GraphCounter self, Handle_IFSelect_Selection sel, Interface_Graph G)

        Adds the result determined by a Selection from a Graph
        Remark : does not impact at all data from SetSelection & Co

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type G: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_AddFromSelection(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_GraphCounter self, Handle_IFSelect_Selection sel)

        Sets a Selection as input : this causes content to be cleared
        then the Selection to be ready to compute (but not immediatly)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SetSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_GraphCounter self) -> Handle_IFSelect_Selection

        Returns the selection, or a null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Selection(self, *args)


    def SetSelMode(self, *args):
        """
        SetSelMode(Handle_IFSelect_GraphCounter self, Standard_Integer const selmode)

        Changes the mode of working with the selection :
        -1 just clears optimisation data and nothing else
        0 clears it   1 inhibits it for computing (but no clearing)
        2 sets it active for computing
        Default at creation is 0, after SetSelection (not null) is 2

        :type selmode: int

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SetSelMode(self, *args)


    def SelMode(self, *args):
        """
        SelMode(Handle_IFSelect_GraphCounter self) -> Standard_Integer

        Returns the mode of working with the selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SelMode(self, *args)


    def ComputeSelected(self, *args):
        """
        ComputeSelected(Handle_IFSelect_GraphCounter self, Interface_Graph G, Standard_Boolean const forced) -> Standard_Boolean

        Computes from the selection result, if selection is active
        (mode 2). If selection is not defined (mode 0) or is inhibited
        (mode 1) does nothing.
        Returns True if computation is done (or optimised), False else
        This method is called by ComputeCounter from WorkSession

        If <forced> is True, recomputes systematically
        Else (D), if the counter was not cleared and if the former
        computed result started from the same total size of Graph and
        same count of selected entities : computation is not redone
        unless <forced> is given as True

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type forced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_ComputeSelected(self, *args)


    def Sign(self, *args):
        """
        Sign(Handle_IFSelect_GraphCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Handle_TCollection_HAsciiString

        Determines and returns the value of the signature for an
        entity as an HAsciiString. This method works exactly as
        AddSign, which is optimized

        Can be redefined, accorded with AddSign

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Sign(self, *args)


    def ComputedSign(self, *args):
        """
        ComputedSign(Handle_IFSelect_GraphCounter self, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_CString

        Applies AddWithGraph on one entity, and returns the Signature
        Value which has been recorded
        To do this, Add is called with SignOnly Mode True during the
        call, the returned value is LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_ComputedSign(self, *args)


    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_GraphCounter self, Standard_Boolean const withlist)

        Changes the record-list status. The list is not cleared but
        its use changes

        :type withlist: bool

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SetList(self, *args)


    def ModeSignOnly(self, *args):
        """
        ModeSignOnly(Handle_IFSelect_GraphCounter self) -> Standard_Boolean &

        Returns modifiable the SignOnly Mode
        If False (D), the counter normally counts
        If True, the counting work is turned off, Add only fills the
        LastValue, which can be used as signature, when a counter
        works from data which are not available from a Signature

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_ModeSignOnly(self, *args)


    def Clear(self, *args):
        """Clear(Handle_IFSelect_GraphCounter self)"""
        return _IFSelect.Handle_IFSelect_GraphCounter_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_GraphCounter self, Handle_Standard_Transient ent, Standard_CString const sign)

        Adds an entity with its signature, i.e. :
        - counts an item more for <sign>
        - if record-list status is set, records the entity
        Accepts a null entity (the signature is then for the global
        model). But if the string is empty, counts a Null item.

        If SignOnly Mode is set, this work is replaced by just
        setting LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sign: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Add(self, *args)


    def LastValue(self, *args):
        """
        LastValue(Handle_IFSelect_GraphCounter self) -> Standard_CString

        Returns the last value recorded by Add (only if SignMode set)
        Cleared by Clear or Init

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_LastValue(self, *args)


    def Init(self, *args):
        """
        Init(Handle_IFSelect_GraphCounter self, Standard_CString const name, NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer > const & count, NCollection_IndexedDataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & list, Standard_Integer const nbnuls)

        Aknowledges the list in once. Name identifies the Signature

        :type name: OCC.wrapper.Standard.Standard_CString
        :type count: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer
        :type list: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Handle_Standard_Transient
        :type nbnuls: int

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Init(self, *args)


    def List(self, *args):
        """
        List(Handle_IFSelect_GraphCounter self, Standard_CString const root) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of signatures, as a sequence of strings
        (but without their respective counts). It is ordered.
        By default, for all the signatures.
        If <root> is given non empty, for the signatures which
        begin by <root>

        :type root: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_List(self, *args)


    def HasEntities(self, *args):
        """
        HasEntities(Handle_IFSelect_GraphCounter self) -> Standard_Boolean

        Returns True if the list of Entities is aknowledged, else
        the method Entities will always return a Null Handle

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_HasEntities(self, *args)


    def NbNulls(self, *args):
        """
        NbNulls(Handle_IFSelect_GraphCounter self) -> Standard_Integer

        Returns the count of null entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_NbNulls(self, *args)


    def NbTimes(self, *args):
        """
        NbTimes(Handle_IFSelect_GraphCounter self, Standard_CString const sign) -> Standard_Integer

        Returns the number of times a signature was counted,
        0 if it has not been recorded at all

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_NbTimes(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_IFSelect_GraphCounter self, Standard_CString const sign) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities attached to a signature
        It is empty if <sign> has not been recorded
        It is a Null Handle if the list of entities is not known

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Entities(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_IFSelect_GraphCounter self, Standard_CString const name)

        Defines a name for a SignatureList (used to print it)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_GraphCounter self) -> Standard_CString

        Returns the recorded Name.
        Remark : default is "..." (no SetName called)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Name(self, *args)


    def PrintCount(self, *args):
        """
        PrintCount(Handle_IFSelect_GraphCounter self, Handle_Message_Messenger S)

        Prints the counts of items (not the list)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_PrintCount(self, *args)


    def PrintList(self, *args):
        """
        PrintList(Handle_IFSelect_GraphCounter self, Handle_Message_Messenger S, Handle_Interface_InterfaceModel model, IFSelect_PrintCount const mod=IFSelect_ListByItem)

        Prints the lists of items, if they are present (else, prints
        a message "no list available")
        Uses <model> to determine for each entity to be listed, its
        number, and its specific identifier (by PrintLabel)
        <mod> gives a mode for printing :
        - CountByItem : just count (as PrintCount)
        - ShortByItem : minimum i.e. count plus 5 first entity numbers
        - ShortByItem(D) complete list of entity numbers (0: "Global")
        - EntitiesByItem : list of (entity number/PrintLabel from the model)
        other modes are ignored

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type mod: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_PrintList(self, *args)


    def PrintSum(self, *args):
        """
        PrintSum(Handle_IFSelect_GraphCounter self, Handle_Message_Messenger S)

        Prints a summary
        Item which has the greatest count of entities
        For items which are numeric values : their count, maximum,
        minimum values, cumul, average

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_PrintSum(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_GraphCounter self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_GraphCounter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_GraphCounter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_GraphCounter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_GraphCounter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_GraphCounter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_GraphCounter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_GraphCounter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_GraphCounter self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_GraphCounter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_GraphCounter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_GraphCounter_DecrementRefCounter(self, *args)

Handle_IFSelect_GraphCounter_swigregister = _IFSelect.Handle_IFSelect_GraphCounter_swigregister
Handle_IFSelect_GraphCounter_swigregister(Handle_IFSelect_GraphCounter)

def Handle_IFSelect_GraphCounter_DownCast(thing):
    return _IFSelect.Handle_IFSelect_GraphCounter_DownCast(thing)
Handle_IFSelect_GraphCounter_DownCast = _IFSelect.Handle_IFSelect_GraphCounter_DownCast

class Handle_IFSelect_SelectCombine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectCombine self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectCombine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectCombine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectCombine self, IFSelect_SelectCombine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectCombine self, Handle_IFSelect_SelectCombine theHandle) -> Handle_IFSelect_SelectCombine
        assign(Handle_IFSelect_SelectCombine self, IFSelect_SelectCombine thePtr) -> Handle_IFSelect_SelectCombine
        assign(Handle_IFSelect_SelectCombine self, Handle_IFSelect_SelectCombine theHandle) -> Handle_IFSelect_SelectCombine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectCombine self) -> IFSelect_SelectCombine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectCombine self) -> IFSelect_SelectCombine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectCombine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectCombine self) -> IFSelect_SelectCombine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectCombine___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectCombine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectCombine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectCombine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectCombine_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectCombine

    def NbInputs(self, *args):
        """
        NbInputs(Handle_IFSelect_SelectCombine self) -> Standard_Integer

        Returns the count of Input Selections

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_NbInputs(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectCombine self, Standard_Integer const num) -> Handle_IFSelect_Selection

        Returns an Input Selection, given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_Input(self, *args)


    def InputRank(self, *args):
        """
        InputRank(Handle_IFSelect_SelectCombine self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the rank of an input Selection, 0 if not in the list.
        Most generally, its value is meaningless, except for testing
        the presence of an input Selection :
        - == 0  if <sel> is not an input for <me>
        - >  0  if <sel> is an input for <me>

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_InputRank(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SelectCombine self, Handle_IFSelect_Selection sel, Standard_Integer const atnum=0)

        Adds a Selection to the filling list
        By default, adds it to the end of the list
        A Positive rank less then NbInputs gives an insertion rank
        (InsertBefore : the new <atnum>th item of the list is <sel>)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_SelectCombine self, Handle_IFSelect_Selection sel) -> Standard_Boolean
        Remove(Handle_IFSelect_SelectCombine self, Standard_Integer const num) -> Standard_Boolean

        Removes an input Selection, given its rank in the list
        Returns True if Done, False if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_Remove(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectCombine self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_FillIterator(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectCombine self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectCombine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectCombine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectCombine self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, computed from Input
        given as a Graph. Specific to each class of Selection
        Note that uniqueness of each entity is not required here
        This method can raise an exception as necessary

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_RootResult(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectCombine self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectCombine self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_CompleteResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectCombine self) -> TCollection_AsciiString

        Returns a text which defines the criterium applied by a
        Selection (can be used to be printed, displayed ...)
        Specific to each class

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectCombine self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectCombine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectCombine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectCombine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectCombine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectCombine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectCombine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectCombine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectCombine self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectCombine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectCombine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectCombine_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectCombine_swigregister = _IFSelect.Handle_IFSelect_SelectCombine_swigregister
Handle_IFSelect_SelectCombine_swigregister(Handle_IFSelect_SelectCombine)

def Handle_IFSelect_SelectCombine_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectCombine_DownCast(thing)
Handle_IFSelect_SelectCombine_DownCast = _IFSelect.Handle_IFSelect_SelectCombine_DownCast

class Handle_IFSelect_SelectDeduct(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectDeduct self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectDeduct self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectDeduct self, IFSelect_SelectDeduct thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectDeduct self, Handle_IFSelect_SelectDeduct theHandle) -> Handle_IFSelect_SelectDeduct
        assign(Handle_IFSelect_SelectDeduct self, IFSelect_SelectDeduct thePtr) -> Handle_IFSelect_SelectDeduct
        assign(Handle_IFSelect_SelectDeduct self, Handle_IFSelect_SelectDeduct theHandle) -> Handle_IFSelect_SelectDeduct

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectDeduct self) -> IFSelect_SelectDeduct

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectDeduct self) -> IFSelect_SelectDeduct

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectDeduct self) -> IFSelect_SelectDeduct

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectDeduct___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectDeduct___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectDeduct(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectDeduct_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectDeduct

    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectDeduct self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectDeduct self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectDeduct self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectDeduct self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectDeduct self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectDeduct self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectDeduct self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_FillIterator(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectDeduct self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectDeduct_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectDeduct_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectDeduct self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, computed from Input
        given as a Graph. Specific to each class of Selection
        Note that uniqueness of each entity is not required here
        This method can raise an exception as necessary

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_RootResult(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectDeduct self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectDeduct self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_CompleteResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectDeduct self) -> TCollection_AsciiString

        Returns a text which defines the criterium applied by a
        Selection (can be used to be printed, displayed ...)
        Specific to each class

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectDeduct self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectDeduct self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectDeduct self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectDeduct self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectDeduct self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectDeduct self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectDeduct self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectDeduct self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectDeduct self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectDeduct_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectDeduct_swigregister = _IFSelect.Handle_IFSelect_SelectDeduct_swigregister
Handle_IFSelect_SelectDeduct_swigregister(Handle_IFSelect_SelectDeduct)

def Handle_IFSelect_SelectDeduct_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectDeduct_DownCast(thing)
Handle_IFSelect_SelectDeduct_DownCast = _IFSelect.Handle_IFSelect_SelectDeduct_DownCast

class Handle_IFSelect_DispGlobal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_DispGlobal self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_DispGlobal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_DispGlobal self, IFSelect_DispGlobal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_DispGlobal self, Handle_IFSelect_DispGlobal theHandle) -> Handle_IFSelect_DispGlobal
        assign(Handle_IFSelect_DispGlobal self, IFSelect_DispGlobal thePtr) -> Handle_IFSelect_DispGlobal
        assign(Handle_IFSelect_DispGlobal self, Handle_IFSelect_DispGlobal theHandle) -> Handle_IFSelect_DispGlobal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_DispGlobal self) -> IFSelect_DispGlobal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_DispGlobal self) -> IFSelect_DispGlobal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispGlobal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_DispGlobal self) -> IFSelect_DispGlobal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_DispGlobal___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_DispGlobal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_DispGlobal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_DispGlobal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_DispGlobal_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_DispGlobal

    def Label(self, *args):
        """
        Label(Handle_IFSelect_DispGlobal self) -> TCollection_AsciiString

        Returns as Label, "One File for all Input"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(Handle_IFSelect_DispGlobal self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True : maximum equates 1

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(Handle_IFSelect_DispGlobal self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It is made of only ONE
        Packet, which gets the RootResult from the Final Selection.
        Remark : the inherited exception raising is never activated.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Packets(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_DispGlobal self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispGlobal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispGlobal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_DispGlobal self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_DispGlobal self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.Handle_IFSelect_DispGlobal_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(Handle_IFSelect_DispGlobal self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(Handle_IFSelect_DispGlobal self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(Handle_IFSelect_DispGlobal self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(Handle_IFSelect_DispGlobal self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_CanHaveRemainder(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(Handle_IFSelect_DispGlobal self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_GetEntities(self, *args)


    def Packeted(self, *args):
        """
        Packeted(Handle_IFSelect_DispGlobal self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(Handle_IFSelect_DispGlobal self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Remainder(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_DispGlobal self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_DispGlobal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_DispGlobal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_DispGlobal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_DispGlobal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_DispGlobal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_DispGlobal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_DispGlobal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_DispGlobal self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_DispGlobal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_DispGlobal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispGlobal_DecrementRefCounter(self, *args)

Handle_IFSelect_DispGlobal_swigregister = _IFSelect.Handle_IFSelect_DispGlobal_swigregister
Handle_IFSelect_DispGlobal_swigregister(Handle_IFSelect_DispGlobal)

def Handle_IFSelect_DispGlobal_DownCast(thing):
    return _IFSelect.Handle_IFSelect_DispGlobal_DownCast(thing)
Handle_IFSelect_DispGlobal_DownCast = _IFSelect.Handle_IFSelect_DispGlobal_DownCast

class IFSelect_SelectSharing(IFSelect_SelectDeduct):
    """
    A SelectSharing selects Entities which directly Share (Level
    One) the Entities of the Input list
    Remark : if an Entity of the Input List directly shares
    another one, it is of course present in the Result List
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectSharing
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectSharing(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectSharing self) -> IFSelect_SelectSharing

        Creates a SelectSharing;


        """
        this = _IFSelect.new_IFSelect_SelectSharing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        which share (level one) those of input list)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectSharing_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectSharing self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Sharing (one level)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSharing_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectSharing_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectSharing_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectSharing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSharing
IFSelect_SelectSharing_swigregister = _IFSelect.IFSelect_SelectSharing_swigregister
IFSelect_SelectSharing_swigregister(IFSelect_SelectSharing)

def IFSelect_SelectSharing_get_type_name(*args):
    """
    IFSelect_SelectSharing_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectSharing_get_type_name(*args)

def IFSelect_SelectSharing_get_type_descriptor(*args):
    """
    IFSelect_SelectSharing_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectSharing_get_type_descriptor(*args)

class Handle_IFSelect_SelectPointed(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectPointed self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectPointed self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectPointed self, IFSelect_SelectPointed thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectPointed self, Handle_IFSelect_SelectPointed theHandle) -> Handle_IFSelect_SelectPointed
        assign(Handle_IFSelect_SelectPointed self, IFSelect_SelectPointed thePtr) -> Handle_IFSelect_SelectPointed
        assign(Handle_IFSelect_SelectPointed self, Handle_IFSelect_SelectPointed theHandle) -> Handle_IFSelect_SelectPointed

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectPointed self) -> IFSelect_SelectPointed

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectPointed self) -> IFSelect_SelectPointed

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectPointed___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectPointed self) -> IFSelect_SelectPointed

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectPointed___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectPointed___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectPointed___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectPointed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectPointed_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectPointed

    def Clear(self, *args):
        """
        Clear(Handle_IFSelect_SelectPointed self)

        Clears the list of selected items
        Also says the list is unset
        All Add* methods and SetList say the list is set


        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Clear(self, *args)


    def IsSet(self, *args):
        """
        IsSet(Handle_IFSelect_SelectPointed self) -> Standard_Boolean

        Tells if the list has been set. Even if empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_IsSet(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(Handle_IFSelect_SelectPointed self, Handle_Standard_Transient item)

        As SetList but with only one entity
        If <ent> is Null, the list is said as being set but is empty

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_SetEntity(self, *args)


    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list)

        Sets a given list to define the list of selected items
        <list> can be empty or null : in this case, the list is said
        as being set, but it is empty

        To use it as an alternate input, one shot :
        - SetList or SetEntity to define the input list
        - RootResult to get it
        - then Clear to drop it

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_SetList(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Boolean

        Adds an item. Returns True if Done, False if <item> is already
        in the selected list

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an item. Returns True if Done, False if <item> was not
        in the selected list

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Remove(self, *args)


    def Toggle(self, *args):
        """
        Toggle(Handle_IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Boolean

        Toggles status of an item : adds it if not pointed or removes
        it if already pointed. Returns the new status (Pointed or not)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Toggle(self, *args)


    def AddList(self, *args):
        """
        AddList(Handle_IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Boolean

        Adds all the items defined in a list. Returns True if at least
        one item has been added, False else

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_AddList(self, *args)


    def RemoveList(self, *args):
        """
        RemoveList(Handle_IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Boolean

        Removes all the items defined in a list. Returns True if at
        least one item has been removed, False else

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_RemoveList(self, *args)


    def ToggleList(self, *args):
        """
        ToggleList(Handle_IFSelect_SelectPointed self, Handle_TColStd_HSequenceOfTransient list) -> Standard_Boolean

        Toggles status of all the items defined in a list : adds it if
        not pointed or removes it if already pointed.

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_ToggleList(self, *args)


    def Rank(self, *args):
        """
        Rank(Handle_IFSelect_SelectPointed self, Handle_Standard_Transient item) -> Standard_Integer

        Returns the rank of an item in the selected list, or 0.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Rank(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_IFSelect_SelectPointed self) -> Standard_Integer

        Returns the count of selected items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_NbItems(self, *args)


    def Item(self, *args):
        """
        Item(Handle_IFSelect_SelectPointed self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns an item given its rank, or a Null Handle

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Item(self, *args)


    def Update(self, *args):
        """
        Update(Handle_IFSelect_SelectPointed self, Handle_Interface_CopyControl control)
        Update(Handle_IFSelect_SelectPointed self, Handle_IFSelect_Transformer trf)

        Rebuilds the selected list, by querying a Transformer
        (same principle as from a CopyControl)

        :type trf: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Update(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectPointed self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected items. Only the selected entities
        which are present in the graph are given (this result assures
        uniqueness).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectPointed self) -> TCollection_AsciiString

        Returns a text which identifies the type of selection made.
        It is "Pointed Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectPointed self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectPointed_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectPointed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectPointed self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list is empty for all SelectBase type Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectPointed self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectPointed self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectPointed self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectPointed_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectPointed self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectPointed self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectPointed self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectPointed self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectPointed self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectPointed self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectPointed self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectPointed_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectPointed self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectPointed_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectPointed_swigregister = _IFSelect.Handle_IFSelect_SelectPointed_swigregister
Handle_IFSelect_SelectPointed_swigregister(Handle_IFSelect_SelectPointed)

def Handle_IFSelect_SelectPointed_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectPointed_DownCast(thing)
Handle_IFSelect_SelectPointed_DownCast = _IFSelect.Handle_IFSelect_SelectPointed_DownCast

class Handle_IFSelect_SignValidity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignValidity self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignValidity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignValidity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignValidity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignValidity self, IFSelect_SignValidity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignValidity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignValidity self, Handle_IFSelect_SignValidity theHandle) -> Handle_IFSelect_SignValidity
        assign(Handle_IFSelect_SignValidity self, IFSelect_SignValidity thePtr) -> Handle_IFSelect_SignValidity
        assign(Handle_IFSelect_SignValidity self, Handle_IFSelect_SignValidity theHandle) -> Handle_IFSelect_SignValidity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignValidity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignValidity self) -> IFSelect_SignValidity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignValidity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignValidity self) -> IFSelect_SignValidity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignValidity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignValidity self) -> IFSelect_SignValidity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignValidity___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignValidity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignValidity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignValidity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignValidity_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignValidity

    def CVal(self, *args):
        """
        CVal(Handle_IFSelect_SignValidity self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as a validity
        deducted from data (reports) stored in the model.
        Class method, can be called by any one

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_CVal(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IFSelect_SignValidity self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as a validity
        deducted from data (reports) stored in the model
        Calls the class method CVal

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignValidity self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignValidity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignValidity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignValidity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_IFSelect_SignValidity self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.Handle_IFSelect_SignValidity_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_IFSelect_SignValidity self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignValidity_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_IFSelect_SignValidity self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_IFSelect_SignValidity self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignValidity self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SignValidity self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_IFSelect_SignValidity self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignValidity_Matches(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_IFSelect_SignValidity self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignValidity_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_SignValidity self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_IFSelect_SignValidity self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_IFSelect_SignValidity self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_IFSelect_SignValidity self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignValidity_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignValidity self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignValidity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignValidity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignValidity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignValidity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignValidity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignValidity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignValidity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignValidity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignValidity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignValidity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignValidity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignValidity self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignValidity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignValidity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignValidity_DecrementRefCounter(self, *args)

Handle_IFSelect_SignValidity_swigregister = _IFSelect.Handle_IFSelect_SignValidity_swigregister
Handle_IFSelect_SignValidity_swigregister(Handle_IFSelect_SignValidity)

def Handle_IFSelect_SignValidity_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignValidity_DownCast(thing)
Handle_IFSelect_SignValidity_DownCast = _IFSelect.Handle_IFSelect_SignValidity_DownCast

class Handle_IFSelect_SelectUnknownEntities(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectUnknownEntities self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectUnknownEntities self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectUnknownEntities self, IFSelect_SelectUnknownEntities thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectUnknownEntities self, Handle_IFSelect_SelectUnknownEntities theHandle) -> Handle_IFSelect_SelectUnknownEntities
        assign(Handle_IFSelect_SelectUnknownEntities self, IFSelect_SelectUnknownEntities thePtr) -> Handle_IFSelect_SelectUnknownEntities
        assign(Handle_IFSelect_SelectUnknownEntities self, Handle_IFSelect_SelectUnknownEntities theHandle) -> Handle_IFSelect_SelectUnknownEntities

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectUnknownEntities self) -> IFSelect_SelectUnknownEntities

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectUnknownEntities self) -> IFSelect_SelectUnknownEntities

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectUnknownEntities self) -> IFSelect_SelectUnknownEntities

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectUnknownEntities___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectUnknownEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectUnknownEntities_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectUnknownEntities

    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectUnknownEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is qualified as "Unknown",
        i.e. if <model> known <ent> (through its Number) as Unknown

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectUnknownEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Recognized Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectUnknownEntities self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectUnknownEntities_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectUnknownEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectUnknownEntities self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectUnknownEntities self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectUnknownEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_RootResult(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectUnknownEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectUnknownEntities self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectUnknownEntities self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectUnknownEntities self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectUnknownEntities self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectUnknownEntities self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectUnknownEntities self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectUnknownEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectUnknownEntities self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectUnknownEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectUnknownEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectUnknownEntities self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectUnknownEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectUnknownEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectUnknownEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectUnknownEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectUnknownEntities self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectUnknownEntities self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectUnknownEntities self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectUnknownEntities self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectUnknownEntities_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectUnknownEntities_swigregister = _IFSelect.Handle_IFSelect_SelectUnknownEntities_swigregister
Handle_IFSelect_SelectUnknownEntities_swigregister(Handle_IFSelect_SelectUnknownEntities)

def Handle_IFSelect_SelectUnknownEntities_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectUnknownEntities_DownCast(thing)
Handle_IFSelect_SelectUnknownEntities_DownCast = _IFSelect.Handle_IFSelect_SelectUnknownEntities_DownCast

class IFSelect_DispPerSignature(IFSelect_Dispatch):
    """
    A DispPerSignature sorts input Entities according to a
    Signature : it works with a SignCounter to do this.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_DispPerSignature
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_DispPerSignature(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_DispPerSignature self) -> IFSelect_DispPerSignature

        Creates a DispPerSignature with no SignCounter (by default,
        produces only one packet)


        """
        this = _IFSelect.new_IFSelect_DispPerSignature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SignCounter(self, *args):
        """
        SignCounter(IFSelect_DispPerSignature self) -> Handle_IFSelect_SignCounter

        Returns the SignCounter used for splitting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.IFSelect_DispPerSignature_SignCounter(self, *args)


    def SetSignCounter(self, *args):
        """
        SetSignCounter(IFSelect_DispPerSignature self, Handle_IFSelect_SignCounter sign)

        Sets a SignCounter for sort
        Remark : it is set to record lists of entities, not only counts

        :type sign: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.IFSelect_DispPerSignature_SetSignCounter(self, *args)


    def SignName(self, *args):
        """
        SignName(IFSelect_DispPerSignature self) -> Standard_CString

        Returns the name of the SignCounter, which caracterises the
        sorting criterium for this Dispatch

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_DispPerSignature_SignName(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_DispPerSignature self) -> TCollection_AsciiString

        Returns as Label, "One File per Signature <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_DispPerSignature_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(IFSelect_DispPerSignature self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum count is given as <nbent>

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_DispPerSignature_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(IFSelect_DispPerSignature self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It defines Packets from
        the SignCounter, which sirts the input Entities per Signature
        (specific of the SignCounter).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.IFSelect_DispPerSignature_Packets(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_DispPerSignature_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_DispPerSignature_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_DispPerSignature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerSignature
IFSelect_DispPerSignature_swigregister = _IFSelect.IFSelect_DispPerSignature_swigregister
IFSelect_DispPerSignature_swigregister(IFSelect_DispPerSignature)

def IFSelect_DispPerSignature_get_type_name(*args):
    """
    IFSelect_DispPerSignature_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_DispPerSignature_get_type_name(*args)

def IFSelect_DispPerSignature_get_type_descriptor(*args):
    """
    IFSelect_DispPerSignature_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_DispPerSignature_get_type_descriptor(*args)

class Handle_IFSelect_Act(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Act self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Act_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Act self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Act_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Act self, IFSelect_Act thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Act_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Act self, Handle_IFSelect_Act theHandle) -> Handle_IFSelect_Act
        assign(Handle_IFSelect_Act self, IFSelect_Act thePtr) -> Handle_IFSelect_Act
        assign(Handle_IFSelect_Act self, Handle_IFSelect_Act theHandle) -> Handle_IFSelect_Act

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Act_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Act self) -> IFSelect_Act

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Act_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Act self) -> IFSelect_Act

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Act___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Act self) -> IFSelect_Act

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Act___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Act___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Act___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Act(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Act_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Act

    def Do(self, *args):
        """
        Do(Handle_IFSelect_Act self, Standard_Integer const number, Handle_IFSelect_SessionPilot pilot) -> IFSelect_ReturnStatus

        Execution of Command Line. remark that <number> is senseless
        because each Act brings one and only one function

        :type number: int
        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_Act_Do(self, *args)


    def Help(self, *args):
        """
        Help(Handle_IFSelect_Act self, Standard_Integer const number) -> Standard_CString

        Short Help for commands : returns the help given to create

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_Help(self, *args)


    def SetGroup(self, *args):
        """
        SetGroup(Handle_IFSelect_Act self, Standard_CString const group, Standard_CString const file)

        Changes the default group name for the following Acts
        group empty means to come back to default from Activator
        Also a file name can be precised (to query by getsource)

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_SetGroup(self, *args)


    def AddFunc(self, *args):
        """
        AddFunc(Handle_IFSelect_Act self, Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func)

        Adds a function with its name and help : creates an Act then
        records it as normal function

        :type name: OCC.wrapper.Standard.Standard_CString
        :type help: OCC.wrapper.Standard.Standard_CString
        :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

        """
        return _IFSelect.Handle_IFSelect_Act_AddFunc(self, *args)


    def AddFSet(self, *args):
        """
        AddFSet(Handle_IFSelect_Act self, Standard_CString const name, Standard_CString const help, IFSelect_ActFunc const func)

        Adds a function with its name and help : creates an Act then
        records it as function for XSET (i.e. to create control item)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type help: OCC.wrapper.Standard.Standard_CString
        :type func: OCC.wrapper.IFSelect.IFSelect_ActFunc

        """
        return _IFSelect.Handle_IFSelect_Act_AddFSet(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Act self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Act_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Act_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Act_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Adding(self, *args):
        """
        Adding(Handle_IFSelect_Act self, Handle_IFSelect_Activator actor, Standard_Integer const number, Standard_CString const command, Standard_Integer const mode)

        Records, in a Dictionary available for all the Activators,
        the command title an Activator can process, attached with
        its number, proper for this Activator
        <mode> allows to distinguish various execution modes
        0: default mode; 1 : for xset

        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_Act_Adding(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_Act self, Standard_Integer const number, Standard_CString const command)

        Allows a self-definition by an Activator of the Commands it
        processes, call the class method Adding (mode 0)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_Add(self, *args)


    def AddSet(self, *args):
        """
        AddSet(Handle_IFSelect_Act self, Standard_Integer const number, Standard_CString const command)

        Same as Add but specifies that this command is candidate for
        xset (creation of items, xset : named items; mode 1)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_AddSet(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_Act self, Standard_CString const command)

        Removes a Command, if it is recorded (else, does nothing)

        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_Remove(self, *args)


    def Select(self, *args):
        """
        Select(Handle_IFSelect_Act self, Standard_CString const command, Handle_IFSelect_Activator actor) -> Standard_Boolean

        Selects, for a Command given by its title, an actor with its
        command number. Returns True if found, False else

        :type command: OCC.wrapper.Standard.Standard_CString
        :type number: int
        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Act_Select(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_IFSelect_Act self, Standard_CString const command) -> Standard_Integer

        Returns mode recorded for a command. -1 if not found

        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Act_Mode(self, *args)


    def Commands(self, *args):
        """
        Commands(Handle_IFSelect_Act self, Standard_Integer const mode=-1, Standard_CString const command) -> Handle_TColStd_HSequenceOfAsciiString

        Returns, for a root of command title, the list of possible
        commands.
        <mode> : -1 (D) for all commands if <commands> is empty
        -1 + command : about a Group , >= 0 see Adding
        By default, it returns the whole list of known commands.

        :type mode: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_Act_Commands(self, *args)


    def Group(self, *args):
        """
        Group(Handle_IFSelect_Act self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_Group(self, *args)


    def File(self, *args):
        """
        File(Handle_IFSelect_Act self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_File(self, *args)


    def SetForGroup(self, *args):
        """
        SetForGroup(Handle_IFSelect_Act self, Standard_CString const group, Standard_CString const file)

        Group and SetGroup define a "Group of commands" which
        correspond to an Activator. Default is "XSTEP"
        Also a file may be attached

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Act_SetForGroup(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Act self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Act_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Act self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Act self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Act_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Act self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Act self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Act_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Act self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Act_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Act self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Act_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Act self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Act_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Act self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Act_DecrementRefCounter(self, *args)

Handle_IFSelect_Act_swigregister = _IFSelect.Handle_IFSelect_Act_swigregister
Handle_IFSelect_Act_swigregister(Handle_IFSelect_Act)

def Handle_IFSelect_Act_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Act_DownCast(thing)
Handle_IFSelect_Act_DownCast = _IFSelect.Handle_IFSelect_Act_DownCast

class Handle_IFSelect_DispPerOne(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_DispPerOne self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_DispPerOne self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_DispPerOne self, IFSelect_DispPerOne thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_DispPerOne self, Handle_IFSelect_DispPerOne theHandle) -> Handle_IFSelect_DispPerOne
        assign(Handle_IFSelect_DispPerOne self, IFSelect_DispPerOne thePtr) -> Handle_IFSelect_DispPerOne
        assign(Handle_IFSelect_DispPerOne self, Handle_IFSelect_DispPerOne theHandle) -> Handle_IFSelect_DispPerOne

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_DispPerOne self) -> IFSelect_DispPerOne

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_DispPerOne self) -> IFSelect_DispPerOne

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerOne___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_DispPerOne self) -> IFSelect_DispPerOne

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_DispPerOne___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_DispPerOne___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_DispPerOne___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_DispPerOne(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_DispPerOne_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_DispPerOne

    def Label(self, *args):
        """
        Label(Handle_IFSelect_DispPerOne self) -> TCollection_AsciiString

        Returns as Label, "One File per Input Entity"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(Handle_IFSelect_DispPerOne self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum limit is given as <nbent>

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(Handle_IFSelect_DispPerOne self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Returns the list of produced Packets. It defines one Packet
        per Entity given by RootResult from the Final Selection.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Packets(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_DispPerOne self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerOne_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerOne_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_DispPerOne self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_DispPerOne self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.Handle_IFSelect_DispPerOne_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(Handle_IFSelect_DispPerOne self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(Handle_IFSelect_DispPerOne self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(Handle_IFSelect_DispPerOne self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(Handle_IFSelect_DispPerOne self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_CanHaveRemainder(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(Handle_IFSelect_DispPerOne self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_GetEntities(self, *args)


    def Packeted(self, *args):
        """
        Packeted(Handle_IFSelect_DispPerOne self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(Handle_IFSelect_DispPerOne self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Remainder(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_DispPerOne self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_DispPerOne_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_DispPerOne self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_DispPerOne self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_DispPerOne self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_DispPerOne self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_DispPerOne self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_DispPerOne self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_DispPerOne self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_DispPerOne_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_DispPerOne self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerOne_DecrementRefCounter(self, *args)

Handle_IFSelect_DispPerOne_swigregister = _IFSelect.Handle_IFSelect_DispPerOne_swigregister
Handle_IFSelect_DispPerOne_swigregister(Handle_IFSelect_DispPerOne)

def Handle_IFSelect_DispPerOne_DownCast(thing):
    return _IFSelect.Handle_IFSelect_DispPerOne_DownCast(thing)
Handle_IFSelect_DispPerOne_DownCast = _IFSelect.Handle_IFSelect_DispPerOne_DownCast

class Handle_IFSelect_SelectEntityNumber(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectEntityNumber self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectEntityNumber self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectEntityNumber self, IFSelect_SelectEntityNumber thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectEntityNumber self, Handle_IFSelect_SelectEntityNumber theHandle) -> Handle_IFSelect_SelectEntityNumber
        assign(Handle_IFSelect_SelectEntityNumber self, IFSelect_SelectEntityNumber thePtr) -> Handle_IFSelect_SelectEntityNumber
        assign(Handle_IFSelect_SelectEntityNumber self, Handle_IFSelect_SelectEntityNumber theHandle) -> Handle_IFSelect_SelectEntityNumber

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectEntityNumber self) -> IFSelect_SelectEntityNumber

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectEntityNumber self) -> IFSelect_SelectEntityNumber

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectEntityNumber self) -> IFSelect_SelectEntityNumber

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectEntityNumber___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectEntityNumber___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectEntityNumber(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectEntityNumber_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectEntityNumber

    def SetNumber(self, *args):
        """
        SetNumber(Handle_IFSelect_SelectEntityNumber self, Handle_IFSelect_IntParam num)

        Sets Entity Number to be taken (initially, none is set : 0)

        :type num: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_SetNumber(self, *args)


    def Number(self, *args):
        """
        Number(Handle_IFSelect_SelectEntityNumber self) -> Handle_IFSelect_IntParam

        Returns specified Number (as a Parameter)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_Number(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectEntityNumber self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : the Entity having the
        specified Number (this result assures naturally uniqueness)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectEntityNumber self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Entity Number ..."

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectEntityNumber self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectEntityNumber_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectEntityNumber_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectEntityNumber self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list is empty for all SelectBase type Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectEntityNumber self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectEntityNumber self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectEntityNumber self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectEntityNumber self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectEntityNumber self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectEntityNumber self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectEntityNumber self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectEntityNumber self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectEntityNumber self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectEntityNumber self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectEntityNumber self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectEntityNumber_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectEntityNumber_swigregister = _IFSelect.Handle_IFSelect_SelectEntityNumber_swigregister
Handle_IFSelect_SelectEntityNumber_swigregister(Handle_IFSelect_SelectEntityNumber)

def Handle_IFSelect_SelectEntityNumber_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectEntityNumber_DownCast(thing)
Handle_IFSelect_SelectEntityNumber_DownCast = _IFSelect.Handle_IFSelect_SelectEntityNumber_DownCast

class Handle_IFSelect_Selection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Selection self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Selection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Selection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Selection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Selection self, IFSelect_Selection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Selection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Selection self, Handle_IFSelect_Selection theHandle) -> Handle_IFSelect_Selection
        assign(Handle_IFSelect_Selection self, IFSelect_Selection thePtr) -> Handle_IFSelect_Selection
        assign(Handle_IFSelect_Selection self, Handle_IFSelect_Selection theHandle) -> Handle_IFSelect_Selection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Selection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Selection self) -> IFSelect_Selection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Selection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Selection self) -> IFSelect_Selection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Selection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Selection self) -> IFSelect_Selection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Selection___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Selection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Selection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Selection_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Selection

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_Selection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, computed from Input
        given as a Graph. Specific to each class of Selection
        Note that uniqueness of each entity is not required here
        This method can raise an exception as necessary

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_Selection_RootResult(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_Selection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_Selection_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_Selection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_Selection_CompleteResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_Selection self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        (there can be zero, or one, or a list).
        Specific to each class of Selection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_Selection_FillIterator(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_Selection self) -> TCollection_AsciiString

        Returns a text which defines the criterium applied by a
        Selection (can be used to be printed, displayed ...)
        Specific to each class

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Selection_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Selection self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Selection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Selection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Selection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Selection self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Selection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Selection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Selection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Selection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Selection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Selection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Selection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Selection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Selection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Selection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Selection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Selection self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Selection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Selection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Selection_DecrementRefCounter(self, *args)

Handle_IFSelect_Selection_swigregister = _IFSelect.Handle_IFSelect_Selection_swigregister
Handle_IFSelect_Selection_swigregister(Handle_IFSelect_Selection)

def Handle_IFSelect_Selection_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Selection_DownCast(thing)
Handle_IFSelect_Selection_DownCast = _IFSelect.Handle_IFSelect_Selection_DownCast

class Handle_IFSelect_Activator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Activator self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Activator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Activator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Activator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Activator self, IFSelect_Activator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Activator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Activator self, Handle_IFSelect_Activator theHandle) -> Handle_IFSelect_Activator
        assign(Handle_IFSelect_Activator self, IFSelect_Activator thePtr) -> Handle_IFSelect_Activator
        assign(Handle_IFSelect_Activator self, Handle_IFSelect_Activator theHandle) -> Handle_IFSelect_Activator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Activator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Activator self) -> IFSelect_Activator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Activator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Activator self) -> IFSelect_Activator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Activator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Activator self) -> IFSelect_Activator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Activator___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Activator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Activator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Activator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Activator_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Activator

    def Adding(self, *args):
        """
        Adding(Handle_IFSelect_Activator self, Handle_IFSelect_Activator actor, Standard_Integer const number, Standard_CString const command, Standard_Integer const mode)

        Records, in a Dictionary available for all the Activators,
        the command title an Activator can process, attached with
        its number, proper for this Activator
        <mode> allows to distinguish various execution modes
        0: default mode; 1 : for xset

        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_Activator_Adding(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_Activator self, Standard_Integer const number, Standard_CString const command)

        Allows a self-definition by an Activator of the Commands it
        processes, call the class method Adding (mode 0)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_Add(self, *args)


    def AddSet(self, *args):
        """
        AddSet(Handle_IFSelect_Activator self, Standard_Integer const number, Standard_CString const command)

        Same as Add but specifies that this command is candidate for
        xset (creation of items, xset : named items; mode 1)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_AddSet(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_Activator self, Standard_CString const command)

        Removes a Command, if it is recorded (else, does nothing)

        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_Remove(self, *args)


    def Select(self, *args):
        """
        Select(Handle_IFSelect_Activator self, Standard_CString const command, Handle_IFSelect_Activator actor) -> Standard_Boolean

        Selects, for a Command given by its title, an actor with its
        command number. Returns True if found, False else

        :type command: OCC.wrapper.Standard.Standard_CString
        :type number: int
        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Activator_Select(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_IFSelect_Activator self, Standard_CString const command) -> Standard_Integer

        Returns mode recorded for a command. -1 if not found

        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Activator_Mode(self, *args)


    def Commands(self, *args):
        """
        Commands(Handle_IFSelect_Activator self, Standard_Integer const mode=-1, Standard_CString const command) -> Handle_TColStd_HSequenceOfAsciiString

        Returns, for a root of command title, the list of possible
        commands.
        <mode> : -1 (D) for all commands if <commands> is empty
        -1 + command : about a Group , >= 0 see Adding
        By default, it returns the whole list of known commands.

        :type mode: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_Activator_Commands(self, *args)


    def Do(self, *args):
        """
        Do(Handle_IFSelect_Activator self, Standard_Integer const number, Handle_IFSelect_SessionPilot pilot) -> IFSelect_ReturnStatus

        Tries to execute a Command Line. <number> is the number of the
        command for this Activator. It Must forecast to record the
        result of the execution, for need of Undo-Redo
        Must Returns : 0 for a void command (not to be recorded),
        1 if execution OK, -1 if command incorrect, -2 if error
        on execution

        :type number: int
        :type pilot: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_Activator_Do(self, *args)


    def Help(self, *args):
        """
        Help(Handle_IFSelect_Activator self, Standard_Integer const number) -> Standard_CString

        Sends a short help message for a given command identified by
        it number for this Activator (must take one line max)

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_Help(self, *args)


    def Group(self, *args):
        """
        Group(Handle_IFSelect_Activator self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_Group(self, *args)


    def File(self, *args):
        """
        File(Handle_IFSelect_Activator self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_File(self, *args)


    def SetForGroup(self, *args):
        """
        SetForGroup(Handle_IFSelect_Activator self, Standard_CString const group, Standard_CString const file)

        Group and SetGroup define a "Group of commands" which
        correspond to an Activator. Default is "XSTEP"
        Also a file may be attached

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Activator_SetForGroup(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Activator self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Activator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Activator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Activator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Activator self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Activator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Activator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Activator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Activator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Activator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Activator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Activator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Activator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Activator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Activator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Activator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Activator self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Activator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Activator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Activator_DecrementRefCounter(self, *args)

Handle_IFSelect_Activator_swigregister = _IFSelect.Handle_IFSelect_Activator_swigregister
Handle_IFSelect_Activator_swigregister(Handle_IFSelect_Activator)

def Handle_IFSelect_Activator_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Activator_DownCast(thing)
Handle_IFSelect_Activator_DownCast = _IFSelect.Handle_IFSelect_Activator_DownCast

class IFSelect_SelectSignedShared(IFSelect_SelectExplore):
    """
    In the graph, explore the Shareds of the input entities,
    until it encounters some which match a given Signature
    (for a limited level, filters the returned list)
    By default, fitted for any level
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectSignedShared
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectSignedShared(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectSignedShared self, Handle_IFSelect_Signature matcher, Standard_CString const signtext, Standard_Boolean const exact, Standard_Integer const level=0) -> IFSelect_SelectSignedShared

        Creates a SelectSignedShared, defaulted for any level
        with a given Signature and text to match

        :type matcher: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type signtext: OCC.wrapper.Standard.Standard_CString
        :type exact: bool
        :type level: int

        """
        this = _IFSelect.new_IFSelect_SelectSignedShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Signature(self, *args):
        """
        Signature(IFSelect_SelectSignedShared self) -> Handle_IFSelect_Signature

        Returns the used Signature, then it is possible to access it,
        modify it as required

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_SelectSignedShared_Signature(self, *args)


    def SignatureText(self, *args):
        """
        Returns Text used to Sort Entity on its Signature

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SelectSignedShared_SignatureText(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsExact(self, *args):
        """
        IsExact(IFSelect_SelectSignedShared self) -> Standard_Boolean

        Returns True if match must be exact

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignedShared_IsExact(self, *args)


    def Explore(self, *args):
        """
        Explore(IFSelect_SelectSignedShared self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity : its Shared entities
        <ent> to take if it matches the Signature
        At level max, filters the result. Else gives all Shareds

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignedShared_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(IFSelect_SelectSignedShared self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (it refers to the text and exact flag to be matched, and is
        qualified by the Name provided by the Signature)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSignedShared_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectSignedShared_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectSignedShared_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectSignedShared_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSignedShared
IFSelect_SelectSignedShared_swigregister = _IFSelect.IFSelect_SelectSignedShared_swigregister
IFSelect_SelectSignedShared_swigregister(IFSelect_SelectSignedShared)

def IFSelect_SelectSignedShared_get_type_name(*args):
    """
    IFSelect_SelectSignedShared_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectSignedShared_get_type_name(*args)

def IFSelect_SelectSignedShared_get_type_descriptor(*args):
    """
    IFSelect_SelectSignedShared_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectSignedShared_get_type_descriptor(*args)

class Handle_IFSelect_Dispatch(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Dispatch self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Dispatch_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Dispatch self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Dispatch_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Dispatch self, IFSelect_Dispatch thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Dispatch_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Dispatch self, Handle_IFSelect_Dispatch theHandle) -> Handle_IFSelect_Dispatch
        assign(Handle_IFSelect_Dispatch self, IFSelect_Dispatch thePtr) -> Handle_IFSelect_Dispatch
        assign(Handle_IFSelect_Dispatch self, Handle_IFSelect_Dispatch theHandle) -> Handle_IFSelect_Dispatch

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Dispatch_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Dispatch self) -> IFSelect_Dispatch

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Dispatch_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Dispatch self) -> IFSelect_Dispatch

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Dispatch___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Dispatch self) -> IFSelect_Dispatch

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Dispatch___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Dispatch___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Dispatch___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Dispatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Dispatch_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Dispatch

    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_Dispatch self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_Dispatch_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_Dispatch self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Dispatch_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.Handle_IFSelect_Dispatch_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(Handle_IFSelect_Dispatch self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_Dispatch_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(Handle_IFSelect_Dispatch self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_Dispatch_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(Handle_IFSelect_Dispatch self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_Dispatch_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(Handle_IFSelect_Dispatch self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Dispatch_CanHaveRemainder(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(Handle_IFSelect_Dispatch self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True if a Dispatch generates a count of Packets always
        less than or equal to a maximum value : it can be computed
        from the total count of Entities to be dispatched : <nbent>.
        If answer is False, no limited maximum is expected for account
        If answer is True, expected maximum is given in argument <max>
        Default answer given here is False (can be redefined)

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Dispatch_LimitedMax(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_Dispatch self) -> TCollection_AsciiString

        Returns a text which defines the way a Dispatch produces
        packets (which will become files) from its Input

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Dispatch_Label(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(Handle_IFSelect_Dispatch self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_Dispatch_GetEntities(self, *args)


    def Packets(self, *args):
        """
        Packets(Handle_IFSelect_Dispatch self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Returns the list of produced Packets into argument <pack>.
        Each Packet corresponds to a Part, the Entities listed are the
        Roots given by the Selection. Input is given as a Graph.
        Thus, to create a file from a packet, it suffices to take the
        entities listed in a Part of Packets (that is, a Packet)
        without worrying about Shared entities
        This method can raise an Exception if data are not coherent

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.Handle_IFSelect_Dispatch_Packets(self, *args)


    def Packeted(self, *args):
        """
        Packeted(Handle_IFSelect_Dispatch self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_Dispatch_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(Handle_IFSelect_Dispatch self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_Dispatch_Remainder(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Dispatch self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Dispatch_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Dispatch_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Dispatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Dispatch self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Dispatch_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Dispatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Dispatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Dispatch_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Dispatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Dispatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Dispatch_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Dispatch self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Dispatch_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Dispatch self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Dispatch_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Dispatch self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Dispatch_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Dispatch self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Dispatch_DecrementRefCounter(self, *args)

Handle_IFSelect_Dispatch_swigregister = _IFSelect.Handle_IFSelect_Dispatch_swigregister
Handle_IFSelect_Dispatch_swigregister(Handle_IFSelect_Dispatch)

def Handle_IFSelect_Dispatch_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Dispatch_DownCast(thing)
Handle_IFSelect_Dispatch_DownCast = _IFSelect.Handle_IFSelect_Dispatch_DownCast

class Handle_IFSelect_SelectRootComps(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectRootComps self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectRootComps self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectRootComps self, IFSelect_SelectRootComps thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectRootComps self, Handle_IFSelect_SelectRootComps theHandle) -> Handle_IFSelect_SelectRootComps
        assign(Handle_IFSelect_SelectRootComps self, IFSelect_SelectRootComps thePtr) -> Handle_IFSelect_SelectRootComps
        assign(Handle_IFSelect_SelectRootComps self, Handle_IFSelect_SelectRootComps theHandle) -> Handle_IFSelect_SelectRootComps

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectRootComps self) -> IFSelect_SelectRootComps

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectRootComps self) -> IFSelect_SelectRootComps

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectRootComps self) -> IFSelect_SelectRootComps

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectRootComps___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectRootComps___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectRootComps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectRootComps_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectRootComps

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectRootComps self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of local root strong componants, by one
        Entity par componant. It is redefined for a purpose of
        effeciency : calling a Sort routine for each Entity would
        cost more ressource than to work in once using a Map
        RootResult takes in account the Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectRootComps self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always True, because RootResult has done work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectRootComps self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Local Root Componants"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectRootComps self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectRootComps_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectRootComps_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectRootComps self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectRootComps self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_SetDirect(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectRootComps self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectRootComps self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectRootComps self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectRootComps self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectRootComps self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectRootComps self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectRootComps self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectRootComps self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectRootComps self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectRootComps self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectRootComps self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectRootComps self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectRootComps self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectRootComps self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectRootComps self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectRootComps self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectRootComps self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectRootComps self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectRootComps self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectRootComps self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRootComps_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectRootComps_swigregister = _IFSelect.Handle_IFSelect_SelectRootComps_swigregister
Handle_IFSelect_SelectRootComps_swigregister(Handle_IFSelect_SelectRootComps)

def Handle_IFSelect_SelectRootComps_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectRootComps_DownCast(thing)
Handle_IFSelect_SelectRootComps_DownCast = _IFSelect.Handle_IFSelect_SelectRootComps_DownCast

class Handle_IFSelect_Modifier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Modifier self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Modifier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Modifier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Modifier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Modifier self, IFSelect_Modifier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Modifier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Modifier self, Handle_IFSelect_Modifier theHandle) -> Handle_IFSelect_Modifier
        assign(Handle_IFSelect_Modifier self, IFSelect_Modifier thePtr) -> Handle_IFSelect_Modifier
        assign(Handle_IFSelect_Modifier self, Handle_IFSelect_Modifier theHandle) -> Handle_IFSelect_Modifier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Modifier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Modifier self) -> IFSelect_Modifier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Modifier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Modifier self) -> IFSelect_Modifier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Modifier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Modifier self) -> IFSelect_Modifier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Modifier___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Modifier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Modifier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Modifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Modifier_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Modifier

    def Perform(self, *args):
        """
        Perform(Handle_IFSelect_Modifier self, IFSelect_ContextModif ctx, Handle_Interface_InterfaceModel target, Handle_Interface_Protocol protocol, Interface_CopyTool TC)

        This deferred method defines the action specific to each class
        of Modifier. It is called by a ModelCopier, once the Model
        generated and filled. ModelCopier has already checked the
        criteria (Dispatch, Model Rank, Selection) before calling it.

        <ctx> detains informations about original data and selection.
        The result of copying, on which modifications are to be done,
        is <target>.
        <TC> allows to run additional copies as required

        In case of Error, use methods CCheck from the ContextModif
        to aknowledge an entity Check or a Global Check with messages

        :type ctx: OCC.wrapper.IFSelect.IFSelect_ContextModif
        :type target: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _IFSelect.Handle_IFSelect_Modifier_Perform(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Modifier self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Modifier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Modifier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Modifier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MayChangeGraph(self, *args):
        """
        MayChangeGraph(Handle_IFSelect_Modifier self) -> Standard_Boolean

        Returns True if this modifier may change the graph of
        dependences (aknowledged at creation time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Modifier_MayChangeGraph(self, *args)


    def SetDispatch(self, *args):
        """
        SetDispatch(Handle_IFSelect_Modifier self, Handle_IFSelect_Dispatch disp)

        Attaches to a Dispatch. If <disp> is Null, Resets it
        (to apply the Modifier on every Dispatch)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_Modifier_SetDispatch(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_IFSelect_Modifier self) -> Handle_IFSelect_Dispatch

        Returns the Dispatch to be matched, Null if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_Modifier_Dispatch(self, *args)


    def Applies(self, *args):
        """
        Applies(Handle_IFSelect_Modifier self, Handle_IFSelect_Dispatch disp) -> Standard_Boolean

        Returns True if a Model obtained from the Dispatch <disp>
        is to be treated (apart from the Selection criterium)
        If Dispatch(me) is Null, returns True. Else, checks <disp>

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Modifier_Applies(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_Modifier self, Handle_IFSelect_Selection sel)

        Sets a Selection : a Model is treated if it contains one or
        more Entities designated by the Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_Modifier_SetSelection(self, *args)


    def ResetSelection(self, *args):
        """
        ResetSelection(Handle_IFSelect_Modifier self)

        Resets the Selection : this criterium is not longer active


        """
        return _IFSelect.Handle_IFSelect_Modifier_ResetSelection(self, *args)


    def HasSelection(self, *args):
        """
        HasSelection(Handle_IFSelect_Modifier self) -> Standard_Boolean

        Returns True if a Selection is set as an additionnal criterium

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Modifier_HasSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_Modifier self) -> Handle_IFSelect_Selection

        Returns the Selection, or a Null Handle if not set

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_Modifier_Selection(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_Modifier self) -> TCollection_AsciiString

        Returns a short text which defines the operation performed

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Modifier_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Modifier self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Modifier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Modifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Modifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Modifier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Modifier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Modifier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Modifier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Modifier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Modifier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Modifier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Modifier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Modifier self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Modifier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Modifier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Modifier_DecrementRefCounter(self, *args)

Handle_IFSelect_Modifier_swigregister = _IFSelect.Handle_IFSelect_Modifier_swigregister
Handle_IFSelect_Modifier_swigregister(Handle_IFSelect_Modifier)

def Handle_IFSelect_Modifier_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Modifier_DownCast(thing)
Handle_IFSelect_Modifier_DownCast = _IFSelect.Handle_IFSelect_Modifier_DownCast

class Handle_IFSelect_SelectSignature(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectSignature self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectSignature self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectSignature self, IFSelect_SelectSignature thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectSignature self, Handle_IFSelect_SelectSignature theHandle) -> Handle_IFSelect_SelectSignature
        assign(Handle_IFSelect_SelectSignature self, IFSelect_SelectSignature thePtr) -> Handle_IFSelect_SelectSignature
        assign(Handle_IFSelect_SelectSignature self, Handle_IFSelect_SelectSignature theHandle) -> Handle_IFSelect_SelectSignature

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectSignature self) -> IFSelect_SelectSignature

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectSignature self) -> IFSelect_SelectSignature

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignature___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectSignature self) -> IFSelect_SelectSignature

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectSignature___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectSignature___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectSignature___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectSignature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectSignature_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectSignature

    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_SelectSignature self) -> Handle_IFSelect_Signature

        Returns the used Signature, then it is possible to access it,
        modify it as required. Can be null, hence see Counter

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Signature(self, *args)


    def Counter(self, *args):
        """
        Counter(Handle_IFSelect_SelectSignature self) -> Handle_IFSelect_SignCounter

        Returns the used SignCounter. Can be used as alternative for
        Signature

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Counter(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectSignature self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Returns True for an Entity (model->Value(num)) of which the
        signature matches the text given as creation time
        May also work with a Counter from the Graph

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_SortInGraph(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectSignature self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Not called, defined only to remove a deferred method here

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Sort(self, *args)


    def SignatureText(self, *args):
        """
        Returns Text used to Sort Entity on its Signature or SignCounter

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.Handle_IFSelect_SelectSignature_SignatureText(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsExact(self, *args):
        """
        IsExact(Handle_IFSelect_SelectSignature self) -> Standard_Boolean

        Returns True if match must be exact

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_IsExact(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectSignature self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (it refers to the text and exact flag to be matched, and is
        qualified by the Name provided by the Signature)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectSignature self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSignature_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSignature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectSignature self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectSignature self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectSignature self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectSignature self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectSignature self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectSignature self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectSignature self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectSignature self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectSignature self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectSignature self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectSignature self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectSignature self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectSignature self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectSignature self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectSignature_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectSignature self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectSignature self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectSignature self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectSignature self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectSignature self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectSignature self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectSignature self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectSignature_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectSignature self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignature_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectSignature_swigregister = _IFSelect.Handle_IFSelect_SelectSignature_swigregister
Handle_IFSelect_SelectSignature_swigregister(Handle_IFSelect_SelectSignature)

def Handle_IFSelect_SelectSignature_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectSignature_DownCast(thing)
Handle_IFSelect_SelectSignature_DownCast = _IFSelect.Handle_IFSelect_SelectSignature_DownCast

class Handle_IFSelect_HSeqOfSelection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_HSeqOfSelection self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_HSeqOfSelection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_HSeqOfSelection self, IFSelect_HSeqOfSelection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_HSeqOfSelection self, Handle_IFSelect_HSeqOfSelection theHandle) -> Handle_IFSelect_HSeqOfSelection
        assign(Handle_IFSelect_HSeqOfSelection self, IFSelect_HSeqOfSelection thePtr) -> Handle_IFSelect_HSeqOfSelection
        assign(Handle_IFSelect_HSeqOfSelection self, Handle_IFSelect_HSeqOfSelection theHandle) -> Handle_IFSelect_HSeqOfSelection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_HSeqOfSelection self) -> IFSelect_HSeqOfSelection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_HSeqOfSelection self) -> IFSelect_HSeqOfSelection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_HSeqOfSelection self) -> IFSelect_HSeqOfSelection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_HSeqOfSelection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_HSeqOfSelection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_HSeqOfSelection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_HSeqOfSelection_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_HSeqOfSelection

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        res = _IFSelect.Handle_IFSelect_HSeqOfSelection_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_IFSelect_HSeqOfSelection self, Handle_IFSelect_Selection theItem)
        Append(Handle_IFSelect_HSeqOfSelection self, NCollection_Sequence_Handle_IFSelect_Selection theSequence)

        :type theSequence: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_IFSelect_HSeqOfSelection self) -> NCollection_Sequence_Handle_IFSelect_Selection

        :rtype: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_HSeqOfSelection self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_HSeqOfSelection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_HSeqOfSelection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_HSeqOfSelection self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_HSeqOfSelection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_HSeqOfSelection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_HSeqOfSelection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_HSeqOfSelection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_HSeqOfSelection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_HSeqOfSelection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_HSeqOfSelection self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_HSeqOfSelection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_HSeqOfSelection_DecrementRefCounter(self, *args)

Handle_IFSelect_HSeqOfSelection_swigregister = _IFSelect.Handle_IFSelect_HSeqOfSelection_swigregister
Handle_IFSelect_HSeqOfSelection_swigregister(Handle_IFSelect_HSeqOfSelection)

def Handle_IFSelect_HSeqOfSelection_DownCast(thing):
    return _IFSelect.Handle_IFSelect_HSeqOfSelection_DownCast(thing)
Handle_IFSelect_HSeqOfSelection_DownCast = _IFSelect.Handle_IFSelect_HSeqOfSelection_DownCast

class Handle_IFSelect_SessionPilot(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SessionPilot self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SessionPilot self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SessionPilot self, IFSelect_SessionPilot thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SessionPilot self, Handle_IFSelect_SessionPilot theHandle) -> Handle_IFSelect_SessionPilot
        assign(Handle_IFSelect_SessionPilot self, IFSelect_SessionPilot thePtr) -> Handle_IFSelect_SessionPilot
        assign(Handle_IFSelect_SessionPilot self, Handle_IFSelect_SessionPilot theHandle) -> Handle_IFSelect_SessionPilot

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SessionPilot self) -> IFSelect_SessionPilot

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SessionPilot self) -> IFSelect_SessionPilot

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SessionPilot___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SessionPilot self) -> IFSelect_SessionPilot

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SessionPilot___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SessionPilot___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SessionPilot___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SessionPilot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SessionPilot_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SessionPilot

    def Session(self, *args):
        """
        Session(Handle_IFSelect_SessionPilot self) -> Handle_IFSelect_WorkSession

        Returns the WorkSession which is worked on

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Session(self, *args)


    def Library(self, *args):
        """
        Library(Handle_IFSelect_SessionPilot self) -> Handle_IFSelect_WorkLibrary

        Returns the WorKlibrary (Null if not set). WorkLibrary is used
        to Read and Write Files, according to the Norm

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Library(self, *args)


    def RecordMode(self, *args):
        """
        RecordMode(Handle_IFSelect_SessionPilot self) -> Standard_Boolean

        Returns the Record Mode for Commands. Default is False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_RecordMode(self, *args)


    def SetSession(self, *args):
        """
        SetSession(Handle_IFSelect_SessionPilot self, Handle_IFSelect_WorkSession WS)

        Sets a WorkSession to be worked on

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_SetSession(self, *args)


    def SetLibrary(self, *args):
        """
        SetLibrary(Handle_IFSelect_SessionPilot self, Handle_IFSelect_WorkLibrary WL)

        Sets a WorkLibrary

        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_SetLibrary(self, *args)


    def SetRecordMode(self, *args):
        """
        SetRecordMode(Handle_IFSelect_SessionPilot self, Standard_Boolean const mode)

        Changes the RecordMode.

        :type mode: bool

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_SetRecordMode(self, *args)


    def SetCommandLine(self, *args):
        """
        SetCommandLine(Handle_IFSelect_SessionPilot self, TCollection_AsciiString command)

        Sets the value of the Command Line to be interpreted
        Also prepares the interpretation (splitting by blanks)

        :type command: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_SetCommandLine(self, *args)


    def CommandLine(self, *args):
        """
        Returns the Command Line to be interpreted

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.Handle_IFSelect_SessionPilot_CommandLine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommandPart(self, *args):
        """
        CommandPart(Handle_IFSelect_SessionPilot self, Standard_Integer const numarg=0) -> Standard_CString

        Returns the part of the command line which begins at argument
        <numarg> between 0 and NbWords-1 (by default, all the line)
        Empty string if out of range

        :type numarg: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_CommandPart(self, *args)


    def NbWords(self, *args):
        """
        NbWords(Handle_IFSelect_SessionPilot self) -> Standard_Integer

        Returns the count of words of the Command Line, separated by
        blanks : 0 if empty, one if a command without args, else it
        gives the count of args minus one.
        Warning : limited to 10 (command title + 9 args)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_NbWords(self, *args)


    def Word(self, *args):
        """
        Returns a word given its rank in the Command Line. Begins at 0
        which is the Command Title, 1 is the 1st arg., etc...

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.Handle_IFSelect_SessionPilot_Word(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Arg(self, *args):
        """
        Arg(Handle_IFSelect_SessionPilot self, Standard_Integer const num) -> Standard_CString

        Returns a word given its rank, as a CString.
        As for Word, begins at 0 (the command name), etc...

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Arg(self, *args)


    def RemoveWord(self, *args):
        """
        RemoveWord(Handle_IFSelect_SessionPilot self, Standard_Integer const num) -> Standard_Boolean

        Removes a word given its rank. Returns True if Done, False if
        <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_RemoveWord(self, *args)


    def NbCommands(self, *args):
        """
        NbCommands(Handle_IFSelect_SessionPilot self) -> Standard_Integer

        Returns the count of recorded Commands

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_NbCommands(self, *args)


    def Command(self, *args):
        """
        Returns a recorded Command, given its rank (from 1)

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.Handle_IFSelect_SessionPilot_Command(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RecordItem(self, *args):
        """
        RecordItem(Handle_IFSelect_SessionPilot self, Handle_Standard_Transient item) -> IFSelect_ReturnStatus

        Allows to associate a Transient Value with the last execution
        as a partial result
        Returns RetDone if item is not Null, RetFail if item is Null
        Remark : it is nullified for each Perform

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_RecordItem(self, *args)


    def RecordedItem(self, *args):
        """
        RecordedItem(Handle_IFSelect_SessionPilot self) -> Handle_Standard_Transient

        Returns the Transient Object which was recorded with the
        current Line Command. If none was, returns a Null Handle

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_RecordedItem(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_IFSelect_SessionPilot self)

        Clears the recorded informations (commands, objects)


        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Clear(self, *args)


    def ReadScript(self, *args):
        """
        ReadScript(Handle_IFSelect_SessionPilot self, Standard_CString const file) -> IFSelect_ReturnStatus

        Reads commands from a Script File, named <file>. By default
        (file = ""), reads from standard input with a prompt
        Else (reading from a file), the read commands are displayed
        onto standard output. Allows nested reads. Reading is stopped
        either by command x or exit, or by reaching end of file
        Return Value follows the rules of Do : RetEnd for normal end,
        RetFail if script could not be opened

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_ReadScript(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_IFSelect_SessionPilot self) -> IFSelect_ReturnStatus

        Executes the Command, itself (for built-in commands, which
        have priority) or by using the list of Activators.
        The value returned is : RetVoid if nothing done (void command)
        RetDone if execution OK, RetEnd if END OF SESSION, RetError if
        command unknown or incorrect, RetFail if error on execution
        If execution is OK and RecordMode is set, this Command Line is
        recorded to the list (see below).

        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Perform(self, *args)


    def ExecuteAlias(self, *args):
        """
        ExecuteAlias(Handle_IFSelect_SessionPilot self, TCollection_AsciiString aliasname) -> IFSelect_ReturnStatus

        Executes the Commands, except that the command name (word 0)
        is aliased. The rest of the command line is unchanged
        If <alias> is empty, Executes with no change

        Error status is returned if the alias is unknown as command

        :type aliasname: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_ExecuteAlias(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_IFSelect_SessionPilot self, TCollection_AsciiString command) -> IFSelect_ReturnStatus

        Sets the Command then tries to execute it. Return value :
        same as for Perform

        :type command: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Execute(self, *args)


    def ExecuteCounter(self, *args):
        """
        ExecuteCounter(Handle_IFSelect_SessionPilot self, Handle_IFSelect_SignCounter counter, Standard_Integer const numword, IFSelect_PrintCount const mode=IFSelect_CountByItem) -> IFSelect_ReturnStatus

        Executes a Counter in a general way
        If <numword> is greater than count of command words, it counts
        all the model. Else it considers the word <numword> as the
        identifier of a Selection
        <mode> gives the mode of printing results, default is
        CountByItem

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type numword: int
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_ExecuteCounter(self, *args)


    def Number(self, *args):
        """
        Number(Handle_IFSelect_SessionPilot self, Standard_CString const val) -> Standard_Integer

        Interprets a string value as an entity number :
        if it gives an integer, returns its value
        else, considers it as ENtityLabel (preferably case sensitive)
        in case of failure, returns 0

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Number(self, *args)


    def Do(self, *args):
        """
        Do(Handle_IFSelect_SessionPilot self, Standard_Integer const number, Handle_IFSelect_SessionPilot session) -> IFSelect_ReturnStatus

        Processes specific commands, which are :
        x or exit for end of session
        ? or help for help messages
        xcommand to control command lines (Record Mode, List, Clear,
        File Output ...)
        xsource to execute a command file (no nesting allowed),
        in case of error, source is stopped and keyword recovers
        xstep is a simple prefix (useful in a wider environment, to
        avoid conflicts on command names)
        xset control commands which create items with names

        :type number: int
        :type session: OCC.wrapper.IFSelect.Handle_IFSelect_SessionPilot
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Do(self, *args)


    def Help(self, *args):
        """
        Help(Handle_IFSelect_SessionPilot self, Standard_Integer const number) -> Standard_CString

        Help for specific commands (apart from general command help)

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Help(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SessionPilot self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SessionPilot_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SessionPilot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Adding(self, *args):
        """
        Adding(Handle_IFSelect_SessionPilot self, Handle_IFSelect_Activator actor, Standard_Integer const number, Standard_CString const command, Standard_Integer const mode)

        Records, in a Dictionary available for all the Activators,
        the command title an Activator can process, attached with
        its number, proper for this Activator
        <mode> allows to distinguish various execution modes
        0: default mode; 1 : for xset

        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Adding(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SessionPilot self, Standard_Integer const number, Standard_CString const command)

        Allows a self-definition by an Activator of the Commands it
        processes, call the class method Adding (mode 0)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Add(self, *args)


    def AddSet(self, *args):
        """
        AddSet(Handle_IFSelect_SessionPilot self, Standard_Integer const number, Standard_CString const command)

        Same as Add but specifies that this command is candidate for
        xset (creation of items, xset : named items; mode 1)

        :type number: int
        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_AddSet(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_SessionPilot self, Standard_CString const command)

        Removes a Command, if it is recorded (else, does nothing)

        :type command: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Remove(self, *args)


    def Select(self, *args):
        """
        Select(Handle_IFSelect_SessionPilot self, Standard_CString const command, Handle_IFSelect_Activator actor) -> Standard_Boolean

        Selects, for a Command given by its title, an actor with its
        command number. Returns True if found, False else

        :type command: OCC.wrapper.Standard.Standard_CString
        :type number: int
        :type actor: OCC.wrapper.IFSelect.Handle_IFSelect_Activator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Select(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_IFSelect_SessionPilot self, Standard_CString const command) -> Standard_Integer

        Returns mode recorded for a command. -1 if not found

        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Mode(self, *args)


    def Commands(self, *args):
        """
        Commands(Handle_IFSelect_SessionPilot self, Standard_Integer const mode=-1, Standard_CString const command) -> Handle_TColStd_HSequenceOfAsciiString

        Returns, for a root of command title, the list of possible
        commands.
        <mode> : -1 (D) for all commands if <commands> is empty
        -1 + command : about a Group , >= 0 see Adding
        By default, it returns the whole list of known commands.

        :type mode: int
        :type command: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Commands(self, *args)


    def Group(self, *args):
        """
        Group(Handle_IFSelect_SessionPilot self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Group(self, *args)


    def File(self, *args):
        """
        File(Handle_IFSelect_SessionPilot self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_File(self, *args)


    def SetForGroup(self, *args):
        """
        SetForGroup(Handle_IFSelect_SessionPilot self, Standard_CString const group, Standard_CString const file)

        Group and SetGroup define a "Group of commands" which
        correspond to an Activator. Default is "XSTEP"
        Also a file may be attached

        :type group: OCC.wrapper.Standard.Standard_CString
        :type file: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_SetForGroup(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SessionPilot self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SessionPilot_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SessionPilot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SessionPilot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SessionPilot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SessionPilot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SessionPilot self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SessionPilot self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SessionPilot self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SessionPilot_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SessionPilot self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionPilot_DecrementRefCounter(self, *args)

Handle_IFSelect_SessionPilot_swigregister = _IFSelect.Handle_IFSelect_SessionPilot_swigregister
Handle_IFSelect_SessionPilot_swigregister(Handle_IFSelect_SessionPilot)

def Handle_IFSelect_SessionPilot_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SessionPilot_DownCast(thing)
Handle_IFSelect_SessionPilot_DownCast = _IFSelect.Handle_IFSelect_SessionPilot_DownCast

class IFSelect_SelectDiff(IFSelect_SelectControl):
    """
    A SelectDiff keeps the entities from a Selection, the Main
    Input, which are not listed by the Second Input
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectDiff
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectDiff(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectDiff self) -> IFSelect_SelectDiff

        Creates an empty SelectDiff


        """
        this = _IFSelect.new_IFSelect_SelectDiff(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectDiff self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : they are the Entities
        gotten from the Main Input but not from the Diff Input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectDiff_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectDiff self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Difference"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectDiff_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectDiff_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectDiff_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectDiff_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectDiff
IFSelect_SelectDiff_swigregister = _IFSelect.IFSelect_SelectDiff_swigregister
IFSelect_SelectDiff_swigregister(IFSelect_SelectDiff)

def IFSelect_SelectDiff_get_type_name(*args):
    """
    IFSelect_SelectDiff_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectDiff_get_type_name(*args)

def IFSelect_SelectDiff_get_type_descriptor(*args):
    """
    IFSelect_SelectDiff_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectDiff_get_type_descriptor(*args)

class IFSelect_SignCategory(IFSelect_Signature):
    """
    This Signature returns the Category of an entity, as recorded
    in the model
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignCategory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignCategory(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignCategory self) -> IFSelect_SignCategory

        Returns a SignCategory


        """
        this = _IFSelect.new_IFSelect_SignCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(IFSelect_SignCategory self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its Category
        recorded in the model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignCategory_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignCategory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignCategory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignCategory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignCategory
IFSelect_SignCategory_swigregister = _IFSelect.IFSelect_SignCategory_swigregister
IFSelect_SignCategory_swigregister(IFSelect_SignCategory)

def IFSelect_SignCategory_get_type_name(*args):
    """
    IFSelect_SignCategory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignCategory_get_type_name(*args)

def IFSelect_SignCategory_get_type_descriptor(*args):
    """
    IFSelect_SignCategory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignCategory_get_type_descriptor(*args)

class IFSelect_BasicDumper(IFSelect_SessionDumper):
    """
    BasicDumper takes into account, for SessionFile, all the
    classes defined in the package IFSelect : Selections,
    Dispatches (there is no Modifier)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_BasicDumper
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_BasicDumper(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_BasicDumper self) -> IFSelect_BasicDumper

        Creates a BasicDumper and puts it into the Library of Dumper


        """
        this = _IFSelect.new_IFSelect_BasicDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def WriteOwn(self, *args):
        """
        WriteOwn(IFSelect_BasicDumper self, IFSelect_SessionFile file, Handle_Standard_Transient item) -> Standard_Boolean

        Write the Own Parameters of Types defined in package IFSelect
        Returns True if <item> has been processed, False else

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_BasicDumper_WriteOwn(self, *args)


    def ReadOwn(self, *args):
        """
        ReadOwn(IFSelect_BasicDumper self, IFSelect_SessionFile file, TCollection_AsciiString type, Handle_Standard_Transient item) -> Standard_Boolean

        Recognizes and Read Own Parameters for Types of package
        IFSelect. Returns True if done and <item> created, False else

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type type: OCC.wrapper.TCollection.TCollection_AsciiString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_BasicDumper_ReadOwn(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_BasicDumper_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_BasicDumper_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_BasicDumper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_BasicDumper
IFSelect_BasicDumper_swigregister = _IFSelect.IFSelect_BasicDumper_swigregister
IFSelect_BasicDumper_swigregister(IFSelect_BasicDumper)

def IFSelect_BasicDumper_get_type_name(*args):
    """
    IFSelect_BasicDumper_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_BasicDumper_get_type_name(*args)

def IFSelect_BasicDumper_get_type_descriptor(*args):
    """
    IFSelect_BasicDumper_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_BasicDumper_get_type_descriptor(*args)

class Handle_IFSelect_SessionDumper(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SessionDumper self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SessionDumper_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SessionDumper self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SessionDumper self, IFSelect_SessionDumper thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SessionDumper self, Handle_IFSelect_SessionDumper theHandle) -> Handle_IFSelect_SessionDumper
        assign(Handle_IFSelect_SessionDumper self, IFSelect_SessionDumper thePtr) -> Handle_IFSelect_SessionDumper
        assign(Handle_IFSelect_SessionDumper self, Handle_IFSelect_SessionDumper theHandle) -> Handle_IFSelect_SessionDumper

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SessionDumper self) -> IFSelect_SessionDumper

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SessionDumper self) -> IFSelect_SessionDumper

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SessionDumper___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SessionDumper self) -> IFSelect_SessionDumper

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SessionDumper___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SessionDumper___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SessionDumper___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SessionDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SessionDumper_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SessionDumper

    def First(self, *args):
        """
        First(Handle_IFSelect_SessionDumper self) -> Handle_IFSelect_SessionDumper

        Returns the First item of the Library of Dumper. The Next ones
        are then obtained by Next on the returned items

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_First(self, *args)


    def Next(self, *args):
        """
        Next(Handle_IFSelect_SessionDumper self) -> Handle_IFSelect_SessionDumper

        Returns the Next SesionDumper in the Library. Returns a Null
        Handle at the End.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_Next(self, *args)


    def WriteOwn(self, *args):
        """
        WriteOwn(Handle_IFSelect_SessionDumper self, IFSelect_SessionFile file, Handle_Standard_Transient item) -> Standard_Boolean

        Writes the Own Parameters of a given Item, if it forecast to
        manage its Type.
        Returns True if it has recognized the Type of the Item (in
        this case, it is assumed to have written the Own Parameters if
        there are some), False else : in that case, SessionFile will
        try another SessionDumper in the Library.
        WriteOwn can use these methods from SessionFile : SendVoid,
        SendItem, SendText, and if necessary, WorkSession.

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_WriteOwn(self, *args)


    def ReadOwn(self, *args):
        """
        ReadOwn(Handle_IFSelect_SessionDumper self, IFSelect_SessionFile file, TCollection_AsciiString type, Handle_Standard_Transient item) -> Standard_Boolean

        Recognizes a Type (given as <type>) then Creates an Item of
        this Type with the Own Parameter, as required.
        Returns True if it has recognized the Type (in this case, it
        is assumed to have created the Item, returned as <item>),
        False else : in that case, SessionFile will try another
        SessionDumper in the Library.
        ReadOwn can use these methods from SessionFile to access Own
        Parameters : NbOwnParams, IsVoid, IsText, TextValue, ItemValue

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type type: OCC.wrapper.TCollection.TCollection_AsciiString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_ReadOwn(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SessionDumper self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SessionDumper_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SessionDumper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SessionDumper self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SessionDumper_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SessionDumper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SessionDumper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SessionDumper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SessionDumper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SessionDumper self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SessionDumper self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SessionDumper self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SessionDumper_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SessionDumper self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SessionDumper_DecrementRefCounter(self, *args)

Handle_IFSelect_SessionDumper_swigregister = _IFSelect.Handle_IFSelect_SessionDumper_swigregister
Handle_IFSelect_SessionDumper_swigregister(Handle_IFSelect_SessionDumper)

def Handle_IFSelect_SessionDumper_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SessionDumper_DownCast(thing)
Handle_IFSelect_SessionDumper_DownCast = _IFSelect.Handle_IFSelect_SessionDumper_DownCast

class Handle_IFSelect_SelectControl(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectControl self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectControl_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectControl self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectControl_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectControl self, IFSelect_SelectControl thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectControl_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectControl self, Handle_IFSelect_SelectControl theHandle) -> Handle_IFSelect_SelectControl
        assign(Handle_IFSelect_SelectControl self, IFSelect_SelectControl thePtr) -> Handle_IFSelect_SelectControl
        assign(Handle_IFSelect_SelectControl self, Handle_IFSelect_SelectControl theHandle) -> Handle_IFSelect_SelectControl

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectControl_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectControl self) -> IFSelect_SelectControl

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectControl_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectControl self) -> IFSelect_SelectControl

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectControl___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectControl self) -> IFSelect_SelectControl

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectControl___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectControl___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectControl___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectControl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectControl_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectControl

    def MainInput(self, *args):
        """
        MainInput(Handle_IFSelect_SelectControl self) -> Handle_IFSelect_Selection

        Returns the Main Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectControl_MainInput(self, *args)


    def HasSecondInput(self, *args):
        """
        HasSecondInput(Handle_IFSelect_SelectControl self) -> Standard_Boolean

        Returns True if a Control Input is defined
        Thus, Result can be computed differently if there is a
        Control Input or if there is none

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectControl_HasSecondInput(self, *args)


    def SecondInput(self, *args):
        """
        SecondInput(Handle_IFSelect_SelectControl self) -> Handle_IFSelect_Selection

        Returns the Control Input Selection, or a Null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectControl_SecondInput(self, *args)


    def SetMainInput(self, *args):
        """
        SetMainInput(Handle_IFSelect_SelectControl self, Handle_IFSelect_Selection sel)

        Sets a Selection to be the Main Input

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectControl_SetMainInput(self, *args)


    def SetSecondInput(self, *args):
        """
        SetSecondInput(Handle_IFSelect_SelectControl self, Handle_IFSelect_Selection sel)

        Sets a Selection to be the Control Input

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectControl_SetSecondInput(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectControl self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectControl_FillIterator(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectControl self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectControl_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectControl_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectControl_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectControl self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, computed from Input
        given as a Graph. Specific to each class of Selection
        Note that uniqueness of each entity is not required here
        This method can raise an exception as necessary

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectControl_RootResult(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectControl self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectControl_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectControl self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectControl_CompleteResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectControl self) -> TCollection_AsciiString

        Returns a text which defines the criterium applied by a
        Selection (can be used to be printed, displayed ...)
        Specific to each class

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectControl_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectControl self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectControl_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectControl self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectControl self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectControl_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectControl self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectControl self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectControl_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectControl self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectControl_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectControl self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectControl_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectControl self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectControl_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectControl self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectControl_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectControl_swigregister = _IFSelect.Handle_IFSelect_SelectControl_swigregister
Handle_IFSelect_SelectControl_swigregister(Handle_IFSelect_SelectControl)

def Handle_IFSelect_SelectControl_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectControl_DownCast(thing)
Handle_IFSelect_SelectControl_DownCast = _IFSelect.Handle_IFSelect_SelectControl_DownCast

class NCollection_Sequence_Handle_Interface_InterfaceModel(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IFSelect.new_NCollection_Sequence_Handle_Interface_InterfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Interface_InterfaceModel self)

        Reverse sequence


        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Interface_InterfaceModel self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Interface_InterfaceModel self, NCollection_Sequence_Handle_Interface_InterfaceModel theOther) -> NCollection_Sequence_Handle_Interface_InterfaceModel

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Interface_InterfaceModel self, NCollection_Sequence_Handle_Interface_InterfaceModel theOther) -> NCollection_Sequence_Handle_Interface_InterfaceModel

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Interface_InterfaceModel self, NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Interface_InterfaceModel self, Handle_Interface_InterfaceModel theItem)
        Append(NCollection_Sequence_Handle_Interface_InterfaceModel self, NCollection_Sequence_Handle_Interface_InterfaceModel theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Interface_InterfaceModel self, Handle_Interface_InterfaceModel theItem)
        Prepend(NCollection_Sequence_Handle_Interface_InterfaceModel self, NCollection_Sequence_Handle_Interface_InterfaceModel theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex, Handle_Interface_InterfaceModel theItem)
        InsertBefore(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Interface_InterfaceModel theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Interface_InterfaceModel self, NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::Iterator & thePosition, Handle_Interface_InterfaceModel theItem)
        InsertAfter(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Interface_InterfaceModel theSeq)
        InsertAfter(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex, Handle_Interface_InterfaceModel theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Interface_InterfaceModel theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Handle_Interface_InterfaceModel

        First item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Interface_InterfaceModel self) -> Handle_Interface_InterfaceModel

        Last item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex) -> Handle_Interface_InterfaceModel

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Interface_InterfaceModel self, Standard_Integer const theIndex, Handle_Interface_InterfaceModel theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_SetValue(self, *args)


    def __iter__(self):
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel___iter__(self)
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_Interface_InterfaceModel
NCollection_Sequence_Handle_Interface_InterfaceModel_swigregister = _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_swigregister
NCollection_Sequence_Handle_Interface_InterfaceModel_swigregister(NCollection_Sequence_Handle_Interface_InterfaceModel)

def NCollection_Sequence_Handle_Interface_InterfaceModel_delNode(*args):
    """
    NCollection_Sequence_Handle_Interface_InterfaceModel_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_delNode(*args)

class NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IFSelect.new_NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper

    def __next__(self):
        return _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper_swigregister = _IFSelect.NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper_swigregister
NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper_swigregister(NCollection_Sequence_Handle_Interface_InterfaceModel_IteratorHelper)


try:
	IFSelect_SequenceOfInterfaceModel = NCollection_Sequence_Handle_Interface_InterfaceModel
except NameError:
	pass # does not exist, probably ignored

class Handle_IFSelect_CheckCounter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_CheckCounter self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_CheckCounter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_CheckCounter self, IFSelect_CheckCounter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_CheckCounter self, Handle_IFSelect_CheckCounter theHandle) -> Handle_IFSelect_CheckCounter
        assign(Handle_IFSelect_CheckCounter self, IFSelect_CheckCounter thePtr) -> Handle_IFSelect_CheckCounter
        assign(Handle_IFSelect_CheckCounter self, Handle_IFSelect_CheckCounter theHandle) -> Handle_IFSelect_CheckCounter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_CheckCounter self) -> IFSelect_CheckCounter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_CheckCounter self) -> IFSelect_CheckCounter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_CheckCounter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_CheckCounter self) -> IFSelect_CheckCounter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_CheckCounter___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_CheckCounter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_CheckCounter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_CheckCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_CheckCounter_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_CheckCounter

    def SetSignature(self, *args):
        """
        SetSignature(Handle_IFSelect_CheckCounter self, Handle_MoniTool_SignText sign)

        Sets a specific signature
        Else, the current SignType (in the model) is used

        :type sign: OCC.wrapper.MoniTool.Handle_MoniTool_SignText

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_SetSignature(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_CheckCounter self) -> Handle_MoniTool_SignText

        Returns the Signature;

        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_SignText

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Signature(self, *args)


    def Analyse(self, *args):
        """
        Analyse(Handle_IFSelect_CheckCounter self, Interface_CheckIterator list, Handle_Interface_InterfaceModel model, Standard_Boolean const original, Standard_Boolean const failsonly)

        Analyses a CheckIterator according a Model (which detains the
        entities for which the CheckIterator has messages), i.e.
        counts messages for entities
        If <original> is True, does not consider final messages but
        those before interpretation (such as inserting variables :
        integers, reals, strings)
        If <failsonly> is True, only Fails are considered
        Remark : global messages are recorded with a Null entity

        :type list: OCC.wrapper.Interface.Interface_CheckIterator
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type original: bool
        :type failsonly: bool

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Analyse(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_CheckCounter self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_CheckCounter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_CheckCounter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_CheckCounter self, Standard_Boolean const withlist)

        Changes the record-list status. The list is not cleared but
        its use changes

        :type withlist: bool

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_SetList(self, *args)


    def ModeSignOnly(self, *args):
        """
        ModeSignOnly(Handle_IFSelect_CheckCounter self) -> Standard_Boolean &

        Returns modifiable the SignOnly Mode
        If False (D), the counter normally counts
        If True, the counting work is turned off, Add only fills the
        LastValue, which can be used as signature, when a counter
        works from data which are not available from a Signature

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_ModeSignOnly(self, *args)


    def Clear(self, *args):
        """Clear(Handle_IFSelect_CheckCounter self)"""
        return _IFSelect.Handle_IFSelect_CheckCounter_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_CheckCounter self, Handle_Standard_Transient ent, Standard_CString const sign)

        Adds an entity with its signature, i.e. :
        - counts an item more for <sign>
        - if record-list status is set, records the entity
        Accepts a null entity (the signature is then for the global
        model). But if the string is empty, counts a Null item.

        If SignOnly Mode is set, this work is replaced by just
        setting LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sign: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Add(self, *args)


    def LastValue(self, *args):
        """
        LastValue(Handle_IFSelect_CheckCounter self) -> Standard_CString

        Returns the last value recorded by Add (only if SignMode set)
        Cleared by Clear or Init

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_LastValue(self, *args)


    def Init(self, *args):
        """
        Init(Handle_IFSelect_CheckCounter self, Standard_CString const name, NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer > const & count, NCollection_IndexedDataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & list, Standard_Integer const nbnuls)

        Aknowledges the list in once. Name identifies the Signature

        :type name: OCC.wrapper.Standard.Standard_CString
        :type count: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer
        :type list: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Handle_Standard_Transient
        :type nbnuls: int

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Init(self, *args)


    def List(self, *args):
        """
        List(Handle_IFSelect_CheckCounter self, Standard_CString const root) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of signatures, as a sequence of strings
        (but without their respective counts). It is ordered.
        By default, for all the signatures.
        If <root> is given non empty, for the signatures which
        begin by <root>

        :type root: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_List(self, *args)


    def HasEntities(self, *args):
        """
        HasEntities(Handle_IFSelect_CheckCounter self) -> Standard_Boolean

        Returns True if the list of Entities is aknowledged, else
        the method Entities will always return a Null Handle

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_HasEntities(self, *args)


    def NbNulls(self, *args):
        """
        NbNulls(Handle_IFSelect_CheckCounter self) -> Standard_Integer

        Returns the count of null entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_NbNulls(self, *args)


    def NbTimes(self, *args):
        """
        NbTimes(Handle_IFSelect_CheckCounter self, Standard_CString const sign) -> Standard_Integer

        Returns the number of times a signature was counted,
        0 if it has not been recorded at all

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_NbTimes(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_IFSelect_CheckCounter self, Standard_CString const sign) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities attached to a signature
        It is empty if <sign> has not been recorded
        It is a Null Handle if the list of entities is not known

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Entities(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_IFSelect_CheckCounter self, Standard_CString const name)

        Defines a name for a SignatureList (used to print it)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_CheckCounter self) -> Standard_CString

        Returns the recorded Name.
        Remark : default is "..." (no SetName called)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Name(self, *args)


    def PrintCount(self, *args):
        """
        PrintCount(Handle_IFSelect_CheckCounter self, Handle_Message_Messenger S)

        Prints the counts of items (not the list)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_PrintCount(self, *args)


    def PrintList(self, *args):
        """
        PrintList(Handle_IFSelect_CheckCounter self, Handle_Message_Messenger S, Handle_Interface_InterfaceModel model, IFSelect_PrintCount const mod=IFSelect_ListByItem)

        Prints the lists of items, if they are present (else, prints
        a message "no list available")
        Uses <model> to determine for each entity to be listed, its
        number, and its specific identifier (by PrintLabel)
        <mod> gives a mode for printing :
        - CountByItem : just count (as PrintCount)
        - ShortByItem : minimum i.e. count plus 5 first entity numbers
        - ShortByItem(D) complete list of entity numbers (0: "Global")
        - EntitiesByItem : list of (entity number/PrintLabel from the model)
        other modes are ignored

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type mod: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_PrintList(self, *args)


    def PrintSum(self, *args):
        """
        PrintSum(Handle_IFSelect_CheckCounter self, Handle_Message_Messenger S)

        Prints a summary
        Item which has the greatest count of entities
        For items which are numeric values : their count, maximum,
        minimum values, cumul, average

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_PrintSum(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_CheckCounter self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_CheckCounter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_CheckCounter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_CheckCounter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_CheckCounter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_CheckCounter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_CheckCounter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_CheckCounter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_CheckCounter self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_CheckCounter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_CheckCounter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_CheckCounter_DecrementRefCounter(self, *args)

Handle_IFSelect_CheckCounter_swigregister = _IFSelect.Handle_IFSelect_CheckCounter_swigregister
Handle_IFSelect_CheckCounter_swigregister(Handle_IFSelect_CheckCounter)

def Handle_IFSelect_CheckCounter_DownCast(thing):
    return _IFSelect.Handle_IFSelect_CheckCounter_DownCast(thing)
Handle_IFSelect_CheckCounter_DownCast = _IFSelect.Handle_IFSelect_CheckCounter_DownCast

class Handle_IFSelect_Editor(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Editor self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Editor_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Editor self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Editor_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Editor self, IFSelect_Editor thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Editor_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Editor self, Handle_IFSelect_Editor theHandle) -> Handle_IFSelect_Editor
        assign(Handle_IFSelect_Editor self, IFSelect_Editor thePtr) -> Handle_IFSelect_Editor
        assign(Handle_IFSelect_Editor self, Handle_IFSelect_Editor theHandle) -> Handle_IFSelect_Editor

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Editor_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Editor self) -> IFSelect_Editor

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Editor_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Editor self) -> IFSelect_Editor

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Editor___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Editor self) -> IFSelect_Editor

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Editor___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Editor___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Editor___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Editor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Editor_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Editor

    def SetValue(self, *args):
        """
        SetValue(Handle_IFSelect_Editor self, Standard_Integer const num, Handle_Interface_TypedValue typval, Standard_CString const shortname, IFSelect_EditValue const accessmode=IFSelect_Editable)

        Sets a Typed Value for a given ident and short name, with an
        Edit Mode

        :type num: int
        :type typval: OCC.wrapper.Interface.Handle_Interface_TypedValue
        :type shortname: OCC.wrapper.Standard.Standard_CString
        :type accessmode: OCC.wrapper.IFSelect.IFSelect_EditValue

        """
        return _IFSelect.Handle_IFSelect_Editor_SetValue(self, *args)


    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_Editor self, Standard_Integer const num, Standard_Integer const max=0)

        Sets a parameter to be a List
        max < 0 : not for a list (set when starting)
        max = 0 : list with no length limit (default for SetList)
        max > 0 : list limited to <max> items

        :type num: int
        :type max: int

        """
        return _IFSelect.Handle_IFSelect_Editor_SetList(self, *args)


    def NbValues(self, *args):
        """
        NbValues(Handle_IFSelect_Editor self) -> Standard_Integer

        Returns the count of Typed Values

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Editor_NbValues(self, *args)


    def TypedValue(self, *args):
        """
        TypedValue(Handle_IFSelect_Editor self, Standard_Integer const num) -> Handle_Interface_TypedValue

        Returns a Typed Value from its ident

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_TypedValue

        """
        return _IFSelect.Handle_IFSelect_Editor_TypedValue(self, *args)


    def IsList(self, *args):
        """
        IsList(Handle_IFSelect_Editor self, Standard_Integer const num) -> Standard_Boolean

        Tells if a parameter is a list

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_IsList(self, *args)


    def MaxList(self, *args):
        """
        MaxList(Handle_IFSelect_Editor self, Standard_Integer const num) -> Standard_Integer

        Returns max length allowed for a list
        = 0 means : list with no limit
        < 0 means : not a list

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Editor_MaxList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_Editor self, Standard_Integer const num, Standard_Boolean const isshort) -> Standard_CString

        Returns the name of a Value (complete or short) from its ident
        Short Name can be empty

        :type num: int
        :type isshort: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_Editor_Name(self, *args)


    def EditMode(self, *args):
        """
        EditMode(Handle_IFSelect_Editor self, Standard_Integer const num) -> IFSelect_EditValue

        Returns the edit mode of a Value

        :type num: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_EditValue

        """
        return _IFSelect.Handle_IFSelect_Editor_EditMode(self, *args)


    def NameNumber(self, *args):
        """
        NameNumber(Handle_IFSelect_Editor self, Standard_CString const name) -> Standard_Integer

        Returns the number (ident) of a Value, from its name, short or
        complete. If not found, returns 0

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Editor_NameNumber(self, *args)


    def PrintNames(self, *args):
        """
        PrintNames(Handle_IFSelect_Editor self, Handle_Message_Messenger S)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_Editor_PrintNames(self, *args)


    def PrintDefs(self, *args):
        """
        PrintDefs(Handle_IFSelect_Editor self, Handle_Message_Messenger S, Standard_Boolean const labels)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type labels: bool

        """
        return _IFSelect.Handle_IFSelect_Editor_PrintDefs(self, *args)


    def MaxNameLength(self, *args):
        """
        MaxNameLength(Handle_IFSelect_Editor self, Standard_Integer const what) -> Standard_Integer

        Returns the MaxLength of, according to what :
        <what> = -1 : length of short names
        <what> =  0 : length of complete names
        <what> =  1 : length of values labels

        :type what: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Editor_MaxNameLength(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_Editor self) -> TCollection_AsciiString

        Returns the specific label

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Editor_Label(self, *args)


    def Form(self, *args):
        """
        Form(Handle_IFSelect_Editor self, Standard_Boolean const readonly, Standard_Boolean const undoable) -> Handle_IFSelect_EditForm

        Builds and Returns an EditForm, empty (no data yet)
        Can be redefined to return a specific type of EditForm

        :type readonly: bool
        :type undoable: bool
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm

        """
        return _IFSelect.Handle_IFSelect_Editor_Form(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form) -> Standard_Boolean

        Tells if this Editor can work on this EditForm and its content
        (model, entity ?)

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_Recognize(self, *args)


    def StringValue(self, *args):
        """
        StringValue(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns the value of an EditForm, for a given item
        (if not a list. for a list, a Null String may be returned)

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_Editor_StringValue(self, *args)


    def ListEditor(self, *args):
        """
        ListEditor(Handle_IFSelect_Editor self, Standard_Integer const num) -> Handle_IFSelect_ListEditor

        Returns a ListEditor for a parameter which is a List
        Default returns a basic ListEditor for a List, a Null Handle
        if <num> is not for a List. Can be redefined

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor

        """
        return _IFSelect.Handle_IFSelect_Editor_ListEditor(self, *args)


    def ListValue(self, *args):
        """
        ListValue(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the value of an EditForm as a List, for a given item
        If not a list, a Null Handle should be returned
        Default returns a Null Handle, because many Editors have
        no list to edit. To be redefined as required

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_Editor_ListValue(self, *args)


    def Load(self, *args):
        """
        Load(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Loads original values from some data, to an EditForm
        Remark: <ent> may be Null, this means all <model> is concerned
        Also <model> may be Null, if no context applies for <ent>
        And both <ent> and <model> may be Null, for a full static
        editor

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_Load(self, *args)


    def Update(self, *args):
        """
        Update(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num, Handle_TCollection_HAsciiString newval, Standard_Boolean const enforce) -> Standard_Boolean

        Updates the EditForm when a parameter is modified
        I.E.  default does nothing, can be redefined, as follows :
        Returns True when done (even if does nothing), False in case
        of refuse (for instance, if the new value is not suitable)
        <num> is the rank of the parameter for the EDITOR itself
        <enforce> True means that protected parameters can be touched

        If a parameter commands the value of other ones, when it is
        modified, it is necessary to touch them by Touch from EditForm

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_Update(self, *args)


    def UpdateList(self, *args):
        """
        UpdateList(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString newlist, Standard_Boolean const enforce) -> Standard_Boolean

        Acts as Update, but when the value is a list

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type num: int
        :type newlist: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_UpdateList(self, *args)


    def Apply(self, *args):
        """
        Apply(Handle_IFSelect_Editor self, Handle_IFSelect_EditForm form, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Applies modified values of the EditForm with some data
        Remark: <ent> may be Null, this means all <model> is concerned
        Also <model> may be Null, if no context applies for <ent>
        And both <ent> and <model> may be Null, for a full static
        editor

        :type form: OCC.wrapper.IFSelect.Handle_IFSelect_EditForm
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Editor self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Editor_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Editor_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Editor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Editor self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Editor_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Editor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Editor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Editor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Editor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Editor_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Editor self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Editor_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Editor self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Editor_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Editor self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Editor_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Editor self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Editor_DecrementRefCounter(self, *args)

Handle_IFSelect_Editor_swigregister = _IFSelect.Handle_IFSelect_Editor_swigregister
Handle_IFSelect_Editor_swigregister(Handle_IFSelect_Editor)

def Handle_IFSelect_Editor_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Editor_DownCast(thing)
Handle_IFSelect_Editor_DownCast = _IFSelect.Handle_IFSelect_Editor_DownCast

class IFSelect_ContextModif(object):
    """
    This class gathers various informations used by Model Modifiers
    apart from the target model itself, and the CopyTool which
    must be passed directly.

    These informations report to original data : model, entities,
    and the selection list if there is one : it allows to query
    about such or such starting entity, or result entity, or
    iterate on selection list ...
    Also data useful for file output are available (because some
    Modifiers concern models produced for file output).

    Furthermore, in return, ContextModif can record Checks, either
    one for all, or one for each Entity. It supports trace too.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFSelect_ContextModif self, Interface_Graph graph, Interface_CopyTool TC, Standard_CString const filename) -> IFSelect_ContextModif
        __init__(IFSelect_ContextModif self, Interface_Graph graph, Standard_CString const filename) -> IFSelect_ContextModif

        Prepares a ContextModif with these informations :
        - the graph established from original model (target passed
        directly to Modifier)
        - an optional file name (for file output)
        Here, no CopyControl, hence all entities are considered equal
        as starting and result

        Such a ContextModif is considered to be applied on all
        transferred entities (no filter active)

        :type graph: OCC.wrapper.Interface.Interface_Graph
        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_ContextModif(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Select(self, *args):
        """
        Select(IFSelect_ContextModif self, Interface_EntityIterator list)

        This method requires ContextModif to be applied with a filter.
        If a ModelModifier is defined with a Selection criterium,
        the result of this Selection is used as a filter :
        - if none of its items has been transferred, the modification
        does not apply at all
        - else, the Modifier can query for what entities were selected
        and what are their results
        - if this method is not called before working, the Modifier
        has to work on the whole Model

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ContextModif_Select(self, *args)


    def OriginalGraph(self, *args):
        """
        Returns the original Graph (compared to OriginalModel, it
        gives more query capabilitites)

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _IFSelect.IFSelect_ContextModif_OriginalGraph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OriginalModel(self, *args):
        """
        OriginalModel(IFSelect_ContextModif self) -> Handle_Interface_InterfaceModel

        Returns the original model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_ContextModif_OriginalModel(self, *args)


    def SetProtocol(self, *args):
        """
        SetProtocol(IFSelect_ContextModif self, Handle_Interface_Protocol proto)

        Allows to transmit a Protocol as part of a ContextModif

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _IFSelect.IFSelect_ContextModif_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Protocol(IFSelect_ContextModif self) -> Handle_Interface_Protocol

        Returns the Protocol (Null if not set)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _IFSelect.IFSelect_ContextModif_Protocol(self, *args)


    def HasFileName(self, *args):
        """
        HasFileName(IFSelect_ContextModif self) -> Standard_Boolean

        Returns True if a non empty file name has been defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextModif_HasFileName(self, *args)


    def FileName(self, *args):
        """
        FileName(IFSelect_ContextModif self) -> Standard_CString

        Returns File Name (can be empty)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextModif_FileName(self, *args)


    def Control(self, *args):
        """
        Control(IFSelect_ContextModif self) -> Handle_Interface_CopyControl

        Returns the map for a direct use, if required

        :rtype: OCC.wrapper.Interface.Handle_Interface_CopyControl

        """
        return _IFSelect.IFSelect_ContextModif_Control(self, *args)


    def IsForNone(self, *args):
        """
        IsForNone(IFSelect_ContextModif self) -> Standard_Boolean

        Returns True if Select has determined that a Modifier may not
        be run (filter defined and empty)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextModif_IsForNone(self, *args)


    def IsForAll(self, *args):
        """
        IsForAll(IFSelect_ContextModif self) -> Standard_Boolean

        Returns True if no filter is defined : a Modifier has to work
        on all entities of the resulting (target) model

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextModif_IsForAll(self, *args)


    def IsTransferred(self, *args):
        """
        IsTransferred(IFSelect_ContextModif self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if a starting item has been transferred

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextModif_IsTransferred(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(IFSelect_ContextModif self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if a starting item has been transferred and selected

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextModif_IsSelected(self, *args)


    def SelectedOriginal(self, *args):
        """
        SelectedOriginal(IFSelect_ContextModif self) -> Interface_EntityIterator

        Returns the list of original selected items.
        See also the iteration

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ContextModif_SelectedOriginal(self, *args)


    def SelectedResult(self, *args):
        """
        SelectedResult(IFSelect_ContextModif self) -> Interface_EntityIterator

        Returns the list of resulting counterparts of selected items.
        See also the iteration

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ContextModif_SelectedResult(self, *args)


    def SelectedCount(self, *args):
        """
        SelectedCount(IFSelect_ContextModif self) -> Standard_Integer

        Returns the count of selected and transferred items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ContextModif_SelectedCount(self, *args)


    def Start(self, *args):
        """
        Start(IFSelect_ContextModif self)

        Starts an iteration on selected items. It takes into account
        IsForAll/IsForNone, by really iterating on all selected items.


        """
        return _IFSelect.IFSelect_ContextModif_Start(self, *args)


    def More(self, *args):
        """
        More(IFSelect_ContextModif self) -> Standard_Boolean

        Returns True until the iteration has finished

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextModif_More(self, *args)


    def Next(self, *args):
        """
        Next(IFSelect_ContextModif self)

        Advances the iteration


        """
        return _IFSelect.IFSelect_ContextModif_Next(self, *args)


    def ValueOriginal(self, *args):
        """
        ValueOriginal(IFSelect_ContextModif self) -> Handle_Standard_Transient

        Returns the current selected item in the original model

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_ContextModif_ValueOriginal(self, *args)


    def ValueResult(self, *args):
        """
        ValueResult(IFSelect_ContextModif self) -> Handle_Standard_Transient

        Returns the result counterpart of current selected item
        (in the target model)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_ContextModif_ValueResult(self, *args)


    def TraceModifier(self, *args):
        """
        TraceModifier(IFSelect_ContextModif self, Handle_IFSelect_GeneralModifier modif)

        Traces the application of a Modifier. Works with default trace
        File and Level. Fills the trace if default trace level is at
        least 1. Traces the Modifier (its Label) and its Selection if
        there is one (its Label).
        To be called after Select (because status IsForAll is printed)
        Worths to trace a global modification. See also Trace below

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _IFSelect.IFSelect_ContextModif_TraceModifier(self, *args)


    def Trace(self, *args):
        """
        Trace(IFSelect_ContextModif self, Standard_CString const mess)

        Traces the modification of the current entity (see above,
        ValueOriginal and ValueResult) for default trace level >= 2.
        To be called on each indivudual entity really modified
        <mess> is an optionnal additional message

        :type mess: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextModif_Trace(self, *args)


    def AddCheck(self, *args):
        """
        AddCheck(IFSelect_ContextModif self, Handle_Interface_Check check)

        Adds a Check to the CheckList. If it is empty, nothing is done
        If it concerns an Entity from the Original Model (by SetEntity)
        to which another Check is attached, it is merged to it.
        Else, it is added or merged as to GlobalCheck.

        :type check: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _IFSelect.IFSelect_ContextModif_AddCheck(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(IFSelect_ContextModif self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        Adds a Warning Message for an Entity from the original Model
        If <start> is not an Entity from the original model (e.g. the
        model itself) this message is added to Global Check.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextModif_AddWarning(self, *args)


    def AddFail(self, *args):
        """
        AddFail(IFSelect_ContextModif self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        Adds a Fail Message for an Entity from the original Model
        If <start> is not an Entity from the original model (e.g. the
        model itself) this message is added to Global Check.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextModif_AddFail(self, *args)


    def CCheck(self, *args):
        """
        CCheck(IFSelect_ContextModif self, Standard_Integer const num=0) -> Handle_Interface_Check
        CCheck(IFSelect_ContextModif self, Handle_Standard_Transient start) -> Handle_Interface_Check

        Returns a Check attached to an Entity from the original Model
        It can then be acknowledged on the spot, in condition that the
        caller works by reference ("Interface_Check& check = ...")

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _IFSelect.IFSelect_ContextModif_CCheck(self, *args)


    def CheckList(self, *args):
        """
        CheckList(IFSelect_ContextModif self) -> Interface_CheckIterator

        Returns the complete CheckList

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ContextModif_CheckList(self, *args)

    __swig_destroy__ = _IFSelect.delete_IFSelect_ContextModif
IFSelect_ContextModif_swigregister = _IFSelect.IFSelect_ContextModif_swigregister
IFSelect_ContextModif_swigregister(IFSelect_ContextModif)

class Handle_IFSelect_SelectIncorrectEntities(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectIncorrectEntities self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectIncorrectEntities self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectIncorrectEntities self, IFSelect_SelectIncorrectEntities thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectIncorrectEntities self, Handle_IFSelect_SelectIncorrectEntities theHandle) -> Handle_IFSelect_SelectIncorrectEntities
        assign(Handle_IFSelect_SelectIncorrectEntities self, IFSelect_SelectIncorrectEntities thePtr) -> Handle_IFSelect_SelectIncorrectEntities
        assign(Handle_IFSelect_SelectIncorrectEntities self, Handle_IFSelect_SelectIncorrectEntities theHandle) -> Handle_IFSelect_SelectIncorrectEntities

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectIncorrectEntities self) -> IFSelect_SelectIncorrectEntities

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectIncorrectEntities self) -> IFSelect_SelectIncorrectEntities

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectIncorrectEntities self) -> IFSelect_SelectIncorrectEntities

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectIncorrectEntities___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectIncorrectEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectIncorrectEntities_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectIncorrectEntities

    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectIncorrectEntities self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FlagName(self, *args):
        """
        FlagName(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_CString

        Returns the name of the flag

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_FlagName(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectIncorrectEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. It is redefined to
        work on the graph itself (not queried by sort)

        An entity is selected if its flag is True on Direct mode,
        False on Reversed mode

        If flag does not exist for the given name, returns an empty
        result, whatever the Direct/Reversed sense

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectIncorrectEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always False because RootResult has done the work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectIncorrectEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium, includes the flag name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_ExtractLabel(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectIncorrectEntities self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_SetDirect(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectIncorrectEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectIncorrectEntities self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectIncorrectEntities self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectIncorrectEntities self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectIncorrectEntities self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectIncorrectEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectIncorrectEntities self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectIncorrectEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectIncorrectEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectIncorrectEntities self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectIncorrectEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectIncorrectEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectIncorrectEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectIncorrectEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectIncorrectEntities self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectIncorrectEntities self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectIncorrectEntities_swigregister = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_swigregister
Handle_IFSelect_SelectIncorrectEntities_swigregister(Handle_IFSelect_SelectIncorrectEntities)

def Handle_IFSelect_SelectIncorrectEntities_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_DownCast(thing)
Handle_IFSelect_SelectIncorrectEntities_DownCast = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_DownCast

class Handle_IFSelect_PacketList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_PacketList self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_PacketList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_PacketList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_PacketList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_PacketList self, IFSelect_PacketList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_PacketList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_PacketList self, Handle_IFSelect_PacketList theHandle) -> Handle_IFSelect_PacketList
        assign(Handle_IFSelect_PacketList self, IFSelect_PacketList thePtr) -> Handle_IFSelect_PacketList
        assign(Handle_IFSelect_PacketList self, Handle_IFSelect_PacketList theHandle) -> Handle_IFSelect_PacketList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_PacketList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_PacketList self) -> IFSelect_PacketList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_PacketList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_PacketList self) -> IFSelect_PacketList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_PacketList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_PacketList self) -> IFSelect_PacketList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_PacketList___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_PacketList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_PacketList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_PacketList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_PacketList_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_PacketList

    def SetName(self, *args):
        """
        SetName(Handle_IFSelect_PacketList self, Standard_CString const name)

        Sets a name to a packet list : this makes easier a general
        routine to print it. Default is "Packets"

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_PacketList_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_PacketList self) -> Standard_CString

        Returns the recorded name for a packet list

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_PacketList_Name(self, *args)


    def Model(self, *args):
        """
        Model(Handle_IFSelect_PacketList self) -> Handle_Interface_InterfaceModel

        Returns the Model of reference

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_PacketList_Model(self, *args)


    def AddPacket(self, *args):
        """
        AddPacket(Handle_IFSelect_PacketList self)

        Declares a new Packet, ready to be filled
        The entities to be added will be added to this Packet


        """
        return _IFSelect.Handle_IFSelect_PacketList_AddPacket(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_PacketList self, Handle_Standard_Transient ent)

        Adds an entity from the Model into the current packet for Add

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_PacketList_Add(self, *args)


    def AddList(self, *args):
        """
        AddList(Handle_IFSelect_PacketList self, Handle_TColStd_HSequenceOfTransient list)

        Adds an list of entities into the current packet for Add

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_PacketList_AddList(self, *args)


    def NbPackets(self, *args):
        """
        NbPackets(Handle_IFSelect_PacketList self) -> Standard_Integer

        Returns the count of non-empty packets

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_PacketList_NbPackets(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Handle_IFSelect_PacketList self, Standard_Integer const numpack) -> Standard_Integer

        Returns the count of entities in a Packet given its rank, or 0

        :type numpack: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_PacketList_NbEntities(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_IFSelect_PacketList self, Standard_Integer const numpack) -> Interface_EntityIterator

        Returns the content of a Packet given its rank
        Null Handle if <numpack> is out of range

        :type numpack: int
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_PacketList_Entities(self, *args)


    def HighestDuplicationCount(self, *args):
        """
        HighestDuplicationCount(Handle_IFSelect_PacketList self) -> Standard_Integer

        Returns the highest number of packets which know a same entity
        For no duplication, should be one

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_PacketList_HighestDuplicationCount(self, *args)


    def NbDuplicated(self, *args):
        """
        NbDuplicated(Handle_IFSelect_PacketList self, Standard_Integer const count, Standard_Boolean const andmore) -> Standard_Integer

        Returns the count of entities duplicated :
        <count> times, if <andmore> is False, or
        <count> or more times, if <andmore> is True
        See Duplicated for more details

        :type count: int
        :type andmore: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_PacketList_NbDuplicated(self, *args)


    def Duplicated(self, *args):
        """
        Duplicated(Handle_IFSelect_PacketList self, Standard_Integer const count, Standard_Boolean const andmore) -> Interface_EntityIterator

        Returns a list of entities duplicated :
        <count> times, if <andmore> is False, or
        <count> or more times, if <andmore> is True
        Hence, count=2 & andmore=True gives all duplicated entities
        count=1 gives non-duplicated entities (in only one packet)
        count=0 gives remaining entities (in no packet at all)

        :type count: int
        :type andmore: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_PacketList_Duplicated(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_PacketList self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_PacketList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_PacketList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_PacketList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_PacketList self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_PacketList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_PacketList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_PacketList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_PacketList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_PacketList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_PacketList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_PacketList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_PacketList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_PacketList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_PacketList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_PacketList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_PacketList self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_PacketList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_PacketList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_PacketList_DecrementRefCounter(self, *args)

Handle_IFSelect_PacketList_swigregister = _IFSelect.Handle_IFSelect_PacketList_swigregister
Handle_IFSelect_PacketList_swigregister(Handle_IFSelect_PacketList)

def Handle_IFSelect_PacketList_DownCast(thing):
    return _IFSelect.Handle_IFSelect_PacketList_DownCast(thing)
Handle_IFSelect_PacketList_DownCast = _IFSelect.Handle_IFSelect_PacketList_DownCast

class IFSelect_ShareOut(Standard.Standard_Transient):
    """
    This class gathers the informations required to produce one or
    several file(s) from the content of an InterfaceModel (passing
    through the creation of intermediate Models).

    It can correspond to a complete Divide up of a set of Entities
    intended to be exhaustive and to limit duplications. Or to a
    simple Extraction of some Entities, in order to work on them.

    A ShareOut is composed of a list of Dispatches.
    To Each Dispatch in the ShareOut, is bound an Id. Number
    This Id. Number allows to identify a Display inside the
    ShareOut in a stable way (for instance, to attach file names)

    ShareOut can be seen as a "passive" description, activated
    through a ShareOutResult, which gives the InterfaceModel on
    which to work, as a unique source. Thus it is easy to change
    it without coherence problems

    Services about it are provided by the class ShareOutResult
    which is a service class : simulation (list of files and of
    entities per file; "forgotten" entities; duplicated entities),
    exploitation (generation of derivated Models, each of them
    generating an output file)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_ShareOut
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_ShareOut(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_ShareOut self) -> IFSelect_ShareOut

        Creates an empty ShareOut


        """
        this = _IFSelect.new_IFSelect_ShareOut(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(IFSelect_ShareOut self, Standard_Boolean const onlydisp)

        Removes in one operation all the Dispatches with their Idents
        Also clears all informations about Names, and all Results but
        naming informations which are :
        - kept if <onlydisp> is True.
        - cleared if <onlydisp> is False (complete clearing)
        If <onlydisp> is True, that's all. Else, clears also Modifiers

        :type onlydisp: bool

        """
        return _IFSelect.IFSelect_ShareOut_Clear(self, *args)


    def ClearResult(self, *args):
        """
        ClearResult(IFSelect_ShareOut self, Standard_Boolean const alsoname)

        Clears all data produced (apart from Dispatches, etc...)
        if <alsoname> is True, all is cleared. Else, informations
        about produced Names are kept (to maintain unicity of naming
        across clearings)

        :type alsoname: bool

        """
        return _IFSelect.IFSelect_ShareOut_ClearResult(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(IFSelect_ShareOut self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an item, which can be, either a Dispatch (removed from
        the list of Dispatches), or a GeneralModifier (removed from
        the list of Model Modifiers or from the list of File Modifiers
        according to its type).
        Returns True if done, False if has not been found or if it is
        neither a Dispatch, nor a Modifier.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_RemoveItem(self, *args)


    def LastRun(self, *args):
        """
        LastRun(IFSelect_ShareOut self) -> Standard_Integer

        Returns the rank of last run item (ClearResult resets it to 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOut_LastRun(self, *args)


    def SetLastRun(self, *args):
        """
        SetLastRun(IFSelect_ShareOut self, Standard_Integer const last)

        Records a new alue for the rank of last run item

        :type last: int

        """
        return _IFSelect.IFSelect_ShareOut_SetLastRun(self, *args)


    def NbDispatches(self, *args):
        """
        NbDispatches(IFSelect_ShareOut self) -> Standard_Integer

        Returns the count of Dispatches

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOut_NbDispatches(self, *args)


    def DispatchRank(self, *args):
        """
        DispatchRank(IFSelect_ShareOut self, Handle_IFSelect_Dispatch disp) -> Standard_Integer

        Returns the Rank of a Dispatch, given its Value (Handle).
        Returns 0 if the Dispatch is unknown in the ShareOut

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOut_DispatchRank(self, *args)


    def Dispatch(self, *args):
        """
        Returns a Dispatch, given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        res = _IFSelect.IFSelect_ShareOut_Dispatch(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddDispatch(self, *args):
        """
        AddDispatch(IFSelect_ShareOut self, Handle_IFSelect_Dispatch disp)

        Adds a Dispatch to the list

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.IFSelect_ShareOut_AddDispatch(self, *args)


    def RemoveDispatch(self, *args):
        """
        RemoveDispatch(IFSelect_ShareOut self, Standard_Integer const rank) -> Standard_Boolean

        Removes a Dispatch, given its rank in the list
        Returns True if done, False if rank is not between
        (LastRun + 1) and (NbDispatches)

        :type rank: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_RemoveDispatch(self, *args)


    def AddModifier(self, *args):
        """
        AddModifier(IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier, Standard_Integer const atnum)
        AddModifier(IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier, Standard_Integer const dispnum, Standard_Integer const atnum)

        Sets a Modifier to be applied on the Dispatch <dispnum>
        If <modifier> is a ModelModifier, adds it to the list of
        Model Modifiers; else to the list of File Modifiers
        This is the same list as for all Dispatches, but the
        Modifier is qualified to be applied to one Dispatch only
        Then, <atnum> refers to the entire list
        By default (atnum = 0) at the end of the list, else at <atnum>
        Remark : if the Modifier was already in the list and if
        <atnum> = 0, the Modifier is not moved, but only qualified
        for a Dispatch

        :type modifier: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type dispnum: int
        :type atnum: int

        """
        return _IFSelect.IFSelect_ShareOut_AddModifier(self, *args)


    def AddModif(self, *args):
        """
        AddModif(IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier, Standard_Boolean const formodel, Standard_Integer const atnum=0)

        Adds a Modifier to the list of Modifiers : Model Modifiers if
        <formodel> is True, File Modifiers else (internal).

        :type modifier: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type formodel: bool
        :type atnum: int

        """
        return _IFSelect.IFSelect_ShareOut_AddModif(self, *args)


    def NbModifiers(self, *args):
        """
        NbModifiers(IFSelect_ShareOut self, Standard_Boolean const formodel) -> Standard_Integer

        Returns count of Modifiers (which apply to complete Models) :
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOut_NbModifiers(self, *args)


    def GeneralModifier(self, *args):
        """
        GeneralModifier(IFSelect_ShareOut self, Standard_Boolean const formodel, Standard_Integer const num) -> Handle_IFSelect_GeneralModifier

        Returns a Modifier of the list, given its rank :
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool
        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _IFSelect.IFSelect_ShareOut_GeneralModifier(self, *args)


    def ModelModifier(self, *args):
        """
        ModelModifier(IFSelect_ShareOut self, Standard_Integer const num) -> Handle_IFSelect_Modifier

        Returns a Modifier of the list of Model Modifiers, duely casted

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _IFSelect.IFSelect_ShareOut_ModelModifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier) -> Standard_Integer

        Gives the rank of a Modifier in the list, 0 if not in the list
        Model Modifiers if <modifier> is kind of ModelModifer,
        File Modifiers else

        :type modifier: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOut_ModifierRank(self, *args)


    def RemoveModifier(self, *args):
        """
        RemoveModifier(IFSelect_ShareOut self, Standard_Boolean const formodel, Standard_Integer const num) -> Standard_Boolean

        Removes a Modifier, given it rank in the list :
        Model Modifiers if <formodel> is True, File Modifiers else
        Returns True if done, False if <num> is out of range

        :type formodel: bool
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_RemoveModifier(self, *args)


    def ChangeModifierRank(self, *args):
        """
        ChangeModifierRank(IFSelect_ShareOut self, Standard_Boolean const formodel, Standard_Integer const befor, Standard_Integer const after) -> Standard_Boolean

        Changes the rank of a modifier in the list :
        Model Modifiers if <formodel> is True, File Modifiers else
        from <before> to <after>
        Returns True if done, False else (before or after out of range)

        :type formodel: bool
        :type befor: int
        :type after: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_ChangeModifierRank(self, *args)


    def SetRootName(self, *args):
        """
        SetRootName(IFSelect_ShareOut self, Standard_Integer const num, Handle_TCollection_HAsciiString name) -> Standard_Boolean

        Attaches a Root Name to a Dispatch given its rank, as an
        HAsciiString (standard form). A Null Handle resets this name.
        Returns True if OK, False if this Name is already attached,
        for a Dispatch or for Default, or <num> out of range

        :type num: int
        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(IFSelect_ShareOut self, Standard_Integer const num) -> Standard_Boolean

        Returns True if the Dispatch of rank <num> has an attached
        Root Name. False else, or if num is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_HasRootName(self, *args)


    def RootName(self, *args):
        """
        RootName(IFSelect_ShareOut self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns the Root bound to a Dispatch, given its rank
        Returns a Null Handle if not defined

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ShareOut_RootName(self, *args)


    def RootNumber(self, *args):
        """
        RootNumber(IFSelect_ShareOut self, Handle_TCollection_HAsciiString name) -> Standard_Integer

        Returns an integer value about a given root name :
        - positive : it's the rank of the Dispatch which has this name
        - null : this root name is unknown
        - negative (-1) : this root name is the default root name

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ShareOut_RootNumber(self, *args)


    def SetPrefix(self, *args):
        """
        SetPrefix(IFSelect_ShareOut self, Handle_TCollection_HAsciiString pref)

        Defines or Changes the general Prefix (which is prepended to
        complete file name generated). If this method is not call,
        Prefix remains empty

        :type pref: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ShareOut_SetPrefix(self, *args)


    def SetDefaultRootName(self, *args):
        """
        SetDefaultRootName(IFSelect_ShareOut self, Handle_TCollection_HAsciiString defrt) -> Standard_Boolean

        Defines or Changes the Default Root Name to a new value (which
        is used for dispatches which have no attached root name).
        If this method is not called, DefaultRootName remains empty
        Returns True if OK, False if this Name is already attached,
        for a Dispatch or for Default

        :type defrt: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ShareOut_SetDefaultRootName(self, *args)


    def SetExtension(self, *args):
        """
        SetExtension(IFSelect_ShareOut self, Handle_TCollection_HAsciiString ext)

        Defines or Changes the general Extension (which is appended to
        complete file name generated). If this method is not call,
        Extension remains empty

        :type ext: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ShareOut_SetExtension(self, *args)


    def Prefix(self, *args):
        """
        Prefix(IFSelect_ShareOut self) -> Handle_TCollection_HAsciiString

        Returns the general Prefix. Can be empty.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ShareOut_Prefix(self, *args)


    def DefaultRootName(self, *args):
        """
        DefaultRootName(IFSelect_ShareOut self) -> Handle_TCollection_HAsciiString

        Returns the Default Root Name. Can be empty.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ShareOut_DefaultRootName(self, *args)


    def Extension(self, *args):
        """
        Extension(IFSelect_ShareOut self) -> Handle_TCollection_HAsciiString

        Returns the general Extension. Can be empty (not recommanded)

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_ShareOut_Extension(self, *args)


    def FileName(self, *args):
        """
        FileName(IFSelect_ShareOut self, Standard_Integer const dnum, Standard_Integer const pnum, Standard_Integer const nbpack=0) -> TCollection_AsciiString

        Computes the complete file name for a Packet of a Dispatch,
        given Dispatch Number (Rank), Packet Number, and Count of
        Packets generated by this Dispatch (0 if unknown)

        File Name is made of following strings, concatenated :
        General Prefix, Root Name for Dispatch, Packet Suffix, and
        General Extension. If no Root Name is specified for a
        Dispatch, DefaultRootName is considered (and pnum is not used,
        but <thenbdefs> is incremented and used
        Error if no Root is defined for this <idnum>

        :type dnum: int
        :type pnum: int
        :type nbpack: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ShareOut_FileName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_ShareOut_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_ShareOut_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_ShareOut_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_ShareOut
IFSelect_ShareOut_swigregister = _IFSelect.IFSelect_ShareOut_swigregister
IFSelect_ShareOut_swigregister(IFSelect_ShareOut)

def IFSelect_ShareOut_get_type_name(*args):
    """
    IFSelect_ShareOut_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_ShareOut_get_type_name(*args)

def IFSelect_ShareOut_get_type_descriptor(*args):
    """
    IFSelect_ShareOut_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_ShareOut_get_type_descriptor(*args)

class IFSelect_SignAncestor(IFSelect_SignType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignAncestor
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignAncestor(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignAncestor self, Standard_Boolean const nopk) -> IFSelect_SignAncestor

        :type nopk: bool

        """
        this = _IFSelect.new_IFSelect_SignAncestor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Matches(self, *args):
        """
        Matches(IFSelect_SignAncestor self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SignAncestor_Matches(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignAncestor_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignAncestor_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignAncestor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignAncestor
IFSelect_SignAncestor_swigregister = _IFSelect.IFSelect_SignAncestor_swigregister
IFSelect_SignAncestor_swigregister(IFSelect_SignAncestor)

def IFSelect_SignAncestor_get_type_name(*args):
    """
    IFSelect_SignAncestor_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignAncestor_get_type_name(*args)

def IFSelect_SignAncestor_get_type_descriptor(*args):
    """
    IFSelect_SignAncestor_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignAncestor_get_type_descriptor(*args)

class IFSelect_ModelCopier(Standard.Standard_Transient):
    """
    This class performs the Copy operations involved by the
    description of a ShareOut (evaluated by a ShareOutResult)
    plus, if there are, the Modifications on the results, with
    the help of Modifiers. Each Modifier can work on one or more
    resulting packets, accoding its criteria : it operates on a
    Model once copied and filled with the content of the packet.

    Modifiers can be :
    - Model Modifiers, inheriting from the specific class Modifier
    able to run on the content of a Model (header or entities),
    activated by the ModelCopier itself
    - File Modifiers, inheriting directly from GeneralModifier,
    intended to be activated under the control of a WorkLibrary,
    once the Model has been produced (i.e. to act on output
    format, or other specific file features)

    The Copy operations can be :
    - immediately put to files : for each packet, a Model is
    created and filled, then the file is output, at that's all
    - memorized : for each packet, a Model is created and filled,
    it is memorized with the corresponding file name.
    it is possible to query the result of memorization (list of
    produced Models and their file names)
    -> it is also possible to send it into the files :
    once files are written, the result is cleared

    In addition, a list of really written files is managed :
    A first call to BeginSentFiles clears the list and commands,
    either to begin a new list, or to stop recording it. A call
    to SentFiles returns the list (if recording has been required)
    This list allows to globally exploit the set of produced files

    Remark : For operations which concern specific Entities, see
    also in package IFAdapt : a sub-class of ModelCopier allows
    to work with EntityModifier, in addition to Modifier itself
    which still applies to a whole copied Model.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_ModelCopier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_ModelCopier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_ModelCopier self) -> IFSelect_ModelCopier

        Creates an empty ModelCopier


        """
        this = _IFSelect.new_IFSelect_ModelCopier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetShareOut(self, *args):
        """
        SetShareOut(IFSelect_ModelCopier self, Handle_IFSelect_ShareOut sho)

        Sets the ShareOut, which is used to define Modifiers to apply

        :type sho: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        return _IFSelect.IFSelect_ModelCopier_SetShareOut(self, *args)


    def ClearResult(self, *args):
        """
        ClearResult(IFSelect_ModelCopier self)

        Clears the list of produced Models


        """
        return _IFSelect.IFSelect_ModelCopier_ClearResult(self, *args)


    def AddFile(self, *args):
        """
        AddFile(IFSelect_ModelCopier self, TCollection_AsciiString filename, Handle_Interface_InterfaceModel content) -> Standard_Boolean

        Records a new File to be sent, as a couple
        (Name as AsciiString, Content as InterfaceModel)
        Returns True if Done, False if <filename> is already attached
        to another File

        :type filename: OCC.wrapper.TCollection.TCollection_AsciiString
        :type content: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ModelCopier_AddFile(self, *args)


    def NameFile(self, *args):
        """
        NameFile(IFSelect_ModelCopier self, Standard_Integer const num, TCollection_AsciiString filename) -> Standard_Boolean

        Changes the Name attached to a File which was formerly defined
        by a call to AddFile
        Returns True if Done, False else : if <num> out of range or if
        the new <filename> is already attached to another File
        Remark : Giving an empty File Name is equivalent to ClearFile

        :type num: int
        :type filename: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ModelCopier_NameFile(self, *args)


    def ClearFile(self, *args):
        """
        ClearFile(IFSelect_ModelCopier self, Standard_Integer const num) -> Standard_Boolean

        Clears the Name attached to a File which was formerly defined
        by a call to AddFile. This Clearing can be undone by a call to
        NameFile (with same <num>)
        Returns True if Done, False else : if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ModelCopier_ClearFile(self, *args)


    def SetAppliedModifiers(self, *args):
        """
        SetAppliedModifiers(IFSelect_ModelCopier self, Standard_Integer const num, Handle_IFSelect_AppliedModifiers applied) -> Standard_Boolean

        Sets a list of File Modifiers to be applied on a file

        :type num: int
        :type applied: OCC.wrapper.IFSelect.Handle_IFSelect_AppliedModifiers
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ModelCopier_SetAppliedModifiers(self, *args)


    def ClearAppliedModifiers(self, *args):
        """
        ClearAppliedModifiers(IFSelect_ModelCopier self, Standard_Integer const num) -> Standard_Boolean

        Clears the list of File Modifiers to be applied on a file

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ModelCopier_ClearAppliedModifiers(self, *args)


    def Copy(self, *args):
        """
        Copy(IFSelect_ModelCopier self, IFSelect_ShareOutResult eval, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Performs the Copy Operations, which include the Modifications
        defined by the list of Modifiers. Memorizes the result, as a
        list of InterfaceModels with the corresponding FileNames
        They can then be sent, by the method Send, or queried
        Copy calls internal method Copying.
        Returns the produced CheckList

        :type eval: OCC.wrapper.IFSelect.IFSelect_ShareOutResult
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_Copy(self, *args)


    def SendCopied(self, *args):
        """
        SendCopied(IFSelect_ModelCopier self, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Sends the formerly defined results (see method Copy) to files,
        then clears it
        Remark : A Null File Name cause file to be not produced

        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_SendCopied(self, *args)


    def Send(self, *args):
        """
        Send(IFSelect_ModelCopier self, IFSelect_ShareOutResult eval, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Performs the Copy Operations (which include the Modifications)
        and Sends the result on files, without memorizing it.
        (the memorized result is ignored : neither queried not filled)

        :type eval: OCC.wrapper.IFSelect.IFSelect_ShareOutResult
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_Send(self, *args)


    def SendAll(self, *args):
        """
        SendAll(IFSelect_ModelCopier self, Standard_CString const filename, Interface_Graph G, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Sends a model (defined in <G>) into one file, without managing
        remaining data, already sent files, etc. Applies the Model and
        File Modifiers.
        Returns True if well done, False else

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_SendAll(self, *args)


    def SendSelected(self, *args):
        """
        SendSelected(IFSelect_ModelCopier self, Standard_CString const filename, Interface_Graph G, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol, Interface_EntityIterator iter) -> Interface_CheckIterator

        Sends a part of a model into one file. Model is gotten from
        <G>, the part is defined in <iter>.
        Remaining data are managed and can be later be worked on.
        Returns True if well done, False else

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_SendSelected(self, *args)


    def CopiedRemaining(self, *args):
        """
        CopiedRemaining(IFSelect_ModelCopier self, Interface_Graph G, Handle_IFSelect_WorkLibrary WL, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        Produces a Model copied from the Remaining List as <newmod>
        <newmod> is a Null Handle if this list is empty
        <WL> performs the copy by using <TC>
        <TC> is assumed to have been defined with the starting model
        same as defined by <G>.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_ModelCopier_CopiedRemaining(self, *args)


    def SetRemaining(self, *args):
        """
        SetRemaining(IFSelect_ModelCopier self, Interface_Graph CG) -> Standard_Boolean

        Updates Graph status for remaining data, for each entity :
        - Entities just Sent to file or Copied (by CopiedRemaining)
        have their status set to 1
        - the other keep their former status (1 for Send/Copied,
        0 for Remaining)
        These status are computed by Copying/Sending/CopiedRemaining
        Then, SetRemaining updates graph status, and mustr be called
        just after one of these method has been called
        Returns True if done, False if remaining info if not in phase
        which the Graph (not same counts of items)

        :type CG: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ModelCopier_SetRemaining(self, *args)


    def NbFiles(self, *args):
        """
        NbFiles(IFSelect_ModelCopier self) -> Standard_Integer

        Returns the count of Files produced, i.e. the count of Models
        memorized (produced by the mmethod Copy) with their file names

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ModelCopier_NbFiles(self, *args)


    def FileName(self, *args):
        """
        FileName(IFSelect_ModelCopier self, Standard_Integer const num) -> TCollection_AsciiString

        Returns the File Name for a file given its rank
        It is empty after a call to ClearFile on same <num>

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ModelCopier_FileName(self, *args)


    def FileModel(self, *args):
        """
        FileModel(IFSelect_ModelCopier self, Standard_Integer const num) -> Handle_Interface_InterfaceModel

        Returns the content of a file before sending, under the form
        of an InterfaceModel, given its rank

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_ModelCopier_FileModel(self, *args)


    def AppliedModifiers(self, *args):
        """
        AppliedModifiers(IFSelect_ModelCopier self, Standard_Integer const num) -> Handle_IFSelect_AppliedModifiers

        Returns the list of File Modifiers to be applied on a file
        when it will be sent, as computed by CopiedModel :
        If it is a null handle, no File Modifier has to be applied.

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_AppliedModifiers

        """
        return _IFSelect.IFSelect_ModelCopier_AppliedModifiers(self, *args)


    def BeginSentFiles(self, *args):
        """
        BeginSentFiles(IFSelect_ModelCopier self, Handle_IFSelect_ShareOut sho, Standard_Boolean const record)

        Begins a sequence of recording the really sent files
        <sho> : the default file numbering is cleared
        If <record> is False, clears the list and stops recording
        If <record> is True, clears the list and commands recording
        Creation time corresponds to "stop recording"

        :type sho: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut
        :type record: bool

        """
        return _IFSelect.IFSelect_ModelCopier_BeginSentFiles(self, *args)


    def AddSentFile(self, *args):
        """
        AddSentFile(IFSelect_ModelCopier self, Standard_CString const filename)

        Adds the name of a just sent file, if BeginSentFiles
        has commanded recording; else does nothing
        It is called by methods SendCopied Sending

        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ModelCopier_AddSentFile(self, *args)


    def SentFiles(self, *args):
        """
        SentFiles(IFSelect_ModelCopier self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of recorded names of sent files. Can be empty
        (if no file has been sent). Returns a Null Handle if
        BeginSentFiles has stopped recording.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_ModelCopier_SentFiles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_ModelCopier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_ModelCopier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_ModelCopier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_ModelCopier
IFSelect_ModelCopier_swigregister = _IFSelect.IFSelect_ModelCopier_swigregister
IFSelect_ModelCopier_swigregister(IFSelect_ModelCopier)

def IFSelect_ModelCopier_get_type_name(*args):
    """
    IFSelect_ModelCopier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_ModelCopier_get_type_name(*args)

def IFSelect_ModelCopier_get_type_descriptor(*args):
    """
    IFSelect_ModelCopier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_ModelCopier_get_type_descriptor(*args)

class Handle_IFSelect_SelectUnion(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectUnion self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectUnion_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectUnion self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectUnion self, IFSelect_SelectUnion thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectUnion self, Handle_IFSelect_SelectUnion theHandle) -> Handle_IFSelect_SelectUnion
        assign(Handle_IFSelect_SelectUnion self, IFSelect_SelectUnion thePtr) -> Handle_IFSelect_SelectUnion
        assign(Handle_IFSelect_SelectUnion self, Handle_IFSelect_SelectUnion theHandle) -> Handle_IFSelect_SelectUnion

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectUnion self) -> IFSelect_SelectUnion

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectUnion self) -> IFSelect_SelectUnion

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectUnion___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectUnion self) -> IFSelect_SelectUnion

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectUnion___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectUnion___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectUnion___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectUnion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectUnion_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectUnion

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectUnion self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected Entities, which is the addition
        result from all input selections. Uniqueness is guaranteed.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectUnion self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Union (OR)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectUnion self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectUnion_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectUnion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbInputs(self, *args):
        """
        NbInputs(Handle_IFSelect_SelectUnion self) -> Standard_Integer

        Returns the count of Input Selections

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_NbInputs(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectUnion self, Standard_Integer const num) -> Handle_IFSelect_Selection

        Returns an Input Selection, given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_Input(self, *args)


    def InputRank(self, *args):
        """
        InputRank(Handle_IFSelect_SelectUnion self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the rank of an input Selection, 0 if not in the list.
        Most generally, its value is meaningless, except for testing
        the presence of an input Selection :
        - == 0  if <sel> is not an input for <me>
        - >  0  if <sel> is an input for <me>

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_InputRank(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SelectUnion self, Handle_IFSelect_Selection sel, Standard_Integer const atnum=0)

        Adds a Selection to the filling list
        By default, adds it to the end of the list
        A Positive rank less then NbInputs gives an insertion rank
        (InsertBefore : the new <atnum>th item of the list is <sel>)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_SelectUnion self, Handle_IFSelect_Selection sel) -> Standard_Boolean
        Remove(Handle_IFSelect_SelectUnion self, Standard_Integer const num) -> Standard_Boolean

        Removes an input Selection, given its rank in the list
        Returns True if Done, False if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_Remove(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectUnion self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectUnion self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectUnion self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectUnion self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectUnion_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectUnion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectUnion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectUnion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectUnion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectUnion self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectUnion self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectUnion self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectUnion_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectUnion self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectUnion_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectUnion_swigregister = _IFSelect.Handle_IFSelect_SelectUnion_swigregister
Handle_IFSelect_SelectUnion_swigregister(Handle_IFSelect_SelectUnion)

def Handle_IFSelect_SelectUnion_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectUnion_DownCast(thing)
Handle_IFSelect_SelectUnion_DownCast = _IFSelect.Handle_IFSelect_SelectUnion_DownCast

class IFSelect_(object):
    """
    Gives tools to manage Selecting a group of Entities
    processed by an Interface, for instance to divide up an
    original Model (from a File) to several smaller ones
    They use description of an Interface Model as a graph

    Remark that this corresponds to the description of a
    "scenario" of sharing out a File. Parts of this Scenario
    are intended to be permanently stored. IFSelect provides
    the Transient, active counterparts (to run the Scenario).
    But a permanent one (either as Persistent Objects or as
    interpretable Text) must be provided elsewhere.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SaveSession(*args):
        """
        SaveSession(Handle_IFSelect_WorkSession WS, Standard_CString const file) -> Standard_Boolean

        Saves the state of a WorkSession from IFSelect, by using a
        SessionFile from IFSelect. Returns True if Done, False in
        case of Error on Writing. <file> gives the name of the File
        to be produced (this avoids to export the class SessionFile).

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect__SaveSession(*args)

    SaveSession = staticmethod(SaveSession)

    def RestoreSession(*args):
        """
        RestoreSession(Handle_IFSelect_WorkSession WS, Standard_CString const file) -> Standard_Boolean

        Restore the state of a WorkSession from IFSelect, by using a
        SessionFile from IFSelect. Returns True if Done, False in
        case of Error on Writing. <file> gives the name of the File
        to be used (this avoids to export the class SessionFile).

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect__RestoreSession(*args)

    RestoreSession = staticmethod(RestoreSession)

    def __init__(self):
        """
        Gives tools to manage Selecting a group of Entities
        processed by an Interface, for instance to divide up an
        original Model (from a File) to several smaller ones
        They use description of an Interface Model as a graph

        Remark that this corresponds to the description of a
        "scenario" of sharing out a File. Parts of this Scenario
        are intended to be permanently stored. IFSelect provides
        the Transient, active counterparts (to run the Scenario).
        But a permanent one (either as Persistent Objects or as
        interpretable Text) must be provided elsewhere.
        """
        this = _IFSelect.new_IFSelect_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_IFSelect_
IFSelect__swigregister = _IFSelect.IFSelect__swigregister
IFSelect__swigregister(IFSelect_)

def IFSelect__SaveSession(*args):
    """
    IFSelect__SaveSession(Handle_IFSelect_WorkSession WS, Standard_CString const file) -> Standard_Boolean

    Saves the state of a WorkSession from IFSelect, by using a
    SessionFile from IFSelect. Returns True if Done, False in
    case of Error on Writing. <file> gives the name of the File
    to be produced (this avoids to export the class SessionFile).

    :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
    :type file: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IFSelect.IFSelect__SaveSession(*args)

def IFSelect__RestoreSession(*args):
    """
    IFSelect__RestoreSession(Handle_IFSelect_WorkSession WS, Standard_CString const file) -> Standard_Boolean

    Restore the state of a WorkSession from IFSelect, by using a
    SessionFile from IFSelect. Returns True if Done, False in
    case of Error on Writing. <file> gives the name of the File
    to be used (this avoids to export the class SessionFile).

    :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
    :type file: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IFSelect.IFSelect__RestoreSession(*args)

class Handle_IFSelect_SignType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignType self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignType self, IFSelect_SignType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignType self, Handle_IFSelect_SignType theHandle) -> Handle_IFSelect_SignType
        assign(Handle_IFSelect_SignType self, IFSelect_SignType thePtr) -> Handle_IFSelect_SignType
        assign(Handle_IFSelect_SignType self, Handle_IFSelect_SignType theHandle) -> Handle_IFSelect_SignType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignType self) -> IFSelect_SignType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignType self) -> IFSelect_SignType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignType self) -> IFSelect_SignType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignType___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignType_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignType

    def Value(self, *args):
        """
        Value(Handle_IFSelect_SignType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its Dynamic
        Type, with or without package name, according starting option

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignType_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignType self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_IFSelect_SignType self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.Handle_IFSelect_SignType_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_IFSelect_SignType self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignType_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_IFSelect_SignType self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignType_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_IFSelect_SignType self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignType_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignType self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignType_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SignType self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignType_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_IFSelect_SignType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignType_Matches(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_IFSelect_SignType self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignType_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_SignType self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignType_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_IFSelect_SignType self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignType_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_IFSelect_SignType self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignType_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_IFSelect_SignType self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignType_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignType self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignType self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignType_DecrementRefCounter(self, *args)

Handle_IFSelect_SignType_swigregister = _IFSelect.Handle_IFSelect_SignType_swigregister
Handle_IFSelect_SignType_swigregister(Handle_IFSelect_SignType)

def Handle_IFSelect_SignType_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignType_DownCast(thing)
Handle_IFSelect_SignType_DownCast = _IFSelect.Handle_IFSelect_SignType_DownCast

class Handle_IFSelect_SignCounter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignCounter self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignCounter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignCounter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignCounter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignCounter self, IFSelect_SignCounter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignCounter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignCounter self, Handle_IFSelect_SignCounter theHandle) -> Handle_IFSelect_SignCounter
        assign(Handle_IFSelect_SignCounter self, IFSelect_SignCounter thePtr) -> Handle_IFSelect_SignCounter
        assign(Handle_IFSelect_SignCounter self, Handle_IFSelect_SignCounter theHandle) -> Handle_IFSelect_SignCounter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignCounter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignCounter self) -> IFSelect_SignCounter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignCounter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignCounter self) -> IFSelect_SignCounter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignCounter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignCounter self) -> IFSelect_SignCounter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignCounter___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignCounter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignCounter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignCounter_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignCounter

    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_SignCounter self) -> Handle_IFSelect_Signature

        Returns the Signature used to count entities. It can be null.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Signature(self, *args)


    def SetMap(self, *args):
        """
        SetMap(Handle_IFSelect_SignCounter self, Standard_Boolean const withmap)

        Changes the control status. The map is not cleared, simply
        its use changes

        :type withmap: bool

        """
        return _IFSelect.Handle_IFSelect_SignCounter_SetMap(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Handle_IFSelect_SignCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Adds an entity by considering its signature, which is given by
        call to method AddSign
        Returns True if added, False if already in the map (and
        map control status set)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCounter_AddEntity(self, *args)


    def AddSign(self, *args):
        """
        AddSign(Handle_IFSelect_SignCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model)

        Adds an entity (already filtered by Map) with its signature.
        This signature can be computed with the containing model.
        Its value is provided by the object Signature given at start,
        if no Signature is defined, it does nothing.

        Can be redefined (in this case, see also Sign)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_SignCounter_AddSign(self, *args)


    def AddList(self, *args):
        """
        AddList(Handle_IFSelect_SignCounter self, Handle_TColStd_HSequenceOfTransient list, Handle_Interface_InterfaceModel model)

        Adds a list of entities by adding each of the items

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_SignCounter_AddList(self, *args)


    def AddWithGraph(self, *args):
        """
        AddWithGraph(Handle_IFSelect_SignCounter self, Handle_TColStd_HSequenceOfTransient list, Interface_Graph graph)

        Adds a list of entities in the context given by the graph
        Default just call basic AddList
        Can be redefined to get a signature computed with the graph

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type graph: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.Handle_IFSelect_SignCounter_AddWithGraph(self, *args)


    def AddModel(self, *args):
        """
        AddModel(Handle_IFSelect_SignCounter self, Handle_Interface_InterfaceModel model)

        Adds all the entities contained in a Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_SignCounter_AddModel(self, *args)


    def AddFromSelection(self, *args):
        """
        AddFromSelection(Handle_IFSelect_SignCounter self, Handle_IFSelect_Selection sel, Interface_Graph G)

        Adds the result determined by a Selection from a Graph
        Remark : does not impact at all data from SetSelection & Co

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type G: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFSelect.Handle_IFSelect_SignCounter_AddFromSelection(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_SignCounter self, Handle_IFSelect_Selection sel)

        Sets a Selection as input : this causes content to be cleared
        then the Selection to be ready to compute (but not immediatly)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SignCounter_SetSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_SignCounter self) -> Handle_IFSelect_Selection

        Returns the selection, or a null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Selection(self, *args)


    def SetSelMode(self, *args):
        """
        SetSelMode(Handle_IFSelect_SignCounter self, Standard_Integer const selmode)

        Changes the mode of working with the selection :
        -1 just clears optimisation data and nothing else
        0 clears it   1 inhibits it for computing (but no clearing)
        2 sets it active for computing
        Default at creation is 0, after SetSelection (not null) is 2

        :type selmode: int

        """
        return _IFSelect.Handle_IFSelect_SignCounter_SetSelMode(self, *args)


    def SelMode(self, *args):
        """
        SelMode(Handle_IFSelect_SignCounter self) -> Standard_Integer

        Returns the mode of working with the selection

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCounter_SelMode(self, *args)


    def ComputeSelected(self, *args):
        """
        ComputeSelected(Handle_IFSelect_SignCounter self, Interface_Graph G, Standard_Boolean const forced) -> Standard_Boolean

        Computes from the selection result, if selection is active
        (mode 2). If selection is not defined (mode 0) or is inhibited
        (mode 1) does nothing.
        Returns True if computation is done (or optimised), False else
        This method is called by ComputeCounter from WorkSession

        If <forced> is True, recomputes systematically
        Else (D), if the counter was not cleared and if the former
        computed result started from the same total size of Graph and
        same count of selected entities : computation is not redone
        unless <forced> is given as True

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type forced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCounter_ComputeSelected(self, *args)


    def Sign(self, *args):
        """
        Sign(Handle_IFSelect_SignCounter self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Handle_TCollection_HAsciiString

        Determines and returns the value of the signature for an
        entity as an HAsciiString. This method works exactly as
        AddSign, which is optimized

        Can be redefined, accorded with AddSign

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Sign(self, *args)


    def ComputedSign(self, *args):
        """
        ComputedSign(Handle_IFSelect_SignCounter self, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_CString

        Applies AddWithGraph on one entity, and returns the Signature
        Value which has been recorded
        To do this, Add is called with SignOnly Mode True during the
        call, the returned value is LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_ComputedSign(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignCounter self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignCounter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignCounter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignCounter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetList(self, *args):
        """
        SetList(Handle_IFSelect_SignCounter self, Standard_Boolean const withlist)

        Changes the record-list status. The list is not cleared but
        its use changes

        :type withlist: bool

        """
        return _IFSelect.Handle_IFSelect_SignCounter_SetList(self, *args)


    def ModeSignOnly(self, *args):
        """
        ModeSignOnly(Handle_IFSelect_SignCounter self) -> Standard_Boolean &

        Returns modifiable the SignOnly Mode
        If False (D), the counter normally counts
        If True, the counting work is turned off, Add only fills the
        LastValue, which can be used as signature, when a counter
        works from data which are not available from a Signature

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCounter_ModeSignOnly(self, *args)


    def Clear(self, *args):
        """Clear(Handle_IFSelect_SignCounter self)"""
        return _IFSelect.Handle_IFSelect_SignCounter_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SignCounter self, Handle_Standard_Transient ent, Standard_CString const sign)

        Adds an entity with its signature, i.e. :
        - counts an item more for <sign>
        - if record-list status is set, records the entity
        Accepts a null entity (the signature is then for the global
        model). But if the string is empty, counts a Null item.

        If SignOnly Mode is set, this work is replaced by just
        setting LastValue

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sign: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Add(self, *args)


    def LastValue(self, *args):
        """
        LastValue(Handle_IFSelect_SignCounter self) -> Standard_CString

        Returns the last value recorded by Add (only if SignMode set)
        Cleared by Clear or Init

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_LastValue(self, *args)


    def Init(self, *args):
        """
        Init(Handle_IFSelect_SignCounter self, Standard_CString const name, NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer > const & count, NCollection_IndexedDataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const & list, Standard_Integer const nbnuls)

        Aknowledges the list in once. Name identifies the Signature

        :type name: OCC.wrapper.Standard.Standard_CString
        :type count: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer
        :type list: OCC.wrapper.IFSelect.NCollection_IndexedDataMap_TCollection_AsciiString_Handle_Standard_Transient
        :type nbnuls: int

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Init(self, *args)


    def List(self, *args):
        """
        List(Handle_IFSelect_SignCounter self, Standard_CString const root) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of signatures, as a sequence of strings
        (but without their respective counts). It is ordered.
        By default, for all the signatures.
        If <root> is given non empty, for the signatures which
        begin by <root>

        :type root: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_List(self, *args)


    def HasEntities(self, *args):
        """
        HasEntities(Handle_IFSelect_SignCounter self) -> Standard_Boolean

        Returns True if the list of Entities is aknowledged, else
        the method Entities will always return a Null Handle

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCounter_HasEntities(self, *args)


    def NbNulls(self, *args):
        """
        NbNulls(Handle_IFSelect_SignCounter self) -> Standard_Integer

        Returns the count of null entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCounter_NbNulls(self, *args)


    def NbTimes(self, *args):
        """
        NbTimes(Handle_IFSelect_SignCounter self, Standard_CString const sign) -> Standard_Integer

        Returns the number of times a signature was counted,
        0 if it has not been recorded at all

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCounter_NbTimes(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_IFSelect_SignCounter self, Standard_CString const sign) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities attached to a signature
        It is empty if <sign> has not been recorded
        It is a Null Handle if the list of entities is not known

        :type sign: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Entities(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_IFSelect_SignCounter self, Standard_CString const name)

        Defines a name for a SignatureList (used to print it)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignCounter self) -> Standard_CString

        Returns the recorded Name.
        Remark : default is "..." (no SetName called)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCounter_Name(self, *args)


    def PrintCount(self, *args):
        """
        PrintCount(Handle_IFSelect_SignCounter self, Handle_Message_Messenger S)

        Prints the counts of items (not the list)

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_SignCounter_PrintCount(self, *args)


    def PrintList(self, *args):
        """
        PrintList(Handle_IFSelect_SignCounter self, Handle_Message_Messenger S, Handle_Interface_InterfaceModel model, IFSelect_PrintCount const mod=IFSelect_ListByItem)

        Prints the lists of items, if they are present (else, prints
        a message "no list available")
        Uses <model> to determine for each entity to be listed, its
        number, and its specific identifier (by PrintLabel)
        <mod> gives a mode for printing :
        - CountByItem : just count (as PrintCount)
        - ShortByItem : minimum i.e. count plus 5 first entity numbers
        - ShortByItem(D) complete list of entity numbers (0: "Global")
        - EntitiesByItem : list of (entity number/PrintLabel from the model)
        other modes are ignored

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type mod: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.Handle_IFSelect_SignCounter_PrintList(self, *args)


    def PrintSum(self, *args):
        """
        PrintSum(Handle_IFSelect_SignCounter self, Handle_Message_Messenger S)

        Prints a summary
        Item which has the greatest count of entities
        For items which are numeric values : their count, maximum,
        minimum values, cumul, average

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_SignCounter_PrintSum(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignCounter self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignCounter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignCounter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignCounter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCounter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignCounter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignCounter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCounter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignCounter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignCounter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignCounter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCounter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignCounter self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignCounter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignCounter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCounter_DecrementRefCounter(self, *args)

Handle_IFSelect_SignCounter_swigregister = _IFSelect.Handle_IFSelect_SignCounter_swigregister
Handle_IFSelect_SignCounter_swigregister(Handle_IFSelect_SignCounter)

def Handle_IFSelect_SignCounter_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignCounter_DownCast(thing)
Handle_IFSelect_SignCounter_DownCast = _IFSelect.Handle_IFSelect_SignCounter_DownCast

class IFSelect_SessionFile(object):
    """
    A SessionFile is intended to manage access between a
    WorkSession and an Ascii Form, to be considered as a Dump.
    It allows to write the File from the WorkSession, and later
    read the File to the WorkSession, by keeping required
    descriptions (such as dependances).

    The produced File is under an Ascii Form, then it may be
    easily consulted.
    It is possible to cumulate reading of several Files. But in
    case of Names conflict, the newer Names are forgottens.

    The Dump supports the description of XSTEP functionnalities
    (Sharing an Interface File, with Selections, Dispatches,
    Modifiers ...) but does not refer to the Interface File
    which is currently loaded.

    SessionFile works with a library of SessionDumper type objects

    The File is Produced as follows :
    SessionFile produces all general Informations (such as Int and
    Text Parameters, Types and Inputs of Selections, Dispatches,
    Modifiers ...) and calls the SessionDumpers to produce all
    the particular Data : creation arguments, parameters to be set
    It is Read in the same terms :
    SessionFile reads and interprets all general Informations,
    and calls the SessionDumpers to recognize Types and for a
    recognized Type create the corresponding Object with its
    particular parameters as they were written.
    The best way to work is to have one SessionDumper for each
    consistent set of classes (e.g. a package).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFSelect_SessionFile self, Handle_IFSelect_WorkSession WS) -> IFSelect_SessionFile
        __init__(IFSelect_SessionFile self, Handle_IFSelect_WorkSession WS, Standard_CString const filename) -> IFSelect_SessionFile

        Creates a SessionFile which Writes the content of a WorkSession
        to a File (directly calls Write)
        Then, IsDone aknowledges on the result of the Operation.
        But such a SessionFile may not Read a File to a WorkSession.

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_SessionFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ClearLines(self, *args):
        """
        ClearLines(IFSelect_SessionFile self)

        Clears the lines recorded whatever for writing or for reading


        """
        return _IFSelect.IFSelect_SessionFile_ClearLines(self, *args)


    def NbLines(self, *args):
        """
        NbLines(IFSelect_SessionFile self) -> Standard_Integer

        Returns the count of recorded lines

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns a line given its rank in the list of recorded lines

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SessionFile_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddLine(self, *args):
        """
        AddLine(IFSelect_SessionFile self, Standard_CString const line)

        Adds a line to the list of recorded lines

        :type line: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SessionFile_AddLine(self, *args)


    def RemoveLastLine(self, *args):
        """
        RemoveLastLine(IFSelect_SessionFile self)

        Removes the last line. Can be called recursively.
        Does nothing if the list is empty


        """
        return _IFSelect.IFSelect_SessionFile_RemoveLastLine(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(IFSelect_SessionFile self, Standard_CString const name) -> Standard_Boolean

        Writes the recorded lines to a file named <name> then clears
        the list of lines.
        Returns False (with no clearing) if the file could not be
        created

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_WriteFile(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(IFSelect_SessionFile self, Standard_CString const name) -> Standard_Boolean

        Reads the recorded lines from a file named <name>, after
        having cleared the list (stops if RecognizeFile fails)
        Returns False (with no clearing) if the file could not be read

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_ReadFile(self, *args)


    def RecognizeFile(self, *args):
        """
        RecognizeFile(IFSelect_SessionFile self, Standard_CString const headerline) -> Standard_Boolean

        Recognizes the header line. returns True if OK, False else

        :type headerline: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_RecognizeFile(self, *args)


    def Write(self, *args):
        """
        Write(IFSelect_SessionFile self, Standard_CString const filename) -> Standard_Integer

        Performs a Write Operation from a WorkSession to a File
        i.e. calls WriteSession then WriteEnd, and WriteFile
        Returned Value is : 0 for OK, -1 File could not be created,
        >0 Error during Write (see WriteSession)
        IsDone can be called too (will return True for OK)

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_Write(self, *args)


    def Read(self, *args):
        """
        Read(IFSelect_SessionFile self, Standard_CString const filename) -> Standard_Integer

        Performs a Read Operation from a file to a WorkSession
        i.e. calls ReadFile, then ReadSession and ReadEnd
        Returned Value is : 0 for OK, -1 File could not be opened,
        >0 Error during Read  (see WriteSession)
        IsDone can be called too (will return True for OK)

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_Read(self, *args)


    def WriteSession(self, *args):
        """
        WriteSession(IFSelect_SessionFile self) -> Standard_Integer

        Prepares the Write operation from a WorkSession (IFSelect) to
        a File, i.e. fills the list of lines (the file itself remains
        to be written; or NbLines/Line may be called)
        Important Remark : this excludes the reading of the last line,
        which is performed by WriteEnd
        Returns 0 if OK, status > 0 in case of error

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_WriteSession(self, *args)


    def WriteEnd(self, *args):
        """
        WriteEnd(IFSelect_SessionFile self) -> Standard_Integer

        Writes the trailing line. It is separate from WriteSession,
        in order to allow to redefine WriteSession without touching
        WriteEnd (WriteSession defines the body of the file)
        WriteEnd fills the list of lines. Returns a status of error,
        0 if OK, >0 else

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_WriteEnd(self, *args)


    def WriteLine(self, *args):
        """
        WriteLine(IFSelect_SessionFile self, Standard_CString const line, Standard_Character const follow=0)

        Writes a line to the File. If <follow> is given, it is added
        at the following of the line. '
        ' must be added for the end.

        :type line: OCC.wrapper.Standard.Standard_CString
        :type follow: OCC.wrapper.Standard.Standard_Character

        """
        return _IFSelect.IFSelect_SessionFile_WriteLine(self, *args)


    def WriteOwn(self, *args):
        """
        WriteOwn(IFSelect_SessionFile self, Handle_Standard_Transient item) -> Standard_Boolean

        Writes the Parameters own to each type of Item. Uses the
        Library of SessionDumpers
        Returns True if Done, False if <item> could not be treated
        (hence it remains written with no Own Parameter)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_WriteOwn(self, *args)


    def ReadSession(self, *args):
        """
        ReadSession(IFSelect_SessionFile self) -> Standard_Integer

        Performs a Read Operation from a File to a WorkSession, i.e.
        reads the list of line (which must have already been loaded,
        by ReadFile or by calls to AddLine)
        Important Remark : this excludes the reading of the last line,
        which is performed by ReadEnd
        Returns 0 for OK, >0 status for Read Error (not a suitable
        File, or WorkSession given as Immutable at Creation Time)
        IsDone can be called too (will return True for OK)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_ReadSession(self, *args)


    def ReadEnd(self, *args):
        """
        ReadEnd(IFSelect_SessionFile self) -> Standard_Integer

        Reads the end of a file (its last line). Returns 0 if OK,
        status >0 in case of error (not a suitable end line).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_ReadEnd(self, *args)


    def ReadLine(self, *args):
        """
        ReadLine(IFSelect_SessionFile self) -> Standard_Boolean

        Reads a Line and splits it into a set of alphanumeric items,
        which can then be queried by NbParams/ParamValue ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_ReadLine(self, *args)


    def SplitLine(self, *args):
        """
        SplitLine(IFSelect_SessionFile self, Standard_CString const line)

        Internal routine which processes a line into words
        and prepares its exploration

        :type line: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SessionFile_SplitLine(self, *args)


    def ReadOwn(self, *args):
        """
        ReadOwn(IFSelect_SessionFile self, Handle_Standard_Transient item) -> Standard_Boolean

        Tries to Read an Item, by calling the Library of Dumpers
        Sets the list of parameters of the line to be read from the
        first own one

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_ReadOwn(self, *args)


    def AddItem(self, *args):
        """
        AddItem(IFSelect_SessionFile self, Handle_Standard_Transient item, Standard_Boolean const active)

        Adds an Item to the WorkSession, taken as Name the first
        item of the read Line. If this Name is not a Name but a Number
        or if this Name is already recorded in the WorkSession, it
        adds the Item but with no Name. Then the Name is recorded
        in order to be used by the method ItemValue
        <active> commands to make <item> active or not in the session

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool

        """
        return _IFSelect.IFSelect_SessionFile_AddItem(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IFSelect_SessionFile self) -> Standard_Boolean

        Returns True if the last Read or Write operation has been
        corectly performed. ELse returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_IsDone(self, *args)


    def WorkSession(self, *args):
        """
        WorkSession(IFSelect_SessionFile self) -> Handle_IFSelect_WorkSession

        Returns the WorkSession on which a SessionFile works.
        Remark that it is returned as Immutable.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession

        """
        return _IFSelect.IFSelect_SessionFile_WorkSession(self, *args)


    def NewItem(self, *args):
        """
        NewItem(IFSelect_SessionFile self, Standard_Integer const ident, Handle_Standard_Transient par)

        At beginning of writing an Item, writes its basics :
        - either its name in the session if it has one
        - or its relative number of item in the file, else
        (preceeded by a '_')
        - then, its Dynamic Type (in the sense of cdl : pk_class)
        This basic description can be followed by the parameters
        which are used in the definition of the item.

        :type ident: int
        :type par: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SessionFile_NewItem(self, *args)


    def SetOwn(self, *args):
        """
        SetOwn(IFSelect_SessionFile self, Standard_Boolean const mode)

        Sets Parameters to be sent as Own if <mode> is True (their
        Name or Number or Void Mark or Text Value is preceeded by a
        Column sign ':') else they are sent normally
        Hence, the Own Parameter are clearly identified in the File

        :type mode: bool

        """
        return _IFSelect.IFSelect_SessionFile_SetOwn(self, *args)


    def SendVoid(self, *args):
        """
        SendVoid(IFSelect_SessionFile self)

        During a Write action, commands to send a Void Parameter
        i.e. a Parameter which is present but undefined
        Its form will be the dollar sign : $


        """
        return _IFSelect.IFSelect_SessionFile_SendVoid(self, *args)


    def SendItem(self, *args):
        """
        SendItem(IFSelect_SessionFile self, Handle_Standard_Transient par)

        During a Write action, commands to send the identification of
        a Parameter : if it is Null (undefined) it is send as Void ($)
        if it is Named in the WorkSession, its Name is sent preceeded
        by ':', else a relative Ident Number is sent preceeded by '#'
        (relative to the present Write, i.e. starting at one, without
        skip, and counted part from Named Items)

        :type par: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SessionFile_SendItem(self, *args)


    def SendText(self, *args):
        """
        SendText(IFSelect_SessionFile self, Standard_CString const text)

        During a Write action, commands to send a Text without
        interpretation. It will be sent as well

        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SessionFile_SendText(self, *args)


    def SetLastGeneral(self, *args):
        """
        SetLastGeneral(IFSelect_SessionFile self, Standard_Integer const lastgen)

        Sets the rank of Last General Parameter to a new value. It is
        followed by the Fist Own Parameter of the item.
        Used by SessionFile after reading general parameters.

        :type lastgen: int

        """
        return _IFSelect.IFSelect_SessionFile_SetLastGeneral(self, *args)


    def NbParams(self, *args):
        """
        NbParams(IFSelect_SessionFile self) -> Standard_Integer

        During a Read operation, SessionFile processes sequencially
        the Items to read. For each one, it gives access to the list
        of its Parameters : they were defined by calls to
        SendVoid/SendParam/SendText during Writing the File.
        NbParams returns the count of Parameters for the line
        currently read.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SessionFile_NbParams(self, *args)


    def IsVoid(self, *args):
        """
        IsVoid(IFSelect_SessionFile self, Standard_Integer const num) -> Standard_Boolean

        Returns True if a Parameter, given its rank in the Own List
        (see NbOwnParams), is Void. Returns also True if <num> is
        out of range (undefined parameters)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_IsVoid(self, *args)


    def IsText(self, *args):
        """
        IsText(IFSelect_SessionFile self, Standard_Integer const num) -> Standard_Boolean

        Returns True if a Parameter, in the Own List (see NbOwnParams)
        is a Text (between "..."). Else it is an Item (Parameter,
        Selection, Dispatch ...), which can be Void.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SessionFile_IsText(self, *args)


    def ParamValue(self, *args):
        """
        Returns a Parameter (alphanumeric item of a line) as it
        has been read

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SessionFile_ParamValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextValue(self, *args):
        """
        TextValue(IFSelect_SessionFile self, Standard_Integer const num) -> TCollection_AsciiString

        Returns the content of a Text Parameter (without the quotes).
        Returns an empty string if the Parameter is not a Text.

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionFile_TextValue(self, *args)


    def ItemValue(self, *args):
        """
        ItemValue(IFSelect_SessionFile self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns a Parameter as an Item. Returns a Null Handle if the
        Parameter is a Text, or if it is defined as Void

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_SessionFile_ItemValue(self, *args)


    def Destroy(self, *args):
        """
        Destroy(IFSelect_SessionFile self)

        Specific Destructor (closes the File if not yet done)


        """
        return _IFSelect.IFSelect_SessionFile_Destroy(self, *args)

    __swig_destroy__ = _IFSelect.delete_IFSelect_SessionFile
IFSelect_SessionFile_swigregister = _IFSelect.IFSelect_SessionFile_swigregister
IFSelect_SessionFile_swigregister(IFSelect_SessionFile)

class IFSelect_SignMultiple(IFSelect_Signature):
    """
    Multiple Signature : ordered list of other Signatures
    It concatenates on a same line the result of its sub-items
    separated by sets of 3 blanks
    It is possible to define tabulations between sub-items
    Moreover, match rules are specific
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SignMultiple
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SignMultiple(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SignMultiple self, Standard_CString const name) -> IFSelect_SignMultiple

        Creates an empty SignMultiple with a Name
        This name should take expected tabulations into account

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_SignMultiple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(IFSelect_SignMultiple self, Handle_IFSelect_Signature subsign, Standard_Integer const width=0, Standard_Boolean const maxi)

        Adds a Signature. Width, if given, gives the tabulation
        If <maxi> is True, it is a forced tabulation (overlength is
        replaced by a final dot)
        If <maxi> is False, just 3 blanks follow an overlength

        :type subsign: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type width: int
        :type maxi: bool

        """
        return _IFSelect.IFSelect_SignMultiple_Add(self, *args)


    def Value(self, *args):
        """
        Value(IFSelect_SignMultiple self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Concatenates the values of sub-signatures, with their
        tabulations

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SignMultiple_Value(self, *args)


    def Matches(self, *args):
        """
        Matches(IFSelect_SignMultiple self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Specialized Match Rule
        If <exact> is False, simply checks if at least one sub-item
        matches
        If <exact> is True, standard match with Value
        (i.e. tabulations must be respected)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SignMultiple_Matches(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SignMultiple_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SignMultiple_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SignMultiple_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SignMultiple
IFSelect_SignMultiple_swigregister = _IFSelect.IFSelect_SignMultiple_swigregister
IFSelect_SignMultiple_swigregister(IFSelect_SignMultiple)

def IFSelect_SignMultiple_get_type_name(*args):
    """
    IFSelect_SignMultiple_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SignMultiple_get_type_name(*args)

def IFSelect_SignMultiple_get_type_descriptor(*args):
    """
    IFSelect_SignMultiple_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SignMultiple_get_type_descriptor(*args)

class Handle_IFSelect_SelectSent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectSent self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectSent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectSent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectSent self, IFSelect_SelectSent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectSent self, Handle_IFSelect_SelectSent theHandle) -> Handle_IFSelect_SelectSent
        assign(Handle_IFSelect_SelectSent self, IFSelect_SelectSent thePtr) -> Handle_IFSelect_SelectSent
        assign(Handle_IFSelect_SelectSent self, Handle_IFSelect_SelectSent theHandle) -> Handle_IFSelect_SelectSent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectSent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectSent self) -> IFSelect_SelectSent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectSent self) -> IFSelect_SelectSent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectSent self) -> IFSelect_SelectSent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectSent___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectSent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectSent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectSent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectSent_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectSent

    def SentCount(self, *args):
        """
        SentCount(Handle_IFSelect_SelectSent self) -> Standard_Integer

        Returns the queried count of sending

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSent_SentCount(self, *args)


    def AtLeast(self, *args):
        """
        AtLeast(Handle_IFSelect_SelectSent self) -> Standard_Boolean

        Returns the <atleast> status, True for sending at least the
        sending count, False for sending exactly the sending count
        Remark : if SentCount is 0, AtLeast is ignored

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_AtLeast(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectSent self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. It is redefined to
        work on the graph itself (not queried by sort)

        An entity is selected if its count complies to the query in
        Direct Mode, rejected in Reversed Mode

        Query works on the sending count recorded as status in Graph

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSent_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectSent self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always False because RootResult has done the work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectSent self) -> TCollection_AsciiString

        Returns a text defining the criterium : query :
        SentCount = 0 -> "Remaining (non-sent) entities"
        SentCount = 1, AtLeast = True  -> "Sent entities"
        SentCount = 1, AtLeast = False -> "Sent once (no duplicated)"
        SentCount = 2, AtLeast = True  -> "Sent several times entities"
        SentCount = 2, AtLeast = False -> "Sent twice entities"
        SentCount > 2, AtLeast = True  -> "Sent at least <count> times entities"
        SentCount > 2, AtLeast = False -> "Sent <count> times entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSent_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectSent self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectSent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectSent self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectSent self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSent_SetDirect(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectSent self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectSent self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSent_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectSent self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSent_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectSent self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSent_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectSent self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectSent self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectSent self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectSent_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectSent self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSent_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectSent self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSent_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectSent self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSent_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectSent self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSent_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectSent self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectSent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectSent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectSent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectSent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectSent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectSent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectSent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectSent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectSent self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectSent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectSent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSent_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectSent_swigregister = _IFSelect.Handle_IFSelect_SelectSent_swigregister
Handle_IFSelect_SelectSent_swigregister(Handle_IFSelect_SelectSent)

def Handle_IFSelect_SelectSent_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectSent_DownCast(thing)
Handle_IFSelect_SelectSent_DownCast = _IFSelect.Handle_IFSelect_SelectSent_DownCast

class Handle_IFSelect_SelectIntersection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectIntersection self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectIntersection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectIntersection self, IFSelect_SelectIntersection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectIntersection self, Handle_IFSelect_SelectIntersection theHandle) -> Handle_IFSelect_SelectIntersection
        assign(Handle_IFSelect_SelectIntersection self, IFSelect_SelectIntersection thePtr) -> Handle_IFSelect_SelectIntersection
        assign(Handle_IFSelect_SelectIntersection self, Handle_IFSelect_SelectIntersection theHandle) -> Handle_IFSelect_SelectIntersection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectIntersection self) -> IFSelect_SelectIntersection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectIntersection self) -> IFSelect_SelectIntersection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectIntersection self) -> IFSelect_SelectIntersection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectIntersection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectIntersection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectIntersection_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectIntersection

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectIntersection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected Entities, which is the common part
        of results from all input selections. Uniqueness is guaranteed.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectIntersection self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Intersection (AND)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectIntersection self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectIntersection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectIntersection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbInputs(self, *args):
        """
        NbInputs(Handle_IFSelect_SelectIntersection self) -> Standard_Integer

        Returns the count of Input Selections

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_NbInputs(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectIntersection self, Standard_Integer const num) -> Handle_IFSelect_Selection

        Returns an Input Selection, given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_Input(self, *args)


    def InputRank(self, *args):
        """
        InputRank(Handle_IFSelect_SelectIntersection self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the rank of an input Selection, 0 if not in the list.
        Most generally, its value is meaningless, except for testing
        the presence of an input Selection :
        - == 0  if <sel> is not an input for <me>
        - >  0  if <sel> is an input for <me>

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_InputRank(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IFSelect_SelectIntersection self, Handle_IFSelect_Selection sel, Standard_Integer const atnum=0)

        Adds a Selection to the filling list
        By default, adds it to the end of the list
        A Positive rank less then NbInputs gives an insertion rank
        (InsertBefore : the new <atnum>th item of the list is <sel>)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_IFSelect_SelectIntersection self, Handle_IFSelect_Selection sel) -> Standard_Boolean
        Remove(Handle_IFSelect_SelectIntersection self, Standard_Integer const num) -> Standard_Boolean

        Removes an input Selection, given its rank in the list
        Returns True if Done, False if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_Remove(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectIntersection self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectIntersection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectIntersection self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectIntersection self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectIntersection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectIntersection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectIntersection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectIntersection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectIntersection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectIntersection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectIntersection self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectIntersection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectIntersection_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectIntersection_swigregister = _IFSelect.Handle_IFSelect_SelectIntersection_swigregister
Handle_IFSelect_SelectIntersection_swigregister(Handle_IFSelect_SelectIntersection)

def Handle_IFSelect_SelectIntersection_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectIntersection_DownCast(thing)
Handle_IFSelect_SelectIntersection_DownCast = _IFSelect.Handle_IFSelect_SelectIntersection_DownCast

class Handle_IFSelect_SelectDiff(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectDiff self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectDiff_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectDiff self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectDiff self, IFSelect_SelectDiff thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectDiff self, Handle_IFSelect_SelectDiff theHandle) -> Handle_IFSelect_SelectDiff
        assign(Handle_IFSelect_SelectDiff self, IFSelect_SelectDiff thePtr) -> Handle_IFSelect_SelectDiff
        assign(Handle_IFSelect_SelectDiff self, Handle_IFSelect_SelectDiff theHandle) -> Handle_IFSelect_SelectDiff

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectDiff self) -> IFSelect_SelectDiff

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectDiff self) -> IFSelect_SelectDiff

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectDiff___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectDiff self) -> IFSelect_SelectDiff

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectDiff___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectDiff___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectDiff___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectDiff(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectDiff_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectDiff

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectDiff self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : they are the Entities
        gotten from the Main Input but not from the Diff Input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectDiff self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Difference"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectDiff self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectDiff_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectDiff_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MainInput(self, *args):
        """
        MainInput(Handle_IFSelect_SelectDiff self) -> Handle_IFSelect_Selection

        Returns the Main Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_MainInput(self, *args)


    def HasSecondInput(self, *args):
        """
        HasSecondInput(Handle_IFSelect_SelectDiff self) -> Standard_Boolean

        Returns True if a Control Input is defined
        Thus, Result can be computed differently if there is a
        Control Input or if there is none

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_HasSecondInput(self, *args)


    def SecondInput(self, *args):
        """
        SecondInput(Handle_IFSelect_SelectDiff self) -> Handle_IFSelect_Selection

        Returns the Control Input Selection, or a Null Handle

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_SecondInput(self, *args)


    def SetMainInput(self, *args):
        """
        SetMainInput(Handle_IFSelect_SelectDiff self, Handle_IFSelect_Selection sel)

        Sets a Selection to be the Main Input

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_SetMainInput(self, *args)


    def SetSecondInput(self, *args):
        """
        SetSecondInput(Handle_IFSelect_SelectDiff self, Handle_IFSelect_Selection sel)

        Sets a Selection to be the Control Input

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_SetSecondInput(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectDiff self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        That is to say, the list of Input Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectDiff self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectDiff self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectDiff self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectDiff_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectDiff self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectDiff self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectDiff self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectDiff self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectDiff self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectDiff self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectDiff self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectDiff_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectDiff self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectDiff_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectDiff_swigregister = _IFSelect.Handle_IFSelect_SelectDiff_swigregister
Handle_IFSelect_SelectDiff_swigregister(Handle_IFSelect_SelectDiff)

def Handle_IFSelect_SelectDiff_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectDiff_DownCast(thing)
Handle_IFSelect_SelectDiff_DownCast = _IFSelect.Handle_IFSelect_SelectDiff_DownCast

class IFSelect_IntParam(Standard.Standard_Transient):
    """
    This class simply allows to access an Integer value through a
    Handle, as a String can be (by using HString).
    Hence, this value can be accessed : read and modified, without
    passing through the specific object which detains it. Thus,
    parameters of a Selection or a Dispatch (according its type)
    can be controlled directly from the ShareOut which contains them

    Additionnaly, an IntParam can be bound to a Static.
    Remember that for a String, binding is immediate, because the
    string value of a Static is a HAsciiString, it then suffices
    to get its Handle.
    For an Integer, an IntParam can designate (by its name) a
    Static : each time its value is required or set, the Static
    is aknowledged
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_IntParam
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_IntParam(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_IntParam self) -> IFSelect_IntParam

        Creates an IntParam. Initial value is set to zer


        """
        this = _IFSelect.new_IFSelect_IntParam(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetStaticName(self, *args):
        """
        SetStaticName(IFSelect_IntParam self, Standard_CString const statname)

        Commands this IntParam to be bound to a Static
        Hence, Value will return the value if this Static if it is set
        Else, Value works on the locally stored value
        SetValue also will set the value of the Static
        This works only for a present static of type integer or enum
        Else, it is ignored

        If <statname> is empty, disconnects the IntParam from Static

        :type statname: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_IntParam_SetStaticName(self, *args)


    def Value(self, *args):
        """
        Value(IFSelect_IntParam self) -> Standard_Integer

        Reads Integer Value of the IntParam. If a StaticName is
        defined and the Static is set, looks in priority the value
        of the static

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_IntParam_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(IFSelect_IntParam self, Standard_Integer const val)

        Sets a new Integer Value for the IntParam. If a StaticName is
        defined and the Static is set, also sets the value of the static

        :type val: int

        """
        return _IFSelect.IFSelect_IntParam_SetValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_IntParam_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_IntParam_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_IntParam_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_IntParam
IFSelect_IntParam_swigregister = _IFSelect.IFSelect_IntParam_swigregister
IFSelect_IntParam_swigregister(IFSelect_IntParam)

def IFSelect_IntParam_get_type_name(*args):
    """
    IFSelect_IntParam_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_IntParam_get_type_name(*args)

def IFSelect_IntParam_get_type_descriptor(*args):
    """
    IFSelect_IntParam_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_IntParam_get_type_descriptor(*args)

class Handle_IFSelect_SelectAnyList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectAnyList self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectAnyList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectAnyList self, IFSelect_SelectAnyList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_SelectAnyList theHandle) -> Handle_IFSelect_SelectAnyList
        assign(Handle_IFSelect_SelectAnyList self, IFSelect_SelectAnyList thePtr) -> Handle_IFSelect_SelectAnyList
        assign(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_SelectAnyList theHandle) -> Handle_IFSelect_SelectAnyList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectAnyList self) -> IFSelect_SelectAnyList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectAnyList self) -> IFSelect_SelectAnyList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectAnyList self) -> IFSelect_SelectAnyList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectAnyList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectAnyList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectAnyList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectAnyList_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectAnyList

    def KeepInputEntity(self, *args):
        """
        KeepInputEntity(Handle_IFSelect_SelectAnyList self, Interface_EntityIterator iter)

        Keeps Input Entity, as having required type. It works by
        keeping in <iter>, only suitable Entities (SelectType can be
        used). Called by RootResult (which waits for ONE ENTITY MAX)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_KeepInputEntity(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_IFSelect_SelectAnyList self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns count of Items in the list in the Entity <ent>
        If <ent> has not required type, returned value must be Zero

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_NbItems(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rankfrom, Handle_IFSelect_IntParam rankto)

        Sets a Range for numbers, with a lower and a upper limits

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_SetRange(self, *args)


    def SetOne(self, *args):
        """
        SetOne(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rank)

        Sets a unique number (only one Entity will be sorted as True)

        :type rank: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_SetOne(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rankfrom)

        Sets a Lower limit but no upper limit

        :type rankfrom: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_SetFrom(self, *args)


    def SetUntil(self, *args):
        """
        SetUntil(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_IntParam rankto)

        Sets an Upper limit but no lower limit (equivalent to lower 1)

        :type rankto: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_SetUntil(self, *args)


    def HasLower(self, *args):
        """
        HasLower(Handle_IFSelect_SelectAnyList self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_HasLower(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_IFSelect_SelectAnyList self) -> Handle_IFSelect_IntParam

        Returns Lower limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Lower(self, *args)


    def LowerValue(self, *args):
        """
        LowerValue(Handle_IFSelect_SelectAnyList self) -> Standard_Integer

        Returns Integer Value of Lower Limit (0 if none)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_LowerValue(self, *args)


    def HasUpper(self, *args):
        """
        HasUpper(Handle_IFSelect_SelectAnyList self) -> Standard_Boolean

        Returns True if a Lower limit is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_HasUpper(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_IFSelect_SelectAnyList self) -> Handle_IFSelect_IntParam

        Returns Upper limit (if there is; else, value is senseless)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Upper(self, *args)


    def UpperValue(self, *args):
        """
        UpperValue(Handle_IFSelect_SelectAnyList self) -> Standard_Integer

        Returns Integer Value of Upper Limit (0 if none)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_UpperValue(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectAnyList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        complying with rank criterium)
        Error if the input list has more than one Item

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_RootResult(self, *args)


    def FillResult(self, *args):
        """
        FillResult(Handle_IFSelect_SelectAnyList self, Standard_Integer const n1, Standard_Integer const n2, Handle_Standard_Transient ent, Interface_EntityIterator res)

        Puts into <res>, the sub-entities of the list, from n1 to
        n2 included. Remark that adequation with Entity's type and
        length of list has already been made at this stage
        Called by RootResult

        :type n1: int
        :type n2: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_FillResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectAnyList self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Componants of List "
        then Specific List Label, then, following cases :
        " From .. Until .." or "From .." or "Until .." or "Rank no .."
        Specific type is given by deferred method ListLabel

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Label(self, *args)


    def ListLabel(self, *args):
        """
        ListLabel(Handle_IFSelect_SelectAnyList self) -> TCollection_AsciiString

        Returns the specific label for the list, which is included as
        a part of Label

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_ListLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectAnyList self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectAnyList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectAnyList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectAnyList self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectAnyList self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectAnyList self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectAnyList self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectAnyList self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectAnyList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectAnyList self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectAnyList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectAnyList self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectAnyList self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectAnyList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectAnyList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectAnyList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectAnyList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectAnyList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectAnyList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectAnyList self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectAnyList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyList_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectAnyList_swigregister = _IFSelect.Handle_IFSelect_SelectAnyList_swigregister
Handle_IFSelect_SelectAnyList_swigregister(Handle_IFSelect_SelectAnyList)

def Handle_IFSelect_SelectAnyList_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectAnyList_DownCast(thing)
Handle_IFSelect_SelectAnyList_DownCast = _IFSelect.Handle_IFSelect_SelectAnyList_DownCast

class Handle_IFSelect_Transformer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_Transformer self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_Transformer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_Transformer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_Transformer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_Transformer self, IFSelect_Transformer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_Transformer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_Transformer self, Handle_IFSelect_Transformer theHandle) -> Handle_IFSelect_Transformer
        assign(Handle_IFSelect_Transformer self, IFSelect_Transformer thePtr) -> Handle_IFSelect_Transformer
        assign(Handle_IFSelect_Transformer self, Handle_IFSelect_Transformer theHandle) -> Handle_IFSelect_Transformer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_Transformer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_Transformer self) -> IFSelect_Transformer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Transformer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_Transformer self) -> IFSelect_Transformer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_Transformer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_Transformer self) -> IFSelect_Transformer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_Transformer___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_Transformer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_Transformer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_Transformer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_Transformer_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_Transformer

    def Perform(self, *args):
        """
        Perform(Handle_IFSelect_Transformer self, Interface_Graph G, Handle_Interface_Protocol protocol, Interface_CheckIterator checks, Handle_Interface_InterfaceModel newmod) -> Standard_Boolean

        Performs a Transformation (defined by each sub-class) :
        <G> gives the input data (especially the starting model) and
        can be used for queries (by Selections, etc...)
        <protocol> allows to work with General Services as necessary
        (it applies to input data)
        If the change corresponds to a conversion to a new protocol,
        see also the method ChangeProtocol
        <checks> stores produced checks messages if any
        <newmod> gives the result of the transformation :
        - if it is Null (i.e. has not been affected), the transformation
        has been made on the spot, it is assumed to cause no change
        to the graph of dependances
        - if it equates the starting Model, it has been transformed on
        the spot (possibiliy some entities were replaced inside it)
        - if it is new, it corresponds to a new data set which replaces
        the starting one

        <me> is mutable to allow results for ChangeProtocol to be
        memorized if needed, and to store informations useful for
        the method Updated

        Returns True if Done, False if an Error occured : in this case,
        if a new data set has been produced, the transformation
        is ignored, else data may be corrupted.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Transformer_Perform(self, *args)


    def ChangeProtocol(self, *args):
        """
        ChangeProtocol(Handle_IFSelect_Transformer self, Handle_Interface_Protocol newproto) -> Standard_Boolean

        This methods allows to declare that the Protocol applied to
        the new Model has changed. It applies to the last call to
        Perform.

        Returns True if the Protocol has changed, False else.
        The provided default keeps the starting Protocol. This method
        should be redefined as required by the effect of Perform.

        :type newproto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Transformer_ChangeProtocol(self, *args)


    def Updated(self, *args):
        """
        Updated(Handle_IFSelect_Transformer self, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto) -> Standard_Boolean

        This method allows to know what happened to a starting
        entity after the last Perform. If <entfrom> (from starting
        model) has one and only one known item which corresponds in
        the new produced model, this method must return True and
        fill the argument <entto>. Else, it returns False.

        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Transformer_Updated(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_Transformer self) -> TCollection_AsciiString

        Returns a text which defines the way a Transformer works
        (to identify the transformation it performs)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_Transformer_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_Transformer self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_Transformer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Transformer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_Transformer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_Transformer self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_Transformer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_Transformer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_Transformer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Transformer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_Transformer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_Transformer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_Transformer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_Transformer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_Transformer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_Transformer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Transformer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_Transformer self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_Transformer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_Transformer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_Transformer_DecrementRefCounter(self, *args)

Handle_IFSelect_Transformer_swigregister = _IFSelect.Handle_IFSelect_Transformer_swigregister
Handle_IFSelect_Transformer_swigregister(Handle_IFSelect_Transformer)

def Handle_IFSelect_Transformer_DownCast(thing):
    return _IFSelect.Handle_IFSelect_Transformer_DownCast(thing)
Handle_IFSelect_Transformer_DownCast = _IFSelect.Handle_IFSelect_Transformer_DownCast

class Handle_IFSelect_SelectAnyType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectAnyType self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectAnyType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectAnyType self, IFSelect_SelectAnyType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectAnyType self, Handle_IFSelect_SelectAnyType theHandle) -> Handle_IFSelect_SelectAnyType
        assign(Handle_IFSelect_SelectAnyType self, IFSelect_SelectAnyType thePtr) -> Handle_IFSelect_SelectAnyType
        assign(Handle_IFSelect_SelectAnyType self, Handle_IFSelect_SelectAnyType theHandle) -> Handle_IFSelect_SelectAnyType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectAnyType self) -> IFSelect_SelectAnyType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectAnyType self) -> IFSelect_SelectAnyType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectAnyType self) -> IFSelect_SelectAnyType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectAnyType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectAnyType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectAnyType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectAnyType_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectAnyType

    def TypeForMatch(self, *args):
        """
        TypeForMatch(Handle_IFSelect_SelectAnyType self) -> Handle_Standard_Type

        Returns the Type which has to be matched for select

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_TypeForMatch(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectAnyType self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity (model->Value(num)) which is kind
        of the choosen type, given by the method TypeForMatch.
        Criterium is IsKind.

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_Sort(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectAnyType self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectAnyType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectAnyType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectAnyType self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectAnyType self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectAnyType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_RootResult(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectAnyType self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectAnyType self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_Label(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectAnyType self) -> TCollection_AsciiString

        Returns a text defining the criterium for extraction

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_ExtractLabel(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectAnyType self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectAnyType self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectAnyType self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectAnyType self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectAnyType self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectAnyType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectAnyType self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectAnyType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectAnyType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectAnyType self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectAnyType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectAnyType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectAnyType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectAnyType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectAnyType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectAnyType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectAnyType self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectAnyType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectAnyType_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectAnyType_swigregister = _IFSelect.Handle_IFSelect_SelectAnyType_swigregister
Handle_IFSelect_SelectAnyType_swigregister(Handle_IFSelect_SelectAnyType)

def Handle_IFSelect_SelectAnyType_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectAnyType_DownCast(thing)
Handle_IFSelect_SelectAnyType_DownCast = _IFSelect.Handle_IFSelect_SelectAnyType_DownCast

class IFSelect_Functions(object):
    """
    Functions gives access to all the actions which can be
    commanded with the resources provided by IFSelect : especially
    WorkSession and various types of Selections and Dispatches

    It works by adding functions by method Init
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GiveEntity(*args):
        """
        GiveEntity(Handle_IFSelect_WorkSession WS, Standard_CString const name) -> Handle_Standard_Transient

        Takes the name of an entity, either as argument, or (if <name>
        is empty) on keybord, and returns the entity
        name can be a label or a number (in alphanumeric), it is
        searched by NumberFromLabel from WorkSession.
        If <name> doesn't match en entity, a Null Handle is returned

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_Functions_GiveEntity(*args)

    GiveEntity = staticmethod(GiveEntity)

    def GiveEntityNumber(*args):
        """
        GiveEntityNumber(Handle_IFSelect_WorkSession WS, Standard_CString const name) -> Standard_Integer

        Same as GetEntity, but returns the number in the model of the
        entity. Returns 0 for null handle

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_Functions_GiveEntityNumber(*args)

    GiveEntityNumber = staticmethod(GiveEntityNumber)

    def GiveList(*args):
        """
        GiveList(Handle_IFSelect_WorkSession WS, Standard_CString const first, Standard_CString const second) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from a WorkSession and two idents,
        first and second, as follows :
        if <first> is a Number or Label of an entity : this entity
        if <first> is the name of a Selection in <WS>, and <second>
        not defined, the standard result of this Selection
        if <first> is for a Selection and <second> is defined, the
        standard result of this selection from the list computed
        with <second> (an entity or a selection)
        If <second> is erroneous, it is ignored

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type first: OCC.wrapper.Standard.Standard_CString
        :type second: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.IFSelect_Functions_GiveList(*args)

    GiveList = staticmethod(GiveList)

    def GiveDispatch(*args):
        """
        GiveDispatch(Handle_IFSelect_WorkSession WS, Standard_CString const name, Standard_Boolean const mode) -> Handle_IFSelect_Dispatch

        Evaluates and returns a Dispatch, from data of a WorkSession
        if <mode> is False, searches for exact name of Dispatch in WS
        Else (D), allows a parameter between brackets :
        ex.: dispatch_name(parameter)
        The parameter can be: an integer for DispPerCount or DispPerFiles
        or the name of a Signature for DispPerSignature
        Returns Null Handle if not found not well evaluated

        :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
        :type name: OCC.wrapper.Standard.Standard_CString
        :type mode: bool
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.IFSelect_Functions_GiveDispatch(*args)

    GiveDispatch = staticmethod(GiveDispatch)

    def Init(*args):
        """
        Init()

        Defines and loads all basic functions (as ActFunc)


        """
        return _IFSelect.IFSelect_Functions_Init(*args)

    Init = staticmethod(Init)

    def __init__(self):
        """
        Functions gives access to all the actions which can be
        commanded with the resources provided by IFSelect : especially
        WorkSession and various types of Selections and Dispatches

        It works by adding functions by method Init
        """
        this = _IFSelect.new_IFSelect_Functions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_IFSelect_Functions
IFSelect_Functions_swigregister = _IFSelect.IFSelect_Functions_swigregister
IFSelect_Functions_swigregister(IFSelect_Functions)

def IFSelect_Functions_GiveEntity(*args):
    """
    IFSelect_Functions_GiveEntity(Handle_IFSelect_WorkSession WS, Standard_CString const name) -> Handle_Standard_Transient

    Takes the name of an entity, either as argument, or (if <name>
    is empty) on keybord, and returns the entity
    name can be a label or a number (in alphanumeric), it is
    searched by NumberFromLabel from WorkSession.
    If <name> doesn't match en entity, a Null Handle is returned

    :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

    """
    return _IFSelect.IFSelect_Functions_GiveEntity(*args)

def IFSelect_Functions_GiveEntityNumber(*args):
    """
    IFSelect_Functions_GiveEntityNumber(Handle_IFSelect_WorkSession WS, Standard_CString const name) -> Standard_Integer

    Same as GetEntity, but returns the number in the model of the
    entity. Returns 0 for null handle

    :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IFSelect.IFSelect_Functions_GiveEntityNumber(*args)

def IFSelect_Functions_GiveList(*args):
    """
    IFSelect_Functions_GiveList(Handle_IFSelect_WorkSession WS, Standard_CString const first, Standard_CString const second) -> Handle_TColStd_HSequenceOfTransient

    Computes a List of entities from a WorkSession and two idents,
    first and second, as follows :
    if <first> is a Number or Label of an entity : this entity
    if <first> is the name of a Selection in <WS>, and <second>
    not defined, the standard result of this Selection
    if <first> is for a Selection and <second> is defined, the
    standard result of this selection from the list computed
    with <second> (an entity or a selection)
    If <second> is erroneous, it is ignored

    :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
    :type first: OCC.wrapper.Standard.Standard_CString
    :type second: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

    """
    return _IFSelect.IFSelect_Functions_GiveList(*args)

def IFSelect_Functions_GiveDispatch(*args):
    """
    IFSelect_Functions_GiveDispatch(Handle_IFSelect_WorkSession WS, Standard_CString const name, Standard_Boolean const mode) -> Handle_IFSelect_Dispatch

    Evaluates and returns a Dispatch, from data of a WorkSession
    if <mode> is False, searches for exact name of Dispatch in WS
    Else (D), allows a parameter between brackets :
    ex.: dispatch_name(parameter)
    The parameter can be: an integer for DispPerCount or DispPerFiles
    or the name of a Signature for DispPerSignature
    Returns Null Handle if not found not well evaluated

    :type WS: OCC.wrapper.IFSelect.Handle_IFSelect_WorkSession
    :type name: OCC.wrapper.Standard.Standard_CString
    :type mode: bool
    :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

    """
    return _IFSelect.IFSelect_Functions_GiveDispatch(*args)

def IFSelect_Functions_Init(*args):
    """
    IFSelect_Functions_Init()

    Defines and loads all basic functions (as ActFunc)


    """
    return _IFSelect.IFSelect_Functions_Init(*args)

class Handle_IFSelect_TransformStandard(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_TransformStandard self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_TransformStandard self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_TransformStandard self, IFSelect_TransformStandard thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_TransformStandard self, Handle_IFSelect_TransformStandard theHandle) -> Handle_IFSelect_TransformStandard
        assign(Handle_IFSelect_TransformStandard self, IFSelect_TransformStandard thePtr) -> Handle_IFSelect_TransformStandard
        assign(Handle_IFSelect_TransformStandard self, Handle_IFSelect_TransformStandard theHandle) -> Handle_IFSelect_TransformStandard

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_TransformStandard self) -> IFSelect_TransformStandard

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_TransformStandard self) -> IFSelect_TransformStandard

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_TransformStandard___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_TransformStandard self) -> IFSelect_TransformStandard

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_TransformStandard___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_TransformStandard___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_TransformStandard___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_TransformStandard(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_TransformStandard_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_TransformStandard

    def SetCopyOption(self, *args):
        """
        SetCopyOption(Handle_IFSelect_TransformStandard self, Standard_Boolean const option)

        Sets the Copy option to a new value :
        - True for StandardCopy  - False for OnTheSpot

        :type option: bool

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_SetCopyOption(self, *args)


    def CopyOption(self, *args):
        """
        CopyOption(Handle_IFSelect_TransformStandard self) -> Standard_Boolean

        Returns the Copy option

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_CopyOption(self, *args)


    def SetSelection(self, *args):
        """
        SetSelection(Handle_IFSelect_TransformStandard self, Handle_IFSelect_Selection sel)

        Sets a Selection (or unsets if Null)
        This Selection then defines the list of entities on which the
        Modifiers will be applied
        If it is set, it has priority on Selections of Modifiers
        Else, for each Modifier its Selection is evaluated
        By default, all the Model is taken

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_SetSelection(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_TransformStandard self) -> Handle_IFSelect_Selection

        Returns the Selection, Null by default

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Selection(self, *args)


    def NbModifiers(self, *args):
        """
        NbModifiers(Handle_IFSelect_TransformStandard self) -> Standard_Integer

        Returns the count of recorded Modifiers

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_NbModifiers(self, *args)


    def Modifier(self, *args):
        """
        Modifier(Handle_IFSelect_TransformStandard self, Standard_Integer const num) -> Handle_IFSelect_Modifier

        Returns a Modifier given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Modifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(Handle_IFSelect_TransformStandard self, Handle_IFSelect_Modifier modif) -> Standard_Integer

        Returns the rank of a Modifier in the list, 0 if unknown

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_ModifierRank(self, *args)


    def AddModifier(self, *args):
        """
        AddModifier(Handle_IFSelect_TransformStandard self, Handle_IFSelect_Modifier modif, Standard_Integer const atnum=0) -> Standard_Boolean

        Adds a Modifier to the list :
        - <atnum> = 0 (default) : at the end of the list
        - <atnum> > 0 : at rank <atnum>
        Returns True if done, False if <atnum> is out of range

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_AddModifier(self, *args)


    def RemoveModifier(self, *args):
        """
        RemoveModifier(Handle_IFSelect_TransformStandard self, Handle_IFSelect_Modifier modif) -> Standard_Boolean
        RemoveModifier(Handle_IFSelect_TransformStandard self, Standard_Integer const num) -> Standard_Boolean

        Removes a Modifier from the list, given its rank
        Returns True if done, False if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_RemoveModifier(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_IFSelect_TransformStandard self, Interface_Graph G, Handle_Interface_Protocol protocol, Interface_CheckIterator checks, Handle_Interface_InterfaceModel newmod) -> Standard_Boolean

        Performs the Standard Transformation, by calling Copy then
        ApplyModifiers (which can return an error status)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Perform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_IFSelect_TransformStandard self, Interface_Graph G, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        This the first operation. It calls StandardCopy or OnTheSpot
        according the option

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Copy(self, *args)


    def StandardCopy(self, *args):
        """
        StandardCopy(Handle_IFSelect_TransformStandard self, Interface_Graph G, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        This is the standard action of Copy : its takes into account
        only the remaining entities (noted by Graph Status positive)
        and their proper dependances of course. Produces a new model.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_StandardCopy(self, *args)


    def OnTheSpot(self, *args):
        """
        OnTheSpot(Handle_IFSelect_TransformStandard self, Interface_Graph G, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        This is the OnTheSpot action : each entity is bound with ...
        itself. The produced model is the same as the starting one.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_OnTheSpot(self, *args)


    def ApplyModifiers(self, *args):
        """
        ApplyModifiers(Handle_IFSelect_TransformStandard self, Interface_Graph G, Handle_Interface_Protocol protocol, Interface_CopyTool TC, Interface_CheckIterator checks, Handle_Interface_InterfaceModel newmod) -> Standard_Boolean

        Applies the modifiers sequencially.
        For each one, prepares required data (if a Selection is
        associated as a filter).
        For the option OnTheSpot, it determines if the graph may be
        changed and updates <newmod> if required
        If a Modifier causes an error (check "HasFailed"),
        ApplyModifier stops : the following Modifiers are ignored

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_ApplyModifiers(self, *args)


    def Updated(self, *args):
        """
        Updated(Handle_IFSelect_TransformStandard self, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto) -> Standard_Boolean

        This methods allows to know what happened to a starting
        entity after the last Perform. It reads result from the map
        which was filled by Perform.

        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Updated(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_TransformStandard self) -> TCollection_AsciiString

        Returns a text which defines the way a Transformer works :
        "On the spot edition" or "Standard Copy" followed by
        "<nn> Modifiers"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_TransformStandard self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_TransformStandard_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_TransformStandard_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeProtocol(self, *args):
        """
        ChangeProtocol(Handle_IFSelect_TransformStandard self, Handle_Interface_Protocol newproto) -> Standard_Boolean

        This methods allows to declare that the Protocol applied to
        the new Model has changed. It applies to the last call to
        Perform.

        Returns True if the Protocol has changed, False else.
        The provided default keeps the starting Protocol. This method
        should be redefined as required by the effect of Perform.

        :type newproto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_ChangeProtocol(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_TransformStandard self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_TransformStandard_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_TransformStandard self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_TransformStandard self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_TransformStandard self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_TransformStandard self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_TransformStandard self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_TransformStandard self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_TransformStandard self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_TransformStandard_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_TransformStandard self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_TransformStandard_DecrementRefCounter(self, *args)

Handle_IFSelect_TransformStandard_swigregister = _IFSelect.Handle_IFSelect_TransformStandard_swigregister
Handle_IFSelect_TransformStandard_swigregister(Handle_IFSelect_TransformStandard)

def Handle_IFSelect_TransformStandard_DownCast(thing):
    return _IFSelect.Handle_IFSelect_TransformStandard_DownCast(thing)
Handle_IFSelect_TransformStandard_DownCast = _IFSelect.Handle_IFSelect_TransformStandard_DownCast

class IFSelect_SelectModelRoots(IFSelect_SelectBase):
    """
    A SelectModelRoots gets all the Root Entities of an
    InterfaceModel. Remember that a "Root Entity" is defined as
    having no Sharing Entity (if there is a Loop between Entities,
    none of them can be a "Root").
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectModelRoots
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectModelRoots(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectModelRoots self) -> IFSelect_SelectModelRoots

        Creates a SelectModelRoot


        """
        this = _IFSelect.new_IFSelect_SelectModelRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectModelRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : the Roots of the Model
        (note that this result assures naturally uniqueness)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectModelRoots_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectModelRoots self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Model Roots"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectModelRoots_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectModelRoots_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectModelRoots_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectModelRoots_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectModelRoots
IFSelect_SelectModelRoots_swigregister = _IFSelect.IFSelect_SelectModelRoots_swigregister
IFSelect_SelectModelRoots_swigregister(IFSelect_SelectModelRoots)

def IFSelect_SelectModelRoots_get_type_name(*args):
    """
    IFSelect_SelectModelRoots_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectModelRoots_get_type_name(*args)

def IFSelect_SelectModelRoots_get_type_descriptor(*args):
    """
    IFSelect_SelectModelRoots_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectModelRoots_get_type_descriptor(*args)

class Handle_IFSelect_SignCategory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignCategory self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignCategory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignCategory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignCategory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignCategory self, IFSelect_SignCategory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignCategory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignCategory self, Handle_IFSelect_SignCategory theHandle) -> Handle_IFSelect_SignCategory
        assign(Handle_IFSelect_SignCategory self, IFSelect_SignCategory thePtr) -> Handle_IFSelect_SignCategory
        assign(Handle_IFSelect_SignCategory self, Handle_IFSelect_SignCategory theHandle) -> Handle_IFSelect_SignCategory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignCategory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignCategory self) -> IFSelect_SignCategory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignCategory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignCategory self) -> IFSelect_SignCategory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignCategory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignCategory self) -> IFSelect_SignCategory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignCategory___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignCategory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignCategory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignCategory_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignCategory

    def Value(self, *args):
        """
        Value(Handle_IFSelect_SignCategory self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its Category
        recorded in the model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignCategory self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignCategory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignCategory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignCategory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_IFSelect_SignCategory self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.Handle_IFSelect_SignCategory_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_IFSelect_SignCategory self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCategory_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_IFSelect_SignCategory self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_IFSelect_SignCategory self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignCategory self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SignCategory self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_Label(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_IFSelect_SignCategory self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Tells if the value for <ent> in <model> matches a text, with
        a criterium <exact>.
        The default definition calls MatchValue
        Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCategory_Matches(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_IFSelect_SignCategory self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCategory_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_SignCategory self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_IFSelect_SignCategory self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_IFSelect_SignCategory self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_IFSelect_SignCategory self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignCategory_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignCategory self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignCategory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignCategory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignCategory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCategory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignCategory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignCategory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignCategory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignCategory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignCategory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignCategory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCategory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignCategory self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignCategory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignCategory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignCategory_DecrementRefCounter(self, *args)

Handle_IFSelect_SignCategory_swigregister = _IFSelect.Handle_IFSelect_SignCategory_swigregister
Handle_IFSelect_SignCategory_swigregister(Handle_IFSelect_SignCategory)

def Handle_IFSelect_SignCategory_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignCategory_DownCast(thing)
Handle_IFSelect_SignCategory_DownCast = _IFSelect.Handle_IFSelect_SignCategory_DownCast

class IFSelect_ContextWrite(object):
    """
    This class gathers various informations used by File Modifiers
    apart from the writer object, which is specific of the norm
    and of the physical format

    These informations are controlled by an object AppliedModifiers
    (if it is not defined, no modification is allowed on writing)

    Furthermore, in return, ContextModif can record Checks, either
    one for all, or one for each Entity. It supports trace too.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFSelect_ContextWrite self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol proto, Handle_IFSelect_AppliedModifiers applieds, Standard_CString const filename) -> IFSelect_ContextWrite
        __init__(IFSelect_ContextWrite self, Handle_Interface_HGraph hgraph, Handle_Interface_Protocol proto, Handle_IFSelect_AppliedModifiers applieds, Standard_CString const filename) -> IFSelect_ContextWrite

        Same as above but with an already computed Graph

        :type hgraph: OCC.wrapper.Interface.Handle_Interface_HGraph
        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type applieds: OCC.wrapper.IFSelect.Handle_IFSelect_AppliedModifiers
        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_ContextWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args):
        """
        Model(IFSelect_ContextWrite self) -> Handle_Interface_InterfaceModel

        Returns the Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_ContextWrite_Model(self, *args)


    def Protocol(self, *args):
        """
        Protocol(IFSelect_ContextWrite self) -> Handle_Interface_Protocol

        Returns the Protocol;

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _IFSelect.IFSelect_ContextWrite_Protocol(self, *args)


    def FileName(self, *args):
        """
        FileName(IFSelect_ContextWrite self) -> Standard_CString

        Returns the File Name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextWrite_FileName(self, *args)


    def AppliedModifiers(self, *args):
        """
        AppliedModifiers(IFSelect_ContextWrite self) -> Handle_IFSelect_AppliedModifiers

        Returns the object AppliedModifiers

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_AppliedModifiers

        """
        return _IFSelect.IFSelect_ContextWrite_AppliedModifiers(self, *args)


    def Graph(self, *args):
        """
        Returns the Graph, either given when created, else created
        the first time it is queried

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _IFSelect.IFSelect_ContextWrite_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbModifiers(self, *args):
        """
        NbModifiers(IFSelect_ContextWrite self) -> Standard_Integer

        Returns the count of recorded File Modifiers

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ContextWrite_NbModifiers(self, *args)


    def SetModifier(self, *args):
        """
        SetModifier(IFSelect_ContextWrite self, Standard_Integer const numod) -> Standard_Boolean

        Sets active the File Modifier n0 <numod>
        Then, it prepares the list of entities to consider, if any
        Returns False if <numod> out of range

        :type numod: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextWrite_SetModifier(self, *args)


    def FileModifier(self, *args):
        """
        FileModifier(IFSelect_ContextWrite self) -> Handle_IFSelect_GeneralModifier

        Returns the currently active File Modifier. Cast to be done
        Null if not properly set : must be test IsNull after casting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _IFSelect.IFSelect_ContextWrite_FileModifier(self, *args)


    def IsForNone(self, *args):
        """
        IsForNone(IFSelect_ContextWrite self) -> Standard_Boolean

        Returns True if no modifier is currently set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextWrite_IsForNone(self, *args)


    def IsForAll(self, *args):
        """
        IsForAll(IFSelect_ContextWrite self) -> Standard_Boolean

        Returns True if the current modifier is to be applied to
        the whole model. Else, a restricted list of selected entities
        is defined, it can be exploited by the File Modifier

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextWrite_IsForAll(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(IFSelect_ContextWrite self) -> Standard_Integer

        Returns the total count of selected entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_ContextWrite_NbEntities(self, *args)


    def Start(self, *args):
        """
        Start(IFSelect_ContextWrite self)

        Starts an iteration on selected items. It takes into account
        IsForAll/IsForNone, by really iterating on all selected items.


        """
        return _IFSelect.IFSelect_ContextWrite_Start(self, *args)


    def More(self, *args):
        """
        More(IFSelect_ContextWrite self) -> Standard_Boolean

        Returns True until the iteration has finished

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_ContextWrite_More(self, *args)


    def Next(self, *args):
        """
        Next(IFSelect_ContextWrite self)

        Advances the iteration


        """
        return _IFSelect.IFSelect_ContextWrite_Next(self, *args)


    def Value(self, *args):
        """
        Value(IFSelect_ContextWrite self) -> Handle_Standard_Transient

        Returns the current selected entity in the model

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_ContextWrite_Value(self, *args)


    def AddCheck(self, *args):
        """
        AddCheck(IFSelect_ContextWrite self, Handle_Interface_Check check)

        Adds a Check to the CheckList. If it is empty, nothing is done
        If it concerns an Entity from the Model (by SetEntity)
        to which another Check is attached, it is merged to it.
        Else, it is added or merged as to GlobalCheck.

        :type check: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _IFSelect.IFSelect_ContextWrite_AddCheck(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(IFSelect_ContextWrite self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        Adds a Warning Message for an Entity from the Model
        If <start> is not an Entity from the model (e.g. the
        model itself) this message is added to Global Check.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextWrite_AddWarning(self, *args)


    def AddFail(self, *args):
        """
        AddFail(IFSelect_ContextWrite self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        Adds a Fail Message for an Entity from the Model
        If <start> is not an Entity from the model (e.g. the
        model itself) this message is added to Global Check.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_ContextWrite_AddFail(self, *args)


    def CCheck(self, *args):
        """
        CCheck(IFSelect_ContextWrite self, Standard_Integer const num=0) -> Handle_Interface_Check
        CCheck(IFSelect_ContextWrite self, Handle_Standard_Transient start) -> Handle_Interface_Check

        Returns a Check attached to an Entity from the Model
        It can then be acknowledged on the spot, in condition that the
        caller works by reference ("Interface_Check& check = ...")

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _IFSelect.IFSelect_ContextWrite_CCheck(self, *args)


    def CheckList(self, *args):
        """
        CheckList(IFSelect_ContextWrite self) -> Interface_CheckIterator

        Returns the complete CheckList

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ContextWrite_CheckList(self, *args)

    __swig_destroy__ = _IFSelect.delete_IFSelect_ContextWrite
IFSelect_ContextWrite_swigregister = _IFSelect.IFSelect_ContextWrite_swigregister
IFSelect_ContextWrite_swigregister(IFSelect_ContextWrite)

class Handle_IFSelect_DispPerSignature(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_DispPerSignature self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_DispPerSignature self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_DispPerSignature self, IFSelect_DispPerSignature thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_DispPerSignature self, Handle_IFSelect_DispPerSignature theHandle) -> Handle_IFSelect_DispPerSignature
        assign(Handle_IFSelect_DispPerSignature self, IFSelect_DispPerSignature thePtr) -> Handle_IFSelect_DispPerSignature
        assign(Handle_IFSelect_DispPerSignature self, Handle_IFSelect_DispPerSignature theHandle) -> Handle_IFSelect_DispPerSignature

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_DispPerSignature self) -> IFSelect_DispPerSignature

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_DispPerSignature self) -> IFSelect_DispPerSignature

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_DispPerSignature self) -> IFSelect_DispPerSignature

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_DispPerSignature___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_DispPerSignature___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_DispPerSignature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_DispPerSignature_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_DispPerSignature

    def SignCounter(self, *args):
        """
        SignCounter(Handle_IFSelect_DispPerSignature self) -> Handle_IFSelect_SignCounter

        Returns the SignCounter used for splitting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_SignCounter(self, *args)


    def SetSignCounter(self, *args):
        """
        SetSignCounter(Handle_IFSelect_DispPerSignature self, Handle_IFSelect_SignCounter sign)

        Sets a SignCounter for sort
        Remark : it is set to record lists of entities, not only counts

        :type sign: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_SetSignCounter(self, *args)


    def SignName(self, *args):
        """
        SignName(Handle_IFSelect_DispPerSignature self) -> Standard_CString

        Returns the name of the SignCounter, which caracterises the
        sorting criterium for this Dispatch

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_SignName(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_DispPerSignature self) -> TCollection_AsciiString

        Returns as Label, "One File per Signature <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(Handle_IFSelect_DispPerSignature self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum count is given as <nbent>

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(Handle_IFSelect_DispPerSignature self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It defines Packets from
        the SignCounter, which sirts the input Entities per Signature
        (specific of the SignCounter).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Packets(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_DispPerSignature self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerSignature_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerSignature_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_DispPerSignature self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_DispPerSignature self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.Handle_IFSelect_DispPerSignature_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(Handle_IFSelect_DispPerSignature self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(Handle_IFSelect_DispPerSignature self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(Handle_IFSelect_DispPerSignature self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(Handle_IFSelect_DispPerSignature self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_CanHaveRemainder(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(Handle_IFSelect_DispPerSignature self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_GetEntities(self, *args)


    def Packeted(self, *args):
        """
        Packeted(Handle_IFSelect_DispPerSignature self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(Handle_IFSelect_DispPerSignature self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Remainder(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_DispPerSignature self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_DispPerSignature self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_DispPerSignature self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_DispPerSignature self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_DispPerSignature self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_DispPerSignature self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_DispPerSignature self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_DispPerSignature self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_DispPerSignature self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerSignature_DecrementRefCounter(self, *args)

Handle_IFSelect_DispPerSignature_swigregister = _IFSelect.Handle_IFSelect_DispPerSignature_swigregister
Handle_IFSelect_DispPerSignature_swigregister(Handle_IFSelect_DispPerSignature)

def Handle_IFSelect_DispPerSignature_DownCast(thing):
    return _IFSelect.Handle_IFSelect_DispPerSignature_DownCast(thing)
Handle_IFSelect_DispPerSignature_DownCast = _IFSelect.Handle_IFSelect_DispPerSignature_DownCast

class IFSelect_EditForm(Standard.Standard_Transient):
    """
    An EditForm is the way to apply an Editor on an Entity or on
    the Model
    It gives read-only or read-write access, with or without undo

    It can be complete (all the values of the Editor are present)
    or partial (a sub-list of these value are present)
    Anyway, all references to Number (argument <num>) refer to
    Number of Value for the Editor
    While references to Rank are for rank in the EditForm, which
    may differ if it is not Complete
    Two methods give the correspondance between this Number and
    the Rank in the EditForm : RankFromNumber and NumberFromRank
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_EditForm
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_EditForm(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_EditForm self, Handle_IFSelect_Editor editor, Standard_Boolean const readonly, Standard_Boolean const undoable, Standard_CString const label) -> IFSelect_EditForm
        __init__(IFSelect_EditForm self, Handle_IFSelect_Editor editor, NCollection_Sequence_Standard_Integer nums, Standard_Boolean const readonly, Standard_Boolean const undoable, Standard_CString const label) -> IFSelect_EditForm

        Creates an extracted EditForm from an Editor, limited to
        the values identified in <nums>
        A specific Label can be given

        :type editor: OCC.wrapper.IFSelect.Handle_IFSelect_Editor
        :type nums: OCC.wrapper.TColStd.TColStd_SequenceOfInteger
        :type readonly: bool
        :type undoable: bool
        :type label: OCC.wrapper.Standard.Standard_CString

        """
        this = _IFSelect.new_IFSelect_EditForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def EditKeepStatus(self, *args):
        """
        EditKeepStatus(IFSelect_EditForm self) -> Standard_Boolean &

        Returns and may change the keep status on modif
        It starts as False
        If it is True, Apply does not clear modification status
        and the EditForm can be loaded again, modified value remain
        and may be applied again
        Remark that ApplyData does not clear the modification status,
        a call to ClearEdit does

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_EditKeepStatus(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_EditForm self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_EditForm_Label(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(IFSelect_EditForm self) -> Standard_Boolean

        Tells if the EditForm is loaded now

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_IsLoaded(self, *args)


    def ClearData(self, *args):
        """ClearData(IFSelect_EditForm self)"""
        return _IFSelect.IFSelect_EditForm_ClearData(self, *args)


    def SetData(self, *args):
        """
        SetData(IFSelect_EditForm self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_EditForm_SetData(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(IFSelect_EditForm self, Handle_Standard_Transient ent)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_EditForm_SetEntity(self, *args)


    def SetModel(self, *args):
        """
        SetModel(IFSelect_EditForm self, Handle_Interface_InterfaceModel model)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_EditForm_SetModel(self, *args)


    def Entity(self, *args):
        """
        Entity(IFSelect_EditForm self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.IFSelect_EditForm_Entity(self, *args)


    def Model(self, *args):
        """
        Model(IFSelect_EditForm self) -> Handle_Interface_InterfaceModel

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.IFSelect_EditForm_Model(self, *args)


    def Editor(self, *args):
        """
        Editor(IFSelect_EditForm self) -> Handle_IFSelect_Editor

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Editor

        """
        return _IFSelect.IFSelect_EditForm_Editor(self, *args)


    def IsComplete(self, *args):
        """
        IsComplete(IFSelect_EditForm self) -> Standard_Boolean

        Tells if an EditForm is complete or is an extract from Editor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_IsComplete(self, *args)


    def NbValues(self, *args):
        """
        NbValues(IFSelect_EditForm self, Standard_Boolean const editable) -> Standard_Integer

        Returns the count of values
        <editable> True : count of editable values, i.e.
        For a complete EditForm, it is given by the Editor
        Else, it is the length of the extraction map
        <editable> False : all the values from the Editor

        :type editable: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_EditForm_NbValues(self, *args)


    def NumberFromRank(self, *args):
        """
        NumberFromRank(IFSelect_EditForm self, Standard_Integer const rank) -> Standard_Integer

        Returns the Value Number in the Editor from a given Rank in
        the EditForm
        For a complete EditForm, both are equal
        Else, it is given by the extraction map
        Returns 0 if <rank> exceeds the count of editable values,

        :type rank: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_EditForm_NumberFromRank(self, *args)


    def RankFromNumber(self, *args):
        """
        RankFromNumber(IFSelect_EditForm self, Standard_Integer const number) -> Standard_Integer

        Returns the Rank in the EditForm from a given Number of Value
        for the Editor
        For a complete EditForm, both are equal
        Else, it is given by the extraction map
        Returns 0 if <number> is not forecast to be edited, or is
        out of range

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_EditForm_RankFromNumber(self, *args)


    def NameNumber(self, *args):
        """
        NameNumber(IFSelect_EditForm self, Standard_CString const name) -> Standard_Integer

        Returns the Value Number in the Editor for a given Name
        i.e. the true ValueNumber which can be used in various methods
        of EditForm
        If it is not complete, for a recorded (in the Editor) but
        non-loaded name, returns negative value (- number)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_EditForm_NameNumber(self, *args)


    def NameRank(self, *args):
        """
        NameRank(IFSelect_EditForm self, Standard_CString const name) -> Standard_Integer

        Returns the Rank of Value in the EditForm for a given Name
        i.e. if it is not complete, for a recorded (in the Editor) but
        non-loaded name, returns 0

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_EditForm_NameRank(self, *args)


    def LoadDefault(self, *args):
        """
        LoadDefault(IFSelect_EditForm self)

        For a read-write undoable EditForm, loads original values
        from defaults stored in the Editor


        """
        return _IFSelect.IFSelect_EditForm_LoadDefault(self, *args)


    def LoadEntity(self, *args):
        """
        LoadEntity(IFSelect_EditForm self, Handle_Standard_Transient ent) -> Standard_Boolean

        Shortcut for LoadData when <model> is not used

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_LoadEntity(self, *args)


    def LoadModel(self, *args):
        """
        LoadModel(IFSelect_EditForm self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Shortcut for LoadData when only the model is concerned

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_LoadModel(self, *args)


    def LoadData(self, *args):
        """
        LoadData(IFSelect_EditForm self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean
        LoadData(IFSelect_EditForm self) -> Standard_Boolean

        Shortcut when both <ent> and <model> are not used
        (when the Editor works on fully static or global data)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_LoadData(self, *args)


    def ListEditor(self, *args):
        """
        ListEditor(IFSelect_EditForm self, Standard_Integer const num) -> Handle_IFSelect_ListEditor

        Returns a ListEditor to edit the parameter <num> of the
        EditForm, if it is a List
        The Editor created it (by ListEditor) then loads it (by
        ListValue)
        For a single parameter, returns a Null Handle ...

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor

        """
        return _IFSelect.IFSelect_EditForm_ListEditor(self, *args)


    def LoadValue(self, *args):
        """
        LoadValue(IFSelect_EditForm self, Standard_Integer const num, Handle_TCollection_HAsciiString val)

        Loads an original value (single). Called by the Editor only

        :type num: int
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_EditForm_LoadValue(self, *args)


    def LoadList(self, *args):
        """
        LoadList(IFSelect_EditForm self, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString list)

        Loads an original value as a list. Called by the Editor only

        :type num: int
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_EditForm_LoadList(self, *args)


    def OriginalValue(self, *args):
        """
        OriginalValue(IFSelect_EditForm self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        From an edited value, returns its ... value (original one)
        Null means that this value is not defined
        <num> is for the EditForm, not the Editor
        It is for a single parameter. For a list, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_EditForm_OriginalValue(self, *args)


    def OriginalList(self, *args):
        """
        OriginalList(IFSelect_EditForm self, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns an original value, as a list
        <num> is for the EditForm, not the Editor
        For a single parameter, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_EditForm_OriginalList(self, *args)


    def EditedValue(self, *args):
        """
        EditedValue(IFSelect_EditForm self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns the Edited (i.e. Modified) Value (string for single)
        <num> reports to the EditForm
        If IsModified is False, returns OriginalValue
        Null with IsModified True : means that this value is not
        defined or has been removed
        It is for a single parameter. For a list, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.IFSelect_EditForm_EditedValue(self, *args)


    def EditedList(self, *args):
        """
        EditedList(IFSelect_EditForm self, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the Edited Value as a list
        If IsModified is False, returns OriginalValue
        Null with IsModified True : means that this value is not
        defined or has been removed
        For a single parameter, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.IFSelect_EditForm_EditedList(self, *args)


    def IsModified(self, *args):
        """
        IsModified(IFSelect_EditForm self, Standard_Integer const num) -> Standard_Boolean

        Tells if a Value (of the EditForm) is modified (directly or
        through touching by Update)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_IsModified(self, *args)


    def IsTouched(self, *args):
        """
        IsTouched(IFSelect_EditForm self, Standard_Integer const num) -> Standard_Boolean

        Tells if a Value (of the EditForm) has been touched, i.e.
        not modified directly but by the modification of another one
        (by method Update from the Editor)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_IsTouched(self, *args)


    def Modify(self, *args):
        """
        Modify(IFSelect_EditForm self, Standard_Integer const num, Handle_TCollection_HAsciiString newval, Standard_Boolean const enforce) -> Standard_Boolean

        Gives a new value for the item <num> of the EditForm, if
        it is a single parameter (for a list, just returns False)
        Null means to Remove it
        <enforce> True to overpass Protected or Computed Access Mode
        Calls the method Update from the Editor, which can touch other
        parameters (see NbTouched)
        Returns True if well recorded, False if this value is not
        allowed
        Warning : Does not apply immediately : will be applied by the method
        Apply

        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_Modify(self, *args)


    def ModifyList(self, *args):
        """
        ModifyList(IFSelect_EditForm self, Standard_Integer const num, Handle_IFSelect_ListEditor edited, Standard_Boolean const enforce) -> Standard_Boolean

        Changes the value of an item of the EditForm, if it is a List
        (else, just returns False)
        The ListEditor contains the edited values of the list
        If no edition was recorded, just returns False
        Calls the method Update from the Editor, which can touch other
        parameters (see NbTouched)
        Returns True if well recorded, False if this value is not
        allowed
        Warning : Does not apply immediately : will be applied by the method
        Apply

        :type num: int
        :type edited: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_ModifyList(self, *args)


    def ModifyListValue(self, *args):
        """
        ModifyListValue(IFSelect_EditForm self, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString list, Standard_Boolean const enforce) -> Standard_Boolean

        As ModifyList but the new value is given as such
        Creates a ListEditor, Loads it, then calls ModifyList

        :type num: int
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_ModifyListValue(self, *args)


    def Touch(self, *args):
        """
        Touch(IFSelect_EditForm self, Standard_Integer const num, Handle_TCollection_HAsciiString newval) -> Standard_Boolean

        Gives a new value computed by the Editor, if another parameter
        commands the value of <num>
        It is generally the case for a Computed Parameter for instance
        Increments the counter of touched parameters
        Warning : it gives no protection for ReadOnly etc... while it is the
        internal way of touching parameters
        Does not work (returns False) if <num> is for a list

        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_Touch(self, *args)


    def TouchList(self, *args):
        """
        TouchList(IFSelect_EditForm self, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString newlist) -> Standard_Boolean

        Acts as Touch but for a list
        Does not work (returns False) if <num> is for a single param

        :type num: int
        :type newlist: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_TouchList(self, *args)


    def ClearEdit(self, *args):
        """
        ClearEdit(IFSelect_EditForm self, Standard_Integer const num=0)

        Clears modification status : by default all, or one by its
        numbers (in the Editor)

        :type num: int

        """
        return _IFSelect.IFSelect_EditForm_ClearEdit(self, *args)


    def PrintDefs(self, *args):
        """
        PrintDefs(IFSelect_EditForm self, Handle_Message_Messenger S)

        Prints Definitions, relative to the Editor

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.IFSelect_EditForm_PrintDefs(self, *args)


    def PrintValues(self, *args):
        """
        PrintValues(IFSelect_EditForm self, Handle_Message_Messenger S, Standard_Integer const what, Standard_Boolean const names, Standard_Boolean const alsolist)

        Prints Values, according to what and alsolist
        <names> True : prints Long Names; False : prints Short Names
        <what> < 0 : prints Original Values (+ flag Modified)
        <what> > 0 : prints Final Values (+flag Modified)
        <what> = 0 : prints Modified Values (Original + Edited)
        <alsolist> False (D) : lists are printed only as their count
        <alsolist> True : lists are printed for all their items

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type what: int
        :type names: bool
        :type alsolist: bool

        """
        return _IFSelect.IFSelect_EditForm_PrintValues(self, *args)


    def Apply(self, *args):
        """
        Apply(IFSelect_EditForm self) -> Standard_Boolean

        Applies modifications to own data
        Calls ApplyData then Clears Status according EditKeepStatus

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_Apply(self, *args)


    def Recognize(self, *args):
        """
        Recognize(IFSelect_EditForm self) -> Standard_Boolean

        Tells if this EditForm can work with its Editor and its actual
        Data (Entity and Model)
        Default uses Editor. Can be redefined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_Recognize(self, *args)


    def ApplyData(self, *args):
        """
        ApplyData(IFSelect_EditForm self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Applies modifications to data
        Default uses Editor. Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_ApplyData(self, *args)


    def Undo(self, *args):
        """
        Undo(IFSelect_EditForm self) -> Standard_Boolean

        For an undoable EditForm, Applies ... origibal values !
        and clears modified ones
        Can be run only once

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_EditForm_Undo(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_EditForm_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_EditForm_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_EditForm_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_EditForm
IFSelect_EditForm_swigregister = _IFSelect.IFSelect_EditForm_swigregister
IFSelect_EditForm_swigregister(IFSelect_EditForm)

def IFSelect_EditForm_get_type_name(*args):
    """
    IFSelect_EditForm_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_EditForm_get_type_name(*args)

def IFSelect_EditForm_get_type_descriptor(*args):
    """
    IFSelect_EditForm_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_EditForm_get_type_descriptor(*args)

class IFSelect_SelectErrorEntities(IFSelect_SelectExtract):
    """
    A SelectErrorEntities sorts the Entities which are qualified
    as "Error" (their Type has not been recognized) during reading
    a File. This does not concern Entities which are syntactically
    correct, but with incorrect data (for integrity constraints).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectErrorEntities
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectErrorEntities(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectErrorEntities self) -> IFSelect_SelectErrorEntities

        Creates a SelectErrorEntities


        """
        this = _IFSelect.new_IFSelect_SelectErrorEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sort(self, *args):
        """
        Sort(IFSelect_SelectErrorEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is qualified as "Error", i.e.
        if <model> explicitly knows <ent> (through its Number) as
        Erroneous

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectErrorEntities_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectErrorEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Error Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectErrorEntities_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectErrorEntities_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectErrorEntities_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectErrorEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectErrorEntities
IFSelect_SelectErrorEntities_swigregister = _IFSelect.IFSelect_SelectErrorEntities_swigregister
IFSelect_SelectErrorEntities_swigregister(IFSelect_SelectErrorEntities)

def IFSelect_SelectErrorEntities_get_type_name(*args):
    """
    IFSelect_SelectErrorEntities_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectErrorEntities_get_type_name(*args)

def IFSelect_SelectErrorEntities_get_type_descriptor(*args):
    """
    IFSelect_SelectErrorEntities_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectErrorEntities_get_type_descriptor(*args)

class Handle_IFSelect_SelectBase(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectBase self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectBase_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectBase self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectBase_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectBase self, IFSelect_SelectBase thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectBase_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectBase self, Handle_IFSelect_SelectBase theHandle) -> Handle_IFSelect_SelectBase
        assign(Handle_IFSelect_SelectBase self, IFSelect_SelectBase thePtr) -> Handle_IFSelect_SelectBase
        assign(Handle_IFSelect_SelectBase self, Handle_IFSelect_SelectBase theHandle) -> Handle_IFSelect_SelectBase

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectBase_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectBase self) -> IFSelect_SelectBase

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectBase_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectBase self) -> IFSelect_SelectBase

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectBase___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectBase self) -> IFSelect_SelectBase

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectBase___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectBase___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectBase___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectBase_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectBase

    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectBase self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list is empty for all SelectBase type Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectBase_FillIterator(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectBase self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectBase_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectBase_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectBase_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectBase self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, computed from Input
        given as a Graph. Specific to each class of Selection
        Note that uniqueness of each entity is not required here
        This method can raise an exception as necessary

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectBase_RootResult(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectBase self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectBase_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectBase self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectBase_CompleteResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectBase self) -> TCollection_AsciiString

        Returns a text which defines the criterium applied by a
        Selection (can be used to be printed, displayed ...)
        Specific to each class

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectBase_Label(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectBase self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectBase_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectBase self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectBase self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectBase_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectBase self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectBase self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectBase_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectBase self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectBase_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectBase self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectBase_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectBase self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectBase_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectBase self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectBase_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectBase_swigregister = _IFSelect.Handle_IFSelect_SelectBase_swigregister
Handle_IFSelect_SelectBase_swigregister(Handle_IFSelect_SelectBase)

def Handle_IFSelect_SelectBase_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectBase_DownCast(thing)
Handle_IFSelect_SelectBase_DownCast = _IFSelect.Handle_IFSelect_SelectBase_DownCast

class IFSelect_SelectionIterator(object):
    """Defines an Iterator on a list of Selections"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFSelect_SelectionIterator self) -> IFSelect_SelectionIterator
        __init__(IFSelect_SelectionIterator self, Handle_IFSelect_Selection sel) -> IFSelect_SelectionIterator

        Creates an iterator from a Selection : it lists the Selections
        from which <sel> depends (given by its method FillIterator)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        this = _IFSelect.new_IFSelect_SelectionIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFromIter(self, *args):
        """
        AddFromIter(IFSelect_SelectionIterator self, IFSelect_SelectionIterator iter)

        Adds to an iterator the content of another one
        (each selection is present only once in the result)

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_SelectionIterator_AddFromIter(self, *args)


    def AddItem(self, *args):
        """
        AddItem(IFSelect_SelectionIterator self, Handle_IFSelect_Selection sel)

        Adds a Selection to an iterator (if not yet noted)

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.IFSelect_SelectionIterator_AddItem(self, *args)


    def AddList(self, *args):
        """
        AddList(IFSelect_SelectionIterator self, NCollection_Sequence_Handle_IFSelect_Selection list)

        Adds a list of Selections to an iterator (this list comes
        from the description of a Selection or a Dispatch, etc...)

        :type list: OCC.wrapper.IFSelect.IFSelect_TSeqOfSelection

        """
        return _IFSelect.IFSelect_SelectionIterator_AddList(self, *args)


    def More(self, *args):
        """
        More(IFSelect_SelectionIterator self) -> Standard_Boolean

        Returns True if there are more Selections to get

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectionIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(IFSelect_SelectionIterator self)

        Sets iterator to the next item


        """
        return _IFSelect.IFSelect_SelectionIterator_Next(self, *args)


    def Value(self, *args):
        """
        Returns the current Selction beeing iterated
        Error if count of Selection has been passed

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        res = _IFSelect.IFSelect_SelectionIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectionIterator
IFSelect_SelectionIterator_swigregister = _IFSelect.IFSelect_SelectionIterator_swigregister
IFSelect_SelectionIterator_swigregister(IFSelect_SelectionIterator)

class Handle_IFSelect_AppliedModifiers(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_AppliedModifiers self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_AppliedModifiers self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_AppliedModifiers self, IFSelect_AppliedModifiers thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_AppliedModifiers self, Handle_IFSelect_AppliedModifiers theHandle) -> Handle_IFSelect_AppliedModifiers
        assign(Handle_IFSelect_AppliedModifiers self, IFSelect_AppliedModifiers thePtr) -> Handle_IFSelect_AppliedModifiers
        assign(Handle_IFSelect_AppliedModifiers self, Handle_IFSelect_AppliedModifiers theHandle) -> Handle_IFSelect_AppliedModifiers

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_AppliedModifiers self) -> IFSelect_AppliedModifiers

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_AppliedModifiers self) -> IFSelect_AppliedModifiers

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_AppliedModifiers self) -> IFSelect_AppliedModifiers

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_AppliedModifiers___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_AppliedModifiers___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_AppliedModifiers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_AppliedModifiers_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_AppliedModifiers

    def AddModif(self, *args):
        """
        AddModif(Handle_IFSelect_AppliedModifiers self, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Records a modifier. By default, it is to apply on all a
        produced file. Further calls to AddNum will restrict this.
        Returns True if done, False if too many modifiers are already
        recorded

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_AddModif(self, *args)


    def AddNum(self, *args):
        """
        AddNum(Handle_IFSelect_AppliedModifiers self, Standard_Integer const nument) -> Standard_Boolean

        Adds a number of entity of the output file to be applied on.
        If a sequence of AddNum is called after AddModif, this
        Modifier will be applied on the list of designated entities.
        Else, it will be applied on all the file
        Returns True if done, False if no modifier has yet been added

        :type nument: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_AddNum(self, *args)


    def Count(self, *args):
        """
        Count(Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Returns the count of recorded modifiers

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_Count(self, *args)


    def Item(self, *args):
        """
        Item(Handle_IFSelect_AppliedModifiers self, Standard_Integer const num, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Returns the description for applied modifier n0 <num> :
        the modifier itself, and the count of entities to be applied
        on. If no specific list of number has been defined, returns
        the total count of entities of the file
        If this count is zero, then the modifier applies to all
        the file (see below). Else, the numbers are then queried by
        calls to ItemNum between 1 and <entcount>
        Returns True if OK, False if <num> is out of range

        :type num: int
        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type entcount: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_Item(self, *args)


    def ItemNum(self, *args):
        """
        ItemNum(Handle_IFSelect_AppliedModifiers self, Standard_Integer const nument) -> Standard_Integer

        Returns a numero of entity to be applied on, given its rank
        in the list. If no list is defined (i.e. for all the file),
        returns <nument> itself, to give all the entities of the file
        Returns 0 if <nument> out of range

        :type nument: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_ItemNum(self, *args)


    def ItemList(self, *args):
        """
        ItemList(Handle_IFSelect_AppliedModifiers self) -> Handle_TColStd_HSequenceOfInteger

        Returns the list of entities to be applied on (see Item)
        as a HSequence (IsForAll produces the complete list of all
        the entity numbers of the file

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_ItemList(self, *args)


    def IsForAll(self, *args):
        """
        IsForAll(Handle_IFSelect_AppliedModifiers self) -> Standard_Boolean

        Returns True if the applied modifier queried by last call to
        Item is to be applied to all the produced file.
        Else, <entcount> returned by Item gives the count of entity
        numbers, each one is queried by ItemNum

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_IsForAll(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_AppliedModifiers self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_AppliedModifiers_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_AppliedModifiers_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_AppliedModifiers self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_AppliedModifiers self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_AppliedModifiers self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_AppliedModifiers self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_AppliedModifiers self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_AppliedModifiers self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_AppliedModifiers self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_AppliedModifiers self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_AppliedModifiers_DecrementRefCounter(self, *args)

Handle_IFSelect_AppliedModifiers_swigregister = _IFSelect.Handle_IFSelect_AppliedModifiers_swigregister
Handle_IFSelect_AppliedModifiers_swigregister(Handle_IFSelect_AppliedModifiers)

def Handle_IFSelect_AppliedModifiers_DownCast(thing):
    return _IFSelect.Handle_IFSelect_AppliedModifiers_DownCast(thing)
Handle_IFSelect_AppliedModifiers_DownCast = _IFSelect.Handle_IFSelect_AppliedModifiers_DownCast

class Handle_IFSelect_DispPerCount(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_DispPerCount self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_DispPerCount self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_DispPerCount self, IFSelect_DispPerCount thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_DispPerCount self, Handle_IFSelect_DispPerCount theHandle) -> Handle_IFSelect_DispPerCount
        assign(Handle_IFSelect_DispPerCount self, IFSelect_DispPerCount thePtr) -> Handle_IFSelect_DispPerCount
        assign(Handle_IFSelect_DispPerCount self, Handle_IFSelect_DispPerCount theHandle) -> Handle_IFSelect_DispPerCount

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_DispPerCount self) -> IFSelect_DispPerCount

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_DispPerCount self) -> IFSelect_DispPerCount

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_DispPerCount___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_DispPerCount self) -> IFSelect_DispPerCount

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_DispPerCount___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_DispPerCount___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_DispPerCount___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_DispPerCount(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_DispPerCount_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_DispPerCount

    def Count(self, *args):
        """
        Count(Handle_IFSelect_DispPerCount self) -> Handle_IFSelect_IntParam

        Returns the Count Parameter used for splitting

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Count(self, *args)


    def SetCount(self, *args):
        """
        SetCount(Handle_IFSelect_DispPerCount self, Handle_IFSelect_IntParam count)

        Sets a new Parameter for Count

        :type count: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_SetCount(self, *args)


    def CountValue(self, *args):
        """
        CountValue(Handle_IFSelect_DispPerCount self) -> Standard_Integer

        Returns the effective value of the count parameter
        (if Count Parameter not Set or value not positive, returns 1)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_CountValue(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_DispPerCount self) -> TCollection_AsciiString

        Returns as Label, "One File per <count> Input Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Label(self, *args)


    def LimitedMax(self, *args):
        """
        LimitedMax(Handle_IFSelect_DispPerCount self, Standard_Integer const nbent) -> Standard_Boolean

        Returns True, maximum count is given as <nbent>

        :type nbent: int
        :type max: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_LimitedMax(self, *args)


    def Packets(self, *args):
        """
        Packets(Handle_IFSelect_DispPerCount self, Interface_Graph G, IFGraph_SubPartsIterator packs)

        Computes the list of produced Packets. It defines Packets in
        order to have at most <Count> Entities per Packet, Entities
        are given by RootResult from the Final Selection.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type packs: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Packets(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_DispPerCount self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerCount_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_DispPerCount_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_DispPerCount self, Handle_TCollection_HAsciiString name)

        Sets a Root Name as an HAsciiString
        To reset it, give a Null Handle (then, a ShareOut will have
        to define the Default Root Name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_DispPerCount self) -> Standard_Boolean

        Returns True if a specific Root Name has been set
        (else, the Default Root Name has to be used)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_HasRootName(self, *args)


    def RootName(self, *args):
        """
        Returns the Root Name for files produced by this dispatch
        It is empty if it has not been set or if it has been reset

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _IFSelect.Handle_IFSelect_DispPerCount_RootName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFinalSelection(self, *args):
        """
        SetFinalSelection(Handle_IFSelect_DispPerCount self, Handle_IFSelect_Selection sel)

        Stores (or Changes) the Final Selection for a Dispatch

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_SetFinalSelection(self, *args)


    def FinalSelection(self, *args):
        """
        FinalSelection(Handle_IFSelect_DispPerCount self) -> Handle_IFSelect_Selection

        Returns the Final Selection of a Dispatch
        we 'd like : C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_FinalSelection(self, *args)


    def Selections(self, *args):
        """
        Selections(Handle_IFSelect_DispPerCount self) -> IFSelect_SelectionIterator

        Returns the complete list of source Selections (starting
        from FinalSelection)

        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Selections(self, *args)


    def CanHaveRemainder(self, *args):
        """
        CanHaveRemainder(Handle_IFSelect_DispPerCount self) -> Standard_Boolean

        Returns True if a Dispatch can have a Remainder, i.e. if its
        criterium can let entities apart. It is a potential answer,
        remainder can be empty at run-time even if answer is True.
        (to attach a RemainderFromDispatch Selection is not allowed if
        answer is True).
        Default answer given here is False (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_CanHaveRemainder(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(Handle_IFSelect_DispPerCount self, Interface_Graph G) -> Interface_EntityIterator

        Gets Unique Root Entities from the Final Selection, given an
        input Graph
        This the starting step for an Evaluation (Packets - Remainder)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_GetEntities(self, *args)


    def Packeted(self, *args):
        """
        Packeted(Handle_IFSelect_DispPerCount self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of all Input Entities (see GetEntities) which
        are put in a Packet. That is, Entities listed in GetEntities
        but not in Remainder (see below). Input is given as a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Packeted(self, *args)


    def Remainder(self, *args):
        """
        Remainder(Handle_IFSelect_DispPerCount self, Interface_Graph G) -> Interface_EntityIterator

        Returns Remainder which is a set of Entities. Can be empty.
        Default evaluation is empty (has to be redefined if
        CanHaveRemainder is redefined to return True).

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Remainder(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_DispPerCount self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_DispPerCount_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_DispPerCount self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_DispPerCount self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_DispPerCount self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_DispPerCount self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_DispPerCount self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_DispPerCount self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_DispPerCount self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_DispPerCount_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_DispPerCount self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_DispPerCount_DecrementRefCounter(self, *args)

Handle_IFSelect_DispPerCount_swigregister = _IFSelect.Handle_IFSelect_DispPerCount_swigregister
Handle_IFSelect_DispPerCount_swigregister(Handle_IFSelect_DispPerCount)

def Handle_IFSelect_DispPerCount_DownCast(thing):
    return _IFSelect.Handle_IFSelect_DispPerCount_DownCast(thing)
Handle_IFSelect_DispPerCount_DownCast = _IFSelect.Handle_IFSelect_DispPerCount_DownCast

class IFSelect_SelectSuite(IFSelect_SelectDeduct):
    """
    A SelectSuite can describe a suite of SelectDeduct as a unique
    one : in other words, it can be seen as a "macro selection"

    It works by applying each of its items (which is a
    SelectDeduct) on the result computed by the previous one
    (by using Alternate Input)

    But each of these Selections used as items may be used
    independently, it will then give its own result

    Hence, SelectSuite gives a way of defining a new Selection
    from existing ones, without having to do copies or saves
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectSuite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectSuite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectSuite self) -> IFSelect_SelectSuite

        Creates an empty SelectSuite


        """
        this = _IFSelect.new_IFSelect_SelectSuite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddInput(self, *args):
        """
        AddInput(IFSelect_SelectSuite self, Handle_IFSelect_Selection item) -> Standard_Boolean

        Adds an input selection. I.E. :
        If <item> is a SelectDeduct, adds it as Previous, not as Input
        Else, sets it as Input
        Returns True when done
        Returns False and refuses to work if Input is already defined

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSuite_AddInput(self, *args)


    def AddPrevious(self, *args):
        """
        AddPrevious(IFSelect_SelectSuite self, Handle_IFSelect_SelectDeduct item)

        Adds a new first item (prepends to the list). The Input is not
        touched
        If <item> is null, does nothing

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.IFSelect_SelectSuite_AddPrevious(self, *args)


    def AddNext(self, *args):
        """
        AddNext(IFSelect_SelectSuite self, Handle_IFSelect_SelectDeduct item)

        Adds a new last item (prepends to the list)
        If <item> is null, does nothing

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.IFSelect_SelectSuite_AddNext(self, *args)


    def NbItems(self, *args):
        """
        NbItems(IFSelect_SelectSuite self) -> Standard_Integer

        Returns the count of Items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.IFSelect_SelectSuite_NbItems(self, *args)


    def Item(self, *args):
        """
        Item(IFSelect_SelectSuite self, Standard_Integer const num) -> Handle_IFSelect_SelectDeduct

        Returns an item from its rank in the list
        (the Input is always apart)

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.IFSelect_SelectSuite_Item(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(IFSelect_SelectSuite self, Standard_CString const lab)

        Sets a value for the Label

        :type lab: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.IFSelect_SelectSuite_SetLabel(self, *args)


    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectSuite self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities
        To do this, once InputResult has been taken (if Input or
        Alternate has been defined, else the first Item gives it) :
        this result is set as alternate input for the first item,
        which computes its result : this result is set as alternate
        input for the second item, etc...

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectSuite_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectSuite self) -> TCollection_AsciiString

        Returns the Label
        Either it has been defined by SetLabel, or it will give
        "Suite of nn Selections"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSuite_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectSuite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectSuite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectSuite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSuite
IFSelect_SelectSuite_swigregister = _IFSelect.IFSelect_SelectSuite_swigregister
IFSelect_SelectSuite_swigregister(IFSelect_SelectSuite)

def IFSelect_SelectSuite_get_type_name(*args):
    """
    IFSelect_SelectSuite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectSuite_get_type_name(*args)

def IFSelect_SelectSuite_get_type_descriptor(*args):
    """
    IFSelect_SelectSuite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectSuite_get_type_descriptor(*args)

class IFSelect_SelectRoots(IFSelect_SelectExtract):
    """
    A SelectRoots sorts the Entities which are local roots of a
    set of Entities (not shared by other Entities inside this set,
    even if they are shared by other Entities outside it)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectRoots
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectRoots(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectRoots self) -> IFSelect_SelectRoots

        Creates a SelectRoots


        """
        this = _IFSelect.new_IFSelect_SelectRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of local roots. It is redefined for a purpose
        of effeciency : calling a Sort routine for each Entity would
        cost more ressource than to work in once using a Map
        RootResult takes in account the Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectRoots_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(IFSelect_SelectRoots self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always True, because RootResult has done work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectRoots_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(IFSelect_SelectRoots self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Local Root Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectRoots_ExtractLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectRoots_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectRoots_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectRoots_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectRoots
IFSelect_SelectRoots_swigregister = _IFSelect.IFSelect_SelectRoots_swigregister
IFSelect_SelectRoots_swigregister(IFSelect_SelectRoots)

def IFSelect_SelectRoots_get_type_name(*args):
    """
    IFSelect_SelectRoots_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectRoots_get_type_name(*args)

def IFSelect_SelectRoots_get_type_descriptor(*args):
    """
    IFSelect_SelectRoots_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectRoots_get_type_descriptor(*args)

class Handle_IFSelect_WorkSession(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_WorkSession self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_WorkSession_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_WorkSession self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_WorkSession self, IFSelect_WorkSession thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_WorkSession_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_WorkSession self, Handle_IFSelect_WorkSession theHandle) -> Handle_IFSelect_WorkSession
        assign(Handle_IFSelect_WorkSession self, IFSelect_WorkSession thePtr) -> Handle_IFSelect_WorkSession
        assign(Handle_IFSelect_WorkSession self, Handle_IFSelect_WorkSession theHandle) -> Handle_IFSelect_WorkSession

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_WorkSession_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_WorkSession self) -> IFSelect_WorkSession

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_WorkSession_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_WorkSession self) -> IFSelect_WorkSession

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_WorkSession___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_WorkSession self) -> IFSelect_WorkSession

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_WorkSession___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_WorkSession___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_WorkSession___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_WorkSession(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_WorkSession_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_WorkSession

    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Handle_IFSelect_WorkSession self, Standard_Boolean const toHandle)

        Changes the Error Handler status (by default, it is not set)

        :type toHandle: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Handle_IFSelect_WorkSession self) -> Standard_Boolean

        Returns the Error Handler status

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ErrorHandle(self, *args)


    def ShareOut(self, *args):
        """
        Returns the ShareOut defined at creation time

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_ShareOut(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShareOut(self, *args):
        """
        SetShareOut(Handle_IFSelect_WorkSession self, Handle_IFSelect_ShareOut shareout)

        Sets a new ShareOut. Fills Items which its content
        Warning : data from the former ShareOut are lost

        :type shareout: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetShareOut(self, *args)


    def SetModeStat(self, *args):
        """
        SetModeStat(Handle_IFSelect_WorkSession self, Standard_Boolean const theMode)

        Set value of mode responsible for precence of selections after loading
        If mode set to true that different selections will be accessible after loading
        else selections will be not accessible after loading( for economy memory in applicatios)

        :type theMode: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetModeStat(self, *args)


    def GetModeStat(self, *args):
        """
        GetModeStat(Handle_IFSelect_WorkSession self) -> Standard_Boolean

        Return value of mode defining of filling selection during loading

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GetModeStat(self, *args)


    def SetLibrary(self, *args):
        """
        SetLibrary(Handle_IFSelect_WorkSession self, Handle_IFSelect_WorkLibrary theLib)

        Sets a WorkLibrary, which will be used to Read and Write Files

        :type theLib: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetLibrary(self, *args)


    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary. Null Handle if not yet set
        should be C++ : return const &

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_IFSelect_WorkSession self, Handle_Interface_Protocol protocol)

        Sets a Protocol, which will be used to determine Graphs, to
        Read and to Write Files

        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol. Null Handle if not yet set
        should be C++ : return const &

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSignType(self, *args):
        """
        SetSignType(Handle_IFSelect_WorkSession self, Handle_IFSelect_Signature signtype)

        Sets a specific Signature to be the SignType, i.e. the
        Signature which will determine TypeName from the Model
        (basic function). It is recorded in the GTool
        This Signature is also set as "xst-sign-type" (reserved name)

        :type signtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetSignType(self, *args)


    def SignType(self, *args):
        """
        SignType(Handle_IFSelect_WorkSession self) -> Handle_IFSelect_Signature

        Returns the current SignType

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SignType(self, *args)


    def HasModel(self, *args):
        """
        HasModel(Handle_IFSelect_WorkSession self) -> Standard_Boolean

        Returns True is a Model has been set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_HasModel(self, *args)


    def SetModel(self, *args):
        """
        SetModel(Handle_IFSelect_WorkSession self, Handle_Interface_InterfaceModel model, Standard_Boolean const clearpointed)

        Sets a Model as input : this will be the Model from which the
        ShareOut will work
        if <clearpointed> is True (default) all SelectPointed items
        are cleared, else they must be managed by the caller
        Remark : SetModel clears the Graph, recomputes it if a
        Protocol is set and if the Model is not empty, of course

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type clearpointed: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetModel(self, *args)


    def Model(self, *args):
        """
        Returns the Model of the Work Session (Null Handle if none)
        should be C++ : return const &

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLoadedFile(self, *args):
        """
        SetLoadedFile(Handle_IFSelect_WorkSession self, Standard_CString const theFileName)

        Stores the filename used for read for setting the model
        It is cleared by SetModel and ClearData(1)

        :type theFileName: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetLoadedFile(self, *args)


    def LoadedFile(self, *args):
        """
        LoadedFile(Handle_IFSelect_WorkSession self) -> Standard_CString

        Returns the filename used to load current model
        empty if unknown

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_LoadedFile(self, *args)


    def ReadFile(self, *args):
        """
        ReadFile(Handle_IFSelect_WorkSession self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Reads a file with the WorkLibrary (sets Model and LoadedFile)
        Returns a integer status which can be :
        RetDone if OK,  RetVoid if no Protocol not defined,
        RetError for file not found, RetFail if fail during read

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ReadFile(self, *args)


    def NbStartingEntities(self, *args):
        """
        NbStartingEntities(Handle_IFSelect_WorkSession self) -> Standard_Integer

        Returns the count of Entities stored in the Model, or 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NbStartingEntities(self, *args)


    def StartingEntity(self, *args):
        """
        StartingEntity(Handle_IFSelect_WorkSession self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns an  Entity stored in the Model of the WorkSession
        (Null Handle is no Model or num out of range)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_StartingEntity(self, *args)


    def StartingNumber(self, *args):
        """
        StartingNumber(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Number of an Entity in the Model
        (0 if no Model set or <ent> not in the Model)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_StartingNumber(self, *args)


    def NumberFromLabel(self, *args):
        """
        NumberFromLabel(Handle_IFSelect_WorkSession self, Standard_CString const val, Standard_Integer const afternum=0) -> Standard_Integer

        From a given label in Model, returns the corresponding number
        Starts from first entity by Default, may start after a given
        number : this number may be given negative, its absolute value
        is then considered. Hence a loop on NumberFromLabel may be
        programmed (stop test is : returned value positive or null)

        Returns 0 if not found, < 0 if more than one found (first
        found in negative).
        If <val> just gives an integer value, returns it

        :type val: OCC.wrapper.Standard.Standard_CString
        :type afternum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NumberFromLabel(self, *args)


    def EntityLabel(self, *args):
        """
        EntityLabel(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns the label for <ent>, as the Model does
        If <ent> is not in the Model or if no Model is loaded, a Null
        Handle is returned

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EntityLabel(self, *args)


    def EntityName(self, *args):
        """
        EntityName(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns the Name of an Entity
        This Name is computed by the general service Name
        Returns a Null Handle if fails

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EntityName(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Category Number determined for an entity
        it is computed by the class Category
        An unknown entity (number 0) gives a value -1

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_CategoryNumber(self, *args)


    def CategoryName(self, *args):
        """
        CategoryName(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Category Name determined for an entity
        it is computed by the class Category
        Remark : an unknown entity gives an empty string

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_CategoryName(self, *args)


    def ValidityName(self, *args):
        """
        ValidityName(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Validity Name determined for an entity
        it is computed by the class SignValidity
        Remark : an unknown entity gives an empty string

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ValidityName(self, *args)


    def ClearData(self, *args):
        """
        ClearData(Handle_IFSelect_WorkSession self, Standard_Integer const mode)

        Clears recorded data (not the items) according mode :
        1 : all Data : Model, Graph, CheckList, + ClearData 4
        2 : Graph and CheckList (they will then be recomputed later)
        3 : CheckList (it will be recomputed by ComputeCheck)
        4 : just content of SelectPointed and Counters
        Plus 0 : does nothing but called by SetModel
        ClearData is virtual, hence it can be redefined to clear
        other data of a specialised Work Session

        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ClearData(self, *args)


    def ComputeGraph(self, *args):
        """
        ComputeGraph(Handle_IFSelect_WorkSession self, Standard_Boolean const enforce) -> Standard_Boolean

        Computes the Graph used for Selections, Displays ...
        If a HGraph is already set, with same model as given by method
        Model, does nothing. Else, computes a new Graph.
        If <enforce> is given True, computes a new Graph anyway.
        Remark that a call to ClearGraph will cause ComputeGraph to
        really compute a new Graph
        Returns True if Graph is OK, False else (i.e. if no Protocol
        is set, or if Model is absent or empty).

        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ComputeGraph(self, *args)


    def HGraph(self, *args):
        """
        HGraph(Handle_IFSelect_WorkSession self) -> Handle_Interface_HGraph

        Returns the Computed Graph as HGraph (Null Handle if not set)

        :rtype: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _IFSelect.Handle_IFSelect_WorkSession_HGraph(self, *args)


    def Graph(self, *args):
        """
        Returns the Computed Graph, for Read only

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shareds(self, *args):
        """
        Shareds(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities shared by <ent> (can be empty)
        Returns a null Handle if <ent> is unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Shareds(self, *args)


    def Sharings(self, *args):
        """
        Sharings(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities sharing <ent> (can be empty)
        Returns a null Handle if <ent> is unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Sharings(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(Handle_IFSelect_WorkSession self) -> Standard_Boolean

        Returns True if a Model is defined and really loaded (not
        empty), a Protocol is set and a Graph has been computed.
        In this case, the WorkSession can start to work

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IsLoaded(self, *args)


    def ComputeCheck(self, *args):
        """
        ComputeCheck(Handle_IFSelect_WorkSession self, Standard_Boolean const enforce) -> Standard_Boolean

        Computes the CheckList for the Model currently loaded
        It can then be used for displays, querries ...
        Returns True if OK, False else (i.e. no Protocol set, or Model
        absent). If <enforce> is False, works only if not already done
        or if a new Model has been loaded from last call.
        Remark : computation is enforced by every call to
        SetModel or RunTransformer

        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ComputeCheck(self, *args)


    def ModelCheckList(self, *args):
        """
        ModelCheckList(Handle_IFSelect_WorkSession self, Standard_Boolean const complete) -> Interface_CheckIterator

        Returns the Check List for the Model currently loaded :
        <complete> = True  : complete (syntactic & semantic messages),
        computed if not yet done
        <complete> = False : only syntactic (check file form)

        :type complete: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ModelCheckList(self, *args)


    def CheckOne(self, *args):
        """
        CheckOne(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent, Standard_Boolean const complete) -> Interface_CheckIterator

        Returns a Check for a single entity, under the form of a
        CheckIterator (this gives only one form for the user)
        if <ent> is Null or equates the current Model, it gives the
        Global Check, else the Check for the given entity
        <complete> as for ModelCheckList

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type complete: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_CheckOne(self, *args)


    def LastRunCheckList(self, *args):
        """
        LastRunCheckList(Handle_IFSelect_WorkSession self) -> Interface_CheckIterator

        Returns the Check List produced by the last execution of
        either : EvaluateFile(for Split), SendSplit, SendAll,
        SendSelected, RunTransformer-RunModifier
        Cleared by SetModel or ClearData(1)
        The field is protected, hence a specialized WorkSession may
        fill it

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_LastRunCheckList(self, *args)


    def MaxIdent(self, *args):
        """
        MaxIdent(Handle_IFSelect_WorkSession self) -> Standard_Integer

        Returns the Maximum Value for an Item Identifier. It can be
        greater to the count of known Items, because some can have
        been removed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_MaxIdent(self, *args)


    def Item(self, *args):
        """
        Item(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_Standard_Transient

        Returns an Item, given its Ident. Returns a Null Handle if
        no Item corresponds to this Ident.

        :type id: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Item(self, *args)


    def ItemIdent(self, *args):
        """
        ItemIdent(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Integer

        Returns the Ident attached to an Item in the WorkSession, or
        Zero if it is unknown

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ItemIdent(self, *args)


    def NamedItem(self, *args):
        """
        NamedItem(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Handle_Standard_Transient
        NamedItem(Handle_IFSelect_WorkSession self, Handle_TCollection_HAsciiString name) -> Handle_Standard_Transient

        Same as above, but <name> is given through a Handle
        Especially Usefull with methods SelectionNames, etc...

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NamedItem(self, *args)


    def NameIdent(self, *args):
        """
        NameIdent(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Standard_Integer

        Returns the Ident attached to a Name, 0 if name not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NameIdent(self, *args)


    def HasName(self, *args):
        """
        HasName(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Returns True if an Item of the WorkSession has an attached Name

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item) -> Handle_TCollection_HAsciiString

        Returns the Name attached to an Item as a Variable of this
        WorkSession. If <item> is Null or not recorded, returns an
        empty string.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Name(self, *args)


    def AddItem(self, *args):
        """
        AddItem(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item, Standard_Boolean const active) -> Standard_Integer

        Adds an Item and returns its attached Ident. Does nothing
        if <item> is already recorded (and returns its attached Ident)
        <active> if True commands call to SetActive (see below)
        Remark : the determined Ident is used if <item> is a Dispatch,
        to fill the ShareOut

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_AddItem(self, *args)


    def AddNamedItem(self, *args):
        """
        AddNamedItem(Handle_IFSelect_WorkSession self, Standard_CString const name, Handle_Standard_Transient item, Standard_Boolean const active) -> Standard_Integer

        Adds an Item with an attached Name. If the Name is already
        known in the WorkSession, the older item losts it
        Returns Ident if Done, 0 else, i.e. if <item> is null
        If <name> is empty, works as AddItem (i.e. with no name)
        If <item> is already known but with no attached Name, this
        method tries to attached a Name to it
        <active> if True commands call to SetActive (see below)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type active: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_AddNamedItem(self, *args)


    def SetActive(self, *args):
        """
        SetActive(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item, Standard_Boolean const mode) -> Standard_Boolean

        Following the type of <item> :
        - Dispatch : Adds or Removes it in the ShareOut & FileNaming
        - GeneralModifier : Adds or Removes it for final sending
        (i.e. in the ModelCopier)
        Returns True if it did something, False else (state unchanged)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mode: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetActive(self, *args)


    def RemoveNamedItem(self, *args):
        """
        RemoveNamedItem(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Removes an Item from the Session, given its Name
        Returns True if Done, False else (Name not recorded)
        (Applies only on Item which are Named)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_RemoveNamedItem(self, *args)


    def RemoveName(self, *args):
        """
        RemoveName(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Removes a Name without removing the Item
        Returns True if Done, False else (Name not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_RemoveName(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an Item given its Ident. Returns False if <id> is
        attached to no Item in the WorkSession. For a Named Item,
        also removes its Name.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_RemoveItem(self, *args)


    def ClearItems(self, *args):
        """
        ClearItems(Handle_IFSelect_WorkSession self)

        Clears all the recorded Items : Selections, Dispatches,
        Modifiers, and Strings & IntParams, with their Idents & Names.
        Remark that if a Model has been loaded, it is not cleared.


        """
        return _IFSelect.Handle_IFSelect_WorkSession_ClearItems(self, *args)


    def ItemLabel(self, *args):
        """
        ItemLabel(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_TCollection_HAsciiString

        Returns a Label which illustrates the content of an Item,
        given its Ident. This Label is :
        - for a Text Parameter, "Text:<text value>"
        - for an Integer Parameter, "Integer:<integer value>"
        - for a Selection, a Dispatch or a Modifier, its Label
        (see these classes)
        - for any other kind of Variable, its cdl type

        :type id: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ItemLabel(self, *args)


    def ItemIdents(self, *args):
        """
        ItemIdents(Handle_IFSelect_WorkSession self, Handle_Standard_Type type) -> Handle_TColStd_HSequenceOfInteger

        Fills a Sequence with the List of Idents attached to the Items
        of which Type complies with (IsKind) <type> (alphabetic order)
        Remark : <type> = TYPE(Standard_Transient) gives all the
        Idents which are suitable in the WorkSession

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ItemIdents(self, *args)


    def ItemNames(self, *args):
        """
        ItemNames(Handle_IFSelect_WorkSession self, Handle_Standard_Type type) -> Handle_TColStd_HSequenceOfHAsciiString

        Fills a Sequence with the list of the Names attached to Items
        of which Type complies with (IsKind) <type> (alphabetic order)
        Remark : <type> = TYPE(Standard_Transient) gives all the Names

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ItemNames(self, *args)


    def ItemNamesForLabel(self, *args):
        """
        ItemNamesForLabel(Handle_IFSelect_WorkSession self, Standard_CString const label) -> Handle_TColStd_HSequenceOfHAsciiString

        Fills a Sequence with the NAMES of the control items, of which
        the label matches <label> (contain it) : see NextIdentForLabel
        Search mode is fixed to "contained"
        If <label> is empty, returns all Names

        :type label: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ItemNamesForLabel(self, *args)


    def NextIdentForLabel(self, *args):
        """
        NextIdentForLabel(Handle_IFSelect_WorkSession self, Standard_CString const label, Standard_Integer const id, Standard_Integer const mode=0) -> Standard_Integer

        For query by Label with possible iterations
        Searches the Ident of which Item has a Label which matches a
        given one, the search starts from an initial Ident.
        Returns the first found Ident which follows <id>, or ZERO

        The search must start with <id> = 0, it returns the next Ident
        which matches. To iterate, call again this method which this
        returned value as <id>. Once an Ident has been returned, the
        Item can be obtained by the method Item

        <mode> precises the required matching mode :
        - 0 (Default) : <label> must match exactly with the Item Label
        - 1 : <label> must match the exact beginning (the end is free)
        - 2 : <label> must be at least once wherever in the Item Label
        - other values are ignored

        :type label: OCC.wrapper.Standard.Standard_CString
        :type id: int
        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NextIdentForLabel(self, *args)


    def NewParamFromStatic(self, *args):
        """
        NewParamFromStatic(Handle_IFSelect_WorkSession self, Standard_CString const statname, Standard_CString const name) -> Handle_Standard_Transient

        Creates a parameter as being bound to a Static
        If the Static is Integer, this creates an IntParam bound to
        it by its name. Else this creates a String which is the value
        of the Static.
        Returns a null handle if <statname> is unknown as a Static

        :type statname: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NewParamFromStatic(self, *args)


    def IntParam(self, *args):
        """
        IntParam(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_IntParam

        Returns an IntParam, given its Ident in the Session
        Null result if <id> is not suitable for an IntParam
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IntParam(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_WorkSession self, Handle_IFSelect_IntParam it) -> Standard_Integer

        Returns Integer Value of an IntParam

        :type it: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IntValue(self, *args)


    def NewIntParam(self, *args):
        """
        NewIntParam(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Handle_IFSelect_IntParam

        Creates a new IntParam. A Name can be set (Optional)
        Returns the created IntParam, or a Null Handle in case of
        Failure (see AddItem/AddNamedItem)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NewIntParam(self, *args)


    def SetIntValue(self, *args):
        """
        SetIntValue(Handle_IFSelect_WorkSession self, Handle_IFSelect_IntParam it, Standard_Integer const val) -> Standard_Boolean

        Changes the Integer Value of an IntParam
        Returns True if Done, False if <it> is not in the WorkSession

        :type it: OCC.wrapper.IFSelect.Handle_IFSelect_IntParam
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetIntValue(self, *args)


    def TextParam(self, *args):
        """
        TextParam(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_TCollection_HAsciiString

        Returns a TextParam, given its Ident in the Session
        Null result if <id> is not suitable for a TextParam
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_TextParam(self, *args)


    def TextValue(self, *args):
        """
        TextValue(Handle_IFSelect_WorkSession self, Handle_TCollection_HAsciiString par) -> TCollection_AsciiString

        Returns Text Value of a TextParam (a String)
        or an empty string if <it> is not in the WorkSession

        :type par: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_TextValue(self, *args)


    def NewTextParam(self, *args):
        """
        NewTextParam(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Handle_TCollection_HAsciiString

        Creates a new (empty) TextParam. A Name can be set (Optional)
        Returns the created TextParam (as an HAsciiString), or a Null
        Handle in case of Failure (see AddItem/AddNamedItem)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NewTextParam(self, *args)


    def SetTextValue(self, *args):
        """
        SetTextValue(Handle_IFSelect_WorkSession self, Handle_TCollection_HAsciiString par, Standard_CString const val) -> Standard_Boolean

        Changes the Text Value of a TextParam (an HAsciiString)
        Returns True if Done, False if <it> is not in the WorkSession

        :type par: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetTextValue(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Signature

        Returns a Signature, given its Ident in the Session
        Null result if <id> is not suitable for a Signature
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Signature(self, *args)


    def SignValue(self, *args):
        """
        SignValue(Handle_IFSelect_WorkSession self, Handle_IFSelect_Signature sign, Handle_Standard_Transient ent) -> Standard_CString

        Returns the Value computed by a Signature for an Entity
        Returns an empty string if the entity does not belong to the
        loaded model

        :type sign: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SignValue(self, *args)


    def Selection(self, *args):
        """
        Selection(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Selection

        Returns a Selection, given its Ident in the Session
        Null result if <id> is not suitable for a Selection
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Selection(self, *args)


    def EvalSelection(self, *args):
        """
        EvalSelection(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Interface_EntityIterator

        Evaluates the effect of a Selection applied on the input Model
        Returned Result remains empty if no input Model has been set

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EvalSelection(self, *args)


    def Sources(self, *args):
        """
        Sources(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> IFSelect_SelectionIterator

        Returns the Selections which are source of Selection, given
        its rank in the List of Selections (see SelectionIterator)
        Returned value is empty if <num> is out of range or if
        <sel> is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Sources(self, *args)


    def SelectionResult(self, *args):
        """
        SelectionResult(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Handle_TColStd_HSequenceOfTransient

        Returns the result of a Selection, computed by EvalSelection
        (see above) under the form of a HSequence (hence, it can be
        used by a frontal-engine logic). It can be empty
        Returns a Null Handle if <sel> is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SelectionResult(self, *args)


    def SelectionResultFromList(self, *args):
        """
        SelectionResultFromList(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_TColStd_HSequenceOfTransient list) -> Handle_TColStd_HSequenceOfTransient

        Returns the result of a Selection, by forcing its input with
        a given list <list> (unless <list> is Null).
        RULES :
        <list> applies only for a SelectDeduct kind Selection :
        its Input is considered : if it is a SelectDeduct kind
        Selection, its Input is considered, etc... until an Input
        is not a Deduct/Extract : its result is replaced by <list>
        and all the chain of deductions is applied

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SelectionResultFromList(self, *args)


    def SetItemSelection(self, *args):
        """
        SetItemSelection(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Sets a Selection as input for an item, according its type :
        if <item> is a Dispatch : as Final Selection
        if <item> is a GeneralModifier (i.e. any kind of Modifier) :
        as Selection used to filter entities to modify
        <sel>  Null  causes this Selection to be nullified
        Returns False if <item> is not of a suitable type, or
        <item> or <sel> is not in the WorkSession

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetItemSelection(self, *args)


    def ResetItemSelection(self, *args):
        """
        ResetItemSelection(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item) -> Standard_Boolean

        Resets input Selection which was set by SetItemSelection
        Same conditions as for SetItemSelection
        Returns True if done, False if <item> is not in the WorkSession

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ResetItemSelection(self, *args)


    def ItemSelection(self, *args):
        """
        ItemSelection(Handle_IFSelect_WorkSession self, Handle_Standard_Transient item) -> Handle_IFSelect_Selection

        Returns the Selection of a Dispatch or a GeneralModifier.
        Returns a Null Handle if none is defined or <item> not good type

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ItemSelection(self, *args)


    def SignCounter(self, *args):
        """
        SignCounter(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_SignCounter

        Returns a SignCounter from its ident in the Session
        Null result if <id> is not suitable for a SignCounter
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SignCounter(self, *args)


    def ComputeCounter(self, *args):
        """
        ComputeCounter(Handle_IFSelect_WorkSession self, Handle_IFSelect_SignCounter counter, Standard_Boolean const forced) -> Standard_Boolean

        Computes the content of a SignCounter when it is defined with
        a Selection, then returns True
        Returns False if the SignCounter is not defined with a
        Selection, or if its Selection Mode is inhibited
        <forced> to work around optimisations

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type forced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ComputeCounter(self, *args)


    def ComputeCounterFromList(self, *args):
        """
        ComputeCounterFromList(Handle_IFSelect_WorkSession self, Handle_IFSelect_SignCounter counter, Handle_TColStd_HSequenceOfTransient list, Standard_Boolean const clear) -> Standard_Boolean

        Computes the content of a SignCounter from an input list
        If <list> is Null, uses internal definition of the Counter :
        a Selection, else the whole Model (recomputation forced)
        If <clear> is True (D), starts from scratch
        Else, cumulates computations

        :type counter: OCC.wrapper.IFSelect.Handle_IFSelect_SignCounter
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type clear: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ComputeCounterFromList(self, *args)


    def AppliedDispatches(self, *args):
        """
        AppliedDispatches(Handle_IFSelect_WorkSession self) -> Handle_TColStd_HSequenceOfInteger

        Returns the ordered list of dispatches stored by the ShareOut

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.Handle_IFSelect_WorkSession_AppliedDispatches(self, *args)


    def ClearShareOut(self, *args):
        """
        ClearShareOut(Handle_IFSelect_WorkSession self, Standard_Boolean const onlydisp)

        Clears the list of Dispatches recorded by the ShareOut
        if <only> disp is True, tha's all. Else, clears also the lists
        of Modifiers recorded by the ShareOut

        :type onlydisp: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ClearShareOut(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Dispatch

        Returns a Dispatch, given its Ident in the Session
        Null result if <id> is not suitable for a Dispatch
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Dispatch(self, *args)


    def DispatchRank(self, *args):
        """
        DispatchRank(Handle_IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp) -> Standard_Integer

        Returns the rank of a Dispatch in the ShareOut, or 0 if <disp>
        is not in the ShareOut or not in the WorkSession

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_DispatchRank(self, *args)


    def ModelCopier(self, *args):
        """
        Gives access to the complete ModelCopier

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ModelCopier

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_ModelCopier(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetModelCopier(self, *args):
        """
        SetModelCopier(Handle_IFSelect_WorkSession self, Handle_IFSelect_ModelCopier copier)

        Sets a new ModelCopier. Fills Items which its content

        :type copier: OCC.wrapper.IFSelect.Handle_IFSelect_ModelCopier

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetModelCopier(self, *args)


    def NbFinalModifiers(self, *args):
        """
        NbFinalModifiers(Handle_IFSelect_WorkSession self, Standard_Boolean const formodel) -> Standard_Integer

        Returns the count of Modifiers applied to final sending
        Model Modifiers if <formodel> is True, File Modifiers else
        (i.e. Modifiers which apply once the Models have been filled)

        :type formodel: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NbFinalModifiers(self, *args)


    def FinalModifierIdents(self, *args):
        """
        FinalModifierIdents(Handle_IFSelect_WorkSession self, Standard_Boolean const formodel) -> Handle_TColStd_HSequenceOfInteger

        Fills a Sequence with a list of Idents, those attached to
        the Modifiers applied to final sending.
        Model Modifiers if <formodel> is True, File Modifiers else
        This list is given in the order in which they will be applied
        (which takes into account the Changes to Modifier Ranks)

        :type formodel: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _IFSelect.Handle_IFSelect_WorkSession_FinalModifierIdents(self, *args)


    def GeneralModifier(self, *args):
        """
        GeneralModifier(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_GeneralModifier

        Returns a Modifier, given its Ident in the Session
        Null result if <id> is not suitable for a Modifier
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GeneralModifier(self, *args)


    def ModelModifier(self, *args):
        """
        ModelModifier(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Modifier

        Returns a Model Modifier, given its Ident in the Session,
        i.e. typed as a Modifier (not simply a GeneralModifier)
        Null result if <id> is not suitable for a Modifier
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ModelModifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(Handle_IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier item) -> Standard_Integer

        Returns the Rank of a Modifier given its Ident. Model or File
        Modifier according its type (ModelModifier or not)
        Remember that Modifiers are applied sequencially following
        their Rank : first Model Modifiers then File Modifiers
        Rank is given by rank of call to AddItem and can be
        changed by ChangeModifierRank

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ModifierRank(self, *args)


    def ChangeModifierRank(self, *args):
        """
        ChangeModifierRank(Handle_IFSelect_WorkSession self, Standard_Boolean const formodel, Standard_Integer const before, Standard_Integer const after) -> Standard_Boolean

        Changes the Rank of a Modifier in the Session :
        Model Modifiers if <formodel> is True, File Modifiers else
        the Modifier n0 <before> is put to n0 <after>
        Return True if Done, False if <before> or <after> out of range

        :type formodel: bool
        :type before: int
        :type after: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ChangeModifierRank(self, *args)


    def ClearFinalModifiers(self, *args):
        """
        ClearFinalModifiers(Handle_IFSelect_WorkSession self)

        Removes all the Modifiers active in the ModelCopier : they
        become inactive and they are removed from the Session


        """
        return _IFSelect.Handle_IFSelect_WorkSession_ClearFinalModifiers(self, *args)


    def SetAppliedModifier(self, *args):
        """
        SetAppliedModifier(Handle_IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier modif, Handle_Standard_Transient item) -> Standard_Boolean

        Sets a GeneralModifier to be applied to an item :
        - item = ShareOut : applies for final sending (all dispatches)
        - item is a Dispatch : applies for this dispatch only
        Returns True if done, False if <modif> or <item> not in <me>

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetAppliedModifier(self, *args)


    def ResetAppliedModifier(self, *args):
        """
        ResetAppliedModifier(Handle_IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier modif) -> Standard_Boolean

        Resets a GeneralModifier to be applied
        Returns True if done, False if <modif> was not applied

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ResetAppliedModifier(self, *args)


    def UsesAppliedModifier(self, *args):
        """
        UsesAppliedModifier(Handle_IFSelect_WorkSession self, Handle_IFSelect_GeneralModifier modif) -> Handle_Standard_Transient

        Returns the item on which a GeneralModifier is applied :
        the ShareOut, or a given Dispatch
        Returns a Null Handle if <modif> is not applied

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_UsesAppliedModifier(self, *args)


    def Transformer(self, *args):
        """
        Transformer(Handle_IFSelect_WorkSession self, Standard_Integer const id) -> Handle_IFSelect_Transformer

        Returns a Transformer, given its Ident in the Session
        Null result if <id> is not suitable for a Transformer
        (undefined, or defined for another kind of variable)

        :type id: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Transformer(self, *args)


    def RunTransformer(self, *args):
        """
        RunTransformer(Handle_IFSelect_WorkSession self, Handle_IFSelect_Transformer transf) -> Standard_Integer

        Runs a Transformer on starting Model, which can then be edited
        or replaced by a new one. The Protocol can also be changed.
        Fills LastRunCheckList

        Returned status is 0 if nothing done (<transf> or model
        undefined), positive if OK, negative else :
        0  : Nothing done
        1  : OK, edition on the spot with no change to the graph
        of dependances (purely local)
        2  : OK, model edited on the spot (graph recomputed, may
        have changed), protocol unchanged
        3  : OK, new model produced, same protocol
        4  : OK, model edited on the spot (graph recomputed),
        but protocol has changed
        5  : OK, new model produced, protocol has changed
        -1 : Error on the spot (slight changes), data may be corrupted
        (remark : corruption should not be profound)
        -2 : Error on edition the spot, data may be corrupted
        (checking them is recommanded)
        -3 : Error with a new data set, transformation ignored
        -4 : OK as 4, but graph of dependances count not be recomputed
        (the former one is kept) : check the protocol

        :type transf: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_RunTransformer(self, *args)


    def RunModifier(self, *args):
        """
        RunModifier(Handle_IFSelect_WorkSession self, Handle_IFSelect_Modifier modif, Standard_Boolean const copy) -> Standard_Integer

        Runs a Modifier on Starting Model. It can modify entities, or
        add new ones. But the Model or the Protocol is unchanged.
        The Modifier is applied on each entity of the Model. See also
        RunModifierSelected
        Fills LastRunCheckList

        <copy> : if True, a new data set is produced which brings
        the modifications (Model + its Entities)
        if False, data are modified on the spot

        It works through a TransformStandard defined with <modif>
        Returned status as RunTransformer : 0 nothing done, >0 OK,
        <0 problem, but only between -3 and 3 (protocol unchanged)
        Remark : <copy> True will give <effect> = 3 or -3

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type copy: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_RunModifier(self, *args)


    def RunModifierSelected(self, *args):
        """
        RunModifierSelected(Handle_IFSelect_WorkSession self, Handle_IFSelect_Modifier modif, Handle_IFSelect_Selection sel, Standard_Boolean const copy) -> Standard_Integer

        Acts as RunModifier, but the Modifier is applied on the list
        determined by a Selection, rather than on the whole Model
        If the selection is a null handle, the whole model is taken

        :type modif: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type copy: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_RunModifierSelected(self, *args)


    def NewTransformStandard(self, *args):
        """
        NewTransformStandard(Handle_IFSelect_WorkSession self, Standard_Boolean const copy, Standard_CString const name) -> Handle_IFSelect_Transformer

        Creates and returns a TransformStandard, empty, with its
        Copy Option (True = Copy, False = On the Spot) and an
        optional name.
        To a TransformStandard, the method SetAppliedModifier applies

        :type copy: bool
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Transformer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NewTransformStandard(self, *args)


    def SetModelContent(self, *args):
        """
        SetModelContent(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Standard_Boolean const keep) -> Standard_Boolean

        Defines a new content from the former one
        If <keep> is True, it is given by entities selected by
        Selection <sel>  (and all shared entities)
        Else, it is given by all the former content but entities
        selected by the Selection <sel> (and properly shared ones)
        Returns True if done. Returns False if the selected list
        (from <sel>) is empty, hence nothing is done

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type keep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetModelContent(self, *args)


    def FilePrefix(self, *args):
        """
        FilePrefix(Handle_IFSelect_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined File Prefix. Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_FilePrefix(self, *args)


    def DefaultFileRoot(self, *args):
        """
        DefaultFileRoot(Handle_IFSelect_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined Default File Root. It is used for
        Dispatches which have no specific root attached.
        Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_DefaultFileRoot(self, *args)


    def FileExtension(self, *args):
        """
        FileExtension(Handle_IFSelect_WorkSession self) -> Handle_TCollection_HAsciiString

        Returns the defined File Extension. Null Handle if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_FileExtension(self, *args)


    def FileRoot(self, *args):
        """
        FileRoot(Handle_IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp) -> Handle_TCollection_HAsciiString

        Returns the File Root defined for a Dispatch. Null if no
        Root Name is defined for it (hence, no File will be produced)

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_FileRoot(self, *args)


    def SetFilePrefix(self, *args):
        """
        SetFilePrefix(Handle_IFSelect_WorkSession self, Standard_CString const name)

        Defines a File Prefix

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetFilePrefix(self, *args)


    def SetDefaultFileRoot(self, *args):
        """
        SetDefaultFileRoot(Handle_IFSelect_WorkSession self, Standard_CString const name) -> Standard_Boolean

        Defines a Default File Root Name. Clears it is <name> = ""
        Returns True if OK, False if <name> already set for a Dispatch

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetDefaultFileRoot(self, *args)


    def SetFileExtension(self, *args):
        """
        SetFileExtension(Handle_IFSelect_WorkSession self, Standard_CString const name)

        Defines a File Extension

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetFileExtension(self, *args)


    def SetFileRoot(self, *args):
        """
        SetFileRoot(Handle_IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp, Standard_CString const name) -> Standard_Boolean

        Defines a Root for a Dispatch
        If <name> is empty, clears Root Name
        This has as effect to inhibit the production of File by <disp>
        Returns False if <disp> is not in the WorkSession or if a
        root name is already defined for it

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetFileRoot(self, *args)


    def GiveFileRoot(self, *args):
        """
        GiveFileRoot(Handle_IFSelect_WorkSession self, Standard_CString const file) -> Standard_CString

        Extracts File Root Name from a given complete file name
        (uses OSD_Path)

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GiveFileRoot(self, *args)


    def GiveFileComplete(self, *args):
        """
        GiveFileComplete(Handle_IFSelect_WorkSession self, Standard_CString const file) -> Standard_CString

        Completes a file name as required, with Prefix and Extension
        (if defined; for a non-defined item, completes nothing)

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GiveFileComplete(self, *args)


    def ClearFile(self, *args):
        """
        ClearFile(Handle_IFSelect_WorkSession self)

        Erases all stored data from the File Evaluation
        (i.e. ALL former naming informations are lost)


        """
        return _IFSelect.Handle_IFSelect_WorkSession_ClearFile(self, *args)


    def EvaluateFile(self, *args):
        """
        EvaluateFile(Handle_IFSelect_WorkSession self)

        Performs and stores a File Evaluation. The Results are a List
        of produced Models and a List of names (Strings), in parallel
        Fills LastRunCheckList


        """
        return _IFSelect.Handle_IFSelect_WorkSession_EvaluateFile(self, *args)


    def NbFiles(self, *args):
        """
        NbFiles(Handle_IFSelect_WorkSession self) -> Standard_Integer

        Returns the count of produced Models

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NbFiles(self, *args)


    def FileModel(self, *args):
        """
        FileModel(Handle_IFSelect_WorkSession self, Standard_Integer const num) -> Handle_Interface_InterfaceModel

        Returns a Model, given its rank in the Evaluation List

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_WorkSession_FileModel(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_IFSelect_WorkSession self, Standard_Integer const num) -> TCollection_AsciiString

        Returns the name of a file corresponding to a produced Model,
        given its rank in the Evaluation List

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_FileName(self, *args)


    def BeginSentFiles(self, *args):
        """
        BeginSentFiles(Handle_IFSelect_WorkSession self, Standard_Boolean const record)

        Commands file sending to clear the list of already sent files,
        commands to record a new one if <record> is True
        This list is managed by the ModelCopier when SendSplit is called
        It allows a global exploitation of the set of sent files

        :type record: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_BeginSentFiles(self, *args)


    def SentFiles(self, *args):
        """
        SentFiles(Handle_IFSelect_WorkSession self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of recorded sent files, or a Null Handle is
        recording has not been enabled

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SentFiles(self, *args)


    def SendSplit(self, *args):
        """
        SendSplit(Handle_IFSelect_WorkSession self) -> Standard_Boolean

        Performs creation of derived files from the input Model
        Takes its data (sub-models and names), from result EvaluateFile
        if active, else by dynamic Evaluation (not stored)
        After SendSplit, result of EvaluateFile is Cleared
        Fills LastRunCheckList

        Works with the WorkLibrary which acts on specific type of Model
        and can work with File Modifiers (managed by the Model Copier)
        and a ModelCopier, which can work with Model Modifiers
        Returns False if, either WorkLibrary has failed on at least
        one sub-file, or the Work Session is badly conditionned
        (no Model defined, or FileNaming not in phase with ShareOut)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SendSplit(self, *args)


    def EvalSplit(self, *args):
        """
        EvalSplit(Handle_IFSelect_WorkSession self) -> Handle_IFSelect_PacketList

        Returns an Evaluation of the whole ShareOut definition : i.e.
        how the entities of the starting model are forecast to be sent
        to various files :  list of packets according the dispatches,
        effective lists of roots for each packet (which determine the
        content of the corresponding file); plus evaluation of which
        entities are : forgotten (sent into no file), duplicated (sent
        into more than one file), sent into a given file.
        See the class PacketList for more details.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_PacketList

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EvalSplit(self, *args)


    def SentList(self, *args):
        """
        SentList(Handle_IFSelect_WorkSession self, Standard_Integer const count=-1) -> Interface_EntityIterator

        Returns the list of Entities sent in files, accourding the
        count of files each one has been sent (these counts are reset
        by SetModel or SetRemaining(Forget) ) stored in Graph Status
        <count> = -1 (default) is for ENtities sent at least once
        <count> = 0 is for the Remaining List (entities not yet sent)
        <count> = 1 is for entities sent in one and only one file
        (the ideal case)
        Remaining Data are computed on each Sending/Copying output
        files (see methods EvaluateFile and SendSplit)
        Graph Status is 0 for Remaining Entity, <count> for Sent into
        <count> files
        This status is set to 0 (not yet sent) for all by SetModel
        and by SetRemaining(mode=Forget,Display)

        :type count: int
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SentList(self, *args)


    def MaxSendingCount(self, *args):
        """
        MaxSendingCount(Handle_IFSelect_WorkSession self) -> Standard_Integer

        Returns the greater count of different files in which any of
        the starting entities could be sent.
        Before any file output, this count is 0.
        Ideal count is 1. More than 1 means that duplications occur.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_MaxSendingCount(self, *args)


    def SetRemaining(self, *args):
        """
        SetRemaining(Handle_IFSelect_WorkSession self, IFSelect_RemainMode const mode) -> Standard_Boolean

        Processes Remaining data (after having sent files), mode :
        Forget  : forget remaining info (i.e. clear all "Sent" status)
        Compute : compute and keep remaining (does nothing if :
        remaining is empty or if no files has been sent)
        Display : display entities recorded as remaining
        Undo    : restore former state of data (after Remaining(1) )
        Returns True if OK, False else (i.e. mode = 2 and Remaining
        List is either empty or takes all the entities, or mode = 3
        and no former computation of remaining data was done)

        :type mode: OCC.wrapper.IFSelect.IFSelect_RemainMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetRemaining(self, *args)


    def SendAll(self, *args):
        """
        SendAll(Handle_IFSelect_WorkSession self, Standard_CString const filename, Standard_Boolean const computegraph) -> IFSelect_ReturnStatus

        Sends the starting Model into one file, without splitting,
        managing remaining data or anything else.
        <computegraph> true commands the Graph to be recomputed before
        sending : required when a Model is filled in several steps

        The Model and File Modifiers recorded to be applied on sending
        files are.
        Returns a status of execution :
        Done if OK,
        Void if no data available,
        Error if errors occured (work library is not defined), errors
        during translation
        Fail if exception during translation is raised
        Stop if no disk space or disk, file is write protected
        Fills LastRunCheckList

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type computegraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SendAll(self, *args)


    def SendSelected(self, *args):
        """
        SendSelected(Handle_IFSelect_WorkSession self, Standard_CString const filename, Handle_IFSelect_Selection sel, Standard_Boolean const computegraph) -> IFSelect_ReturnStatus

        Sends a part of the starting Model into one file, without
        splitting. But remaining data are managed.
        <computegraph> true commands the Graph to be recomputed before
        sending : required when a Model is filled in several steps

        The Model and File Modifiers recorded to be applied on sending
        files are.
        Returns a status : Done if OK,  Fail if error during send,
        Error : WorkLibrary not defined, Void : selection list empty
        Fills LastRunCheckList

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type computegraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SendSelected(self, *args)


    def WriteFile(self, *args):
        """
        WriteFile(Handle_IFSelect_WorkSession self, Standard_CString const filename) -> IFSelect_ReturnStatus
        WriteFile(Handle_IFSelect_WorkSession self, Standard_CString const filename, Handle_IFSelect_Selection sel) -> IFSelect_ReturnStatus

        Writes a sub-part of the current Interface Model to a File,
        as defined by a Selection <sel>, recomputes the Graph, and
        returns a write status which can be :
        Done OK, Fail file could not be written, Error no norm is selected
        Remark  : It is a simple, one-file writing, other operations are
        available (such as splitting ...) which calls SendSelected

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IFSelect.Handle_IFSelect_WorkSession_WriteFile(self, *args)


    def NbSources(self, *args):
        """
        NbSources(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Integer

        Returns the count of Input Selections known for a Selection,
        or 0 if <sel> not in the WorkSession. This count is one for a
        SelectDeduct / SelectExtract kind, two for SelectControl kind,
        variable for a SelectCombine (Union/Intersection), zero else

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NbSources(self, *args)


    def Source(self, *args):
        """
        Source(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Standard_Integer const num=1) -> Handle_IFSelect_Selection

        Returns the <num>th Input Selection of a Selection
        (see NbSources).
        Returns a Null Handle if <sel> is not in the WorkSession or if
        <num> is out of the range <1-NbSources>
        To obtain more details, see the method Sources

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_Source(self, *args)


    def IsReversedSelectExtract(self, *args):
        """
        IsReversedSelectExtract(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Returns True if <sel> a Reversed SelectExtract, False else

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IsReversedSelectExtract(self, *args)


    def ToggleSelectExtract(self, *args):
        """
        ToggleSelectExtract(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel) -> Standard_Boolean

        Toggles the Sense (Direct <-> Reversed) of a SelectExtract
        Returns True if Done, False if <sel> is not a SelectExtract or
        is not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ToggleSelectExtract(self, *args)


    def SetInputSelection(self, *args):
        """
        SetInputSelection(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_IFSelect_Selection input) -> Standard_Boolean

        Sets an Input Selection (as <input>) to a SelectExtract or
        a SelectDeduct (as <sel>).
        Returns True if Done, False if <sel> is neither a
        SelectExtract nor a SelectDeduct, or not in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type input: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetInputSelection(self, *args)


    def SetControl(self, *args):
        """
        SetControl(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_IFSelect_Selection sc, Standard_Boolean const formain) -> Standard_Boolean

        Sets an Input Selection, Main if <formain> is True, Second else
        (as <sc>) to a SelectControl (as <sel>). Returns True if Done,
        False if <sel> is not a SelectControl, or <sc> or <sel> is not
        in the WorkSession

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type sc: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type formain: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetControl(self, *args)


    def CombineAdd(self, *args):
        """
        CombineAdd(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection selcomb, Handle_IFSelect_Selection seladd, Standard_Integer const atnum=0) -> Standard_Integer

        Adds an input selection to a SelectCombine (Union or Inters.).
        Returns new count of inputs for this SelectCombine if Done or
        0 if <sel> is not kind of SelectCombine, or if <seladd> or
        <sel> is not in the WorkSession
        By default, adding is done at the end of the list
        Else, it is an insertion to rank <atnum> (usefull for Un-ReDo)

        :type selcomb: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type seladd: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type atnum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_CombineAdd(self, *args)


    def CombineRemove(self, *args):
        """
        CombineRemove(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection selcomb, Handle_IFSelect_Selection selrem) -> Standard_Boolean

        Removes an input selection from a SelectCombine (Union or
        Intersection). Returns True if done, False if <selcomb> is not
        kind of SelectCombine or <selrem> is not source of <selcomb>

        :type selcomb: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type selrem: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_CombineRemove(self, *args)


    def NewSelectPointed(self, *args):
        """
        NewSelectPointed(Handle_IFSelect_WorkSession self, Handle_TColStd_HSequenceOfTransient list, Standard_CString const name) -> Handle_IFSelect_Selection

        Creates a new Selection, of type SelectPointed, its content
        starts with <list>. A name must be given (can be empty)

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_NewSelectPointed(self, *args)


    def SetSelectPointed(self, *args):
        """
        SetSelectPointed(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel, Handle_TColStd_HSequenceOfTransient list, Standard_Integer const mode) -> Standard_Boolean

        Changes the content of a Selection of type SelectPointed
        According <mode> : 0  set <list> as new content (clear former)
        1  : adds <list> to actual content
        -1  : removes <list> from actual content
        Returns True if done, False if <sel> is not a SelectPointed

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetSelectPointed(self, *args)


    def GiveSelection(self, *args):
        """
        GiveSelection(Handle_IFSelect_WorkSession self, Standard_CString const selname) -> Handle_IFSelect_Selection

        Returns a Selection from a Name :
        - the name of a Selection : this Selection
        - the name of a Signature + criteria between (..) : a new
        Selection from this Signature
        - an entity or a list of entities : a new SelectPointed
        Else, returns a Null Handle

        :type selname: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GiveSelection(self, *args)


    def GiveList(self, *args):
        """
        GiveList(Handle_IFSelect_WorkSession self, Handle_Standard_Transient obj) -> Handle_TColStd_HSequenceOfTransient
        GiveList(Handle_IFSelect_WorkSession self, Standard_CString const first, Standard_CString const second) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from two alphanums,
        first and second, as follows :
        if <first> is a Number or Label of an entity : this entity
        if <first> is a list of Numbers/Labels : the list of entities
        if <first> is the name of a Selection in <WS>, and <second>
        not defined, the standard result of this Selection
        else, let's consider "first second" : this whole phrase is
        splitted by blanks, as follows (RECURSIVE CALL) :
        - the leftest term is the final selection
        - the other terms define the result of the selection
        - and so on (the "leftest minus one" is a selection, of which
        the input is given by the remaining ...)

        :type first: OCC.wrapper.Standard.Standard_CString
        :type second: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GiveList(self, *args)


    def GiveListFromList(self, *args):
        """
        GiveListFromList(Handle_IFSelect_WorkSession self, Standard_CString const selname, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Computes a List of entities from the model as follows
        <first> beeing a Selection or a combination of Selections,
        <ent> beeing an entity or a list
        of entities (as a HSequenceOfTransient) :
        the standard result of this selection applied to this list
        if <ent> is Null, the standard definition of the selection is
        used (which contains a default input selection)
        if <selname> is erroneous, a null handle is returned

        REMARK : selname is processed as <first second> of preceeding
        GiveList

        :type selname: OCC.wrapper.Standard.Standard_CString
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GiveListFromList(self, *args)


    def GiveListCombined(self, *args):
        """
        GiveListCombined(Handle_IFSelect_WorkSession self, Handle_TColStd_HSequenceOfTransient l1, Handle_TColStd_HSequenceOfTransient l2, Standard_Integer const mode) -> Handle_TColStd_HSequenceOfTransient

        Combines two lists and returns the result, according to mode :
        <mode> < 0 : entities in <l1> AND NOT in <l2>
        <mode> = 0 : entities in <l1> AND in <l2>
        <mode> > 0 : entities in <l1> OR  in <l2>

        :type l1: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type l2: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type mode: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GiveListCombined(self, *args)


    def QueryCheckList(self, *args):
        """
        QueryCheckList(Handle_IFSelect_WorkSession self, Interface_CheckIterator chl)

        Loads data from a check iterator to query status on it

        :type chl: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_WorkSession_QueryCheckList(self, *args)


    def QueryCheckStatus(self, *args):
        """
        QueryCheckStatus(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent) -> Standard_Integer

        Determines check status for an entity regarding last call to
        QueryCheckList :
        -1 : <ent> unknown in the model, ignored
        0 : no check at all, immediate or inherited thru Graph
        1 : immediate warning (no fail), no inherited check
        2 : immediate fail, no inherited check
        +10 : idem but some inherited warning (no fail)
        +20 : idem but some inherited fail

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_QueryCheckStatus(self, *args)


    def QueryParent(self, *args):
        """
        QueryParent(Handle_IFSelect_WorkSession self, Handle_Standard_Transient entdad, Handle_Standard_Transient entson) -> Standard_Integer

        Determines if <entdad> is parent of <entson> (in the graph),
        returns : -1 if no; 0 if <entdad> = <entson>
        1 if immediate parent, > 1 if parent, gives count of steps

        :type entdad: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entson: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_QueryParent(self, *args)


    def SetParams(self, *args):
        """
        SetParams(Handle_IFSelect_WorkSession self, NCollection_Vector< opencascade::handle< Standard_Transient > > const & params, NCollection_Vector< Standard_Integer > const & uselist)

        Sets a list of Parameters, i.e. TypedValue, to be handled
        through an Editor
        The two lists are parallel, if <params> is longer than <uses>,
        surnumeral parameters are for general use

        EditForms are created to handle these parameters (list, edit)
        on the basis of a ParamEditor  xst-params-edit

        A use number dispatches the parameter to a given EditForm
        EditForms are defined as follows
        Name                Use   Means
        xst-params          all   All Parameters (complete list)
        xst-params-general  1     Generals
        xst-params-load     2     LoadFile (no Transfer)
        xst-params-send     3     SendFile (Write, no Transfer)
        xst-params-split    4     Split
        xst-param-read      5     Transfer on Reading
        xst-param-write     6     Transfer on Writing

        :type params: OCC.wrapper.IFSelect.NCollection_Vector_Handle_Standard_Transient
        :type uselist: OCC.wrapper.IFSelect.NCollection_Vector_Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_SetParams(self, *args)


    def TraceStatics(self, *args):
        """
        TraceStatics(Handle_IFSelect_WorkSession self, Standard_Integer const use, Standard_Integer const mode=0)

        Traces the Statics attached to a given use number
        If <use> is given positive (normal), the trace is embedded
        with a header and a trailer
        If <use> is negative, just values are printed
        (this allows to make compositions)
        Remark : use number  5 commands use -2 to be traced
        Remark : use numbers 4 and 6 command use -3 to be traced

        :type use: int
        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_TraceStatics(self, *args)


    def DumpShare(self, *args):
        """
        DumpShare(Handle_IFSelect_WorkSession self)

        Dumps contents of the ShareOut (on "cout")


        """
        return _IFSelect.Handle_IFSelect_WorkSession_DumpShare(self, *args)


    def ListItems(self, *args):
        """
        ListItems(Handle_IFSelect_WorkSession self, Standard_CString const label)

        Lists the Labels of all Items of the WorkSession
        If <label> is defined, lists labels which contain it

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ListItems(self, *args)


    def ListFinalModifiers(self, *args):
        """
        ListFinalModifiers(Handle_IFSelect_WorkSession self, Standard_Boolean const formodel)

        Lists the Modifiers of the session (for each one, displays
        its Label). Listing is done following Ranks (Modifiers are
        invoked following their ranks)
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ListFinalModifiers(self, *args)


    def DumpSelection(self, *args):
        """
        DumpSelection(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel)

        Lists a Selection and its Sources (see SelectionIterator),
        given its rank in the list

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_DumpSelection(self, *args)


    def DumpModel(self, *args):
        """
        DumpModel(Handle_IFSelect_WorkSession self, Standard_Integer const level, Handle_Message_Messenger S)

        Lists the content of the Input Model (if there is one)
        According level : 0 -> gives only count of Entities and Roots
        1 -> Lists also Roots;  2 -> Lists all Entities (by TraceType)
        3 -> Performs a call to CheckList (Fails) and lists the result
        4 -> as 3 but all CheckList (Fails + Warnings)
        5,6,7  : as 3 but resp. Count,List,Labels by Fail
        8,9,10 : as 4 but resp. Count,List,Labels by message

        :type level: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_WorkSession_DumpModel(self, *args)


    def TraceDumpModel(self, *args):
        """
        TraceDumpModel(Handle_IFSelect_WorkSession self, Standard_Integer const mode)

        Dumps the current Model (as inherited DumpModel), on currently
        defined Default Trace File (default is standard output)

        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_TraceDumpModel(self, *args)


    def DumpEntity(self, *args):
        """
        DumpEntity(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent, Standard_Integer const level, Handle_Message_Messenger S)

        Dumps a starting entity according to the current norm.
        To do this, it calls DumpEntity from WorkLibrary.
        <level> is to be interpreted for each norm : see specific
        classes of WorkLibrary for it. Generally, 0 if for very basic
        (only type ...), greater values give more and more details.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_WorkSession_DumpEntity(self, *args)


    def PrintEntityStatus(self, *args):
        """
        PrintEntityStatus(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints main informations about an entity : its number, type,
        validity (and checks if any), category, shareds and sharings..
        mutable because it can recompute checks as necessary

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_WorkSession_PrintEntityStatus(self, *args)


    def TraceDumpEntity(self, *args):
        """
        TraceDumpEntity(Handle_IFSelect_WorkSession self, Handle_Standard_Transient ent, Standard_Integer const level)

        Dumps an entity from the current Model as inherited DumpEntity
        on currently defined Default Trace File
        (<level> interpreted according to the Norm, see WorkLibrary)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_TraceDumpEntity(self, *args)


    def PrintCheckList(self, *args):
        """
        PrintCheckList(Handle_IFSelect_WorkSession self, Interface_CheckIterator checklist, Standard_Boolean const failsonly, IFSelect_PrintCount const mode)

        Prints a CheckIterator to the current Trace File, controlled
        with the current Model
        complete or fails only, according to <failsonly>
        <mode> defines the mode of printing
        0 : sequential, according entities; else with a CheckCounter
        1 : according messages, count of entities
        2 : id but with list of entities, designated by their numbers
        3 : as 2 but with labels of entities

        :type checklist: OCC.wrapper.Interface.Interface_CheckIterator
        :type failsonly: bool
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.Handle_IFSelect_WorkSession_PrintCheckList(self, *args)


    def PrintSignatureList(self, *args):
        """
        PrintSignatureList(Handle_IFSelect_WorkSession self, Handle_IFSelect_SignatureList signlist, IFSelect_PrintCount const mode)

        Prints a SignatureList to the current Trace File, controlled
        with the current Model
        <mode> defines the mode of printing (see SignatureList)

        :type signlist: OCC.wrapper.IFSelect.Handle_IFSelect_SignatureList
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IFSelect.Handle_IFSelect_WorkSession_PrintSignatureList(self, *args)


    def EvaluateSelection(self, *args):
        """
        EvaluateSelection(Handle_IFSelect_WorkSession self, Handle_IFSelect_Selection sel)

        Displays the list of Entities selected by a Selection (i.e.
        the result of EvalSelection).

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EvaluateSelection(self, *args)


    def EvaluateDispatch(self, *args):
        """
        EvaluateDispatch(Handle_IFSelect_WorkSession self, Handle_IFSelect_Dispatch disp, Standard_Integer const mode=0)

        Displays the result of applying a Dispatch on the input Model
        (also shows Remainder if there is)
        <mode> = 0 (default), displays nothing else
        <mode> = 1 : displays also duplicated entities (because of
        this dispatch)
        <mode> = 2 : displays the entities of the starting Model
        which are not taken by this dispatch (forgotten entities)
        <mode> = 3 : displays both duplicated and forgotten entities
        Remark : EvaluateComplete displays these data evaluated for
        for all the dispatches, if there are several

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EvaluateDispatch(self, *args)


    def EvaluateComplete(self, *args):
        """
        EvaluateComplete(Handle_IFSelect_WorkSession self, Standard_Integer const mode=0)

        Displays the effect of applying the ShareOut on the input
        Model.
        <mode> = 0 (default) : displays only roots for each packet,
        <mode> = 1 : displays all entities for each packet, plus
        duplicated entities
        <mode> = 2 : same as <mode> = 1, plus displays forgotten
        entities (which are in no packet at all)

        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_EvaluateComplete(self, *args)


    def ListEntities(self, *args):
        """
        ListEntities(Handle_IFSelect_WorkSession self, Interface_EntityIterator iter, Standard_Integer const mode)

        Internal method which displays an EntityIterator
        <mode> 0 gives short display (only entity numbers)
        1 gives a more complete trace (1 line per Entity)
        (can be used each time a trace has to be output from a list)
        2 gives a form suitable for givelist : (n1,n2,n3...)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type mode: int

        """
        return _IFSelect.Handle_IFSelect_WorkSession_ListEntities(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_WorkSession self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_WorkSession_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_WorkSession_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_WorkSession self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_WorkSession_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_WorkSession self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_WorkSession self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_WorkSession self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_WorkSession self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_WorkSession_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_WorkSession self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_WorkSession_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_WorkSession self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_WorkSession self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_WorkSession_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_WorkSession self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_WorkSession_DecrementRefCounter(self, *args)

Handle_IFSelect_WorkSession_swigregister = _IFSelect.Handle_IFSelect_WorkSession_swigregister
Handle_IFSelect_WorkSession_swigregister(Handle_IFSelect_WorkSession)

def Handle_IFSelect_WorkSession_DownCast(thing):
    return _IFSelect.Handle_IFSelect_WorkSession_DownCast(thing)
Handle_IFSelect_WorkSession_DownCast = _IFSelect.Handle_IFSelect_WorkSession_DownCast

class Handle_IFSelect_SelectModelRoots(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectModelRoots self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectModelRoots self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectModelRoots self, IFSelect_SelectModelRoots thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectModelRoots self, Handle_IFSelect_SelectModelRoots theHandle) -> Handle_IFSelect_SelectModelRoots
        assign(Handle_IFSelect_SelectModelRoots self, IFSelect_SelectModelRoots thePtr) -> Handle_IFSelect_SelectModelRoots
        assign(Handle_IFSelect_SelectModelRoots self, Handle_IFSelect_SelectModelRoots theHandle) -> Handle_IFSelect_SelectModelRoots

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectModelRoots self) -> IFSelect_SelectModelRoots

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectModelRoots self) -> IFSelect_SelectModelRoots

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectModelRoots self) -> IFSelect_SelectModelRoots

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectModelRoots___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectModelRoots___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectModelRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectModelRoots_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectModelRoots

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectModelRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : the Roots of the Model
        (note that this result assures naturally uniqueness)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectModelRoots self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Model Roots"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectModelRoots self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectModelRoots_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectModelRoots_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectModelRoots self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list is empty for all SelectBase type Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectModelRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectModelRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectModelRoots self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectModelRoots self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectModelRoots self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectModelRoots self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectModelRoots self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectModelRoots self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectModelRoots self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectModelRoots self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectModelRoots self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectModelRoots_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectModelRoots_swigregister = _IFSelect.Handle_IFSelect_SelectModelRoots_swigregister
Handle_IFSelect_SelectModelRoots_swigregister(Handle_IFSelect_SelectModelRoots)

def Handle_IFSelect_SelectModelRoots_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectModelRoots_DownCast(thing)
Handle_IFSelect_SelectModelRoots_DownCast = _IFSelect.Handle_IFSelect_SelectModelRoots_DownCast

class Handle_IFSelect_ModelCopier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_ModelCopier self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_ModelCopier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_ModelCopier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_ModelCopier self, IFSelect_ModelCopier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_ModelCopier self, Handle_IFSelect_ModelCopier theHandle) -> Handle_IFSelect_ModelCopier
        assign(Handle_IFSelect_ModelCopier self, IFSelect_ModelCopier thePtr) -> Handle_IFSelect_ModelCopier
        assign(Handle_IFSelect_ModelCopier self, Handle_IFSelect_ModelCopier theHandle) -> Handle_IFSelect_ModelCopier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_ModelCopier self) -> IFSelect_ModelCopier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_ModelCopier self) -> IFSelect_ModelCopier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ModelCopier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_ModelCopier self) -> IFSelect_ModelCopier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_ModelCopier___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_ModelCopier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_ModelCopier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_ModelCopier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_ModelCopier_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_ModelCopier

    def SetShareOut(self, *args):
        """
        SetShareOut(Handle_IFSelect_ModelCopier self, Handle_IFSelect_ShareOut sho)

        Sets the ShareOut, which is used to define Modifiers to apply

        :type sho: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SetShareOut(self, *args)


    def ClearResult(self, *args):
        """
        ClearResult(Handle_IFSelect_ModelCopier self)

        Clears the list of produced Models


        """
        return _IFSelect.Handle_IFSelect_ModelCopier_ClearResult(self, *args)


    def AddFile(self, *args):
        """
        AddFile(Handle_IFSelect_ModelCopier self, TCollection_AsciiString filename, Handle_Interface_InterfaceModel content) -> Standard_Boolean

        Records a new File to be sent, as a couple
        (Name as AsciiString, Content as InterfaceModel)
        Returns True if Done, False if <filename> is already attached
        to another File

        :type filename: OCC.wrapper.TCollection.TCollection_AsciiString
        :type content: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_AddFile(self, *args)


    def NameFile(self, *args):
        """
        NameFile(Handle_IFSelect_ModelCopier self, Standard_Integer const num, TCollection_AsciiString filename) -> Standard_Boolean

        Changes the Name attached to a File which was formerly defined
        by a call to AddFile
        Returns True if Done, False else : if <num> out of range or if
        the new <filename> is already attached to another File
        Remark : Giving an empty File Name is equivalent to ClearFile

        :type num: int
        :type filename: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_NameFile(self, *args)


    def ClearFile(self, *args):
        """
        ClearFile(Handle_IFSelect_ModelCopier self, Standard_Integer const num) -> Standard_Boolean

        Clears the Name attached to a File which was formerly defined
        by a call to AddFile. This Clearing can be undone by a call to
        NameFile (with same <num>)
        Returns True if Done, False else : if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_ClearFile(self, *args)


    def SetAppliedModifiers(self, *args):
        """
        SetAppliedModifiers(Handle_IFSelect_ModelCopier self, Standard_Integer const num, Handle_IFSelect_AppliedModifiers applied) -> Standard_Boolean

        Sets a list of File Modifiers to be applied on a file

        :type num: int
        :type applied: OCC.wrapper.IFSelect.Handle_IFSelect_AppliedModifiers
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SetAppliedModifiers(self, *args)


    def ClearAppliedModifiers(self, *args):
        """
        ClearAppliedModifiers(Handle_IFSelect_ModelCopier self, Standard_Integer const num) -> Standard_Boolean

        Clears the list of File Modifiers to be applied on a file

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_ClearAppliedModifiers(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_IFSelect_ModelCopier self, IFSelect_ShareOutResult eval, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Performs the Copy Operations, which include the Modifications
        defined by the list of Modifiers. Memorizes the result, as a
        list of InterfaceModels with the corresponding FileNames
        They can then be sent, by the method Send, or queried
        Copy calls internal method Copying.
        Returns the produced CheckList

        :type eval: OCC.wrapper.IFSelect.IFSelect_ShareOutResult
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_Copy(self, *args)


    def SendCopied(self, *args):
        """
        SendCopied(Handle_IFSelect_ModelCopier self, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Sends the formerly defined results (see method Copy) to files,
        then clears it
        Remark : A Null File Name cause file to be not produced

        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SendCopied(self, *args)


    def Send(self, *args):
        """
        Send(Handle_IFSelect_ModelCopier self, IFSelect_ShareOutResult eval, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Performs the Copy Operations (which include the Modifications)
        and Sends the result on files, without memorizing it.
        (the memorized result is ignored : neither queried not filled)

        :type eval: OCC.wrapper.IFSelect.IFSelect_ShareOutResult
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_Send(self, *args)


    def SendAll(self, *args):
        """
        SendAll(Handle_IFSelect_ModelCopier self, Standard_CString const filename, Interface_Graph G, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol) -> Interface_CheckIterator

        Sends a model (defined in <G>) into one file, without managing
        remaining data, already sent files, etc. Applies the Model and
        File Modifiers.
        Returns True if well done, False else

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SendAll(self, *args)


    def SendSelected(self, *args):
        """
        SendSelected(Handle_IFSelect_ModelCopier self, Standard_CString const filename, Interface_Graph G, Handle_IFSelect_WorkLibrary WL, Handle_Interface_Protocol protocol, Interface_EntityIterator iter) -> Interface_CheckIterator

        Sends a part of a model into one file. Model is gotten from
        <G>, the part is defined in <iter>.
        Remaining data are managed and can be later be worked on.
        Returns True if well done, False else

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SendSelected(self, *args)


    def CopiedRemaining(self, *args):
        """
        CopiedRemaining(Handle_IFSelect_ModelCopier self, Interface_Graph G, Handle_IFSelect_WorkLibrary WL, Interface_CopyTool TC, Handle_Interface_InterfaceModel newmod)

        Produces a Model copied from the Remaining List as <newmod>
        <newmod> is a Null Handle if this list is empty
        <WL> performs the copy by using <TC>
        <TC> is assumed to have been defined with the starting model
        same as defined by <G>.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type WL: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :type newmod: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_CopiedRemaining(self, *args)


    def SetRemaining(self, *args):
        """
        SetRemaining(Handle_IFSelect_ModelCopier self, Interface_Graph CG) -> Standard_Boolean

        Updates Graph status for remaining data, for each entity :
        - Entities just Sent to file or Copied (by CopiedRemaining)
        have their status set to 1
        - the other keep their former status (1 for Send/Copied,
        0 for Remaining)
        These status are computed by Copying/Sending/CopiedRemaining
        Then, SetRemaining updates graph status, and mustr be called
        just after one of these method has been called
        Returns True if done, False if remaining info if not in phase
        which the Graph (not same counts of items)

        :type CG: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SetRemaining(self, *args)


    def NbFiles(self, *args):
        """
        NbFiles(Handle_IFSelect_ModelCopier self) -> Standard_Integer

        Returns the count of Files produced, i.e. the count of Models
        memorized (produced by the mmethod Copy) with their file names

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_NbFiles(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_IFSelect_ModelCopier self, Standard_Integer const num) -> TCollection_AsciiString

        Returns the File Name for a file given its rank
        It is empty after a call to ClearFile on same <num>

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_FileName(self, *args)


    def FileModel(self, *args):
        """
        FileModel(Handle_IFSelect_ModelCopier self, Standard_Integer const num) -> Handle_Interface_InterfaceModel

        Returns the content of a file before sending, under the form
        of an InterfaceModel, given its rank

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_FileModel(self, *args)


    def AppliedModifiers(self, *args):
        """
        AppliedModifiers(Handle_IFSelect_ModelCopier self, Standard_Integer const num) -> Handle_IFSelect_AppliedModifiers

        Returns the list of File Modifiers to be applied on a file
        when it will be sent, as computed by CopiedModel :
        If it is a null handle, no File Modifier has to be applied.

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_AppliedModifiers

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_AppliedModifiers(self, *args)


    def BeginSentFiles(self, *args):
        """
        BeginSentFiles(Handle_IFSelect_ModelCopier self, Handle_IFSelect_ShareOut sho, Standard_Boolean const record)

        Begins a sequence of recording the really sent files
        <sho> : the default file numbering is cleared
        If <record> is False, clears the list and stops recording
        If <record> is True, clears the list and commands recording
        Creation time corresponds to "stop recording"

        :type sho: OCC.wrapper.IFSelect.Handle_IFSelect_ShareOut
        :type record: bool

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_BeginSentFiles(self, *args)


    def AddSentFile(self, *args):
        """
        AddSentFile(Handle_IFSelect_ModelCopier self, Standard_CString const filename)

        Adds the name of a just sent file, if BeginSentFiles
        has commanded recording; else does nothing
        It is called by methods SendCopied Sending

        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_AddSentFile(self, *args)


    def SentFiles(self, *args):
        """
        SentFiles(Handle_IFSelect_ModelCopier self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of recorded names of sent files. Can be empty
        (if no file has been sent). Returns a Null Handle if
        BeginSentFiles has stopped recording.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_SentFiles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_ModelCopier self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ModelCopier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ModelCopier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_ModelCopier self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_ModelCopier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_ModelCopier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_ModelCopier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_ModelCopier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_ModelCopier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_ModelCopier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_ModelCopier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_ModelCopier self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_ModelCopier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_ModelCopier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ModelCopier_DecrementRefCounter(self, *args)

Handle_IFSelect_ModelCopier_swigregister = _IFSelect.Handle_IFSelect_ModelCopier_swigregister
Handle_IFSelect_ModelCopier_swigregister(Handle_IFSelect_ModelCopier)

def Handle_IFSelect_ModelCopier_DownCast(thing):
    return _IFSelect.Handle_IFSelect_ModelCopier_DownCast(thing)
Handle_IFSelect_ModelCopier_DownCast = _IFSelect.Handle_IFSelect_ModelCopier_DownCast

class Handle_IFSelect_SignAncestor(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignAncestor self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignAncestor self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignAncestor self, IFSelect_SignAncestor thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignAncestor self, Handle_IFSelect_SignAncestor theHandle) -> Handle_IFSelect_SignAncestor
        assign(Handle_IFSelect_SignAncestor self, IFSelect_SignAncestor thePtr) -> Handle_IFSelect_SignAncestor
        assign(Handle_IFSelect_SignAncestor self, Handle_IFSelect_SignAncestor theHandle) -> Handle_IFSelect_SignAncestor

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignAncestor self) -> IFSelect_SignAncestor

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignAncestor self) -> IFSelect_SignAncestor

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignAncestor___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignAncestor self) -> IFSelect_SignAncestor

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignAncestor___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignAncestor___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignAncestor___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignAncestor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignAncestor_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignAncestor

    def Matches(self, *args):
        """
        Matches(Handle_IFSelect_SignAncestor self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Matches(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignAncestor self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignAncestor_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignAncestor_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(Handle_IFSelect_SignAncestor self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object, as its Dynamic
        Type, with or without package name, according starting option

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Value(self, *args)


    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_IFSelect_SignAncestor self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_IFSelect_SignAncestor self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_IFSelect_SignAncestor self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_IFSelect_SignAncestor self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignAncestor self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SignAncestor self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Label(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_IFSelect_SignAncestor self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_SignAncestor self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_IFSelect_SignAncestor self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_IFSelect_SignAncestor self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_IFSelect_SignAncestor self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignAncestor self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignAncestor_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignAncestor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignAncestor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignAncestor self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignAncestor self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignAncestor self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignAncestor self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignAncestor self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignAncestor_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignAncestor self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignAncestor_DecrementRefCounter(self, *args)

Handle_IFSelect_SignAncestor_swigregister = _IFSelect.Handle_IFSelect_SignAncestor_swigregister
Handle_IFSelect_SignAncestor_swigregister(Handle_IFSelect_SignAncestor)

def Handle_IFSelect_SignAncestor_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignAncestor_DownCast(thing)
Handle_IFSelect_SignAncestor_DownCast = _IFSelect.Handle_IFSelect_SignAncestor_DownCast

class IFSelect_SelectSignedSharing(IFSelect_SelectExplore):
    """
    In the graph, explore the sharings of the input entities,
    until it encounters some which match a given Signature
    (for a limited level, filters the returned list)
    By default, fitted for any level
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectSignedSharing
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectSignedSharing(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectSignedSharing self, Handle_IFSelect_Signature matcher, Standard_CString const signtext, Standard_Boolean const exact, Standard_Integer const level=0) -> IFSelect_SelectSignedSharing

        Creates a SelectSignedSharing, defaulted for any level
        with a given Signature and text to match

        :type matcher: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type signtext: OCC.wrapper.Standard.Standard_CString
        :type exact: bool
        :type level: int

        """
        this = _IFSelect.new_IFSelect_SelectSignedSharing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Signature(self, *args):
        """
        Signature(IFSelect_SelectSignedSharing self) -> Handle_IFSelect_Signature

        Returns the used Signature, then it is possible to access it,
        modify it as required

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.IFSelect_SelectSignedSharing_Signature(self, *args)


    def SignatureText(self, *args):
        """
        Returns Text used to Sort Entity on its Signature

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.IFSelect_SelectSignedSharing_SignatureText(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsExact(self, *args):
        """
        IsExact(IFSelect_SelectSignedSharing self) -> Standard_Boolean

        Returns True if match must be exact

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignedSharing_IsExact(self, *args)


    def Explore(self, *args):
        """
        Explore(IFSelect_SelectSignedSharing self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity : its sharing entities
        <ent> to take if it matches the Signature
        At level max, filters the result. Else gives all sharings

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.IFSelect_SelectSignedSharing_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(IFSelect_SelectSignedSharing self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (it refers to the text and exact flag to be matched, and is
        qualified by the Name provided by the Signature)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSignedSharing_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectSignedSharing_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectSignedSharing_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectSignedSharing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSignedSharing
IFSelect_SelectSignedSharing_swigregister = _IFSelect.IFSelect_SelectSignedSharing_swigregister
IFSelect_SelectSignedSharing_swigregister(IFSelect_SelectSignedSharing)

def IFSelect_SelectSignedSharing_get_type_name(*args):
    """
    IFSelect_SelectSignedSharing_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectSignedSharing_get_type_name(*args)

def IFSelect_SelectSignedSharing_get_type_descriptor(*args):
    """
    IFSelect_SelectSignedSharing_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectSignedSharing_get_type_descriptor(*args)

class Handle_IFSelect_IntParam(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_IntParam self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_IntParam_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_IntParam self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_IntParam_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_IntParam self, IFSelect_IntParam thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_IntParam_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_IntParam self, Handle_IFSelect_IntParam theHandle) -> Handle_IFSelect_IntParam
        assign(Handle_IFSelect_IntParam self, IFSelect_IntParam thePtr) -> Handle_IFSelect_IntParam
        assign(Handle_IFSelect_IntParam self, Handle_IFSelect_IntParam theHandle) -> Handle_IFSelect_IntParam

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_IntParam_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_IntParam self) -> IFSelect_IntParam

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_IntParam_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_IntParam self) -> IFSelect_IntParam

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_IntParam___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_IntParam self) -> IFSelect_IntParam

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_IntParam___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_IntParam___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_IntParam___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_IntParam(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_IntParam_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_IntParam

    def SetStaticName(self, *args):
        """
        SetStaticName(Handle_IFSelect_IntParam self, Standard_CString const statname)

        Commands this IntParam to be bound to a Static
        Hence, Value will return the value if this Static if it is set
        Else, Value works on the locally stored value
        SetValue also will set the value of the Static
        This works only for a present static of type integer or enum
        Else, it is ignored

        If <statname> is empty, disconnects the IntParam from Static

        :type statname: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_IntParam_SetStaticName(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IFSelect_IntParam self) -> Standard_Integer

        Reads Integer Value of the IntParam. If a StaticName is
        defined and the Static is set, looks in priority the value
        of the static

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_IntParam_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_IFSelect_IntParam self, Standard_Integer const val)

        Sets a new Integer Value for the IntParam. If a StaticName is
        defined and the Static is set, also sets the value of the static

        :type val: int

        """
        return _IFSelect.Handle_IFSelect_IntParam_SetValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_IntParam self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_IntParam_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_IntParam_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_IntParam_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_IntParam self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_IntParam_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_IntParam self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_IntParam self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_IntParam_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_IntParam self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_IntParam self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_IntParam_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_IntParam self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_IntParam_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_IntParam self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_IntParam_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_IntParam self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_IntParam_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_IntParam self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_IntParam_DecrementRefCounter(self, *args)

Handle_IFSelect_IntParam_swigregister = _IFSelect.Handle_IFSelect_IntParam_swigregister
Handle_IFSelect_IntParam_swigregister(Handle_IFSelect_IntParam)

def Handle_IFSelect_IntParam_DownCast(thing):
    return _IFSelect.Handle_IFSelect_IntParam_DownCast(thing)
Handle_IFSelect_IntParam_DownCast = _IFSelect.Handle_IFSelect_IntParam_DownCast

class Handle_IFSelect_SelectErrorEntities(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectErrorEntities self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectErrorEntities self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectErrorEntities self, IFSelect_SelectErrorEntities thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectErrorEntities self, Handle_IFSelect_SelectErrorEntities theHandle) -> Handle_IFSelect_SelectErrorEntities
        assign(Handle_IFSelect_SelectErrorEntities self, IFSelect_SelectErrorEntities thePtr) -> Handle_IFSelect_SelectErrorEntities
        assign(Handle_IFSelect_SelectErrorEntities self, Handle_IFSelect_SelectErrorEntities theHandle) -> Handle_IFSelect_SelectErrorEntities

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectErrorEntities self) -> IFSelect_SelectErrorEntities

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectErrorEntities self) -> IFSelect_SelectErrorEntities

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectErrorEntities self) -> IFSelect_SelectErrorEntities

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectErrorEntities___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectErrorEntities___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectErrorEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectErrorEntities_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectErrorEntities

    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectErrorEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is qualified as "Error", i.e.
        if <model> explicitly knows <ent> (through its Number) as
        Erroneous

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectErrorEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Error Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectErrorEntities self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectErrorEntities_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectErrorEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectErrorEntities self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectErrorEntities self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectErrorEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_RootResult(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectErrorEntities self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectErrorEntities self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectErrorEntities self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectErrorEntities self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectErrorEntities self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectErrorEntities self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectErrorEntities self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectErrorEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectErrorEntities self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectErrorEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectErrorEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectErrorEntities self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectErrorEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectErrorEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectErrorEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectErrorEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectErrorEntities self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectErrorEntities self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectErrorEntities self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectErrorEntities self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectErrorEntities_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectErrorEntities_swigregister = _IFSelect.Handle_IFSelect_SelectErrorEntities_swigregister
Handle_IFSelect_SelectErrorEntities_swigregister(Handle_IFSelect_SelectErrorEntities)

def Handle_IFSelect_SelectErrorEntities_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectErrorEntities_DownCast(thing)
Handle_IFSelect_SelectErrorEntities_DownCast = _IFSelect.Handle_IFSelect_SelectErrorEntities_DownCast

class Handle_IFSelect_SelectExtract(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectExtract self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectExtract_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectExtract self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectExtract self, IFSelect_SelectExtract thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectExtract self, Handle_IFSelect_SelectExtract theHandle) -> Handle_IFSelect_SelectExtract
        assign(Handle_IFSelect_SelectExtract self, IFSelect_SelectExtract thePtr) -> Handle_IFSelect_SelectExtract
        assign(Handle_IFSelect_SelectExtract self, Handle_IFSelect_SelectExtract theHandle) -> Handle_IFSelect_SelectExtract

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectExtract self) -> IFSelect_SelectExtract

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectExtract self) -> IFSelect_SelectExtract

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectExtract___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectExtract self) -> IFSelect_SelectExtract

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectExtract___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectExtract___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectExtract___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectExtract(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectExtract_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectExtract

    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectExtract self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectExtract self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectExtract self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectExtract self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity if it satisfies the Sort criterium
        It receives :
        - <rank>, the rank of the Entity in the Iteration,
        - <ent> , the Entity itself, and
        - <model>, the Starting Model
        Hence, the Entity to check is "model->Value(num)" (but an
        InterfaceModel allows other checks)
        This method is specific to each class of SelectExtract

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_Sort(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectExtract self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectExtract self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_Label(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectExtract self) -> TCollection_AsciiString

        Returns a text defining the criterium for extraction

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectExtract self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectExtract_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectExtract_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectExtract self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectExtract self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectExtract self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectExtract self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectExtract self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectExtract self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectExtract self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectExtract self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectExtract self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectExtract self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectExtract_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectExtract self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectExtract self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectExtract self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectExtract self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectExtract self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectExtract self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectExtract self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectExtract_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectExtract self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectExtract_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectExtract_swigregister = _IFSelect.Handle_IFSelect_SelectExtract_swigregister
Handle_IFSelect_SelectExtract_swigregister(Handle_IFSelect_SelectExtract)

def Handle_IFSelect_SelectExtract_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectExtract_DownCast(thing)
Handle_IFSelect_SelectExtract_DownCast = _IFSelect.Handle_IFSelect_SelectExtract_DownCast

class Handle_IFSelect_BasicDumper(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_BasicDumper self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_BasicDumper_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_BasicDumper self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_BasicDumper self, IFSelect_BasicDumper thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_BasicDumper self, Handle_IFSelect_BasicDumper theHandle) -> Handle_IFSelect_BasicDumper
        assign(Handle_IFSelect_BasicDumper self, IFSelect_BasicDumper thePtr) -> Handle_IFSelect_BasicDumper
        assign(Handle_IFSelect_BasicDumper self, Handle_IFSelect_BasicDumper theHandle) -> Handle_IFSelect_BasicDumper

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_BasicDumper self) -> IFSelect_BasicDumper

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_BasicDumper self) -> IFSelect_BasicDumper

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_BasicDumper___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_BasicDumper self) -> IFSelect_BasicDumper

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_BasicDumper___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_BasicDumper___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_BasicDumper___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_BasicDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_BasicDumper_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_BasicDumper

    def WriteOwn(self, *args):
        """
        WriteOwn(Handle_IFSelect_BasicDumper self, IFSelect_SessionFile file, Handle_Standard_Transient item) -> Standard_Boolean

        Write the Own Parameters of Types defined in package IFSelect
        Returns True if <item> has been processed, False else

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_WriteOwn(self, *args)


    def ReadOwn(self, *args):
        """
        ReadOwn(Handle_IFSelect_BasicDumper self, IFSelect_SessionFile file, TCollection_AsciiString type, Handle_Standard_Transient item) -> Standard_Boolean

        Recognizes and Read Own Parameters for Types of package
        IFSelect. Returns True if done and <item> created, False else

        :type file: OCC.wrapper.IFSelect.IFSelect_SessionFile
        :type type: OCC.wrapper.TCollection.TCollection_AsciiString
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_ReadOwn(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_BasicDumper self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_BasicDumper_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_BasicDumper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        First(Handle_IFSelect_BasicDumper self) -> Handle_IFSelect_SessionDumper

        Returns the First item of the Library of Dumper. The Next ones
        are then obtained by Next on the returned items

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_First(self, *args)


    def Next(self, *args):
        """
        Next(Handle_IFSelect_BasicDumper self) -> Handle_IFSelect_SessionDumper

        Returns the Next SesionDumper in the Library. Returns a Null
        Handle at the End.

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SessionDumper

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_BasicDumper self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_BasicDumper_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_BasicDumper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_BasicDumper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_BasicDumper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_BasicDumper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_BasicDumper self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_BasicDumper self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_BasicDumper self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_BasicDumper_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_BasicDumper self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_BasicDumper_DecrementRefCounter(self, *args)

Handle_IFSelect_BasicDumper_swigregister = _IFSelect.Handle_IFSelect_BasicDumper_swigregister
Handle_IFSelect_BasicDumper_swigregister(Handle_IFSelect_BasicDumper)

def Handle_IFSelect_BasicDumper_DownCast(thing):
    return _IFSelect.Handle_IFSelect_BasicDumper_DownCast(thing)
Handle_IFSelect_BasicDumper_DownCast = _IFSelect.Handle_IFSelect_BasicDumper_DownCast

class Handle_IFSelect_SelectSignedShared(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectSignedShared self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectSignedShared self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectSignedShared self, IFSelect_SelectSignedShared thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectSignedShared self, Handle_IFSelect_SelectSignedShared theHandle) -> Handle_IFSelect_SelectSignedShared
        assign(Handle_IFSelect_SelectSignedShared self, IFSelect_SelectSignedShared thePtr) -> Handle_IFSelect_SelectSignedShared
        assign(Handle_IFSelect_SelectSignedShared self, Handle_IFSelect_SelectSignedShared theHandle) -> Handle_IFSelect_SelectSignedShared

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectSignedShared self) -> IFSelect_SelectSignedShared

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectSignedShared self) -> IFSelect_SelectSignedShared

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectSignedShared self) -> IFSelect_SelectSignedShared

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectSignedShared___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectSignedShared___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectSignedShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectSignedShared_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectSignedShared

    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_SelectSignedShared self) -> Handle_IFSelect_Signature

        Returns the used Signature, then it is possible to access it,
        modify it as required

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Signature(self, *args)


    def SignatureText(self, *args):
        """
        Returns Text used to Sort Entity on its Signature

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.Handle_IFSelect_SelectSignedShared_SignatureText(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsExact(self, *args):
        """
        IsExact(Handle_IFSelect_SelectSignedShared self) -> Standard_Boolean

        Returns True if match must be exact

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_IsExact(self, *args)


    def Explore(self, *args):
        """
        Explore(Handle_IFSelect_SelectSignedShared self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity : its Shared entities
        <ent> to take if it matches the Signature
        At level max, filters the result. Else gives all Shareds

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_IFSelect_SelectSignedShared self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (it refers to the text and exact flag to be matched, and is
        qualified by the Name provided by the Signature)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectSignedShared self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSignedShared_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSignedShared_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_IFSelect_SelectSignedShared self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectSignedShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectSignedShared self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectSignedShared self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectSignedShared self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectSignedShared self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectSignedShared self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectSignedShared self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectSignedShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectSignedShared self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectSignedShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectSignedShared self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectSignedShared self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectSignedShared self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectSignedShared self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectSignedShared self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectSignedShared self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectSignedShared self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectSignedShared self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectSignedShared self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectSignedShared self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignedShared_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectSignedShared_swigregister = _IFSelect.Handle_IFSelect_SelectSignedShared_swigregister
Handle_IFSelect_SelectSignedShared_swigregister(Handle_IFSelect_SelectSignedShared)

def Handle_IFSelect_SelectSignedShared_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectSignedShared_DownCast(thing)
Handle_IFSelect_SelectSignedShared_DownCast = _IFSelect.Handle_IFSelect_SelectSignedShared_DownCast

class Handle_IFSelect_SelectSuite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectSuite self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectSuite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectSuite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectSuite self, IFSelect_SelectSuite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectSuite self, Handle_IFSelect_SelectSuite theHandle) -> Handle_IFSelect_SelectSuite
        assign(Handle_IFSelect_SelectSuite self, IFSelect_SelectSuite thePtr) -> Handle_IFSelect_SelectSuite
        assign(Handle_IFSelect_SelectSuite self, Handle_IFSelect_SelectSuite theHandle) -> Handle_IFSelect_SelectSuite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectSuite self) -> IFSelect_SelectSuite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectSuite self) -> IFSelect_SelectSuite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSuite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectSuite self) -> IFSelect_SelectSuite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectSuite___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectSuite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectSuite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectSuite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectSuite_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectSuite

    def AddInput(self, *args):
        """
        AddInput(Handle_IFSelect_SelectSuite self, Handle_IFSelect_Selection item) -> Standard_Boolean

        Adds an input selection. I.E. :
        If <item> is a SelectDeduct, adds it as Previous, not as Input
        Else, sets it as Input
        Returns True when done
        Returns False and refuses to work if Input is already defined

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_Selection
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_AddInput(self, *args)


    def AddPrevious(self, *args):
        """
        AddPrevious(Handle_IFSelect_SelectSuite self, Handle_IFSelect_SelectDeduct item)

        Adds a new first item (prepends to the list). The Input is not
        touched
        If <item> is null, does nothing

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_AddPrevious(self, *args)


    def AddNext(self, *args):
        """
        AddNext(Handle_IFSelect_SelectSuite self, Handle_IFSelect_SelectDeduct item)

        Adds a new last item (prepends to the list)
        If <item> is null, does nothing

        :type item: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_AddNext(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_IFSelect_SelectSuite self) -> Standard_Integer

        Returns the count of Items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_NbItems(self, *args)


    def Item(self, *args):
        """
        Item(Handle_IFSelect_SelectSuite self, Standard_Integer const num) -> Handle_IFSelect_SelectDeduct

        Returns an item from its rank in the list
        (the Input is always apart)

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectDeduct

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_Item(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_IFSelect_SelectSuite self, Standard_CString const lab)

        Sets a value for the Label

        :type lab: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_SetLabel(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectSuite self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities
        To do this, once InputResult has been taken (if Input or
        Alternate has been defined, else the first Item gives it) :
        this result is set as alternate input for the first item,
        which computes its result : this result is set as alternate
        input for the second item, etc...

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectSuite self) -> TCollection_AsciiString

        Returns the Label
        Either it has been defined by SetLabel, or it will give
        "Suite of nn Selections"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectSuite self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSuite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSuite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectSuite self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectSuite self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectSuite self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectSuite self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectSuite self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectSuite self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectSuite self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectSuite self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectSuite self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectSuite self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectSuite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectSuite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectSuite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectSuite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectSuite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectSuite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectSuite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectSuite self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectSuite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectSuite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSuite_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectSuite_swigregister = _IFSelect.Handle_IFSelect_SelectSuite_swigregister
Handle_IFSelect_SelectSuite_swigregister(Handle_IFSelect_SelectSuite)

def Handle_IFSelect_SelectSuite_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectSuite_DownCast(thing)
Handle_IFSelect_SelectSuite_DownCast = _IFSelect.Handle_IFSelect_SelectSuite_DownCast

class Handle_IFSelect_SignMultiple(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SignMultiple self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SignMultiple self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SignMultiple self, IFSelect_SignMultiple thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SignMultiple self, Handle_IFSelect_SignMultiple theHandle) -> Handle_IFSelect_SignMultiple
        assign(Handle_IFSelect_SignMultiple self, IFSelect_SignMultiple thePtr) -> Handle_IFSelect_SignMultiple
        assign(Handle_IFSelect_SignMultiple self, Handle_IFSelect_SignMultiple theHandle) -> Handle_IFSelect_SignMultiple

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SignMultiple self) -> IFSelect_SignMultiple

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SignMultiple self) -> IFSelect_SignMultiple

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SignMultiple___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SignMultiple self) -> IFSelect_SignMultiple

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SignMultiple___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SignMultiple___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SignMultiple___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SignMultiple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SignMultiple_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SignMultiple

    def Add(self, *args):
        """
        Add(Handle_IFSelect_SignMultiple self, Handle_IFSelect_Signature subsign, Standard_Integer const width=0, Standard_Boolean const maxi)

        Adds a Signature. Width, if given, gives the tabulation
        If <maxi> is True, it is a forced tabulation (overlength is
        replaced by a final dot)
        If <maxi> is False, just 3 blanks follow an overlength

        :type subsign: OCC.wrapper.IFSelect.Handle_IFSelect_Signature
        :type width: int
        :type maxi: bool

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Add(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IFSelect_SignMultiple self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Concatenates the values of sub-signatures, with their
        tabulations

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Value(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_IFSelect_SignMultiple self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Specialized Match Rule
        If <exact> is False, simply checks if at least one sub-item
        matches
        If <exact> is True, standard match with Value
        (i.e. tabulations must be respected)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Matches(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SignMultiple self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignMultiple_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SignMultiple_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_IFSelect_SignMultiple self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_IFSelect_SignMultiple self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_IFSelect_SignMultiple self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_IFSelect_SignMultiple self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IFSelect_SignMultiple self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SignMultiple self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Label(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_IFSelect_SignMultiple self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_IFSelect_SignMultiple self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_IFSelect_SignMultiple self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_IFSelect_SignMultiple self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_IFSelect_SignMultiple self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SignMultiple self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SignMultiple_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SignMultiple self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SignMultiple self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SignMultiple self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SignMultiple self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SignMultiple self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SignMultiple self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SignMultiple self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SignMultiple_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SignMultiple self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SignMultiple_DecrementRefCounter(self, *args)

Handle_IFSelect_SignMultiple_swigregister = _IFSelect.Handle_IFSelect_SignMultiple_swigregister
Handle_IFSelect_SignMultiple_swigregister(Handle_IFSelect_SignMultiple)

def Handle_IFSelect_SignMultiple_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SignMultiple_DownCast(thing)
Handle_IFSelect_SignMultiple_DownCast = _IFSelect.Handle_IFSelect_SignMultiple_DownCast

class NCollection_Sequence_Handle_IFSelect_GeneralModifier(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_GeneralModifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_IFSelect_GeneralModifier self)

        Reverse sequence


        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, NCollection_Sequence_Handle_IFSelect_GeneralModifier theOther) -> NCollection_Sequence_Handle_IFSelect_GeneralModifier

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, NCollection_Sequence_Handle_IFSelect_GeneralModifier theOther) -> NCollection_Sequence_Handle_IFSelect_GeneralModifier

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Handle_IFSelect_GeneralModifier theItem)
        Append(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, NCollection_Sequence_Handle_IFSelect_GeneralModifier theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Handle_IFSelect_GeneralModifier theItem)
        Prepend(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, NCollection_Sequence_Handle_IFSelect_GeneralModifier theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex, Handle_IFSelect_GeneralModifier theItem)
        InsertBefore(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_GeneralModifier theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::Iterator & thePosition, Handle_IFSelect_GeneralModifier theItem)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_GeneralModifier theSeq)
        InsertAfter(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex, Handle_IFSelect_GeneralModifier theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IFSelect_GeneralModifier theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Handle_IFSelect_GeneralModifier

        First item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_IFSelect_GeneralModifier self) -> Handle_IFSelect_GeneralModifier

        Last item access

        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex) -> Handle_IFSelect_GeneralModifier

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_IFSelect_GeneralModifier self, Standard_Integer const theIndex, Handle_IFSelect_GeneralModifier theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_SetValue(self, *args)


    def __iter__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier___iter__(self)
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_GeneralModifier
NCollection_Sequence_Handle_IFSelect_GeneralModifier_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_swigregister
NCollection_Sequence_Handle_IFSelect_GeneralModifier_swigregister(NCollection_Sequence_Handle_IFSelect_GeneralModifier)

def NCollection_Sequence_Handle_IFSelect_GeneralModifier_delNode(*args):
    """
    NCollection_Sequence_Handle_IFSelect_GeneralModifier_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_delNode(*args)

class NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IFSelect.new_NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper

    def __next__(self):
        return _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper___next__(self)
NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper_swigregister = _IFSelect.NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper_swigregister
NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper_swigregister(NCollection_Sequence_Handle_IFSelect_GeneralModifier_IteratorHelper)


try:
	IFSelect_SequenceOfGeneralModifier = NCollection_Sequence_Handle_IFSelect_GeneralModifier
except NameError:
	pass # does not exist, probably ignored

class Handle_IFSelect_EditForm(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_EditForm self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_EditForm_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_EditForm self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_EditForm self, IFSelect_EditForm thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_EditForm_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_EditForm self, Handle_IFSelect_EditForm theHandle) -> Handle_IFSelect_EditForm
        assign(Handle_IFSelect_EditForm self, IFSelect_EditForm thePtr) -> Handle_IFSelect_EditForm
        assign(Handle_IFSelect_EditForm self, Handle_IFSelect_EditForm theHandle) -> Handle_IFSelect_EditForm

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_EditForm_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_EditForm self) -> IFSelect_EditForm

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_EditForm_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_EditForm self) -> IFSelect_EditForm

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_EditForm___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_EditForm self) -> IFSelect_EditForm

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_EditForm___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_EditForm___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_EditForm___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_EditForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_EditForm_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_EditForm

    def EditKeepStatus(self, *args):
        """
        EditKeepStatus(Handle_IFSelect_EditForm self) -> Standard_Boolean &

        Returns and may change the keep status on modif
        It starts as False
        If it is True, Apply does not clear modification status
        and the EditForm can be loaded again, modified value remain
        and may be applied again
        Remark that ApplyData does not clear the modification status,
        a call to ClearEdit does

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_EditKeepStatus(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_EditForm self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IFSelect.Handle_IFSelect_EditForm_Label(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(Handle_IFSelect_EditForm self) -> Standard_Boolean

        Tells if the EditForm is loaded now

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsLoaded(self, *args)


    def ClearData(self, *args):
        """ClearData(Handle_IFSelect_EditForm self)"""
        return _IFSelect.Handle_IFSelect_EditForm_ClearData(self, *args)


    def SetData(self, *args):
        """
        SetData(Handle_IFSelect_EditForm self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_EditForm_SetData(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(Handle_IFSelect_EditForm self, Handle_Standard_Transient ent)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_EditForm_SetEntity(self, *args)


    def SetModel(self, *args):
        """
        SetModel(Handle_IFSelect_EditForm self, Handle_Interface_InterfaceModel model)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_EditForm_SetModel(self, *args)


    def Entity(self, *args):
        """
        Entity(Handle_IFSelect_EditForm self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_EditForm_Entity(self, *args)


    def Model(self, *args):
        """
        Model(Handle_IFSelect_EditForm self) -> Handle_Interface_InterfaceModel

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFSelect.Handle_IFSelect_EditForm_Model(self, *args)


    def Editor(self, *args):
        """
        Editor(Handle_IFSelect_EditForm self) -> Handle_IFSelect_Editor

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Editor

        """
        return _IFSelect.Handle_IFSelect_EditForm_Editor(self, *args)


    def IsComplete(self, *args):
        """
        IsComplete(Handle_IFSelect_EditForm self) -> Standard_Boolean

        Tells if an EditForm is complete or is an extract from Editor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsComplete(self, *args)


    def NbValues(self, *args):
        """
        NbValues(Handle_IFSelect_EditForm self, Standard_Boolean const editable) -> Standard_Integer

        Returns the count of values
        <editable> True : count of editable values, i.e.
        For a complete EditForm, it is given by the Editor
        Else, it is the length of the extraction map
        <editable> False : all the values from the Editor

        :type editable: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_NbValues(self, *args)


    def NumberFromRank(self, *args):
        """
        NumberFromRank(Handle_IFSelect_EditForm self, Standard_Integer const rank) -> Standard_Integer

        Returns the Value Number in the Editor from a given Rank in
        the EditForm
        For a complete EditForm, both are equal
        Else, it is given by the extraction map
        Returns 0 if <rank> exceeds the count of editable values,

        :type rank: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_NumberFromRank(self, *args)


    def RankFromNumber(self, *args):
        """
        RankFromNumber(Handle_IFSelect_EditForm self, Standard_Integer const number) -> Standard_Integer

        Returns the Rank in the EditForm from a given Number of Value
        for the Editor
        For a complete EditForm, both are equal
        Else, it is given by the extraction map
        Returns 0 if <number> is not forecast to be edited, or is
        out of range

        :type number: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_RankFromNumber(self, *args)


    def NameNumber(self, *args):
        """
        NameNumber(Handle_IFSelect_EditForm self, Standard_CString const name) -> Standard_Integer

        Returns the Value Number in the Editor for a given Name
        i.e. the true ValueNumber which can be used in various methods
        of EditForm
        If it is not complete, for a recorded (in the Editor) but
        non-loaded name, returns negative value (- number)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_NameNumber(self, *args)


    def NameRank(self, *args):
        """
        NameRank(Handle_IFSelect_EditForm self, Standard_CString const name) -> Standard_Integer

        Returns the Rank of Value in the EditForm for a given Name
        i.e. if it is not complete, for a recorded (in the Editor) but
        non-loaded name, returns 0

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_NameRank(self, *args)


    def LoadDefault(self, *args):
        """
        LoadDefault(Handle_IFSelect_EditForm self)

        For a read-write undoable EditForm, loads original values
        from defaults stored in the Editor


        """
        return _IFSelect.Handle_IFSelect_EditForm_LoadDefault(self, *args)


    def LoadData(self, *args):
        """
        LoadData(Handle_IFSelect_EditForm self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean
        LoadData(Handle_IFSelect_EditForm self) -> Standard_Boolean

        Shortcut when both <ent> and <model> are not used
        (when the Editor works on fully static or global data)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_LoadData(self, *args)


    def LoadEntity(self, *args):
        """
        LoadEntity(Handle_IFSelect_EditForm self, Handle_Standard_Transient ent) -> Standard_Boolean

        Shortcut for LoadData when <model> is not used

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_LoadEntity(self, *args)


    def LoadModel(self, *args):
        """
        LoadModel(Handle_IFSelect_EditForm self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Shortcut for LoadData when only the model is concerned

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_LoadModel(self, *args)


    def ListEditor(self, *args):
        """
        ListEditor(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Handle_IFSelect_ListEditor

        Returns a ListEditor to edit the parameter <num> of the
        EditForm, if it is a List
        The Editor created it (by ListEditor) then loads it (by
        ListValue)
        For a single parameter, returns a Null Handle ...

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor

        """
        return _IFSelect.Handle_IFSelect_EditForm_ListEditor(self, *args)


    def LoadValue(self, *args):
        """
        LoadValue(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_TCollection_HAsciiString val)

        Loads an original value (single). Called by the Editor only

        :type num: int
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_EditForm_LoadValue(self, *args)


    def LoadList(self, *args):
        """
        LoadList(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString list)

        Loads an original value as a list. Called by the Editor only

        :type num: int
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_EditForm_LoadList(self, *args)


    def OriginalValue(self, *args):
        """
        OriginalValue(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        From an edited value, returns its ... value (original one)
        Null means that this value is not defined
        <num> is for the EditForm, not the Editor
        It is for a single parameter. For a list, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_EditForm_OriginalValue(self, *args)


    def OriginalList(self, *args):
        """
        OriginalList(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns an original value, as a list
        <num> is for the EditForm, not the Editor
        For a single parameter, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_EditForm_OriginalList(self, *args)


    def EditedValue(self, *args):
        """
        EditedValue(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns the Edited (i.e. Modified) Value (string for single)
        <num> reports to the EditForm
        If IsModified is False, returns OriginalValue
        Null with IsModified True : means that this value is not
        defined or has been removed
        It is for a single parameter. For a list, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_EditForm_EditedValue(self, *args)


    def EditedList(self, *args):
        """
        EditedList(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the Edited Value as a list
        If IsModified is False, returns OriginalValue
        Null with IsModified True : means that this value is not
        defined or has been removed
        For a single parameter, gives a Null Handle

        :type num: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _IFSelect.Handle_IFSelect_EditForm_EditedList(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Standard_Boolean

        Tells if a Value (of the EditForm) is modified (directly or
        through touching by Update)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsModified(self, *args)


    def IsTouched(self, *args):
        """
        IsTouched(Handle_IFSelect_EditForm self, Standard_Integer const num) -> Standard_Boolean

        Tells if a Value (of the EditForm) has been touched, i.e.
        not modified directly but by the modification of another one
        (by method Update from the Editor)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsTouched(self, *args)


    def Modify(self, *args):
        """
        Modify(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_TCollection_HAsciiString newval, Standard_Boolean const enforce) -> Standard_Boolean

        Gives a new value for the item <num> of the EditForm, if
        it is a single parameter (for a list, just returns False)
        Null means to Remove it
        <enforce> True to overpass Protected or Computed Access Mode
        Calls the method Update from the Editor, which can touch other
        parameters (see NbTouched)
        Returns True if well recorded, False if this value is not
        allowed
        Warning : Does not apply immediately : will be applied by the method
        Apply

        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_Modify(self, *args)


    def ModifyList(self, *args):
        """
        ModifyList(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_IFSelect_ListEditor edited, Standard_Boolean const enforce) -> Standard_Boolean

        Changes the value of an item of the EditForm, if it is a List
        (else, just returns False)
        The ListEditor contains the edited values of the list
        If no edition was recorded, just returns False
        Calls the method Update from the Editor, which can touch other
        parameters (see NbTouched)
        Returns True if well recorded, False if this value is not
        allowed
        Warning : Does not apply immediately : will be applied by the method
        Apply

        :type num: int
        :type edited: OCC.wrapper.IFSelect.Handle_IFSelect_ListEditor
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_ModifyList(self, *args)


    def ModifyListValue(self, *args):
        """
        ModifyListValue(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString list, Standard_Boolean const enforce) -> Standard_Boolean

        As ModifyList but the new value is given as such
        Creates a ListEditor, Loads it, then calls ModifyList

        :type num: int
        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_ModifyListValue(self, *args)


    def Touch(self, *args):
        """
        Touch(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_TCollection_HAsciiString newval) -> Standard_Boolean

        Gives a new value computed by the Editor, if another parameter
        commands the value of <num>
        It is generally the case for a Computed Parameter for instance
        Increments the counter of touched parameters
        Warning : it gives no protection for ReadOnly etc... while it is the
        internal way of touching parameters
        Does not work (returns False) if <num> is for a list

        :type num: int
        :type newval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_Touch(self, *args)


    def TouchList(self, *args):
        """
        TouchList(Handle_IFSelect_EditForm self, Standard_Integer const num, Handle_TColStd_HSequenceOfHAsciiString newlist) -> Standard_Boolean

        Acts as Touch but for a list
        Does not work (returns False) if <num> is for a single param

        :type num: int
        :type newlist: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_TouchList(self, *args)


    def ClearEdit(self, *args):
        """
        ClearEdit(Handle_IFSelect_EditForm self, Standard_Integer const num=0)

        Clears modification status : by default all, or one by its
        numbers (in the Editor)

        :type num: int

        """
        return _IFSelect.Handle_IFSelect_EditForm_ClearEdit(self, *args)


    def PrintDefs(self, *args):
        """
        PrintDefs(Handle_IFSelect_EditForm self, Handle_Message_Messenger S)

        Prints Definitions, relative to the Editor

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _IFSelect.Handle_IFSelect_EditForm_PrintDefs(self, *args)


    def PrintValues(self, *args):
        """
        PrintValues(Handle_IFSelect_EditForm self, Handle_Message_Messenger S, Standard_Integer const what, Standard_Boolean const names, Standard_Boolean const alsolist)

        Prints Values, according to what and alsolist
        <names> True : prints Long Names; False : prints Short Names
        <what> < 0 : prints Original Values (+ flag Modified)
        <what> > 0 : prints Final Values (+flag Modified)
        <what> = 0 : prints Modified Values (Original + Edited)
        <alsolist> False (D) : lists are printed only as their count
        <alsolist> True : lists are printed for all their items

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type what: int
        :type names: bool
        :type alsolist: bool

        """
        return _IFSelect.Handle_IFSelect_EditForm_PrintValues(self, *args)


    def Apply(self, *args):
        """
        Apply(Handle_IFSelect_EditForm self) -> Standard_Boolean

        Applies modifications to own data
        Calls ApplyData then Clears Status according EditKeepStatus

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_Apply(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_IFSelect_EditForm self) -> Standard_Boolean

        Tells if this EditForm can work with its Editor and its actual
        Data (Entity and Model)
        Default uses Editor. Can be redefined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_Recognize(self, *args)


    def ApplyData(self, *args):
        """
        ApplyData(Handle_IFSelect_EditForm self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Applies modifications to data
        Default uses Editor. Can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_ApplyData(self, *args)


    def Undo(self, *args):
        """
        Undo(Handle_IFSelect_EditForm self) -> Standard_Boolean

        For an undoable EditForm, Applies ... origibal values !
        and clears modified ones
        Can be run only once

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_Undo(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_EditForm self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_EditForm_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_EditForm_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_EditForm_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_EditForm self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_EditForm_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_EditForm self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_EditForm self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_EditForm self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_EditForm self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_EditForm_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_EditForm self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_EditForm_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_EditForm self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_EditForm self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_EditForm_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_EditForm self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_EditForm_DecrementRefCounter(self, *args)

Handle_IFSelect_EditForm_swigregister = _IFSelect.Handle_IFSelect_EditForm_swigregister
Handle_IFSelect_EditForm_swigregister(Handle_IFSelect_EditForm)

def Handle_IFSelect_EditForm_DownCast(thing):
    return _IFSelect.Handle_IFSelect_EditForm_DownCast(thing)
Handle_IFSelect_EditForm_DownCast = _IFSelect.Handle_IFSelect_EditForm_DownCast

class Handle_IFSelect_SelectType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectType self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectType self, IFSelect_SelectType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectType self, Handle_IFSelect_SelectType theHandle) -> Handle_IFSelect_SelectType
        assign(Handle_IFSelect_SelectType self, IFSelect_SelectType thePtr) -> Handle_IFSelect_SelectType
        assign(Handle_IFSelect_SelectType self, Handle_IFSelect_SelectType theHandle) -> Handle_IFSelect_SelectType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectType self) -> IFSelect_SelectType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectType self) -> IFSelect_SelectType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectType self) -> IFSelect_SelectType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectType___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectType_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectType

    def SetType(self, *args):
        """
        SetType(Handle_IFSelect_SelectType self, Handle_Standard_Type atype)

        Sets a TYpe for filter

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.Handle_IFSelect_SelectType_SetType(self, *args)


    def TypeForMatch(self, *args):
        """
        TypeForMatch(Handle_IFSelect_SelectType self) -> Handle_Standard_Type

        Returns the Type to be matched for select : this is the type
        given at instantiation time

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.Handle_IFSelect_SelectType_TypeForMatch(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectType self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (should by gotten from Type of Entity used for instantiation)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectType_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectType self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectType self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity (model->Value(num)) which is kind
        of the choosen type, given by the method TypeForMatch.
        Criterium is IsKind.

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_Sort(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectType self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectType self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectType_SetDirect(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Sort on each input Entity : the Entity is kept as
        output if Sort returns the same value as Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectType_RootResult(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectType self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectType self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectType_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectType self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectType_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectType self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectType_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectType self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectType self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectType self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectType_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectType_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectType self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectType_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectType_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectType self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectType_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectType self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectType self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectType_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectType_swigregister = _IFSelect.Handle_IFSelect_SelectType_swigregister
Handle_IFSelect_SelectType_swigregister(Handle_IFSelect_SelectType)

def Handle_IFSelect_SelectType_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectType_DownCast(thing)
Handle_IFSelect_SelectType_DownCast = _IFSelect.Handle_IFSelect_SelectType_DownCast

class IFSelect_SelectModelEntities(IFSelect_SelectBase):
    """
    A SelectModelEntities gets all the Entities of an
    InterfaceModel.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IFSelect_SelectModelEntities
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IFSelect_SelectModelEntities(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IFSelect_SelectModelEntities self) -> IFSelect_SelectModelEntities

        Creates a SelectModelRoot


        """
        this = _IFSelect.new_IFSelect_SelectModelEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(IFSelect_SelectModelEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : the Entities of the
        Model (note that this result assures naturally uniqueness)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectModelEntities_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(IFSelect_SelectModelEntities self, Interface_Graph G) -> Interface_EntityIterator

        The complete list of Entities (including shared ones) ...
        is exactly identical to RootResults in this case

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectModelEntities_CompleteResult(self, *args)


    def Label(self, *args):
        """
        Label(IFSelect_SelectModelEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Model Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectModelEntities_Label(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IFSelect.IFSelect_SelectModelEntities_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IFSelect.IFSelect_SelectModelEntities_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.IFSelect_SelectModelEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectModelEntities
IFSelect_SelectModelEntities_swigregister = _IFSelect.IFSelect_SelectModelEntities_swigregister
IFSelect_SelectModelEntities_swigregister(IFSelect_SelectModelEntities)

def IFSelect_SelectModelEntities_get_type_name(*args):
    """
    IFSelect_SelectModelEntities_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IFSelect.IFSelect_SelectModelEntities_get_type_name(*args)

def IFSelect_SelectModelEntities_get_type_descriptor(*args):
    """
    IFSelect_SelectModelEntities_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IFSelect.IFSelect_SelectModelEntities_get_type_descriptor(*args)

class Handle_IFSelect_ShareOut(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_ShareOut self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_ShareOut_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_ShareOut self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_ShareOut_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_ShareOut self, IFSelect_ShareOut thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_ShareOut_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_ShareOut self, Handle_IFSelect_ShareOut theHandle) -> Handle_IFSelect_ShareOut
        assign(Handle_IFSelect_ShareOut self, IFSelect_ShareOut thePtr) -> Handle_IFSelect_ShareOut
        assign(Handle_IFSelect_ShareOut self, Handle_IFSelect_ShareOut theHandle) -> Handle_IFSelect_ShareOut

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_ShareOut_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_ShareOut self) -> IFSelect_ShareOut

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ShareOut_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_ShareOut self) -> IFSelect_ShareOut

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_ShareOut___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_ShareOut self) -> IFSelect_ShareOut

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_ShareOut___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_ShareOut___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_ShareOut___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_ShareOut(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_ShareOut_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_ShareOut

    def Clear(self, *args):
        """
        Clear(Handle_IFSelect_ShareOut self, Standard_Boolean const onlydisp)

        Removes in one operation all the Dispatches with their Idents
        Also clears all informations about Names, and all Results but
        naming informations which are :
        - kept if <onlydisp> is True.
        - cleared if <onlydisp> is False (complete clearing)
        If <onlydisp> is True, that's all. Else, clears also Modifiers

        :type onlydisp: bool

        """
        return _IFSelect.Handle_IFSelect_ShareOut_Clear(self, *args)


    def ClearResult(self, *args):
        """
        ClearResult(Handle_IFSelect_ShareOut self, Standard_Boolean const alsoname)

        Clears all data produced (apart from Dispatches, etc...)
        if <alsoname> is True, all is cleared. Else, informations
        about produced Names are kept (to maintain unicity of naming
        across clearings)

        :type alsoname: bool

        """
        return _IFSelect.Handle_IFSelect_ShareOut_ClearResult(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(Handle_IFSelect_ShareOut self, Handle_Standard_Transient item) -> Standard_Boolean

        Removes an item, which can be, either a Dispatch (removed from
        the list of Dispatches), or a GeneralModifier (removed from
        the list of Model Modifiers or from the list of File Modifiers
        according to its type).
        Returns True if done, False if has not been found or if it is
        neither a Dispatch, nor a Modifier.

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_RemoveItem(self, *args)


    def LastRun(self, *args):
        """
        LastRun(Handle_IFSelect_ShareOut self) -> Standard_Integer

        Returns the rank of last run item (ClearResult resets it to 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_LastRun(self, *args)


    def SetLastRun(self, *args):
        """
        SetLastRun(Handle_IFSelect_ShareOut self, Standard_Integer const last)

        Records a new alue for the rank of last run item

        :type last: int

        """
        return _IFSelect.Handle_IFSelect_ShareOut_SetLastRun(self, *args)


    def NbDispatches(self, *args):
        """
        NbDispatches(Handle_IFSelect_ShareOut self) -> Standard_Integer

        Returns the count of Dispatches

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_NbDispatches(self, *args)


    def DispatchRank(self, *args):
        """
        DispatchRank(Handle_IFSelect_ShareOut self, Handle_IFSelect_Dispatch disp) -> Standard_Integer

        Returns the Rank of a Dispatch, given its Value (Handle).
        Returns 0 if the Dispatch is unknown in the ShareOut

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_DispatchRank(self, *args)


    def Dispatch(self, *args):
        """
        Returns a Dispatch, given its rank in the list

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        res = _IFSelect.Handle_IFSelect_ShareOut_Dispatch(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddDispatch(self, *args):
        """
        AddDispatch(Handle_IFSelect_ShareOut self, Handle_IFSelect_Dispatch disp)

        Adds a Dispatch to the list

        :type disp: OCC.wrapper.IFSelect.Handle_IFSelect_Dispatch

        """
        return _IFSelect.Handle_IFSelect_ShareOut_AddDispatch(self, *args)


    def RemoveDispatch(self, *args):
        """
        RemoveDispatch(Handle_IFSelect_ShareOut self, Standard_Integer const rank) -> Standard_Boolean

        Removes a Dispatch, given its rank in the list
        Returns True if done, False if rank is not between
        (LastRun + 1) and (NbDispatches)

        :type rank: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_RemoveDispatch(self, *args)


    def AddModifier(self, *args):
        """
        AddModifier(Handle_IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier, Standard_Integer const atnum)
        AddModifier(Handle_IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier, Standard_Integer const dispnum, Standard_Integer const atnum)

        Sets a Modifier to be applied on the Dispatch <dispnum>
        If <modifier> is a ModelModifier, adds it to the list of
        Model Modifiers; else to the list of File Modifiers
        This is the same list as for all Dispatches, but the
        Modifier is qualified to be applied to one Dispatch only
        Then, <atnum> refers to the entire list
        By default (atnum = 0) at the end of the list, else at <atnum>
        Remark : if the Modifier was already in the list and if
        <atnum> = 0, the Modifier is not moved, but only qualified
        for a Dispatch

        :type modifier: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type dispnum: int
        :type atnum: int

        """
        return _IFSelect.Handle_IFSelect_ShareOut_AddModifier(self, *args)


    def AddModif(self, *args):
        """
        AddModif(Handle_IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier, Standard_Boolean const formodel, Standard_Integer const atnum=0)

        Adds a Modifier to the list of Modifiers : Model Modifiers if
        <formodel> is True, File Modifiers else (internal).

        :type modifier: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :type formodel: bool
        :type atnum: int

        """
        return _IFSelect.Handle_IFSelect_ShareOut_AddModif(self, *args)


    def NbModifiers(self, *args):
        """
        NbModifiers(Handle_IFSelect_ShareOut self, Standard_Boolean const formodel) -> Standard_Integer

        Returns count of Modifiers (which apply to complete Models) :
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_NbModifiers(self, *args)


    def GeneralModifier(self, *args):
        """
        GeneralModifier(Handle_IFSelect_ShareOut self, Standard_Boolean const formodel, Standard_Integer const num) -> Handle_IFSelect_GeneralModifier

        Returns a Modifier of the list, given its rank :
        Model Modifiers if <formodel> is True, File Modifiers else

        :type formodel: bool
        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier

        """
        return _IFSelect.Handle_IFSelect_ShareOut_GeneralModifier(self, *args)


    def ModelModifier(self, *args):
        """
        ModelModifier(Handle_IFSelect_ShareOut self, Standard_Integer const num) -> Handle_IFSelect_Modifier

        Returns a Modifier of the list of Model Modifiers, duely casted

        :type num: int
        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Modifier

        """
        return _IFSelect.Handle_IFSelect_ShareOut_ModelModifier(self, *args)


    def ModifierRank(self, *args):
        """
        ModifierRank(Handle_IFSelect_ShareOut self, Handle_IFSelect_GeneralModifier modifier) -> Standard_Integer

        Gives the rank of a Modifier in the list, 0 if not in the list
        Model Modifiers if <modifier> is kind of ModelModifer,
        File Modifiers else

        :type modifier: OCC.wrapper.IFSelect.Handle_IFSelect_GeneralModifier
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_ModifierRank(self, *args)


    def RemoveModifier(self, *args):
        """
        RemoveModifier(Handle_IFSelect_ShareOut self, Standard_Boolean const formodel, Standard_Integer const num) -> Standard_Boolean

        Removes a Modifier, given it rank in the list :
        Model Modifiers if <formodel> is True, File Modifiers else
        Returns True if done, False if <num> is out of range

        :type formodel: bool
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_RemoveModifier(self, *args)


    def ChangeModifierRank(self, *args):
        """
        ChangeModifierRank(Handle_IFSelect_ShareOut self, Standard_Boolean const formodel, Standard_Integer const befor, Standard_Integer const after) -> Standard_Boolean

        Changes the rank of a modifier in the list :
        Model Modifiers if <formodel> is True, File Modifiers else
        from <before> to <after>
        Returns True if done, False else (before or after out of range)

        :type formodel: bool
        :type befor: int
        :type after: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_ChangeModifierRank(self, *args)


    def SetRootName(self, *args):
        """
        SetRootName(Handle_IFSelect_ShareOut self, Standard_Integer const num, Handle_TCollection_HAsciiString name) -> Standard_Boolean

        Attaches a Root Name to a Dispatch given its rank, as an
        HAsciiString (standard form). A Null Handle resets this name.
        Returns True if OK, False if this Name is already attached,
        for a Dispatch or for Default, or <num> out of range

        :type num: int
        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_SetRootName(self, *args)


    def HasRootName(self, *args):
        """
        HasRootName(Handle_IFSelect_ShareOut self, Standard_Integer const num) -> Standard_Boolean

        Returns True if the Dispatch of rank <num> has an attached
        Root Name. False else, or if num is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_HasRootName(self, *args)


    def RootName(self, *args):
        """
        RootName(Handle_IFSelect_ShareOut self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns the Root bound to a Dispatch, given its rank
        Returns a Null Handle if not defined

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_RootName(self, *args)


    def RootNumber(self, *args):
        """
        RootNumber(Handle_IFSelect_ShareOut self, Handle_TCollection_HAsciiString name) -> Standard_Integer

        Returns an integer value about a given root name :
        - positive : it's the rank of the Dispatch which has this name
        - null : this root name is unknown
        - negative (-1) : this root name is the default root name

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_RootNumber(self, *args)


    def SetPrefix(self, *args):
        """
        SetPrefix(Handle_IFSelect_ShareOut self, Handle_TCollection_HAsciiString pref)

        Defines or Changes the general Prefix (which is prepended to
        complete file name generated). If this method is not call,
        Prefix remains empty

        :type pref: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_SetPrefix(self, *args)


    def SetDefaultRootName(self, *args):
        """
        SetDefaultRootName(Handle_IFSelect_ShareOut self, Handle_TCollection_HAsciiString defrt) -> Standard_Boolean

        Defines or Changes the Default Root Name to a new value (which
        is used for dispatches which have no attached root name).
        If this method is not called, DefaultRootName remains empty
        Returns True if OK, False if this Name is already attached,
        for a Dispatch or for Default

        :type defrt: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_SetDefaultRootName(self, *args)


    def SetExtension(self, *args):
        """
        SetExtension(Handle_IFSelect_ShareOut self, Handle_TCollection_HAsciiString ext)

        Defines or Changes the general Extension (which is appended to
        complete file name generated). If this method is not call,
        Extension remains empty

        :type ext: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_SetExtension(self, *args)


    def Prefix(self, *args):
        """
        Prefix(Handle_IFSelect_ShareOut self) -> Handle_TCollection_HAsciiString

        Returns the general Prefix. Can be empty.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_Prefix(self, *args)


    def DefaultRootName(self, *args):
        """
        DefaultRootName(Handle_IFSelect_ShareOut self) -> Handle_TCollection_HAsciiString

        Returns the Default Root Name. Can be empty.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_DefaultRootName(self, *args)


    def Extension(self, *args):
        """
        Extension(Handle_IFSelect_ShareOut self) -> Handle_TCollection_HAsciiString

        Returns the general Extension. Can be empty (not recommanded)

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_Extension(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_IFSelect_ShareOut self, Standard_Integer const dnum, Standard_Integer const pnum, Standard_Integer const nbpack=0) -> TCollection_AsciiString

        Computes the complete file name for a Packet of a Dispatch,
        given Dispatch Number (Rank), Packet Number, and Count of
        Packets generated by this Dispatch (0 if unknown)

        File Name is made of following strings, concatenated :
        General Prefix, Root Name for Dispatch, Packet Suffix, and
        General Extension. If no Root Name is specified for a
        Dispatch, DefaultRootName is considered (and pnum is not used,
        but <thenbdefs> is incremented and used
        Error if no Root is defined for this <idnum>

        :type dnum: int
        :type pnum: int
        :type nbpack: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_ShareOut_FileName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_ShareOut self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_ShareOut_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ShareOut_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_ShareOut_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_ShareOut self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_ShareOut_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_ShareOut self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_ShareOut self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_ShareOut self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_ShareOut self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_ShareOut_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_ShareOut self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_ShareOut_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_ShareOut self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_ShareOut self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_ShareOut_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_ShareOut self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_ShareOut_DecrementRefCounter(self, *args)

Handle_IFSelect_ShareOut_swigregister = _IFSelect.Handle_IFSelect_ShareOut_swigregister
Handle_IFSelect_ShareOut_swigregister(Handle_IFSelect_ShareOut)

def Handle_IFSelect_ShareOut_DownCast(thing):
    return _IFSelect.Handle_IFSelect_ShareOut_DownCast(thing)
Handle_IFSelect_ShareOut_DownCast = _IFSelect.Handle_IFSelect_ShareOut_DownCast

class Handle_IFSelect_SelectSharing(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectSharing self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectSharing_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectSharing self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectSharing self, IFSelect_SelectSharing thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectSharing self, Handle_IFSelect_SelectSharing theHandle) -> Handle_IFSelect_SelectSharing
        assign(Handle_IFSelect_SelectSharing self, IFSelect_SelectSharing thePtr) -> Handle_IFSelect_SelectSharing
        assign(Handle_IFSelect_SelectSharing self, Handle_IFSelect_SelectSharing theHandle) -> Handle_IFSelect_SelectSharing

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectSharing self) -> IFSelect_SelectSharing

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectSharing self) -> IFSelect_SelectSharing

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSharing___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectSharing self) -> IFSelect_SelectSharing

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectSharing___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectSharing___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectSharing___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectSharing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectSharing_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectSharing

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities (list of entities
        which share (level one) those of input list)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectSharing self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Sharing (one level)"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectSharing self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSharing_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSharing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectSharing self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectSharing self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectSharing self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectSharing self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectSharing self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectSharing self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectSharing self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectSharing_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectSharing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectSharing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectSharing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectSharing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectSharing self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectSharing self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectSharing self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectSharing_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectSharing self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSharing_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectSharing_swigregister = _IFSelect.Handle_IFSelect_SelectSharing_swigregister
Handle_IFSelect_SelectSharing_swigregister(Handle_IFSelect_SelectSharing)

def Handle_IFSelect_SelectSharing_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectSharing_DownCast(thing)
Handle_IFSelect_SelectSharing_DownCast = _IFSelect.Handle_IFSelect_SelectSharing_DownCast

class Handle_IFSelect_SelectRoots(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectRoots self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectRoots_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectRoots self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectRoots self, IFSelect_SelectRoots thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectRoots self, Handle_IFSelect_SelectRoots theHandle) -> Handle_IFSelect_SelectRoots
        assign(Handle_IFSelect_SelectRoots self, IFSelect_SelectRoots thePtr) -> Handle_IFSelect_SelectRoots
        assign(Handle_IFSelect_SelectRoots self, Handle_IFSelect_SelectRoots theHandle) -> Handle_IFSelect_SelectRoots

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectRoots self) -> IFSelect_SelectRoots

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectRoots self) -> IFSelect_SelectRoots

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectRoots___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectRoots self) -> IFSelect_SelectRoots

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectRoots___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectRoots___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectRoots___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectRoots_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectRoots

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of local roots. It is redefined for a purpose
        of effeciency : calling a Sort routine for each Entity would
        cost more ressource than to work in once using a Map
        RootResult takes in account the Direct status

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_RootResult(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_IFSelect_SelectRoots self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns always True, because RootResult has done work

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_IFSelect_SelectRoots self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Local Root Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_ExtractLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectRoots self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectRoots_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectRoots_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDirect(self, *args):
        """
        IsDirect(Handle_IFSelect_SelectRoots self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_IFSelect_SelectRoots self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_SetDirect(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_IFSelect_SelectRoots self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectRoots self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectRoots self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectRoots self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectRoots self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectRoots self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectRoots self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectRoots self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectRoots self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectRoots self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectRoots_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectRoots self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectRoots self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectRoots self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectRoots self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectRoots self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectRoots self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectRoots self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectRoots_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectRoots self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectRoots_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectRoots_swigregister = _IFSelect.Handle_IFSelect_SelectRoots_swigregister
Handle_IFSelect_SelectRoots_swigregister(Handle_IFSelect_SelectRoots)

def Handle_IFSelect_SelectRoots_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectRoots_DownCast(thing)
Handle_IFSelect_SelectRoots_DownCast = _IFSelect.Handle_IFSelect_SelectRoots_DownCast

class Handle_IFSelect_SelectExplore(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectExplore self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectExplore self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectExplore self, IFSelect_SelectExplore thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectExplore self, Handle_IFSelect_SelectExplore theHandle) -> Handle_IFSelect_SelectExplore
        assign(Handle_IFSelect_SelectExplore self, IFSelect_SelectExplore thePtr) -> Handle_IFSelect_SelectExplore
        assign(Handle_IFSelect_SelectExplore self, Handle_IFSelect_SelectExplore theHandle) -> Handle_IFSelect_SelectExplore

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectExplore self) -> IFSelect_SelectExplore

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectExplore self) -> IFSelect_SelectExplore

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectExplore___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectExplore self) -> IFSelect_SelectExplore

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectExplore___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectExplore___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectExplore___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectExplore(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectExplore_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectExplore

    def Level(self, *args):
        """
        Level(Handle_IFSelect_SelectExplore self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectExplore self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_RootResult(self, *args)


    def Explore(self, *args):
        """
        Explore(Handle_IFSelect_SelectExplore self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Analyses and, if required, Explores an entity, as follows :
        The explored list starts as empty, it has to be filled by this
        method.
        If it returns False, <ent> is rejected for result (this is to
        be used only as safety)
        If it returns True and <explored> remains empty, <ent> is
        taken itself for result, not explored
        If it returns True and <explored> is not empty, the content
        of this list is considered :
        If maximum level is attained, it is taken for result
        Else (or no max), each of its entity will be itself explored

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Explore(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectExplore self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Label(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_IFSelect_SelectExplore self) -> TCollection_AsciiString

        Returns a text defining the way of exploration

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectExplore self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectExplore_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectExplore_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectExplore self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectExplore self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectExplore self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectExplore self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectExplore self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectExplore self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectExplore self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectExplore self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectExplore self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectExplore self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectExplore_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectExplore self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectExplore self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectExplore self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectExplore self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectExplore self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectExplore self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectExplore self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectExplore_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectExplore self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectExplore_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectExplore_swigregister = _IFSelect.Handle_IFSelect_SelectExplore_swigregister
Handle_IFSelect_SelectExplore_swigregister(Handle_IFSelect_SelectExplore)

def Handle_IFSelect_SelectExplore_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectExplore_DownCast(thing)
Handle_IFSelect_SelectExplore_DownCast = _IFSelect.Handle_IFSelect_SelectExplore_DownCast

class Handle_IFSelect_SelectModelEntities(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectModelEntities self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectModelEntities self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectModelEntities self, IFSelect_SelectModelEntities thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectModelEntities self, Handle_IFSelect_SelectModelEntities theHandle) -> Handle_IFSelect_SelectModelEntities
        assign(Handle_IFSelect_SelectModelEntities self, IFSelect_SelectModelEntities thePtr) -> Handle_IFSelect_SelectModelEntities
        assign(Handle_IFSelect_SelectModelEntities self, Handle_IFSelect_SelectModelEntities theHandle) -> Handle_IFSelect_SelectModelEntities

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectModelEntities self) -> IFSelect_SelectModelEntities

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectModelEntities self) -> IFSelect_SelectModelEntities

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectModelEntities self) -> IFSelect_SelectModelEntities

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectModelEntities___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectModelEntities___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectModelEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectModelEntities_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectModelEntities

    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectModelEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities : the Entities of the
        Model (note that this result assures naturally uniqueness)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectModelEntities self, Interface_Graph G) -> Interface_EntityIterator

        The complete list of Entities (including shared ones) ...
        is exactly identical to RootResults in this case

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_CompleteResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectModelEntities self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Model Entities"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_Label(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectModelEntities self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectModelEntities_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectModelEntities_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectModelEntities self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list is empty for all SelectBase type Selections

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectModelEntities self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_UniqueResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectModelEntities self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectModelEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectModelEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectModelEntities self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectModelEntities self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectModelEntities self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectModelEntities self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectModelEntities self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectModelEntities self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectModelEntities_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectModelEntities_swigregister = _IFSelect.Handle_IFSelect_SelectModelEntities_swigregister
Handle_IFSelect_SelectModelEntities_swigregister(Handle_IFSelect_SelectModelEntities)

def Handle_IFSelect_SelectModelEntities_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectModelEntities_DownCast(thing)
Handle_IFSelect_SelectModelEntities_DownCast = _IFSelect.Handle_IFSelect_SelectModelEntities_DownCast

class Handle_IFSelect_SelectSignedSharing(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IFSelect_SelectSignedSharing self)

        Nullify the handle


        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IFSelect_SelectSignedSharing self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IFSelect_SelectSignedSharing self, IFSelect_SelectSignedSharing thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IFSelect_SelectSignedSharing self, Handle_IFSelect_SelectSignedSharing theHandle) -> Handle_IFSelect_SelectSignedSharing
        assign(Handle_IFSelect_SelectSignedSharing self, IFSelect_SelectSignedSharing thePtr) -> Handle_IFSelect_SelectSignedSharing
        assign(Handle_IFSelect_SelectSignedSharing self, Handle_IFSelect_SelectSignedSharing theHandle) -> Handle_IFSelect_SelectSignedSharing

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IFSelect_SelectSignedSharing self) -> IFSelect_SelectSignedSharing

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IFSelect_SelectSignedSharing self) -> IFSelect_SelectSignedSharing

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IFSelect_SelectSignedSharing self) -> IFSelect_SelectSignedSharing

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing___ref__(self, *args)


    def __hash__(self):
        return _IFSelect.Handle_IFSelect_SelectSignedSharing___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IFSelect.Handle_IFSelect_SelectSignedSharing___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IFSelect.new_Handle_IFSelect_SelectSignedSharing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IFSelect.Handle_IFSelect_SelectSignedSharing_DownCast)
    __swig_destroy__ = _IFSelect.delete_Handle_IFSelect_SelectSignedSharing

    def Signature(self, *args):
        """
        Signature(Handle_IFSelect_SelectSignedSharing self) -> Handle_IFSelect_Signature

        Returns the used Signature, then it is possible to access it,
        modify it as required

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Signature

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Signature(self, *args)


    def SignatureText(self, *args):
        """
        Returns Text used to Sort Entity on its Signature

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _IFSelect.Handle_IFSelect_SelectSignedSharing_SignatureText(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsExact(self, *args):
        """
        IsExact(Handle_IFSelect_SelectSignedSharing self) -> Standard_Boolean

        Returns True if match must be exact

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_IsExact(self, *args)


    def Explore(self, *args):
        """
        Explore(Handle_IFSelect_SelectSignedSharing self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity : its sharing entities
        <ent> to take if it matches the Signature
        At level max, filters the result. Else gives all sharings

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_IFSelect_SelectSignedSharing self) -> TCollection_AsciiString

        Returns a text defining the criterium.
        (it refers to the text and exact flag to be matched, and is
        qualified by the Name provided by the Signature)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IFSelect_SelectSignedSharing self) -> char const *

        :rtype: const char *

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSignedSharing_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IFSelect.Handle_IFSelect_SelectSignedSharing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_IFSelect_SelectSignedSharing self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_IFSelect_SelectSignedSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_IFSelect_SelectSignedSharing self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_IFSelect_SelectSignedSharing self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_IFSelect_SelectSignedSharing self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_IFSelect_SelectSignedSharing self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_IFSelect_SelectSignedSharing self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_IFSelect_SelectSignedSharing self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_IFSelect_SelectSignedSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_IFSelect_SelectSignedSharing self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_IFSelect_SelectSignedSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_IFSelect_SelectSignedSharing self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IFSelect_SelectSignedSharing self)

        Memory deallocator for transient classes


        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IFSelect_SelectSignedSharing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IFSelect_SelectSignedSharing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IFSelect_SelectSignedSharing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IFSelect_SelectSignedSharing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IFSelect_SelectSignedSharing self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IFSelect_SelectSignedSharing self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IFSelect_SelectSignedSharing self)

        Increments the reference counter of this object


        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IFSelect_SelectSignedSharing self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFSelect.Handle_IFSelect_SelectSignedSharing_DecrementRefCounter(self, *args)

Handle_IFSelect_SelectSignedSharing_swigregister = _IFSelect.Handle_IFSelect_SelectSignedSharing_swigregister
Handle_IFSelect_SelectSignedSharing_swigregister(Handle_IFSelect_SelectSignedSharing)

def Handle_IFSelect_SelectSignedSharing_DownCast(thing):
    return _IFSelect.Handle_IFSelect_SelectSignedSharing_DownCast(thing)
Handle_IFSelect_SelectSignedSharing_DownCast = _IFSelect.Handle_IFSelect_SelectSignedSharing_DownCast




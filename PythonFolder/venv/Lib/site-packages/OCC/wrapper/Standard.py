# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Standard')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Standard')
    _Standard = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Standard', [dirname(__file__)])
        except ImportError:
            import _Standard
            return _Standard
        try:
            _mod = imp.load_module('_Standard', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Standard = swig_import_helper()
    del swig_import_helper
else:
    import _Standard
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Standard.delete_SwigPyIterator

    def value(self):
        return _Standard.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Standard.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Standard.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Standard.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Standard.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Standard.SwigPyIterator_copy(self)

    def next(self):
        return _Standard.SwigPyIterator_next(self)

    def __next__(self):
        return _Standard.SwigPyIterator___next__(self)

    def previous(self):
        return _Standard.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Standard.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Standard.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Standard.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Standard.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Standard.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Standard.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Standard.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Standard.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Standard.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Standard.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Standard.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Standard.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Standard.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Standard.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Standard.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Standard.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Standard.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Standard.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Standard.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Standard.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Standard.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Standard.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Standard.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Standard.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Standard.ptr_to_number(item)
ptr_to_number = _Standard.ptr_to_number

def HashCode(*args):
    return _Standard.HashCode(*args)
HashCode = _Standard.HashCode

def ptr_equal(a, b):
    return _Standard.ptr_equal(a, b)
ptr_equal = _Standard.ptr_equal
Standard_HandlerVoid = _Standard.Standard_HandlerVoid
Standard_HandlerJumped = _Standard.Standard_HandlerJumped
Standard_HandlerProcessed = _Standard.Standard_HandlerProcessed
class Standard_Transient(object):
    """
    Abstract class which forms the root of the entire 
    Transient class hierarchy.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_Transient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_Transient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_Transient self) -> Standard_Transient
        __init__(Standard_Transient self, Standard_Transient arg2) -> Standard_Transient

        Copy constructor -- does nothing

        :type : OCC.wrapper.Standard.Standard_Transient

        """
        this = _Standard.new_Standard_Transient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def assign(self, *args):
        """
        assign(Standard_Transient self, Standard_Transient arg2) -> Standard_Transient

        Assignment operator, needed to avoid copying reference counter

        :type : OCC.wrapper.Standard.Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Standard_Transient_assign(self, *args)


    def Delete(self, *args):
        """
        Delete(Standard_Transient self)

        Memory deallocator for transient classes


        """
        return _Standard.Standard_Transient_Delete(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_Transient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        Returns type descriptor of Standard_Transient class

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_Transient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        Returns a type descriptor about this object.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Transient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInstance(self, *args):
        """
        IsInstance(Standard_Transient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Standard_Transient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_Transient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Standard_Transient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Standard_Transient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_Transient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Standard_Transient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Standard_Transient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Standard_Transient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_Transient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Standard_Transient self)

        Increments the reference counter of this object


        """
        return _Standard.Standard_Transient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Standard_Transient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_Transient_DecrementRefCounter(self, *args)


    def __hash__(self):
        return _Standard.Standard_Transient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Standard_Transient___eq__(self, *args)
        except TypeError:
            return False


    __swig_destroy__ = _Standard.delete_Standard_Transient
Standard_Transient_swigregister = _Standard.Standard_Transient_swigregister
Standard_Transient_swigregister(Standard_Transient)

def Standard_Transient_get_type_name(*args):
    """
    Standard_Transient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_Transient_get_type_name(*args)

def Standard_Transient_get_type_descriptor(*args):
    """
    Standard_Transient_get_type_descriptor() -> Handle_Standard_Type

    Returns type descriptor of Standard_Transient class

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_Transient_get_type_descriptor(*args)

class Standard_Failure(Standard_Transient):
    """Forms the root of the entire exception hierarchy."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_Failure
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_Failure(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_Failure self) -> Standard_Failure
        __init__(Standard_Failure self, Standard_Failure f) -> Standard_Failure
        __init__(Standard_Failure self, Standard_CString const aString) -> Standard_Failure

        Creates a status object of type "Failure".

        :type aString: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_Failure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Print(self, *args):
        """
        Print(Standard_Failure self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Standard_Failure_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Standard_Failure self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Standard_Failure_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Standard_Failure self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Standard_Failure_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Standard_Failure self)
        Reraise(Standard_Failure self, Standard_CString const aMessage)
        Reraise(Standard_Failure self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Standard_Failure_Reraise(self, *args)


    def NewInstance(*args):
        """
        NewInstance(Standard_CString const aMessage) -> Handle_Standard_Failure

        Used to construct an instance of the exception object
        as a handle. Shall be used to protect against possible
        construction of exception object in C stack -- that is
        dangerous since some of methods require that object
        was allocated dynamically.

        :type aMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Standard_Failure_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def Jump(self, *args):
        """
        Jump(Standard_Failure self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Standard_Failure_Jump(self, *args)


    def Caught(*args):
        """
        Caught() -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Standard_Failure_Caught(*args)

    Caught = staticmethod(Caught)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_Failure_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_Failure_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Failure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_Failure
Standard_Failure_swigregister = _Standard.Standard_Failure_swigregister
Standard_Failure_swigregister(Standard_Failure)

def Standard_Failure_NewInstance(*args):
    """
    Standard_Failure_NewInstance(Standard_CString const aMessage) -> Handle_Standard_Failure

    Used to construct an instance of the exception object
    as a handle. Shall be used to protect against possible
    construction of exception object in C stack -- that is
    dangerous since some of methods require that object
    was allocated dynamically.

    :type aMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

    """
    return _Standard.Standard_Failure_NewInstance(*args)

def Standard_Failure_Caught(*args):
    """
    Standard_Failure_Caught() -> Handle_Standard_Failure

    Returns the last caught exception.
    Needed when exceptions are emulated by C longjumps,
    in other cases is also provided for compatibility.

    :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

    """
    return _Standard.Standard_Failure_Caught(*args)

def Standard_Failure_get_type_name(*args):
    """
    Standard_Failure_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_Failure_get_type_name(*args)

def Standard_Failure_get_type_descriptor(*args):
    """
    Standard_Failure_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_Failure_get_type_descriptor(*args)

class Standard_DomainError(Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_DomainError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_DomainError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_DomainError self) -> Standard_DomainError
        __init__(Standard_DomainError self, Standard_CString const theMessage) -> Standard_DomainError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_DomainError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_DomainError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DomainError

        """
        return _Standard.Standard_DomainError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_DomainError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_DomainError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_DomainError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_DomainError
Standard_DomainError_swigregister = _Standard.Standard_DomainError_swigregister
Standard_DomainError_swigregister(Standard_DomainError)

def Standard_DomainError_NewInstance(*args):
    """
    Standard_DomainError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_DomainError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_DomainError

    """
    return _Standard.Standard_DomainError_NewInstance(*args)

def Standard_DomainError_get_type_name(*args):
    """
    Standard_DomainError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_DomainError_get_type_name(*args)

def Standard_DomainError_get_type_descriptor(*args):
    """
    Standard_DomainError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_DomainError_get_type_descriptor(*args)

class Standard_RangeError(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_RangeError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_RangeError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_RangeError self) -> Standard_RangeError
        __init__(Standard_RangeError self, Standard_CString const theMessage) -> Standard_RangeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_RangeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_RangeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_RangeError

        """
        return _Standard.Standard_RangeError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_RangeError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_RangeError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_RangeError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_RangeError
Standard_RangeError_swigregister = _Standard.Standard_RangeError_swigregister
Standard_RangeError_swigregister(Standard_RangeError)

def Standard_RangeError_NewInstance(*args):
    """
    Standard_RangeError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_RangeError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_RangeError

    """
    return _Standard.Standard_RangeError_NewInstance(*args)

def Standard_RangeError_get_type_name(*args):
    """
    Standard_RangeError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_RangeError_get_type_name(*args)

def Standard_RangeError_get_type_descriptor(*args):
    """
    Standard_RangeError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_RangeError_get_type_descriptor(*args)

class Standard_ProgramError(Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_ProgramError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_ProgramError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_ProgramError self) -> Standard_ProgramError
        __init__(Standard_ProgramError self, Standard_CString const theMessage) -> Standard_ProgramError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_ProgramError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_ProgramError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_ProgramError

        """
        return _Standard.Standard_ProgramError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_ProgramError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_ProgramError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_ProgramError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_ProgramError
Standard_ProgramError_swigregister = _Standard.Standard_ProgramError_swigregister
Standard_ProgramError_swigregister(Standard_ProgramError)

def Standard_ProgramError_NewInstance(*args):
    """
    Standard_ProgramError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_ProgramError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_ProgramError

    """
    return _Standard.Standard_ProgramError_NewInstance(*args)

def Standard_ProgramError_get_type_name(*args):
    """
    Standard_ProgramError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_ProgramError_get_type_name(*args)

def Standard_ProgramError_get_type_descriptor(*args):
    """
    Standard_ProgramError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_ProgramError_get_type_descriptor(*args)

class Standard_NumericError(Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NumericError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NumericError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NumericError self) -> Standard_NumericError
        __init__(Standard_NumericError self, Standard_CString const theMessage) -> Standard_NumericError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NumericError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NumericError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NumericError

        """
        return _Standard.Standard_NumericError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NumericError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NumericError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NumericError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NumericError
Standard_NumericError_swigregister = _Standard.Standard_NumericError_swigregister
Standard_NumericError_swigregister(Standard_NumericError)

def Standard_NumericError_NewInstance(*args):
    """
    Standard_NumericError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NumericError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NumericError

    """
    return _Standard.Standard_NumericError_NewInstance(*args)

def Standard_NumericError_get_type_name(*args):
    """
    Standard_NumericError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NumericError_get_type_name(*args)

def Standard_NumericError_get_type_descriptor(*args):
    """
    Standard_NumericError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NumericError_get_type_descriptor(*args)

class Standard_OutOfRange(Standard_RangeError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_OutOfRange
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_OutOfRange(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_OutOfRange self) -> Standard_OutOfRange
        __init__(Standard_OutOfRange self, Standard_CString const theMessage) -> Standard_OutOfRange

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_OutOfRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_OutOfRange

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_OutOfRange

        """
        return _Standard.Standard_OutOfRange_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_OutOfRange_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_OutOfRange_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_OutOfRange_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_OutOfRange
Standard_OutOfRange_swigregister = _Standard.Standard_OutOfRange_swigregister
Standard_OutOfRange_swigregister(Standard_OutOfRange)

def Standard_OutOfRange_NewInstance(*args):
    """
    Standard_OutOfRange_NewInstance(Standard_CString const theMessage) -> Handle_Standard_OutOfRange

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_OutOfRange

    """
    return _Standard.Standard_OutOfRange_NewInstance(*args)

def Standard_OutOfRange_get_type_name(*args):
    """
    Standard_OutOfRange_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_OutOfRange_get_type_name(*args)

def Standard_OutOfRange_get_type_descriptor(*args):
    """
    Standard_OutOfRange_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_OutOfRange_get_type_descriptor(*args)

class Standard_DimensionError(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_DimensionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_DimensionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_DimensionError self) -> Standard_DimensionError
        __init__(Standard_DimensionError self, Standard_CString const theMessage) -> Standard_DimensionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_DimensionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_DimensionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DimensionError

        """
        return _Standard.Standard_DimensionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_DimensionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_DimensionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_DimensionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_DimensionError
Standard_DimensionError_swigregister = _Standard.Standard_DimensionError_swigregister
Standard_DimensionError_swigregister(Standard_DimensionError)

def Standard_DimensionError_NewInstance(*args):
    """
    Standard_DimensionError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_DimensionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_DimensionError

    """
    return _Standard.Standard_DimensionError_NewInstance(*args)

def Standard_DimensionError_get_type_name(*args):
    """
    Standard_DimensionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_DimensionError_get_type_name(*args)

def Standard_DimensionError_get_type_descriptor(*args):
    """
    Standard_DimensionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_DimensionError_get_type_descriptor(*args)

class Standard_NullValue(Standard_RangeError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NullValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NullValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NullValue self) -> Standard_NullValue
        __init__(Standard_NullValue self, Standard_CString const theMessage) -> Standard_NullValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NullValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NullValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NullValue

        """
        return _Standard.Standard_NullValue_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NullValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NullValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NullValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NullValue
Standard_NullValue_swigregister = _Standard.Standard_NullValue_swigregister
Standard_NullValue_swigregister(Standard_NullValue)

def Standard_NullValue_NewInstance(*args):
    """
    Standard_NullValue_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NullValue

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NullValue

    """
    return _Standard.Standard_NullValue_NewInstance(*args)

def Standard_NullValue_get_type_name(*args):
    """
    Standard_NullValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NullValue_get_type_name(*args)

def Standard_NullValue_get_type_descriptor(*args):
    """
    Standard_NullValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NullValue_get_type_descriptor(*args)

class Standard_DimensionMismatch(Standard_DimensionError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_DimensionMismatch
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_DimensionMismatch(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_DimensionMismatch self) -> Standard_DimensionMismatch
        __init__(Standard_DimensionMismatch self, Standard_CString const theMessage) -> Standard_DimensionMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_DimensionMismatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_DimensionMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DimensionMismatch

        """
        return _Standard.Standard_DimensionMismatch_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_DimensionMismatch_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_DimensionMismatch_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_DimensionMismatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_DimensionMismatch
Standard_DimensionMismatch_swigregister = _Standard.Standard_DimensionMismatch_swigregister
Standard_DimensionMismatch_swigregister(Standard_DimensionMismatch)

def Standard_DimensionMismatch_NewInstance(*args):
    """
    Standard_DimensionMismatch_NewInstance(Standard_CString const theMessage) -> Handle_Standard_DimensionMismatch

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_DimensionMismatch

    """
    return _Standard.Standard_DimensionMismatch_NewInstance(*args)

def Standard_DimensionMismatch_get_type_name(*args):
    """
    Standard_DimensionMismatch_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_DimensionMismatch_get_type_name(*args)

def Standard_DimensionMismatch_get_type_descriptor(*args):
    """
    Standard_DimensionMismatch_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_DimensionMismatch_get_type_descriptor(*args)

class Standard_OutOfMemory(Standard_ProgramError):
    """
    Standard_OutOfMemory exception is defined explicitly and not by
    macro DEFINE_STANDARD_EXCEPTION, to avoid necessity of dynamic
    memory allocations during throwing and stack unwinding:

    - method NewInstance() returns static instance (singleton)
    - method Raise() raises copy of that singleton, resetting 
    its message string
    - message string is stored as field, not allocated dynamically
    (storable message length is limited by buffer size)

    The reason is that in out-of-memory condition any memory allocation can 
    fail, thus use of operator new for allocation of new exception instance 
    is dangerous (can cause recursion until stack overflow, see #24836).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_OutOfMemory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_OutOfMemory(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_OutOfMemory self, Standard_CString const theMessage=None) -> Standard_OutOfMemory

        Constructor is kept public for backward compatibility

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_OutOfMemory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetMessageString(self, *args):
        """
        GetMessageString(Standard_OutOfMemory self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Standard_OutOfMemory_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Standard_OutOfMemory self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Standard_OutOfMemory_SetMessageString(self, *args)


    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_OutOfMemory

        Returns global instance of exception

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_OutOfMemory

        """
        return _Standard.Standard_OutOfMemory_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_OutOfMemory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_OutOfMemory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_OutOfMemory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_OutOfMemory
Standard_OutOfMemory_swigregister = _Standard.Standard_OutOfMemory_swigregister
Standard_OutOfMemory_swigregister(Standard_OutOfMemory)

def Standard_OutOfMemory_NewInstance(*args):
    """
    Standard_OutOfMemory_NewInstance(Standard_CString const theMessage) -> Handle_Standard_OutOfMemory

    Returns global instance of exception

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_OutOfMemory

    """
    return _Standard.Standard_OutOfMemory_NewInstance(*args)

def Standard_OutOfMemory_get_type_name(*args):
    """
    Standard_OutOfMemory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_OutOfMemory_get_type_name(*args)

def Standard_OutOfMemory_get_type_descriptor(*args):
    """
    Standard_OutOfMemory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_OutOfMemory_get_type_descriptor(*args)

class Standard_NoSuchObject(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NoSuchObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NoSuchObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NoSuchObject self) -> Standard_NoSuchObject
        __init__(Standard_NoSuchObject self, Standard_CString const theMessage) -> Standard_NoSuchObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NoSuchObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NoSuchObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NoSuchObject

        """
        return _Standard.Standard_NoSuchObject_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NoSuchObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NoSuchObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NoSuchObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NoSuchObject
Standard_NoSuchObject_swigregister = _Standard.Standard_NoSuchObject_swigregister
Standard_NoSuchObject_swigregister(Standard_NoSuchObject)

def Standard_NoSuchObject_NewInstance(*args):
    """
    Standard_NoSuchObject_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NoSuchObject

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NoSuchObject

    """
    return _Standard.Standard_NoSuchObject_NewInstance(*args)

def Standard_NoSuchObject_get_type_name(*args):
    """
    Standard_NoSuchObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NoSuchObject_get_type_name(*args)

def Standard_NoSuchObject_get_type_descriptor(*args):
    """
    Standard_NoSuchObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NoSuchObject_get_type_descriptor(*args)

class Standard_ImmutableObject(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_ImmutableObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_ImmutableObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_ImmutableObject self) -> Standard_ImmutableObject
        __init__(Standard_ImmutableObject self, Standard_CString const theMessage) -> Standard_ImmutableObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_ImmutableObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_ImmutableObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_ImmutableObject

        """
        return _Standard.Standard_ImmutableObject_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_ImmutableObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_ImmutableObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_ImmutableObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_ImmutableObject
Standard_ImmutableObject_swigregister = _Standard.Standard_ImmutableObject_swigregister
Standard_ImmutableObject_swigregister(Standard_ImmutableObject)

def Standard_ImmutableObject_NewInstance(*args):
    """
    Standard_ImmutableObject_NewInstance(Standard_CString const theMessage) -> Handle_Standard_ImmutableObject

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_ImmutableObject

    """
    return _Standard.Standard_ImmutableObject_NewInstance(*args)

def Standard_ImmutableObject_get_type_name(*args):
    """
    Standard_ImmutableObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_ImmutableObject_get_type_name(*args)

def Standard_ImmutableObject_get_type_descriptor(*args):
    """
    Standard_ImmutableObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_ImmutableObject_get_type_descriptor(*args)

class Standard_Underflow(Standard_NumericError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_Underflow
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_Underflow(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_Underflow self) -> Standard_Underflow
        __init__(Standard_Underflow self, Standard_CString const theMessage) -> Standard_Underflow

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_Underflow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_Underflow

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Underflow

        """
        return _Standard.Standard_Underflow_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_Underflow_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_Underflow_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Underflow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_Underflow
Standard_Underflow_swigregister = _Standard.Standard_Underflow_swigregister
Standard_Underflow_swigregister(Standard_Underflow)

def Standard_Underflow_NewInstance(*args):
    """
    Standard_Underflow_NewInstance(Standard_CString const theMessage) -> Handle_Standard_Underflow

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_Underflow

    """
    return _Standard.Standard_Underflow_NewInstance(*args)

def Standard_Underflow_get_type_name(*args):
    """
    Standard_Underflow_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_Underflow_get_type_name(*args)

def Standard_Underflow_get_type_descriptor(*args):
    """
    Standard_Underflow_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_Underflow_get_type_descriptor(*args)

class Standard_LicenseError(Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_LicenseError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_LicenseError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_LicenseError self) -> Standard_LicenseError
        __init__(Standard_LicenseError self, Standard_CString const theMessage) -> Standard_LicenseError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_LicenseError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_LicenseError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_LicenseError

        """
        return _Standard.Standard_LicenseError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_LicenseError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_LicenseError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_LicenseError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_LicenseError
Standard_LicenseError_swigregister = _Standard.Standard_LicenseError_swigregister
Standard_LicenseError_swigregister(Standard_LicenseError)

def Standard_LicenseError_NewInstance(*args):
    """
    Standard_LicenseError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_LicenseError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_LicenseError

    """
    return _Standard.Standard_LicenseError_NewInstance(*args)

def Standard_LicenseError_get_type_name(*args):
    """
    Standard_LicenseError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_LicenseError_get_type_name(*args)

def Standard_LicenseError_get_type_descriptor(*args):
    """
    Standard_LicenseError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_LicenseError_get_type_descriptor(*args)

class Standard_ErrorHandler(object):
    """
    Class implementing mechanics of conversion of signals to exceptions.

    Each instance of it stores data for jump placement, thread id,
    and callbacks to be called during jump (for proper resource release).

    The active handlers are stored in the global stack, which is used
    to find appropriate handler when signal is raised.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_ErrorHandler self) -> Standard_ErrorHandler

        Create a ErrorHandler (to be used with try{}catch(){}).
        It uses the "setjmp" and "longjmp" routines.


        """
        this = _Standard.new_Standard_ErrorHandler(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """
        Destroy(Standard_ErrorHandler self)

        Unlinks and checks if there is a raised exception.


        """
        return _Standard.Standard_ErrorHandler_Destroy(self, *args)


    def Unlink(self, *args):
        """
        Unlink(Standard_ErrorHandler self)

        Removes handler from the handlers list


        """
        return _Standard.Standard_ErrorHandler_Unlink(self, *args)


    def Catches(self, *args):
        """
        Catches(Standard_ErrorHandler self, Handle_Standard_Type aType) -> Standard_Boolean

        Returns "True" if the caught exception has the same type
        or inherits from "aType"

        :type aType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_ErrorHandler_Catches(self, *args)


    def Label(self, *args):
        """
        Label(Standard_ErrorHandler self) -> Standard_JmpBuf &

        Returns label for jump

        :rtype: OCC.wrapper.Standard.Standard_JmpBuf

        """
        return _Standard.Standard_ErrorHandler_Label(self, *args)


    def Error(self, *args):
        """
        Error(Standard_ErrorHandler self) -> Handle_Standard_Failure

        Returns the current Error.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Standard_ErrorHandler_Error(self, *args)


    def LastCaughtError(*args):
        """
        LastCaughtError() -> Handle_Standard_Failure

        Returns the caught exception.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Standard_ErrorHandler_LastCaughtError(*args)

    LastCaughtError = staticmethod(LastCaughtError)

    def IsInTryBlock(*args):
        """
        IsInTryBlock() -> Standard_Boolean

        Test if the code is currently running in a try block

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_ErrorHandler_IsInTryBlock(*args)

    IsInTryBlock = staticmethod(IsInTryBlock)
    __swig_destroy__ = _Standard.delete_Standard_ErrorHandler
Standard_ErrorHandler_swigregister = _Standard.Standard_ErrorHandler_swigregister
Standard_ErrorHandler_swigregister(Standard_ErrorHandler)

def Standard_ErrorHandler_LastCaughtError(*args):
    """
    Standard_ErrorHandler_LastCaughtError() -> Handle_Standard_Failure

    Returns the caught exception.

    :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

    """
    return _Standard.Standard_ErrorHandler_LastCaughtError(*args)

def Standard_ErrorHandler_IsInTryBlock(*args):
    """
    Standard_ErrorHandler_IsInTryBlock() -> Standard_Boolean

    Test if the code is currently running in a try block

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Standard.Standard_ErrorHandler_IsInTryBlock(*args)

class Standard_LicenseNotFound(Standard_LicenseError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_LicenseNotFound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_LicenseNotFound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_LicenseNotFound self) -> Standard_LicenseNotFound
        __init__(Standard_LicenseNotFound self, Standard_CString const theMessage) -> Standard_LicenseNotFound

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_LicenseNotFound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_LicenseNotFound

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_LicenseNotFound

        """
        return _Standard.Standard_LicenseNotFound_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_LicenseNotFound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_LicenseNotFound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_LicenseNotFound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_LicenseNotFound
Standard_LicenseNotFound_swigregister = _Standard.Standard_LicenseNotFound_swigregister
Standard_LicenseNotFound_swigregister(Standard_LicenseNotFound)

def Standard_LicenseNotFound_NewInstance(*args):
    """
    Standard_LicenseNotFound_NewInstance(Standard_CString const theMessage) -> Handle_Standard_LicenseNotFound

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_LicenseNotFound

    """
    return _Standard.Standard_LicenseNotFound_NewInstance(*args)

def Standard_LicenseNotFound_get_type_name(*args):
    """
    Standard_LicenseNotFound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_LicenseNotFound_get_type_name(*args)

def Standard_LicenseNotFound_get_type_descriptor(*args):
    """
    Standard_LicenseNotFound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_LicenseNotFound_get_type_descriptor(*args)

class Standard_ConstructionError(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_ConstructionError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_ConstructionError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_ConstructionError self) -> Standard_ConstructionError
        __init__(Standard_ConstructionError self, Standard_CString const theMessage) -> Standard_ConstructionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_ConstructionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_ConstructionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_ConstructionError

        """
        return _Standard.Standard_ConstructionError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_ConstructionError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_ConstructionError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_ConstructionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_ConstructionError
Standard_ConstructionError_swigregister = _Standard.Standard_ConstructionError_swigregister
Standard_ConstructionError_swigregister(Standard_ConstructionError)

def Standard_ConstructionError_NewInstance(*args):
    """
    Standard_ConstructionError_NewInstance(Standard_CString const theMessage) -> Handle_Standard_ConstructionError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_ConstructionError

    """
    return _Standard.Standard_ConstructionError_NewInstance(*args)

def Standard_ConstructionError_get_type_name(*args):
    """
    Standard_ConstructionError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_ConstructionError_get_type_name(*args)

def Standard_ConstructionError_get_type_descriptor(*args):
    """
    Standard_ConstructionError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_ConstructionError_get_type_descriptor(*args)

class Standard_MultiplyDefined(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_MultiplyDefined
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_MultiplyDefined(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_MultiplyDefined self) -> Standard_MultiplyDefined
        __init__(Standard_MultiplyDefined self, Standard_CString const theMessage) -> Standard_MultiplyDefined

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_MultiplyDefined(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_MultiplyDefined

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_MultiplyDefined

        """
        return _Standard.Standard_MultiplyDefined_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_MultiplyDefined_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_MultiplyDefined_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_MultiplyDefined_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_MultiplyDefined
Standard_MultiplyDefined_swigregister = _Standard.Standard_MultiplyDefined_swigregister
Standard_MultiplyDefined_swigregister(Standard_MultiplyDefined)

def Standard_MultiplyDefined_NewInstance(*args):
    """
    Standard_MultiplyDefined_NewInstance(Standard_CString const theMessage) -> Handle_Standard_MultiplyDefined

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_MultiplyDefined

    """
    return _Standard.Standard_MultiplyDefined_NewInstance(*args)

def Standard_MultiplyDefined_get_type_name(*args):
    """
    Standard_MultiplyDefined_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_MultiplyDefined_get_type_name(*args)

def Standard_MultiplyDefined_get_type_descriptor(*args):
    """
    Standard_MultiplyDefined_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_MultiplyDefined_get_type_descriptor(*args)

class Standard_MMgrRoot(object):
    """
    Root class for Open CASCADE mmemory managers.
    Defines only abstract interface functions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Allocate(self, *args):
        """
        Allocate(Standard_MMgrRoot self, Standard_Size const theSize) -> Standard_Address

        Allocate specified number of bytes.
        The actually allocated space should be rounded up to 
        double word size (4 bytes), as this is expected by implementation 
        of some classes in OCC (e.g. TCollection_AsciiString)

        :type theSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrRoot_Allocate(self, *args)


    def Reallocate(self, *args):
        """
        Reallocate(Standard_MMgrRoot self, Standard_Address thePtr, Standard_Size const theSize) -> Standard_Address

        Reallocate previously allocated memory to contain at least theSize bytes.
        In case of success, new pointer is returned.

        :type thePtr: OCC.wrapper.Standard.Standard_Address
        :type theSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrRoot_Reallocate(self, *args)


    def Free(self, *args):
        """
        Free(Standard_MMgrRoot self, Standard_Address thePtr)

        Frees previously allocated memory at specified address.

        :type thePtr: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrRoot_Free(self, *args)


    def Purge(self, *args):
        """
        Purge(Standard_MMgrRoot self, Standard_Boolean isDestroyed) -> Standard_Integer

        Purge internally cached unused memory blocks (if any) 
        by releasing them to the operating system.
        Must return non-zero if some memory has been actually released, 
        or zero otherwise.

        If option isDestroyed is True, this means that memory 
        manager is not expected to be used any more; note however 
        that in general case it is still possible to have calls to that 
        instance of memory manager after this (e.g. to free memory
        of static objects in OCC). Thus this option should 
        command the memory manager to release any cached memory
        to the system and not cache any more, but still remain operable...

        Default implementation does nothing and returns 0.

        :type isDestroyed: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_MMgrRoot_Purge(self, *args)

    __swig_destroy__ = _Standard.delete_Standard_MMgrRoot
Standard_MMgrRoot_swigregister = _Standard.Standard_MMgrRoot_swigregister
Standard_MMgrRoot_swigregister(Standard_MMgrRoot)

class Standard_TypeMismatch(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_TypeMismatch
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_TypeMismatch(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_TypeMismatch self) -> Standard_TypeMismatch
        __init__(Standard_TypeMismatch self, Standard_CString const theMessage) -> Standard_TypeMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_TypeMismatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_TypeMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_TypeMismatch

        """
        return _Standard.Standard_TypeMismatch_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_TypeMismatch_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_TypeMismatch_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_TypeMismatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_TypeMismatch
Standard_TypeMismatch_swigregister = _Standard.Standard_TypeMismatch_swigregister
Standard_TypeMismatch_swigregister(Standard_TypeMismatch)

def Standard_TypeMismatch_NewInstance(*args):
    """
    Standard_TypeMismatch_NewInstance(Standard_CString const theMessage) -> Handle_Standard_TypeMismatch

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_TypeMismatch

    """
    return _Standard.Standard_TypeMismatch_NewInstance(*args)

def Standard_TypeMismatch_get_type_name(*args):
    """
    Standard_TypeMismatch_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_TypeMismatch_get_type_name(*args)

def Standard_TypeMismatch_get_type_descriptor(*args):
    """
    Standard_TypeMismatch_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_TypeMismatch_get_type_descriptor(*args)

class Standard_Overflow(Standard_NumericError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_Overflow
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_Overflow(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_Overflow self) -> Standard_Overflow
        __init__(Standard_Overflow self, Standard_CString const theMessage) -> Standard_Overflow

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_Overflow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_Overflow

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Overflow

        """
        return _Standard.Standard_Overflow_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_Overflow_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_Overflow_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Overflow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_Overflow
Standard_Overflow_swigregister = _Standard.Standard_Overflow_swigregister
Standard_Overflow_swigregister(Standard_Overflow)

def Standard_Overflow_NewInstance(*args):
    """
    Standard_Overflow_NewInstance(Standard_CString const theMessage) -> Handle_Standard_Overflow

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_Overflow

    """
    return _Standard.Standard_Overflow_NewInstance(*args)

def Standard_Overflow_get_type_name(*args):
    """
    Standard_Overflow_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_Overflow_get_type_name(*args)

def Standard_Overflow_get_type_descriptor(*args):
    """
    Standard_Overflow_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_Overflow_get_type_descriptor(*args)

class Standard_NegativeValue(Standard_RangeError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NegativeValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NegativeValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NegativeValue self) -> Standard_NegativeValue
        __init__(Standard_NegativeValue self, Standard_CString const theMessage) -> Standard_NegativeValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NegativeValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NegativeValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NegativeValue

        """
        return _Standard.Standard_NegativeValue_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NegativeValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NegativeValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NegativeValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NegativeValue
Standard_NegativeValue_swigregister = _Standard.Standard_NegativeValue_swigregister
Standard_NegativeValue_swigregister(Standard_NegativeValue)

def Standard_NegativeValue_NewInstance(*args):
    """
    Standard_NegativeValue_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NegativeValue

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NegativeValue

    """
    return _Standard.Standard_NegativeValue_NewInstance(*args)

def Standard_NegativeValue_get_type_name(*args):
    """
    Standard_NegativeValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NegativeValue_get_type_name(*args)

def Standard_NegativeValue_get_type_descriptor(*args):
    """
    Standard_NegativeValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NegativeValue_get_type_descriptor(*args)

class Standard_TooManyUsers(Standard_LicenseError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_TooManyUsers
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_TooManyUsers(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_TooManyUsers self) -> Standard_TooManyUsers
        __init__(Standard_TooManyUsers self, Standard_CString const theMessage) -> Standard_TooManyUsers

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_TooManyUsers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_TooManyUsers

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_TooManyUsers

        """
        return _Standard.Standard_TooManyUsers_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_TooManyUsers_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_TooManyUsers_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_TooManyUsers_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_TooManyUsers
Standard_TooManyUsers_swigregister = _Standard.Standard_TooManyUsers_swigregister
Standard_TooManyUsers_swigregister(Standard_TooManyUsers)

def Standard_TooManyUsers_NewInstance(*args):
    """
    Standard_TooManyUsers_NewInstance(Standard_CString const theMessage) -> Handle_Standard_TooManyUsers

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_TooManyUsers

    """
    return _Standard.Standard_TooManyUsers_NewInstance(*args)

def Standard_TooManyUsers_get_type_name(*args):
    """
    Standard_TooManyUsers_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_TooManyUsers_get_type_name(*args)

def Standard_TooManyUsers_get_type_descriptor(*args):
    """
    Standard_TooManyUsers_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_TooManyUsers_get_type_descriptor(*args)

class Standard_Type(Standard_Transient):
    """
    This class provides legacy interface (type descriptor) to run-time type
    information (RTTI) for OCCT classes inheriting from Standard_Transient.

    In addition to features provided by standard C++ RTTI (type_info), 
    Standard_Type allows passing descriptor as an object and using it for 
    analysis of the type:
    - get descriptor of a parent class
    - get user-defined name of the class
    - get size of the object

    Use static template method Instance() to get descriptor for a given type.
    Objects supporting OCCT RTTI return their type descriptor by method DynamicType().

    To be usable with OCCT type system, the class should provide:
    - typedef base_type to its base class in the hierarchy
    - method get_type_name() returning programmer-defined name of the class
    (as a statically allocated constant C string or string literal)

    Note that user-defined name is used since typeid.name() is usually mangled in 
    compiler-dependent way.

    Only single chain of inheritance is supported, with a root base class Standard_Transient.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_Type
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_Type(self) 
            return h


    def SystemName(self, *args):
        """
        SystemName(Standard_Type self) -> Standard_CString

        Returns the system type name of the class (typeinfo.name)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Standard_Type_SystemName(self, *args)


    def Name(self, *args):
        """
        Name(Standard_Type self) -> Standard_CString

        Returns the given name of the class type (get_type_name)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Standard_Type_Name(self, *args)


    def Size(self, *args):
        """
        Size(Standard_Type self) -> Standard_Size

        Returns the size of the class instance in bytes

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Standard.Standard_Type_Size(self, *args)


    def Parent(self, *args):
        """
        Returns descriptor of the base class in the hierarchy

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Type_Parent(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubType(self, *args):
        """
        SubType(Standard_Type self, Handle_Standard_Type theOther) -> Standard_Boolean
        SubType(Standard_Type self, Standard_CString const theOther) -> Standard_Boolean

        Returns True if this type is the same as theOther, or inherits from theOther.
        Note that multiple inheritance is not supported.

        :type theOther: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_Type_SubType(self, *args)


    def Print(self, *args):
        """
        Print(Standard_Type self, Standard_OStream & theStream)

        Prints type (address of descriptor + name) to a stream

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Standard_Type_Print(self, *args)


    def Register(*args):
        """
        Register(char const * theSystemName, char const * theName, Standard_Size theSize, Handle_Standard_Type theParent) -> Standard_Type

        Register a type; returns either new or existing descriptor.

        @param theSystemName name of the class as returned by typeid(class).name()
        @param theName name of the class to be stored in Name field
        @param theSize size of the class instance
        @param theParent base class in the Transient hierarchy

        Note that this function is intended for use by opencascade::type_instance only. 

        :type theSystemName: const char *
        :type theName: const char *
        :type theSize: int
        :type theParent: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Type

        """
        return _Standard.Standard_Type_Register(*args)

    Register = staticmethod(Register)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_Type_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_Type_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Type_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_Type
Standard_Type_swigregister = _Standard.Standard_Type_swigregister
Standard_Type_swigregister(Standard_Type)

def Standard_Type_Register(*args):
    """
    Standard_Type_Register(char const * theSystemName, char const * theName, Standard_Size theSize, Handle_Standard_Type theParent) -> Standard_Type

    Register a type; returns either new or existing descriptor.

    @param theSystemName name of the class as returned by typeid(class).name()
    @param theName name of the class to be stored in Name field
    @param theSize size of the class instance
    @param theParent base class in the Transient hierarchy

    Note that this function is intended for use by opencascade::type_instance only. 

    :type theSystemName: const char *
    :type theName: const char *
    :type theSize: int
    :type theParent: OCC.wrapper.Standard.Handle_Standard_Type
    :rtype: OCC.wrapper.Standard.Standard_Type

    """
    return _Standard.Standard_Type_Register(*args)

def Standard_Type_get_type_name(*args):
    """
    Standard_Type_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_Type_get_type_name(*args)

def Standard_Type_get_type_descriptor(*args):
    """
    Standard_Type_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_Type_get_type_descriptor(*args)

class Handle_Standard_ImmutableObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_ImmutableObject self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_ImmutableObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_ImmutableObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_ImmutableObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_ImmutableObject self, Standard_ImmutableObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_ImmutableObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_ImmutableObject self, Handle_Standard_ImmutableObject theHandle) -> Handle_Standard_ImmutableObject
        assign(Handle_Standard_ImmutableObject self, Standard_ImmutableObject thePtr) -> Handle_Standard_ImmutableObject
        assign(Handle_Standard_ImmutableObject self, Handle_Standard_ImmutableObject theHandle) -> Handle_Standard_ImmutableObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_ImmutableObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_ImmutableObject self) -> Standard_ImmutableObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_ImmutableObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_ImmutableObject self) -> Standard_ImmutableObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_ImmutableObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_ImmutableObject self) -> Standard_ImmutableObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_ImmutableObject___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_ImmutableObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_ImmutableObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_ImmutableObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_ImmutableObject_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_ImmutableObject

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_ImmutableObject self, Standard_CString const theMessage) -> Handle_Standard_ImmutableObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_ImmutableObject

        """
        return _Standard.Handle_Standard_ImmutableObject_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_ImmutableObject self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_ImmutableObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_ImmutableObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_ImmutableObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_ImmutableObject self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_ImmutableObject_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_ImmutableObject self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_ImmutableObject_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_ImmutableObject self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_ImmutableObject_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_ImmutableObject self)
        Reraise(Handle_Standard_ImmutableObject self, Standard_CString const aMessage)
        Reraise(Handle_Standard_ImmutableObject self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_ImmutableObject_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_ImmutableObject self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_ImmutableObject_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_ImmutableObject self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_ImmutableObject_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_ImmutableObject self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_ImmutableObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_ImmutableObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_ImmutableObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_ImmutableObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_ImmutableObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_ImmutableObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_ImmutableObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_ImmutableObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_ImmutableObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_ImmutableObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_ImmutableObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_ImmutableObject self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_ImmutableObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_ImmutableObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_ImmutableObject_DecrementRefCounter(self, *args)

Handle_Standard_ImmutableObject_swigregister = _Standard.Handle_Standard_ImmutableObject_swigregister
Handle_Standard_ImmutableObject_swigregister(Handle_Standard_ImmutableObject)

def Handle_Standard_ImmutableObject_DownCast(thing):
    return _Standard.Handle_Standard_ImmutableObject_DownCast(thing)
Handle_Standard_ImmutableObject_DownCast = _Standard.Handle_Standard_ImmutableObject_DownCast

class Handle_Standard_ConstructionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_ConstructionError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_ConstructionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_ConstructionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_ConstructionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_ConstructionError self, Standard_ConstructionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_ConstructionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_ConstructionError self, Handle_Standard_ConstructionError theHandle) -> Handle_Standard_ConstructionError
        assign(Handle_Standard_ConstructionError self, Standard_ConstructionError thePtr) -> Handle_Standard_ConstructionError
        assign(Handle_Standard_ConstructionError self, Handle_Standard_ConstructionError theHandle) -> Handle_Standard_ConstructionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_ConstructionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_ConstructionError self) -> Standard_ConstructionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_ConstructionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_ConstructionError self) -> Standard_ConstructionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_ConstructionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_ConstructionError self) -> Standard_ConstructionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_ConstructionError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_ConstructionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_ConstructionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_ConstructionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_ConstructionError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_ConstructionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_ConstructionError self, Standard_CString const theMessage) -> Handle_Standard_ConstructionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_ConstructionError

        """
        return _Standard.Handle_Standard_ConstructionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_ConstructionError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_ConstructionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_ConstructionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_ConstructionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_ConstructionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_ConstructionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_ConstructionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_ConstructionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_ConstructionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_ConstructionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_ConstructionError self)
        Reraise(Handle_Standard_ConstructionError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_ConstructionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_ConstructionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_ConstructionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_ConstructionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_ConstructionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_ConstructionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_ConstructionError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_ConstructionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_ConstructionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_ConstructionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_ConstructionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_ConstructionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_ConstructionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_ConstructionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_ConstructionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_ConstructionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_ConstructionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_ConstructionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_ConstructionError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_ConstructionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_ConstructionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_ConstructionError_DecrementRefCounter(self, *args)

Handle_Standard_ConstructionError_swigregister = _Standard.Handle_Standard_ConstructionError_swigregister
Handle_Standard_ConstructionError_swigregister(Handle_Standard_ConstructionError)

def Handle_Standard_ConstructionError_DownCast(thing):
    return _Standard.Handle_Standard_ConstructionError_DownCast(thing)
Handle_Standard_ConstructionError_DownCast = _Standard.Handle_Standard_ConstructionError_DownCast

class Handle_Standard_OutOfRange(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_OutOfRange self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_OutOfRange_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_OutOfRange self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_OutOfRange_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_OutOfRange self, Standard_OutOfRange thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_OutOfRange_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_OutOfRange self, Handle_Standard_OutOfRange theHandle) -> Handle_Standard_OutOfRange
        assign(Handle_Standard_OutOfRange self, Standard_OutOfRange thePtr) -> Handle_Standard_OutOfRange
        assign(Handle_Standard_OutOfRange self, Handle_Standard_OutOfRange theHandle) -> Handle_Standard_OutOfRange

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_OutOfRange_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_OutOfRange self) -> Standard_OutOfRange

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_OutOfRange_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_OutOfRange self) -> Standard_OutOfRange

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_OutOfRange___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_OutOfRange self) -> Standard_OutOfRange

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_OutOfRange___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_OutOfRange___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_OutOfRange___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_OutOfRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_OutOfRange_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_OutOfRange

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_OutOfRange self, Standard_CString const theMessage) -> Handle_Standard_OutOfRange

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_OutOfRange

        """
        return _Standard.Handle_Standard_OutOfRange_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_OutOfRange self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_OutOfRange_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_OutOfRange_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_OutOfRange_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_OutOfRange self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_OutOfRange_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_OutOfRange self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_OutOfRange_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_OutOfRange self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_OutOfRange_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_OutOfRange self)
        Reraise(Handle_Standard_OutOfRange self, Standard_CString const aMessage)
        Reraise(Handle_Standard_OutOfRange self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_OutOfRange_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_OutOfRange self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_OutOfRange_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_OutOfRange self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_OutOfRange_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_OutOfRange self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_OutOfRange_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_OutOfRange self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_OutOfRange self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_OutOfRange_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_OutOfRange self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_OutOfRange self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_OutOfRange_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_OutOfRange self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_OutOfRange_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_OutOfRange self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_OutOfRange_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_OutOfRange self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_OutOfRange_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_OutOfRange self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_OutOfRange_DecrementRefCounter(self, *args)

Handle_Standard_OutOfRange_swigregister = _Standard.Handle_Standard_OutOfRange_swigregister
Handle_Standard_OutOfRange_swigregister(Handle_Standard_OutOfRange)

def Handle_Standard_OutOfRange_DownCast(thing):
    return _Standard.Handle_Standard_OutOfRange_DownCast(thing)
Handle_Standard_OutOfRange_DownCast = _Standard.Handle_Standard_OutOfRange_DownCast

class Standard_NotImplemented(Standard_ProgramError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NotImplemented
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NotImplemented(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NotImplemented self) -> Standard_NotImplemented
        __init__(Standard_NotImplemented self, Standard_CString const theMessage) -> Standard_NotImplemented

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NotImplemented(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NotImplemented

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NotImplemented

        """
        return _Standard.Standard_NotImplemented_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NotImplemented_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NotImplemented_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NotImplemented_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NotImplemented
Standard_NotImplemented_swigregister = _Standard.Standard_NotImplemented_swigregister
Standard_NotImplemented_swigregister(Standard_NotImplemented)

def Standard_NotImplemented_NewInstance(*args):
    """
    Standard_NotImplemented_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NotImplemented

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NotImplemented

    """
    return _Standard.Standard_NotImplemented_NewInstance(*args)

def Standard_NotImplemented_get_type_name(*args):
    """
    Standard_NotImplemented_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NotImplemented_get_type_name(*args)

def Standard_NotImplemented_get_type_descriptor(*args):
    """
    Standard_NotImplemented_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NotImplemented_get_type_descriptor(*args)

class Handle_Standard_RangeError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_RangeError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_RangeError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_RangeError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_RangeError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_RangeError self, Standard_RangeError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_RangeError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_RangeError self, Handle_Standard_RangeError theHandle) -> Handle_Standard_RangeError
        assign(Handle_Standard_RangeError self, Standard_RangeError thePtr) -> Handle_Standard_RangeError
        assign(Handle_Standard_RangeError self, Handle_Standard_RangeError theHandle) -> Handle_Standard_RangeError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_RangeError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_RangeError self) -> Standard_RangeError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_RangeError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_RangeError self) -> Standard_RangeError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_RangeError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_RangeError self) -> Standard_RangeError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_RangeError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_RangeError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_RangeError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_RangeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_RangeError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_RangeError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_RangeError self, Standard_CString const theMessage) -> Handle_Standard_RangeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_RangeError

        """
        return _Standard.Handle_Standard_RangeError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_RangeError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_RangeError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_RangeError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_RangeError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_RangeError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_RangeError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_RangeError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_RangeError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_RangeError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_RangeError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_RangeError self)
        Reraise(Handle_Standard_RangeError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_RangeError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_RangeError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_RangeError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_RangeError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_RangeError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_RangeError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_RangeError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_RangeError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_RangeError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_RangeError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_RangeError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_RangeError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_RangeError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_RangeError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_RangeError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_RangeError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_RangeError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_RangeError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_RangeError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_RangeError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_RangeError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_RangeError_DecrementRefCounter(self, *args)

Handle_Standard_RangeError_swigregister = _Standard.Handle_Standard_RangeError_swigregister
Handle_Standard_RangeError_swigregister(Handle_Standard_RangeError)

def Handle_Standard_RangeError_DownCast(thing):
    return _Standard.Handle_Standard_RangeError_DownCast(thing)
Handle_Standard_RangeError_DownCast = _Standard.Handle_Standard_RangeError_DownCast

class Standard_NullObject(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NullObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NullObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NullObject self) -> Standard_NullObject
        __init__(Standard_NullObject self, Standard_CString const theMessage) -> Standard_NullObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NullObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NullObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NullObject

        """
        return _Standard.Standard_NullObject_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NullObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NullObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NullObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NullObject
Standard_NullObject_swigregister = _Standard.Standard_NullObject_swigregister
Standard_NullObject_swigregister(Standard_NullObject)

def Standard_NullObject_NewInstance(*args):
    """
    Standard_NullObject_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NullObject

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NullObject

    """
    return _Standard.Standard_NullObject_NewInstance(*args)

def Standard_NullObject_get_type_name(*args):
    """
    Standard_NullObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NullObject_get_type_name(*args)

def Standard_NullObject_get_type_descriptor(*args):
    """
    Standard_NullObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NullObject_get_type_descriptor(*args)

class Standard_CLocaleSentry(object):
    """
    This class intended to temporary switch C locale and logically equivalent to setlocale(LC_ALL, "C").
    It is intended to format text regardless of user locale settings (for import/export functionality).
    Thus following calls to sprintf, atoi and other functions will use "C" locale.
    Destructor of this class will return original locale.

    Notice that this functionality is platfrom dependent and intended only to workaround alien code
    that doesn't setup locale correctly.

    Internally you should prefer more portable C++ locale interfaces
    or OCCT wrappers to some C functions like Sprintf, Atof, Strtod.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_CLocaleSentry self) -> Standard_CLocaleSentry

        Setup current C locale to "C".


        """
        this = _Standard.new_Standard_CLocaleSentry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Standard.delete_Standard_CLocaleSentry
Standard_CLocaleSentry_swigregister = _Standard.Standard_CLocaleSentry_swigregister
Standard_CLocaleSentry_swigregister(Standard_CLocaleSentry)

class Standard_DivideByZero(Standard_NumericError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_DivideByZero
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_DivideByZero(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_DivideByZero self) -> Standard_DivideByZero
        __init__(Standard_DivideByZero self, Standard_CString const theMessage) -> Standard_DivideByZero

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_DivideByZero(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_DivideByZero

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DivideByZero

        """
        return _Standard.Standard_DivideByZero_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_DivideByZero_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_DivideByZero_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_DivideByZero_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_DivideByZero
Standard_DivideByZero_swigregister = _Standard.Standard_DivideByZero_swigregister
Standard_DivideByZero_swigregister(Standard_DivideByZero)

def Standard_DivideByZero_NewInstance(*args):
    """
    Standard_DivideByZero_NewInstance(Standard_CString const theMessage) -> Handle_Standard_DivideByZero

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_DivideByZero

    """
    return _Standard.Standard_DivideByZero_NewInstance(*args)

def Standard_DivideByZero_get_type_name(*args):
    """
    Standard_DivideByZero_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_DivideByZero_get_type_name(*args)

def Standard_DivideByZero_get_type_descriptor(*args):
    """
    Standard_DivideByZero_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_DivideByZero_get_type_descriptor(*args)

class Handle_Standard_TooManyUsers(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_TooManyUsers self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_TooManyUsers_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_TooManyUsers self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_TooManyUsers_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_TooManyUsers self, Standard_TooManyUsers thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_TooManyUsers_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_TooManyUsers self, Handle_Standard_TooManyUsers theHandle) -> Handle_Standard_TooManyUsers
        assign(Handle_Standard_TooManyUsers self, Standard_TooManyUsers thePtr) -> Handle_Standard_TooManyUsers
        assign(Handle_Standard_TooManyUsers self, Handle_Standard_TooManyUsers theHandle) -> Handle_Standard_TooManyUsers

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_TooManyUsers_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_TooManyUsers self) -> Standard_TooManyUsers

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_TooManyUsers_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_TooManyUsers self) -> Standard_TooManyUsers

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_TooManyUsers___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_TooManyUsers self) -> Standard_TooManyUsers

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_TooManyUsers___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_TooManyUsers___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_TooManyUsers___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_TooManyUsers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_TooManyUsers_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_TooManyUsers

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_TooManyUsers self, Standard_CString const theMessage) -> Handle_Standard_TooManyUsers

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_TooManyUsers

        """
        return _Standard.Handle_Standard_TooManyUsers_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_TooManyUsers self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_TooManyUsers_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_TooManyUsers_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_TooManyUsers_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_TooManyUsers self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_TooManyUsers_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_TooManyUsers self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_TooManyUsers_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_TooManyUsers self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_TooManyUsers_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_TooManyUsers self)
        Reraise(Handle_Standard_TooManyUsers self, Standard_CString const aMessage)
        Reraise(Handle_Standard_TooManyUsers self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_TooManyUsers_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_TooManyUsers self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_TooManyUsers_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_TooManyUsers self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_TooManyUsers_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_TooManyUsers self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_TooManyUsers_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_TooManyUsers self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_TooManyUsers self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_TooManyUsers_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_TooManyUsers self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_TooManyUsers self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_TooManyUsers_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_TooManyUsers self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_TooManyUsers_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_TooManyUsers self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_TooManyUsers_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_TooManyUsers self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_TooManyUsers_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_TooManyUsers self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_TooManyUsers_DecrementRefCounter(self, *args)

Handle_Standard_TooManyUsers_swigregister = _Standard.Handle_Standard_TooManyUsers_swigregister
Handle_Standard_TooManyUsers_swigregister(Handle_Standard_TooManyUsers)

def Handle_Standard_TooManyUsers_DownCast(thing):
    return _Standard.Handle_Standard_TooManyUsers_DownCast(thing)
Handle_Standard_TooManyUsers_DownCast = _Standard.Handle_Standard_TooManyUsers_DownCast

class Handle_Standard_DomainError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_DomainError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_DomainError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_DomainError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_DomainError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_DomainError self, Standard_DomainError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_DomainError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_DomainError self, Handle_Standard_DomainError theHandle) -> Handle_Standard_DomainError
        assign(Handle_Standard_DomainError self, Standard_DomainError thePtr) -> Handle_Standard_DomainError
        assign(Handle_Standard_DomainError self, Handle_Standard_DomainError theHandle) -> Handle_Standard_DomainError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_DomainError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_DomainError self) -> Standard_DomainError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_DomainError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_DomainError self) -> Standard_DomainError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_DomainError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_DomainError self) -> Standard_DomainError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_DomainError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_DomainError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_DomainError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_DomainError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_DomainError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_DomainError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_DomainError self, Standard_CString const theMessage) -> Handle_Standard_DomainError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DomainError

        """
        return _Standard.Handle_Standard_DomainError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_DomainError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_DomainError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DomainError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DomainError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_DomainError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_DomainError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_DomainError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DomainError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_DomainError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DomainError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_DomainError self)
        Reraise(Handle_Standard_DomainError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_DomainError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_DomainError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_DomainError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_DomainError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_DomainError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_DomainError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_DomainError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_DomainError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_DomainError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_DomainError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DomainError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_DomainError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_DomainError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DomainError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_DomainError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_DomainError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_DomainError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DomainError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_DomainError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_DomainError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_DomainError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DomainError_DecrementRefCounter(self, *args)

Handle_Standard_DomainError_swigregister = _Standard.Handle_Standard_DomainError_swigregister
Handle_Standard_DomainError_swigregister(Handle_Standard_DomainError)

def Handle_Standard_DomainError_DownCast(thing):
    return _Standard.Handle_Standard_DomainError_DownCast(thing)
Handle_Standard_DomainError_DownCast = _Standard.Handle_Standard_DomainError_DownCast

class Handle_Standard_Underflow(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_Underflow self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_Underflow_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_Underflow self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_Underflow_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_Underflow self, Standard_Underflow thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_Underflow_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_Underflow self, Handle_Standard_Underflow theHandle) -> Handle_Standard_Underflow
        assign(Handle_Standard_Underflow self, Standard_Underflow thePtr) -> Handle_Standard_Underflow
        assign(Handle_Standard_Underflow self, Handle_Standard_Underflow theHandle) -> Handle_Standard_Underflow

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_Underflow_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_Underflow self) -> Standard_Underflow

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_Underflow_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_Underflow self) -> Standard_Underflow

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_Underflow___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_Underflow self) -> Standard_Underflow

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_Underflow___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_Underflow___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_Underflow___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_Underflow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_Underflow_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_Underflow

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_Underflow self, Standard_CString const theMessage) -> Handle_Standard_Underflow

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Underflow

        """
        return _Standard.Handle_Standard_Underflow_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_Underflow self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_Underflow_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Underflow_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Underflow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_Underflow self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_Underflow_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_Underflow self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Underflow_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_Underflow self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Underflow_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_Underflow self)
        Reraise(Handle_Standard_Underflow self, Standard_CString const aMessage)
        Reraise(Handle_Standard_Underflow self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_Underflow_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_Underflow self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_Underflow_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_Underflow self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_Underflow_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_Underflow self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_Underflow_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_Underflow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_Underflow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Underflow_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_Underflow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_Underflow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Underflow_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_Underflow self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_Underflow_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_Underflow self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Underflow_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_Underflow self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_Underflow_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_Underflow self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Underflow_DecrementRefCounter(self, *args)

Handle_Standard_Underflow_swigregister = _Standard.Handle_Standard_Underflow_swigregister
Handle_Standard_Underflow_swigregister(Handle_Standard_Underflow)

def Handle_Standard_Underflow_DownCast(thing):
    return _Standard.Handle_Standard_Underflow_DownCast(thing)
Handle_Standard_Underflow_DownCast = _Standard.Handle_Standard_Underflow_DownCast

class Handle_Standard_NumericError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NumericError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NumericError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NumericError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NumericError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NumericError self, Standard_NumericError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NumericError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NumericError self, Handle_Standard_NumericError theHandle) -> Handle_Standard_NumericError
        assign(Handle_Standard_NumericError self, Standard_NumericError thePtr) -> Handle_Standard_NumericError
        assign(Handle_Standard_NumericError self, Handle_Standard_NumericError theHandle) -> Handle_Standard_NumericError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NumericError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NumericError self) -> Standard_NumericError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NumericError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NumericError self) -> Standard_NumericError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NumericError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NumericError self) -> Standard_NumericError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NumericError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NumericError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NumericError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NumericError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NumericError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NumericError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NumericError self, Standard_CString const theMessage) -> Handle_Standard_NumericError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NumericError

        """
        return _Standard.Handle_Standard_NumericError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NumericError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NumericError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NumericError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NumericError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NumericError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NumericError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NumericError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NumericError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NumericError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NumericError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NumericError self)
        Reraise(Handle_Standard_NumericError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NumericError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NumericError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NumericError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NumericError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NumericError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NumericError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NumericError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NumericError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NumericError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NumericError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NumericError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NumericError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NumericError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NumericError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NumericError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NumericError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NumericError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NumericError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NumericError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NumericError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NumericError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NumericError_DecrementRefCounter(self, *args)

Handle_Standard_NumericError_swigregister = _Standard.Handle_Standard_NumericError_swigregister
Handle_Standard_NumericError_swigregister(Handle_Standard_NumericError)

def Handle_Standard_NumericError_DownCast(thing):
    return _Standard.Handle_Standard_NumericError_DownCast(thing)
Handle_Standard_NumericError_DownCast = _Standard.Handle_Standard_NumericError_DownCast

class Standard_(object):
    """
    The package Standard provides global memory allocator and other basic
    services used by other OCCT components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Allocate(*args):
        """
        Allocate(Standard_Size const aSize) -> Standard_Address

        Allocates memory blocks
        aSize - bytes to  allocate

        :type aSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard__Allocate(*args)

    Allocate = staticmethod(Allocate)

    def Free(*args):
        """
        Free(Standard_Address const thePtr)

        Deallocates memory blocks
        @param thePtr - previously allocated memory block to be freed

        :type thePtr: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard__Free(*args)

    Free = staticmethod(Free)

    def Reallocate(*args):
        """
        Reallocate(Standard_Address const aStorage, Standard_Size const aNewSize) -> Standard_Address

        Reallocates memory blocks
        aStorage - previously allocated memory block
        aNewSize - new size in bytes

        :type aStorage: OCC.wrapper.Standard.Standard_Address
        :type aNewSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard__Reallocate(*args)

    Reallocate = staticmethod(Reallocate)

    def AllocateAligned(*args):
        """
        AllocateAligned(Standard_Size const theSize, Standard_Size const theAlign) -> Standard_Address

        Allocates aligned memory blocks.
        Should be used with CPU instructions which require specific alignment.
        For example: SSE requires 16 bytes, AVX requires 32 bytes.
        @param theSize  bytes to allocate
        @param theAlign alignment in bytes

        :type theSize: int
        :type theAlign: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard__AllocateAligned(*args)

    AllocateAligned = staticmethod(AllocateAligned)

    def FreeAligned(*args):
        """
        FreeAligned(Standard_Address const thePtrAligned)

        Deallocates memory blocks
        @param thePtrAligned the memory block previously allocated with AllocateAligned()

        :type thePtrAligned: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard__FreeAligned(*args)

    FreeAligned = staticmethod(FreeAligned)

    def Purge(*args):
        """
        Purge() -> Standard_Integer

        Deallocates the storage retained on the free list
        and clears the list.
        Returns non-zero if some memory has been actually freed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard__Purge(*args)

    Purge = staticmethod(Purge)

    def __init__(self):
        """
        The package Standard provides global memory allocator and other basic
        services used by other OCCT components.
        """
        this = _Standard.new_Standard_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Standard.delete_Standard_
Standard__swigregister = _Standard.Standard__swigregister
Standard__swigregister(Standard_)

def Standard__Allocate(*args):
    """
    Standard__Allocate(Standard_Size const aSize) -> Standard_Address

    Allocates memory blocks
    aSize - bytes to  allocate

    :type aSize: int
    :rtype: OCC.wrapper.Standard.Standard_Address

    """
    return _Standard.Standard__Allocate(*args)

def Standard__Free(*args):
    """
    Standard__Free(Standard_Address const thePtr)

    Deallocates memory blocks
    @param thePtr - previously allocated memory block to be freed

    :type thePtr: OCC.wrapper.Standard.Standard_Address

    """
    return _Standard.Standard__Free(*args)

def Standard__Reallocate(*args):
    """
    Standard__Reallocate(Standard_Address const aStorage, Standard_Size const aNewSize) -> Standard_Address

    Reallocates memory blocks
    aStorage - previously allocated memory block
    aNewSize - new size in bytes

    :type aStorage: OCC.wrapper.Standard.Standard_Address
    :type aNewSize: int
    :rtype: OCC.wrapper.Standard.Standard_Address

    """
    return _Standard.Standard__Reallocate(*args)

def Standard__AllocateAligned(*args):
    """
    Standard__AllocateAligned(Standard_Size const theSize, Standard_Size const theAlign) -> Standard_Address

    Allocates aligned memory blocks.
    Should be used with CPU instructions which require specific alignment.
    For example: SSE requires 16 bytes, AVX requires 32 bytes.
    @param theSize  bytes to allocate
    @param theAlign alignment in bytes

    :type theSize: int
    :type theAlign: int
    :rtype: OCC.wrapper.Standard.Standard_Address

    """
    return _Standard.Standard__AllocateAligned(*args)

def Standard__FreeAligned(*args):
    """
    Standard__FreeAligned(Standard_Address const thePtrAligned)

    Deallocates memory blocks
    @param thePtrAligned the memory block previously allocated with AllocateAligned()

    :type thePtrAligned: OCC.wrapper.Standard.Standard_Address

    """
    return _Standard.Standard__FreeAligned(*args)

def Standard__Purge(*args):
    """
    Standard__Purge() -> Standard_Integer

    Deallocates the storage retained on the free list
    and clears the list.
    Returns non-zero if some memory has been actually freed.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Standard.Standard__Purge(*args)

class Handle_Standard_NotImplemented(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NotImplemented self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NotImplemented_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NotImplemented self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NotImplemented_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NotImplemented self, Standard_NotImplemented thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NotImplemented_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NotImplemented self, Handle_Standard_NotImplemented theHandle) -> Handle_Standard_NotImplemented
        assign(Handle_Standard_NotImplemented self, Standard_NotImplemented thePtr) -> Handle_Standard_NotImplemented
        assign(Handle_Standard_NotImplemented self, Handle_Standard_NotImplemented theHandle) -> Handle_Standard_NotImplemented

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NotImplemented_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NotImplemented self) -> Standard_NotImplemented

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NotImplemented_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NotImplemented self) -> Standard_NotImplemented

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NotImplemented___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NotImplemented self) -> Standard_NotImplemented

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NotImplemented___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NotImplemented___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NotImplemented___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NotImplemented(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NotImplemented_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NotImplemented

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NotImplemented self, Standard_CString const theMessage) -> Handle_Standard_NotImplemented

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NotImplemented

        """
        return _Standard.Handle_Standard_NotImplemented_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NotImplemented self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NotImplemented_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NotImplemented_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NotImplemented_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NotImplemented self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NotImplemented_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NotImplemented self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NotImplemented_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NotImplemented self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NotImplemented_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NotImplemented self)
        Reraise(Handle_Standard_NotImplemented self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NotImplemented self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NotImplemented_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NotImplemented self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NotImplemented_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NotImplemented self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NotImplemented_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NotImplemented self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NotImplemented_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NotImplemented self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NotImplemented self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NotImplemented_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NotImplemented self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NotImplemented self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NotImplemented_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NotImplemented self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NotImplemented_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NotImplemented self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NotImplemented_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NotImplemented self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NotImplemented_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NotImplemented self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NotImplemented_DecrementRefCounter(self, *args)

Handle_Standard_NotImplemented_swigregister = _Standard.Handle_Standard_NotImplemented_swigregister
Handle_Standard_NotImplemented_swigregister(Handle_Standard_NotImplemented)

def Handle_Standard_NotImplemented_DownCast(thing):
    return _Standard.Handle_Standard_NotImplemented_DownCast(thing)
Handle_Standard_NotImplemented_DownCast = _Standard.Handle_Standard_NotImplemented_DownCast

class Handle_Standard_NullValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NullValue self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NullValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NullValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NullValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NullValue self, Standard_NullValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NullValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NullValue self, Handle_Standard_NullValue theHandle) -> Handle_Standard_NullValue
        assign(Handle_Standard_NullValue self, Standard_NullValue thePtr) -> Handle_Standard_NullValue
        assign(Handle_Standard_NullValue self, Handle_Standard_NullValue theHandle) -> Handle_Standard_NullValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NullValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NullValue self) -> Standard_NullValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NullValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NullValue self) -> Standard_NullValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NullValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NullValue self) -> Standard_NullValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NullValue___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NullValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NullValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NullValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NullValue_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NullValue

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NullValue self, Standard_CString const theMessage) -> Handle_Standard_NullValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NullValue

        """
        return _Standard.Handle_Standard_NullValue_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NullValue self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NullValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NullValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NullValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NullValue self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NullValue_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NullValue self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NullValue_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NullValue self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NullValue_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NullValue self)
        Reraise(Handle_Standard_NullValue self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NullValue self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NullValue_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NullValue self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NullValue_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NullValue self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NullValue_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NullValue self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NullValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NullValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NullValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NullValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NullValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NullValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NullValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NullValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NullValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NullValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NullValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NullValue self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NullValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NullValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NullValue_DecrementRefCounter(self, *args)

Handle_Standard_NullValue_swigregister = _Standard.Handle_Standard_NullValue_swigregister
Handle_Standard_NullValue_swigregister(Handle_Standard_NullValue)

def Handle_Standard_NullValue_DownCast(thing):
    return _Standard.Handle_Standard_NullValue_DownCast(thing)
Handle_Standard_NullValue_DownCast = _Standard.Handle_Standard_NullValue_DownCast

class Handle_Standard_Failure(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_Failure self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_Failure_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_Failure self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_Failure_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_Failure self, Standard_Failure thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_Failure_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_Failure self, Handle_Standard_Failure theHandle) -> Handle_Standard_Failure
        assign(Handle_Standard_Failure self, Standard_Failure thePtr) -> Handle_Standard_Failure
        assign(Handle_Standard_Failure self, Handle_Standard_Failure theHandle) -> Handle_Standard_Failure

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_Failure_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_Failure self) -> Standard_Failure

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_Failure_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_Failure self) -> Standard_Failure

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_Failure___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_Failure self) -> Standard_Failure

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_Failure___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_Failure___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_Failure___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_Failure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_Failure_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_Failure

    def Print(self, *args):
        """
        Print(Handle_Standard_Failure self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_Failure_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_Failure self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Failure_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_Failure self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Failure_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_Failure self)
        Reraise(Handle_Standard_Failure self, Standard_CString const aMessage)
        Reraise(Handle_Standard_Failure self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_Failure_Reraise(self, *args)


    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_Failure self, Standard_CString const aMessage) -> Handle_Standard_Failure

        Used to construct an instance of the exception object
        as a handle. Shall be used to protect against possible
        construction of exception object in C stack -- that is
        dangerous since some of methods require that object
        was allocated dynamically.

        :type aMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_Failure_NewInstance(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_Failure self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_Failure_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_Failure self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_Failure_Caught(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_Failure self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_Failure_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Failure_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Failure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Standard_Failure self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_Failure_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_Failure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_Failure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Failure_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_Failure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_Failure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Failure_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_Failure self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_Failure_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_Failure self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Failure_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_Failure self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_Failure_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_Failure self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Failure_DecrementRefCounter(self, *args)

Handle_Standard_Failure_swigregister = _Standard.Handle_Standard_Failure_swigregister
Handle_Standard_Failure_swigregister(Handle_Standard_Failure)

def Handle_Standard_Failure_DownCast(thing):
    return _Standard.Handle_Standard_Failure_DownCast(thing)
Handle_Standard_Failure_DownCast = _Standard.Handle_Standard_Failure_DownCast

class Handle_Standard_Transient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_Transient self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_Transient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_Transient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_Transient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_Transient self, Standard_Transient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_Transient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_Transient self, Handle_Standard_Transient theHandle) -> Handle_Standard_Transient
        assign(Handle_Standard_Transient self, Standard_Transient thePtr) -> Handle_Standard_Transient
        assign(Handle_Standard_Transient self, Handle_Standard_Transient theHandle) -> Handle_Standard_Transient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_Transient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_Transient self) -> Standard_Transient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_Transient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_Transient self) -> Standard_Transient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_Transient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_Transient self) -> Standard_Transient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_Transient___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_Transient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_Transient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_Transient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_Transient_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_Transient

    def Delete(self, *args):
        """
        Delete(Handle_Standard_Transient self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_Transient_Delete(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_Transient self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_Transient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        Returns type descriptor of Standard_Transient class

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Transient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        Returns a type descriptor about this object.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Transient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_Transient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_Transient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Transient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_Transient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_Transient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Transient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_Transient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_Transient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_Transient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Transient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_Transient self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_Transient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_Transient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Transient_DecrementRefCounter(self, *args)

Handle_Standard_Transient_swigregister = _Standard.Handle_Standard_Transient_swigregister
Handle_Standard_Transient_swigregister(Handle_Standard_Transient)

def Handle_Standard_Transient_DownCast(thing):
    return _Standard.Handle_Standard_Transient_DownCast(thing)
Handle_Standard_Transient_DownCast = _Standard.Handle_Standard_Transient_DownCast

class Handle_Standard_MultiplyDefined(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_MultiplyDefined self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_MultiplyDefined_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_MultiplyDefined self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_MultiplyDefined_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_MultiplyDefined self, Standard_MultiplyDefined thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_MultiplyDefined_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_MultiplyDefined self, Handle_Standard_MultiplyDefined theHandle) -> Handle_Standard_MultiplyDefined
        assign(Handle_Standard_MultiplyDefined self, Standard_MultiplyDefined thePtr) -> Handle_Standard_MultiplyDefined
        assign(Handle_Standard_MultiplyDefined self, Handle_Standard_MultiplyDefined theHandle) -> Handle_Standard_MultiplyDefined

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_MultiplyDefined_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_MultiplyDefined self) -> Standard_MultiplyDefined

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_MultiplyDefined_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_MultiplyDefined self) -> Standard_MultiplyDefined

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_MultiplyDefined___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_MultiplyDefined self) -> Standard_MultiplyDefined

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_MultiplyDefined___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_MultiplyDefined___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_MultiplyDefined___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_MultiplyDefined(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_MultiplyDefined_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_MultiplyDefined

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_MultiplyDefined self, Standard_CString const theMessage) -> Handle_Standard_MultiplyDefined

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_MultiplyDefined

        """
        return _Standard.Handle_Standard_MultiplyDefined_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_MultiplyDefined self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_MultiplyDefined_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_MultiplyDefined_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_MultiplyDefined_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_MultiplyDefined self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_MultiplyDefined_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_MultiplyDefined self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_MultiplyDefined_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_MultiplyDefined self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_MultiplyDefined_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_MultiplyDefined self)
        Reraise(Handle_Standard_MultiplyDefined self, Standard_CString const aMessage)
        Reraise(Handle_Standard_MultiplyDefined self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_MultiplyDefined_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_MultiplyDefined self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_MultiplyDefined_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_MultiplyDefined self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_MultiplyDefined_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_MultiplyDefined self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_MultiplyDefined_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_MultiplyDefined self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_MultiplyDefined self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_MultiplyDefined_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_MultiplyDefined self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_MultiplyDefined self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_MultiplyDefined_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_MultiplyDefined self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_MultiplyDefined_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_MultiplyDefined self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_MultiplyDefined_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_MultiplyDefined self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_MultiplyDefined_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_MultiplyDefined self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_MultiplyDefined_DecrementRefCounter(self, *args)

Handle_Standard_MultiplyDefined_swigregister = _Standard.Handle_Standard_MultiplyDefined_swigregister
Handle_Standard_MultiplyDefined_swigregister(Handle_Standard_MultiplyDefined)

def Handle_Standard_MultiplyDefined_DownCast(thing):
    return _Standard.Handle_Standard_MultiplyDefined_DownCast(thing)
Handle_Standard_MultiplyDefined_DownCast = _Standard.Handle_Standard_MultiplyDefined_DownCast

class Handle_Standard_OutOfMemory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_OutOfMemory self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_OutOfMemory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_OutOfMemory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_OutOfMemory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_OutOfMemory self, Standard_OutOfMemory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_OutOfMemory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_OutOfMemory self, Handle_Standard_OutOfMemory theHandle) -> Handle_Standard_OutOfMemory
        assign(Handle_Standard_OutOfMemory self, Standard_OutOfMemory thePtr) -> Handle_Standard_OutOfMemory
        assign(Handle_Standard_OutOfMemory self, Handle_Standard_OutOfMemory theHandle) -> Handle_Standard_OutOfMemory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_OutOfMemory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_OutOfMemory self) -> Standard_OutOfMemory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_OutOfMemory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_OutOfMemory self) -> Standard_OutOfMemory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_OutOfMemory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_OutOfMemory self) -> Standard_OutOfMemory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_OutOfMemory___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_OutOfMemory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_OutOfMemory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_OutOfMemory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_OutOfMemory_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_OutOfMemory

    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_OutOfMemory self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_OutOfMemory_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_OutOfMemory self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_OutOfMemory_SetMessageString(self, *args)


    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_OutOfMemory self, Standard_CString const theMessage) -> Handle_Standard_OutOfMemory

        Returns global instance of exception

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_OutOfMemory

        """
        return _Standard.Handle_Standard_OutOfMemory_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_OutOfMemory self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_OutOfMemory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_OutOfMemory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_OutOfMemory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_OutOfMemory self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_OutOfMemory_Print(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_OutOfMemory self)
        Reraise(Handle_Standard_OutOfMemory self, Standard_CString const aMessage)
        Reraise(Handle_Standard_OutOfMemory self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_OutOfMemory_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_OutOfMemory self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_OutOfMemory_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_OutOfMemory self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_OutOfMemory_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_OutOfMemory self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_OutOfMemory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_OutOfMemory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_OutOfMemory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_OutOfMemory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_OutOfMemory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_OutOfMemory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_OutOfMemory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_OutOfMemory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_OutOfMemory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_OutOfMemory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_OutOfMemory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_OutOfMemory self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_OutOfMemory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_OutOfMemory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_OutOfMemory_DecrementRefCounter(self, *args)

Handle_Standard_OutOfMemory_swigregister = _Standard.Handle_Standard_OutOfMemory_swigregister
Handle_Standard_OutOfMemory_swigregister(Handle_Standard_OutOfMemory)

def Handle_Standard_OutOfMemory_DownCast(thing):
    return _Standard.Handle_Standard_OutOfMemory_DownCast(thing)
Handle_Standard_OutOfMemory_DownCast = _Standard.Handle_Standard_OutOfMemory_DownCast

class Handle_Standard_LicenseNotFound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_LicenseNotFound self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_LicenseNotFound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_LicenseNotFound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_LicenseNotFound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_LicenseNotFound self, Standard_LicenseNotFound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_LicenseNotFound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_LicenseNotFound self, Handle_Standard_LicenseNotFound theHandle) -> Handle_Standard_LicenseNotFound
        assign(Handle_Standard_LicenseNotFound self, Standard_LicenseNotFound thePtr) -> Handle_Standard_LicenseNotFound
        assign(Handle_Standard_LicenseNotFound self, Handle_Standard_LicenseNotFound theHandle) -> Handle_Standard_LicenseNotFound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_LicenseNotFound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_LicenseNotFound self) -> Standard_LicenseNotFound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_LicenseNotFound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_LicenseNotFound self) -> Standard_LicenseNotFound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_LicenseNotFound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_LicenseNotFound self) -> Standard_LicenseNotFound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_LicenseNotFound___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_LicenseNotFound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_LicenseNotFound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_LicenseNotFound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_LicenseNotFound_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_LicenseNotFound

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_LicenseNotFound self, Standard_CString const theMessage) -> Handle_Standard_LicenseNotFound

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_LicenseNotFound

        """
        return _Standard.Handle_Standard_LicenseNotFound_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_LicenseNotFound self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_LicenseNotFound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_LicenseNotFound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_LicenseNotFound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_LicenseNotFound self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_LicenseNotFound_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_LicenseNotFound self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_LicenseNotFound_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_LicenseNotFound self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_LicenseNotFound_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_LicenseNotFound self)
        Reraise(Handle_Standard_LicenseNotFound self, Standard_CString const aMessage)
        Reraise(Handle_Standard_LicenseNotFound self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_LicenseNotFound_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_LicenseNotFound self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_LicenseNotFound_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_LicenseNotFound self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_LicenseNotFound_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_LicenseNotFound self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_LicenseNotFound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_LicenseNotFound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_LicenseNotFound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_LicenseNotFound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_LicenseNotFound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_LicenseNotFound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_LicenseNotFound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_LicenseNotFound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_LicenseNotFound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_LicenseNotFound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_LicenseNotFound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_LicenseNotFound self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_LicenseNotFound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_LicenseNotFound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_LicenseNotFound_DecrementRefCounter(self, *args)

Handle_Standard_LicenseNotFound_swigregister = _Standard.Handle_Standard_LicenseNotFound_swigregister
Handle_Standard_LicenseNotFound_swigregister(Handle_Standard_LicenseNotFound)

def Handle_Standard_LicenseNotFound_DownCast(thing):
    return _Standard.Handle_Standard_LicenseNotFound_DownCast(thing)
Handle_Standard_LicenseNotFound_DownCast = _Standard.Handle_Standard_LicenseNotFound_DownCast

class Handle_Standard_DimensionMismatch(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_DimensionMismatch self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_DimensionMismatch_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_DimensionMismatch self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_DimensionMismatch_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_DimensionMismatch self, Standard_DimensionMismatch thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_DimensionMismatch_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_DimensionMismatch self, Handle_Standard_DimensionMismatch theHandle) -> Handle_Standard_DimensionMismatch
        assign(Handle_Standard_DimensionMismatch self, Standard_DimensionMismatch thePtr) -> Handle_Standard_DimensionMismatch
        assign(Handle_Standard_DimensionMismatch self, Handle_Standard_DimensionMismatch theHandle) -> Handle_Standard_DimensionMismatch

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_DimensionMismatch_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_DimensionMismatch self) -> Standard_DimensionMismatch

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_DimensionMismatch_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_DimensionMismatch self) -> Standard_DimensionMismatch

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_DimensionMismatch___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_DimensionMismatch self) -> Standard_DimensionMismatch

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_DimensionMismatch___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_DimensionMismatch___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_DimensionMismatch___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_DimensionMismatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_DimensionMismatch_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_DimensionMismatch

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_DimensionMismatch self, Standard_CString const theMessage) -> Handle_Standard_DimensionMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DimensionMismatch

        """
        return _Standard.Handle_Standard_DimensionMismatch_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_DimensionMismatch self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_DimensionMismatch_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DimensionMismatch_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DimensionMismatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_DimensionMismatch self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_DimensionMismatch_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_DimensionMismatch self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DimensionMismatch_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_DimensionMismatch self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DimensionMismatch_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_DimensionMismatch self)
        Reraise(Handle_Standard_DimensionMismatch self, Standard_CString const aMessage)
        Reraise(Handle_Standard_DimensionMismatch self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_DimensionMismatch_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_DimensionMismatch self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_DimensionMismatch_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_DimensionMismatch self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_DimensionMismatch_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_DimensionMismatch self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_DimensionMismatch_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_DimensionMismatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_DimensionMismatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DimensionMismatch_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_DimensionMismatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_DimensionMismatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DimensionMismatch_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_DimensionMismatch self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_DimensionMismatch_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_DimensionMismatch self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DimensionMismatch_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_DimensionMismatch self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_DimensionMismatch_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_DimensionMismatch self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DimensionMismatch_DecrementRefCounter(self, *args)

Handle_Standard_DimensionMismatch_swigregister = _Standard.Handle_Standard_DimensionMismatch_swigregister
Handle_Standard_DimensionMismatch_swigregister(Handle_Standard_DimensionMismatch)

def Handle_Standard_DimensionMismatch_DownCast(thing):
    return _Standard.Handle_Standard_DimensionMismatch_DownCast(thing)
Handle_Standard_DimensionMismatch_DownCast = _Standard.Handle_Standard_DimensionMismatch_DownCast

class Handle_Standard_LicenseError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_LicenseError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_LicenseError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_LicenseError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_LicenseError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_LicenseError self, Standard_LicenseError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_LicenseError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_LicenseError self, Handle_Standard_LicenseError theHandle) -> Handle_Standard_LicenseError
        assign(Handle_Standard_LicenseError self, Standard_LicenseError thePtr) -> Handle_Standard_LicenseError
        assign(Handle_Standard_LicenseError self, Handle_Standard_LicenseError theHandle) -> Handle_Standard_LicenseError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_LicenseError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_LicenseError self) -> Standard_LicenseError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_LicenseError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_LicenseError self) -> Standard_LicenseError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_LicenseError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_LicenseError self) -> Standard_LicenseError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_LicenseError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_LicenseError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_LicenseError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_LicenseError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_LicenseError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_LicenseError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_LicenseError self, Standard_CString const theMessage) -> Handle_Standard_LicenseError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_LicenseError

        """
        return _Standard.Handle_Standard_LicenseError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_LicenseError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_LicenseError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_LicenseError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_LicenseError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_LicenseError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_LicenseError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_LicenseError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_LicenseError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_LicenseError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_LicenseError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_LicenseError self)
        Reraise(Handle_Standard_LicenseError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_LicenseError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_LicenseError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_LicenseError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_LicenseError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_LicenseError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_LicenseError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_LicenseError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_LicenseError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_LicenseError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_LicenseError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_LicenseError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_LicenseError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_LicenseError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_LicenseError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_LicenseError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_LicenseError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_LicenseError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_LicenseError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_LicenseError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_LicenseError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_LicenseError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_LicenseError_DecrementRefCounter(self, *args)

Handle_Standard_LicenseError_swigregister = _Standard.Handle_Standard_LicenseError_swigregister
Handle_Standard_LicenseError_swigregister(Handle_Standard_LicenseError)

def Handle_Standard_LicenseError_DownCast(thing):
    return _Standard.Handle_Standard_LicenseError_DownCast(thing)
Handle_Standard_LicenseError_DownCast = _Standard.Handle_Standard_LicenseError_DownCast

class Standard_MMgrOpt(Standard_MMgrRoot):
    """
    @brief Open CASCADE memory manager optimized for speed.

    The behaviour is different for memory blocks of different sizes,
    according to specified options provided to constructor:

    - Small blocks with size less than or equal to aCellSize are allocated 
    in big pools of memory. The parameter aNbPages specifies size of 
    these pools in pages (operating system-dependent). 
    When freed, small block is not returned to the system but added
    into free blocks list and reused when block of the same size is 
    requested.

    - Medium size blocks with size less than aThreshold are allocated 
    using malloc() or calloc() function but not returned to the system
    when method Free() is called; instead they are put into free list
    and reused when block of the same size is requested.
    Blocks of medium size stored in free lists can be released to the 
    system (by free()) by calling method Purge().

    - Large blocks with size greater than or equal to aThreshold are allocated 
    and freed directly: either using malloc()/calloc() and free(), or using 
    memory mapped files (if option aMMap is True)

    Thus the optimization of memory allocation/deallocation is reached 
    for small and medium size blocks using free lists method; 
    note that space allocated for small blocks cannot be (currently) released
    to the system while space for medium size blocks can be released by method Purge().

    Note that destructor of that class frees all free lists and memory pools 
    allocated for small blocks.

    Note that size of memory blocks allocated by this memory manager is always 
    rounded up to 16 bytes. In addition, 8 bytes are added at the beginning 
    of the memory block to hold auxiliary information (size of the block when
    in use, or pointer to the next free block when in free list).
    This the expense of speed optimization. At the same time, allocating small 
    blocks is usually less costly than directly by malloc since allocation is made
    once (when allocating a pool) and overheads induced by malloc are minimized.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_MMgrOpt self, Standard_Boolean const aClear, Standard_Boolean const aMMap, Standard_Size const aCellSize=200, Standard_Integer const aNbPages=10000, Standard_Size const aThreshold=40000) -> Standard_MMgrOpt

        Constructor. If aClear is True, the allocated emmory will be 
        nullified. For description of other parameters, see description 
        of the class above.

        :type aClear: bool
        :type aMMap: bool
        :type aCellSize: int
        :type aNbPages: int
        :type aThreshold: int

        """
        this = _Standard.new_Standard_MMgrOpt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Allocate(self, *args):
        """
        Allocate(Standard_MMgrOpt self, Standard_Size const aSize) -> Standard_Address

        Allocate aSize bytes; see class description above

        :type aSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrOpt_Allocate(self, *args)


    def Reallocate(self, *args):
        """
        Reallocate(Standard_MMgrOpt self, Standard_Address thePtr, Standard_Size const theSize) -> Standard_Address

        Reallocate previously allocated aPtr to a new size; new address is returned.
        In case that aPtr is null, the function behaves exactly as Allocate.

        :type thePtr: OCC.wrapper.Standard.Standard_Address
        :type theSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrOpt_Reallocate(self, *args)


    def Free(self, *args):
        """
        Free(Standard_MMgrOpt self, Standard_Address thePtr)

        Free previously allocated block.
        Note that block can not all blocks are released to the OS by this 
        method (see class description)

        :type thePtr: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrOpt_Free(self, *args)


    def Purge(self, *args):
        """
        Purge(Standard_MMgrOpt self, Standard_Boolean isDestroyed) -> Standard_Integer

        Release medium-sized blocks of memory in free lists to the system.
        Returns number of actually freed blocks

        :type isDestroyed: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_MMgrOpt_Purge(self, *args)


    def SetCallBackFunction(*args):
        """
        SetCallBackFunction(Standard_MMgrOpt::TPCallBackFunc pFunc)

        Set the callback function. You may pass 0 there to turn off the callback.
        The callback function, if set, will be automatically called from within
        Allocate and Free methods.

        :type pFunc: TPCallBackFunc

        """
        return _Standard.Standard_MMgrOpt_SetCallBackFunction(*args)

    SetCallBackFunction = staticmethod(SetCallBackFunction)
    __swig_destroy__ = _Standard.delete_Standard_MMgrOpt
Standard_MMgrOpt_swigregister = _Standard.Standard_MMgrOpt_swigregister
Standard_MMgrOpt_swigregister(Standard_MMgrOpt)

def Standard_MMgrOpt_SetCallBackFunction(*args):
    """
    Standard_MMgrOpt_SetCallBackFunction(Standard_MMgrOpt::TPCallBackFunc pFunc)

    Set the callback function. You may pass 0 there to turn off the callback.
    The callback function, if set, will be automatically called from within
    Allocate and Free methods.

    :type pFunc: TPCallBackFunc

    """
    return _Standard.Standard_MMgrOpt_SetCallBackFunction(*args)

class Handle_Standard_NoSuchObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NoSuchObject self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NoSuchObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NoSuchObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NoSuchObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NoSuchObject self, Standard_NoSuchObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NoSuchObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NoSuchObject self, Handle_Standard_NoSuchObject theHandle) -> Handle_Standard_NoSuchObject
        assign(Handle_Standard_NoSuchObject self, Standard_NoSuchObject thePtr) -> Handle_Standard_NoSuchObject
        assign(Handle_Standard_NoSuchObject self, Handle_Standard_NoSuchObject theHandle) -> Handle_Standard_NoSuchObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NoSuchObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NoSuchObject self) -> Standard_NoSuchObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NoSuchObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NoSuchObject self) -> Standard_NoSuchObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NoSuchObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NoSuchObject self) -> Standard_NoSuchObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NoSuchObject___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NoSuchObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NoSuchObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NoSuchObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NoSuchObject_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NoSuchObject

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NoSuchObject self, Standard_CString const theMessage) -> Handle_Standard_NoSuchObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NoSuchObject

        """
        return _Standard.Handle_Standard_NoSuchObject_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NoSuchObject self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NoSuchObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NoSuchObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NoSuchObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NoSuchObject self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NoSuchObject_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NoSuchObject self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NoSuchObject_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NoSuchObject self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NoSuchObject_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NoSuchObject self)
        Reraise(Handle_Standard_NoSuchObject self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NoSuchObject self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NoSuchObject_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NoSuchObject self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NoSuchObject_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NoSuchObject self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NoSuchObject_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NoSuchObject self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NoSuchObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NoSuchObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NoSuchObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NoSuchObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NoSuchObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NoSuchObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NoSuchObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NoSuchObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NoSuchObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NoSuchObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NoSuchObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NoSuchObject self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NoSuchObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NoSuchObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NoSuchObject_DecrementRefCounter(self, *args)

Handle_Standard_NoSuchObject_swigregister = _Standard.Handle_Standard_NoSuchObject_swigregister
Handle_Standard_NoSuchObject_swigregister(Handle_Standard_NoSuchObject)

def Handle_Standard_NoSuchObject_DownCast(thing):
    return _Standard.Handle_Standard_NoSuchObject_DownCast(thing)
Handle_Standard_NoSuchObject_DownCast = _Standard.Handle_Standard_NoSuchObject_DownCast

class Standard_MMgrRaw(Standard_MMgrRoot):
    """
    Implementation of raw OCC memory manager which uses standard C
    functions: malloc (or calloc), free and realloc 
    without any optimization
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_MMgrRaw self, Standard_Boolean const aClear) -> Standard_MMgrRaw

        Constructor; if aClear is True, the memory will be nullified
        upon allocation.

        :type aClear: bool

        """
        this = _Standard.new_Standard_MMgrRaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Allocate(self, *args):
        """
        Allocate(Standard_MMgrRaw self, Standard_Size const aSize) -> Standard_Address

        Allocate aSize bytes 

        :type aSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrRaw_Allocate(self, *args)


    def Reallocate(self, *args):
        """
        Reallocate(Standard_MMgrRaw self, Standard_Address thePtr, Standard_Size const theSize) -> Standard_Address

        Reallocate aPtr to the size aSize. 
        The new pointer is returned.

        :type thePtr: OCC.wrapper.Standard.Standard_Address
        :type theSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrRaw_Reallocate(self, *args)


    def Free(self, *args):
        """
        Free(Standard_MMgrRaw self, Standard_Address thePtr)

        Free allocated memory. The pointer is nullified.

        :type thePtr: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrRaw_Free(self, *args)

    __swig_destroy__ = _Standard.delete_Standard_MMgrRaw
Standard_MMgrRaw_swigregister = _Standard.Standard_MMgrRaw_swigregister
Standard_MMgrRaw_swigregister(Standard_MMgrRaw)

class Standard_AbortiveTransaction(Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_AbortiveTransaction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_AbortiveTransaction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_AbortiveTransaction self) -> Standard_AbortiveTransaction
        __init__(Standard_AbortiveTransaction self, Standard_CString const theMessage) -> Standard_AbortiveTransaction

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_AbortiveTransaction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_AbortiveTransaction

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_AbortiveTransaction

        """
        return _Standard.Standard_AbortiveTransaction_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_AbortiveTransaction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_AbortiveTransaction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_AbortiveTransaction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_AbortiveTransaction
Standard_AbortiveTransaction_swigregister = _Standard.Standard_AbortiveTransaction_swigregister
Standard_AbortiveTransaction_swigregister(Standard_AbortiveTransaction)

def Standard_AbortiveTransaction_NewInstance(*args):
    """
    Standard_AbortiveTransaction_NewInstance(Standard_CString const theMessage) -> Handle_Standard_AbortiveTransaction

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_AbortiveTransaction

    """
    return _Standard.Standard_AbortiveTransaction_NewInstance(*args)

def Standard_AbortiveTransaction_get_type_name(*args):
    """
    Standard_AbortiveTransaction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_AbortiveTransaction_get_type_name(*args)

def Standard_AbortiveTransaction_get_type_descriptor(*args):
    """
    Standard_AbortiveTransaction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_AbortiveTransaction_get_type_descriptor(*args)

class Standard_Mutex(object):
    """
    @brief Mutex: a class to synchronize access to shared data. 

    This is simple encapsulation of tools provided by the
    operating system to syncronize access to shared data 
    from threads within one process.

    Current implementation is very simple and straightforward;
    it is just a wrapper around POSIX pthread librray on UNIX/Linux,
    and CRITICAL_SECTIONs on Windows NT. It does not provide any
    advanced functionaly such as recursive calls to the same mutex from 
    within one thread (such call will froze the execution).

    Note that all the methods of that class are made inline, in order
    to keep maximal performance. This means that a library using the mutex
    might need to be linked to threads library directly.

    The typical use of this class should be as follows:
    - create instance of the class Standard_Mutex in the global scope
    (whenever possible, or as a field of your class)
    - create instance of class Standard_Mutex::Sentry using that Mutex
    when entering critical section

    Note that this class provides one feature specific to Open CASCADE:
    safe unlocking the mutex when signal is raised and converted to OCC
    exceptions (Note that with current implementation of this functionality
    on UNIX and Linux, C longjumps are used for that, thus destructors of 
    classes are not called automatically).

    To use this feature, call RegisterCallback() after Lock() or successful
    TryLock(), and UnregisterCallback() before Unlock() (or use Sentry classes). 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_Mutex self) -> Standard_Mutex

        Constructor: creates a mutex object and initializes it.
        It is strongly recommended that mutexes were created as 
        static objects whenever possible.


        """
        this = _Standard.new_Standard_Mutex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Lock(self, *args):
        """
        Lock(Standard_Mutex self)

        Method to lock the mutex; waits until the mutex is released
        by other threads, locks it and then returns


        """
        return _Standard.Standard_Mutex_Lock(self, *args)


    def TryLock(self, *args):
        """
        TryLock(Standard_Mutex self) -> Standard_Boolean

        Method to test the mutex; if the mutex is not hold by other thread,
        locks it and returns True; otherwise returns False without waiting
        mutex to be released.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_Mutex_TryLock(self, *args)


    def Unlock(self, *args):
        """
        Unlock(Standard_Mutex self)

        Method to unlock the mutex; releases it to other users


        """
        return _Standard.Standard_Mutex_Unlock(self, *args)

    __swig_destroy__ = _Standard.delete_Standard_Mutex
Standard_Mutex_swigregister = _Standard.Standard_Mutex_swigregister
Standard_Mutex_swigregister(Standard_Mutex)

class Handle_Standard_NegativeValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NegativeValue self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NegativeValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NegativeValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NegativeValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NegativeValue self, Standard_NegativeValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NegativeValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NegativeValue self, Handle_Standard_NegativeValue theHandle) -> Handle_Standard_NegativeValue
        assign(Handle_Standard_NegativeValue self, Standard_NegativeValue thePtr) -> Handle_Standard_NegativeValue
        assign(Handle_Standard_NegativeValue self, Handle_Standard_NegativeValue theHandle) -> Handle_Standard_NegativeValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NegativeValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NegativeValue self) -> Standard_NegativeValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NegativeValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NegativeValue self) -> Standard_NegativeValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NegativeValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NegativeValue self) -> Standard_NegativeValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NegativeValue___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NegativeValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NegativeValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NegativeValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NegativeValue_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NegativeValue

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NegativeValue self, Standard_CString const theMessage) -> Handle_Standard_NegativeValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NegativeValue

        """
        return _Standard.Handle_Standard_NegativeValue_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NegativeValue self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NegativeValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NegativeValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NegativeValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NegativeValue self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NegativeValue_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NegativeValue self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NegativeValue_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NegativeValue self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NegativeValue_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NegativeValue self)
        Reraise(Handle_Standard_NegativeValue self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NegativeValue self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NegativeValue_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NegativeValue self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NegativeValue_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NegativeValue self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NegativeValue_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NegativeValue self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NegativeValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NegativeValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NegativeValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NegativeValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NegativeValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NegativeValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NegativeValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NegativeValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NegativeValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NegativeValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NegativeValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NegativeValue self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NegativeValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NegativeValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NegativeValue_DecrementRefCounter(self, *args)

Handle_Standard_NegativeValue_swigregister = _Standard.Handle_Standard_NegativeValue_swigregister
Handle_Standard_NegativeValue_swigregister(Handle_Standard_NegativeValue)

def Handle_Standard_NegativeValue_DownCast(thing):
    return _Standard.Handle_Standard_NegativeValue_DownCast(thing)
Handle_Standard_NegativeValue_DownCast = _Standard.Handle_Standard_NegativeValue_DownCast

class Standard_NoMoreObject(Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_NoMoreObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_NoMoreObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_NoMoreObject self) -> Standard_NoMoreObject
        __init__(Standard_NoMoreObject self, Standard_CString const theMessage) -> Standard_NoMoreObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Standard.new_Standard_NoMoreObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Standard_NoMoreObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NoMoreObject

        """
        return _Standard.Standard_NoMoreObject_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_NoMoreObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_NoMoreObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_NoMoreObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Standard.delete_Standard_NoMoreObject
Standard_NoMoreObject_swigregister = _Standard.Standard_NoMoreObject_swigregister
Standard_NoMoreObject_swigregister(Standard_NoMoreObject)

def Standard_NoMoreObject_NewInstance(*args):
    """
    Standard_NoMoreObject_NewInstance(Standard_CString const theMessage) -> Handle_Standard_NoMoreObject

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Handle_Standard_NoMoreObject

    """
    return _Standard.Standard_NoMoreObject_NewInstance(*args)

def Standard_NoMoreObject_get_type_name(*args):
    """
    Standard_NoMoreObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_NoMoreObject_get_type_name(*args)

def Standard_NoMoreObject_get_type_descriptor(*args):
    """
    Standard_NoMoreObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_NoMoreObject_get_type_descriptor(*args)

class Handle_Standard_TypeMismatch(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_TypeMismatch self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_TypeMismatch_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_TypeMismatch self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_TypeMismatch_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_TypeMismatch self, Standard_TypeMismatch thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_TypeMismatch_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_TypeMismatch self, Handle_Standard_TypeMismatch theHandle) -> Handle_Standard_TypeMismatch
        assign(Handle_Standard_TypeMismatch self, Standard_TypeMismatch thePtr) -> Handle_Standard_TypeMismatch
        assign(Handle_Standard_TypeMismatch self, Handle_Standard_TypeMismatch theHandle) -> Handle_Standard_TypeMismatch

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_TypeMismatch_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_TypeMismatch self) -> Standard_TypeMismatch

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_TypeMismatch_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_TypeMismatch self) -> Standard_TypeMismatch

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_TypeMismatch___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_TypeMismatch self) -> Standard_TypeMismatch

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_TypeMismatch___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_TypeMismatch___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_TypeMismatch___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_TypeMismatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_TypeMismatch_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_TypeMismatch

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_TypeMismatch self, Standard_CString const theMessage) -> Handle_Standard_TypeMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_TypeMismatch

        """
        return _Standard.Handle_Standard_TypeMismatch_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_TypeMismatch self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_TypeMismatch_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_TypeMismatch_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_TypeMismatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_TypeMismatch self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_TypeMismatch_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_TypeMismatch self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_TypeMismatch_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_TypeMismatch self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_TypeMismatch_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_TypeMismatch self)
        Reraise(Handle_Standard_TypeMismatch self, Standard_CString const aMessage)
        Reraise(Handle_Standard_TypeMismatch self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_TypeMismatch_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_TypeMismatch self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_TypeMismatch_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_TypeMismatch self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_TypeMismatch_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_TypeMismatch self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_TypeMismatch_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_TypeMismatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_TypeMismatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_TypeMismatch_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_TypeMismatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_TypeMismatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_TypeMismatch_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_TypeMismatch self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_TypeMismatch_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_TypeMismatch self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_TypeMismatch_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_TypeMismatch self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_TypeMismatch_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_TypeMismatch self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_TypeMismatch_DecrementRefCounter(self, *args)

Handle_Standard_TypeMismatch_swigregister = _Standard.Handle_Standard_TypeMismatch_swigregister
Handle_Standard_TypeMismatch_swigregister(Handle_Standard_TypeMismatch)

def Handle_Standard_TypeMismatch_DownCast(thing):
    return _Standard.Handle_Standard_TypeMismatch_DownCast(thing)
Handle_Standard_TypeMismatch_DownCast = _Standard.Handle_Standard_TypeMismatch_DownCast

class Handle_Standard_DimensionError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_DimensionError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_DimensionError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_DimensionError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_DimensionError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_DimensionError self, Standard_DimensionError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_DimensionError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_DimensionError self, Handle_Standard_DimensionError theHandle) -> Handle_Standard_DimensionError
        assign(Handle_Standard_DimensionError self, Standard_DimensionError thePtr) -> Handle_Standard_DimensionError
        assign(Handle_Standard_DimensionError self, Handle_Standard_DimensionError theHandle) -> Handle_Standard_DimensionError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_DimensionError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_DimensionError self) -> Standard_DimensionError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_DimensionError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_DimensionError self) -> Standard_DimensionError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_DimensionError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_DimensionError self) -> Standard_DimensionError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_DimensionError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_DimensionError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_DimensionError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_DimensionError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_DimensionError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_DimensionError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_DimensionError self, Standard_CString const theMessage) -> Handle_Standard_DimensionError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DimensionError

        """
        return _Standard.Handle_Standard_DimensionError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_DimensionError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_DimensionError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DimensionError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DimensionError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_DimensionError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_DimensionError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_DimensionError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DimensionError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_DimensionError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DimensionError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_DimensionError self)
        Reraise(Handle_Standard_DimensionError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_DimensionError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_DimensionError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_DimensionError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_DimensionError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_DimensionError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_DimensionError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_DimensionError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_DimensionError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_DimensionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_DimensionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DimensionError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_DimensionError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_DimensionError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DimensionError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_DimensionError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_DimensionError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_DimensionError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DimensionError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_DimensionError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_DimensionError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_DimensionError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DimensionError_DecrementRefCounter(self, *args)

Handle_Standard_DimensionError_swigregister = _Standard.Handle_Standard_DimensionError_swigregister
Handle_Standard_DimensionError_swigregister(Handle_Standard_DimensionError)

def Handle_Standard_DimensionError_DownCast(thing):
    return _Standard.Handle_Standard_DimensionError_DownCast(thing)
Handle_Standard_DimensionError_DownCast = _Standard.Handle_Standard_DimensionError_DownCast

class Handle_Standard_Overflow(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_Overflow self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_Overflow_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_Overflow self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_Overflow_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_Overflow self, Standard_Overflow thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_Overflow_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_Overflow self, Handle_Standard_Overflow theHandle) -> Handle_Standard_Overflow
        assign(Handle_Standard_Overflow self, Standard_Overflow thePtr) -> Handle_Standard_Overflow
        assign(Handle_Standard_Overflow self, Handle_Standard_Overflow theHandle) -> Handle_Standard_Overflow

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_Overflow_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_Overflow self) -> Standard_Overflow

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_Overflow_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_Overflow self) -> Standard_Overflow

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_Overflow___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_Overflow self) -> Standard_Overflow

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_Overflow___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_Overflow___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_Overflow___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_Overflow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_Overflow_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_Overflow

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_Overflow self, Standard_CString const theMessage) -> Handle_Standard_Overflow

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Overflow

        """
        return _Standard.Handle_Standard_Overflow_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_Overflow self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_Overflow_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Overflow_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Overflow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_Overflow self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_Overflow_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_Overflow self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Overflow_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_Overflow self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Overflow_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_Overflow self)
        Reraise(Handle_Standard_Overflow self, Standard_CString const aMessage)
        Reraise(Handle_Standard_Overflow self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_Overflow_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_Overflow self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_Overflow_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_Overflow self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_Overflow_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_Overflow self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_Overflow_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_Overflow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_Overflow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Overflow_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_Overflow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_Overflow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Overflow_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_Overflow self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_Overflow_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_Overflow self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Overflow_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_Overflow self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_Overflow_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_Overflow self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Overflow_DecrementRefCounter(self, *args)

Handle_Standard_Overflow_swigregister = _Standard.Handle_Standard_Overflow_swigregister
Handle_Standard_Overflow_swigregister(Handle_Standard_Overflow)

def Handle_Standard_Overflow_DownCast(thing):
    return _Standard.Handle_Standard_Overflow_DownCast(thing)
Handle_Standard_Overflow_DownCast = _Standard.Handle_Standard_Overflow_DownCast

class Handle_Standard_NoMoreObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NoMoreObject self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NoMoreObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NoMoreObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NoMoreObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NoMoreObject self, Standard_NoMoreObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NoMoreObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NoMoreObject self, Handle_Standard_NoMoreObject theHandle) -> Handle_Standard_NoMoreObject
        assign(Handle_Standard_NoMoreObject self, Standard_NoMoreObject thePtr) -> Handle_Standard_NoMoreObject
        assign(Handle_Standard_NoMoreObject self, Handle_Standard_NoMoreObject theHandle) -> Handle_Standard_NoMoreObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NoMoreObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NoMoreObject self) -> Standard_NoMoreObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NoMoreObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NoMoreObject self) -> Standard_NoMoreObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NoMoreObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NoMoreObject self) -> Standard_NoMoreObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NoMoreObject___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NoMoreObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NoMoreObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NoMoreObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NoMoreObject_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NoMoreObject

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NoMoreObject self, Standard_CString const theMessage) -> Handle_Standard_NoMoreObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NoMoreObject

        """
        return _Standard.Handle_Standard_NoMoreObject_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NoMoreObject self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NoMoreObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NoMoreObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NoMoreObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NoMoreObject self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NoMoreObject_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NoMoreObject self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NoMoreObject_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NoMoreObject self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NoMoreObject_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NoMoreObject self)
        Reraise(Handle_Standard_NoMoreObject self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NoMoreObject self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NoMoreObject_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NoMoreObject self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NoMoreObject_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NoMoreObject self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NoMoreObject_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NoMoreObject self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NoMoreObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NoMoreObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NoMoreObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NoMoreObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NoMoreObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NoMoreObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NoMoreObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NoMoreObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NoMoreObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NoMoreObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NoMoreObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NoMoreObject self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NoMoreObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NoMoreObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NoMoreObject_DecrementRefCounter(self, *args)

Handle_Standard_NoMoreObject_swigregister = _Standard.Handle_Standard_NoMoreObject_swigregister
Handle_Standard_NoMoreObject_swigregister(Handle_Standard_NoMoreObject)

def Handle_Standard_NoMoreObject_DownCast(thing):
    return _Standard.Handle_Standard_NoMoreObject_DownCast(thing)
Handle_Standard_NoMoreObject_DownCast = _Standard.Handle_Standard_NoMoreObject_DownCast

class Handle_Standard_NullObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_NullObject self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_NullObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_NullObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_NullObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_NullObject self, Standard_NullObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_NullObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_NullObject self, Handle_Standard_NullObject theHandle) -> Handle_Standard_NullObject
        assign(Handle_Standard_NullObject self, Standard_NullObject thePtr) -> Handle_Standard_NullObject
        assign(Handle_Standard_NullObject self, Handle_Standard_NullObject theHandle) -> Handle_Standard_NullObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_NullObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_NullObject self) -> Standard_NullObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_NullObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_NullObject self) -> Standard_NullObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_NullObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_NullObject self) -> Standard_NullObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_NullObject___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_NullObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_NullObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_NullObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_NullObject_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_NullObject

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_NullObject self, Standard_CString const theMessage) -> Handle_Standard_NullObject

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_NullObject

        """
        return _Standard.Handle_Standard_NullObject_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_NullObject self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_NullObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NullObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_NullObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_NullObject self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_NullObject_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_NullObject self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NullObject_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_NullObject self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_NullObject_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_NullObject self)
        Reraise(Handle_Standard_NullObject self, Standard_CString const aMessage)
        Reraise(Handle_Standard_NullObject self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_NullObject_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_NullObject self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_NullObject_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_NullObject self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_NullObject_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_NullObject self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_NullObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_NullObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_NullObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NullObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_NullObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_NullObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_NullObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_NullObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_NullObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_NullObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NullObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_NullObject self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_NullObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_NullObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_NullObject_DecrementRefCounter(self, *args)

Handle_Standard_NullObject_swigregister = _Standard.Handle_Standard_NullObject_swigregister
Handle_Standard_NullObject_swigregister(Handle_Standard_NullObject)

def Handle_Standard_NullObject_DownCast(thing):
    return _Standard.Handle_Standard_NullObject_DownCast(thing)
Handle_Standard_NullObject_DownCast = _Standard.Handle_Standard_NullObject_DownCast

class Handle_Standard_DivideByZero(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_DivideByZero self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_DivideByZero_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_DivideByZero self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_DivideByZero_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_DivideByZero self, Standard_DivideByZero thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_DivideByZero_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_DivideByZero self, Handle_Standard_DivideByZero theHandle) -> Handle_Standard_DivideByZero
        assign(Handle_Standard_DivideByZero self, Standard_DivideByZero thePtr) -> Handle_Standard_DivideByZero
        assign(Handle_Standard_DivideByZero self, Handle_Standard_DivideByZero theHandle) -> Handle_Standard_DivideByZero

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_DivideByZero_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_DivideByZero self) -> Standard_DivideByZero

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_DivideByZero_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_DivideByZero self) -> Standard_DivideByZero

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_DivideByZero___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_DivideByZero self) -> Standard_DivideByZero

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_DivideByZero___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_DivideByZero___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_DivideByZero___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_DivideByZero(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_DivideByZero_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_DivideByZero

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_DivideByZero self, Standard_CString const theMessage) -> Handle_Standard_DivideByZero

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_DivideByZero

        """
        return _Standard.Handle_Standard_DivideByZero_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_DivideByZero self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_DivideByZero_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DivideByZero_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_DivideByZero_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_DivideByZero self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_DivideByZero_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_DivideByZero self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DivideByZero_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_DivideByZero self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_DivideByZero_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_DivideByZero self)
        Reraise(Handle_Standard_DivideByZero self, Standard_CString const aMessage)
        Reraise(Handle_Standard_DivideByZero self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_DivideByZero_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_DivideByZero self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_DivideByZero_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_DivideByZero self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_DivideByZero_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_DivideByZero self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_DivideByZero_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_DivideByZero self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_DivideByZero self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DivideByZero_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_DivideByZero self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_DivideByZero self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_DivideByZero_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_DivideByZero self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_DivideByZero_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_DivideByZero self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DivideByZero_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_DivideByZero self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_DivideByZero_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_DivideByZero self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_DivideByZero_DecrementRefCounter(self, *args)

Handle_Standard_DivideByZero_swigregister = _Standard.Handle_Standard_DivideByZero_swigregister
Handle_Standard_DivideByZero_swigregister(Handle_Standard_DivideByZero)

def Handle_Standard_DivideByZero_DownCast(thing):
    return _Standard.Handle_Standard_DivideByZero_DownCast(thing)
Handle_Standard_DivideByZero_DownCast = _Standard.Handle_Standard_DivideByZero_DownCast

class Standard_Persistent(Standard_Transient):
    """
    Root of "persistent" classes, a legacy support of
    object oriented databases, now outdated.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Standard_Persistent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Standard_Persistent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Standard_Persistent self) -> Standard_Persistent

        Root of "persistent" classes, a legacy support of
        object oriented databases, now outdated.
        """
        this = _Standard.new_Standard_Persistent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Standard.Standard_Persistent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Standard.Standard_Persistent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Standard_Persistent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TypeNum(self, *args):
        """
        TypeNum(Standard_Persistent self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_Persistent_TypeNum(self, *args)

    __swig_destroy__ = _Standard.delete_Standard_Persistent
Standard_Persistent_swigregister = _Standard.Standard_Persistent_swigregister
Standard_Persistent_swigregister(Standard_Persistent)

def Standard_Persistent_get_type_name(*args):
    """
    Standard_Persistent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Standard.Standard_Persistent_get_type_name(*args)

def Standard_Persistent_get_type_descriptor(*args):
    """
    Standard_Persistent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Standard.Standard_Persistent_get_type_descriptor(*args)

class Standard_ArrayStreamBuffer(object):
    """
    Custom buffer object implementing STL interface std::streambuf for streamed reading from allocated memory block.
    Implements minimal sub-set of methods for passing buffer to std::istream, including seek support.

    This class can be used for creating a seekable input stream in cases,
    when the source data does not satisfies Reader requirements (non-seekable stream, compressed data)
    or represents an in-memory resource.

    The memory itself is NOT managed by this class - it is up to the caller to ensure that passed memory pointer
    is not released during Standard_ArrayStreamBuffer lifetime.

    Usage example:
    @code
    const char*  theBuffer;
    const size_t theBufferLength;
    Standard_ArrayStreamBuffer aStreamBuffer (theBuffer, theBufferLength);
    std::istream aStream (&aStreamBuffer);
    TopoDS_Shape aShape;
    BRep_Builder aBuilder;
    BRepTools::Read (aShape, aStream, aBuilder);
    @endcode
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_ArrayStreamBuffer self, char const * theBegin, size_t const theSize) -> Standard_ArrayStreamBuffer

        Main constructor.
        Passed pointer is stored as is (memory is NOT copied nor released with destructor).
        @param theBegin pointer to the beggining of pre-allocated buffer
        @param theSize  length of pre-allocated buffer

        :type theBegin: const char *
        :type theSize: size_t

        """
        this = _Standard.new_Standard_ArrayStreamBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(Standard_ArrayStreamBuffer self, char const * theBegin, size_t const theSize)

        (Re)-initialize the stream.
        Passed pointer is stored as is (memory is NOT copied nor released with destructor).
        @param theBegin pointer to the beggining of pre-allocated buffer
        @param theSize  length of pre-allocated buffer

        :type theBegin: const char *
        :type theSize: size_t

        """
        return _Standard.Standard_ArrayStreamBuffer_Init(self, *args)


    def xsgetn(self, *args):
        """
        xsgetn(Standard_ArrayStreamBuffer self, char * thePtr, std::streamsize theCount) -> std::streamsize

        Read a bunch of bytes at once.

        :type thePtr: char *
        :type theCount: streamsize
        :rtype: streamsize

        """
        return _Standard.Standard_ArrayStreamBuffer_xsgetn(self, *args)

    __swig_destroy__ = _Standard.delete_Standard_ArrayStreamBuffer
Standard_ArrayStreamBuffer_swigregister = _Standard.Standard_ArrayStreamBuffer_swigregister
Standard_ArrayStreamBuffer_swigregister(Standard_ArrayStreamBuffer)

class Handle_Standard_Type(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_Type self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_Type_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_Type self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_Type_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_Type self, Standard_Type thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_Type_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_Type self, Handle_Standard_Type theHandle) -> Handle_Standard_Type
        assign(Handle_Standard_Type self, Standard_Type thePtr) -> Handle_Standard_Type
        assign(Handle_Standard_Type self, Handle_Standard_Type theHandle) -> Handle_Standard_Type

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_Type_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_Type self) -> Standard_Type

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_Type_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_Type self) -> Standard_Type

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_Type___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_Type self) -> Standard_Type

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_Type___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_Type___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_Type___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_Type(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_Type_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_Type

    def SystemName(self, *args):
        """
        SystemName(Handle_Standard_Type self) -> Standard_CString

        Returns the system type name of the class (typeinfo.name)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Type_SystemName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_Standard_Type self) -> Standard_CString

        Returns the given name of the class type (get_type_name)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_Type_Name(self, *args)


    def Size(self, *args):
        """
        Size(Handle_Standard_Type self) -> Standard_Size

        Returns the size of the class instance in bytes

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Standard.Handle_Standard_Type_Size(self, *args)


    def Parent(self, *args):
        """
        Returns descriptor of the base class in the hierarchy

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Type_Parent(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubType(self, *args):
        """
        SubType(Handle_Standard_Type self, Handle_Standard_Type theOther) -> Standard_Boolean
        SubType(Handle_Standard_Type self, Standard_CString const theOther) -> Standard_Boolean

        Returns True if this type is the same as theOther, or inherits from theOther.
        Note that multiple inheritance is not supported.

        :type theOther: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Type_SubType(self, *args)


    def Print(self, *args):
        """
        Print(Handle_Standard_Type self, Standard_OStream & theStream)

        Prints type (address of descriptor + name) to a stream

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_Type_Print(self, *args)


    def Register(self, *args):
        """
        Register(Handle_Standard_Type self, char const * theSystemName, char const * theName, Standard_Size theSize, Handle_Standard_Type theParent) -> Standard_Type

        Register a type; returns either new or existing descriptor.

        @param theSystemName name of the class as returned by typeid(class).name()
        @param theName name of the class to be stored in Name field
        @param theSize size of the class instance
        @param theParent base class in the Transient hierarchy

        Note that this function is intended for use by opencascade::type_instance only. 

        :type theSystemName: const char *
        :type theName: const char *
        :type theSize: int
        :type theParent: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Type

        """
        return _Standard.Handle_Standard_Type_Register(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_Type self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_Type_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Type_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_Type_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Standard_Type self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_Type_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_Type self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_Type self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Type_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_Type self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_Type self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_Type_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_Type self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_Type_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_Type self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Type_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_Type self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_Type_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_Type self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_Type_DecrementRefCounter(self, *args)

Handle_Standard_Type_swigregister = _Standard.Handle_Standard_Type_swigregister
Handle_Standard_Type_swigregister(Handle_Standard_Type)

def Handle_Standard_Type_DownCast(thing):
    return _Standard.Handle_Standard_Type_DownCast(thing)
Handle_Standard_Type_DownCast = _Standard.Handle_Standard_Type_DownCast

class Handle_Standard_ProgramError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_ProgramError self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_ProgramError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_ProgramError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_ProgramError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_ProgramError self, Standard_ProgramError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_ProgramError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_ProgramError self, Handle_Standard_ProgramError theHandle) -> Handle_Standard_ProgramError
        assign(Handle_Standard_ProgramError self, Standard_ProgramError thePtr) -> Handle_Standard_ProgramError
        assign(Handle_Standard_ProgramError self, Handle_Standard_ProgramError theHandle) -> Handle_Standard_ProgramError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_ProgramError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_ProgramError self) -> Standard_ProgramError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_ProgramError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_ProgramError self) -> Standard_ProgramError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_ProgramError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_ProgramError self) -> Standard_ProgramError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_ProgramError___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_ProgramError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_ProgramError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_ProgramError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_ProgramError_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_ProgramError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_ProgramError self, Standard_CString const theMessage) -> Handle_Standard_ProgramError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_ProgramError

        """
        return _Standard.Handle_Standard_ProgramError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_ProgramError self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_ProgramError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_ProgramError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_ProgramError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_ProgramError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_ProgramError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_ProgramError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_ProgramError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_ProgramError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_ProgramError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_ProgramError self)
        Reraise(Handle_Standard_ProgramError self, Standard_CString const aMessage)
        Reraise(Handle_Standard_ProgramError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_ProgramError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_ProgramError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_ProgramError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_ProgramError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_ProgramError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_ProgramError self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_ProgramError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_ProgramError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_ProgramError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_ProgramError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_ProgramError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_ProgramError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_ProgramError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_ProgramError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_ProgramError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_ProgramError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_ProgramError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_ProgramError self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_ProgramError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_ProgramError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_ProgramError_DecrementRefCounter(self, *args)

Handle_Standard_ProgramError_swigregister = _Standard.Handle_Standard_ProgramError_swigregister
Handle_Standard_ProgramError_swigregister(Handle_Standard_ProgramError)

def Handle_Standard_ProgramError_DownCast(thing):
    return _Standard.Handle_Standard_ProgramError_DownCast(thing)
Handle_Standard_ProgramError_DownCast = _Standard.Handle_Standard_ProgramError_DownCast

class Standard_MMgrTBBalloc(Standard_MMgrRoot):
    """
    Implementation of OCC memory manager which uses Intel TBB
    scalable allocator.

    On configurations where TBB is not available standard RTL functions 
    malloc() / free() are used.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_MMgrTBBalloc self, Standard_Boolean const aClear) -> Standard_MMgrTBBalloc

        Constructor; if aClear is True, the memory will be nullified
        upon allocation.

        :type aClear: bool

        """
        this = _Standard.new_Standard_MMgrTBBalloc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Allocate(self, *args):
        """
        Allocate(Standard_MMgrTBBalloc self, Standard_Size const aSize) -> Standard_Address

        Allocate aSize bytes 

        :type aSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrTBBalloc_Allocate(self, *args)


    def Reallocate(self, *args):
        """
        Reallocate(Standard_MMgrTBBalloc self, Standard_Address thePtr, Standard_Size const theSize) -> Standard_Address

        Reallocate aPtr to the size aSize. 
        The new pointer is returned.

        :type thePtr: OCC.wrapper.Standard.Standard_Address
        :type theSize: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrTBBalloc_Reallocate(self, *args)


    def Free(self, *args):
        """
        Free(Standard_MMgrTBBalloc self, Standard_Address thePtr)

        Free allocated memory

        :type thePtr: OCC.wrapper.Standard.Standard_Address

        """
        return _Standard.Standard_MMgrTBBalloc_Free(self, *args)

    __swig_destroy__ = _Standard.delete_Standard_MMgrTBBalloc
Standard_MMgrTBBalloc_swigregister = _Standard.Standard_MMgrTBBalloc_swigregister
Standard_MMgrTBBalloc_swigregister(Standard_MMgrTBBalloc)

class Handle_Standard_AbortiveTransaction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_AbortiveTransaction self)

        Nullify the handle


        """
        return _Standard.Handle_Standard_AbortiveTransaction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_AbortiveTransaction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Standard.Handle_Standard_AbortiveTransaction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_AbortiveTransaction self, Standard_AbortiveTransaction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Standard.Handle_Standard_AbortiveTransaction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_AbortiveTransaction self, Handle_Standard_AbortiveTransaction theHandle) -> Handle_Standard_AbortiveTransaction
        assign(Handle_Standard_AbortiveTransaction self, Standard_AbortiveTransaction thePtr) -> Handle_Standard_AbortiveTransaction
        assign(Handle_Standard_AbortiveTransaction self, Handle_Standard_AbortiveTransaction theHandle) -> Handle_Standard_AbortiveTransaction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Standard.Handle_Standard_AbortiveTransaction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_AbortiveTransaction self) -> Standard_AbortiveTransaction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Standard.Handle_Standard_AbortiveTransaction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_AbortiveTransaction self) -> Standard_AbortiveTransaction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Standard.Handle_Standard_AbortiveTransaction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_AbortiveTransaction self) -> Standard_AbortiveTransaction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Standard.Handle_Standard_AbortiveTransaction___ref__(self, *args)


    def __hash__(self):
        return _Standard.Handle_Standard_AbortiveTransaction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Standard.Handle_Standard_AbortiveTransaction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Standard.new_Handle_Standard_AbortiveTransaction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Standard.Handle_Standard_AbortiveTransaction_DownCast)
    __swig_destroy__ = _Standard.delete_Handle_Standard_AbortiveTransaction

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Standard_AbortiveTransaction self, Standard_CString const theMessage) -> Handle_Standard_AbortiveTransaction

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_AbortiveTransaction

        """
        return _Standard.Handle_Standard_AbortiveTransaction_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_AbortiveTransaction self) -> char const *

        :rtype: const char *

        """
        return _Standard.Handle_Standard_AbortiveTransaction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_AbortiveTransaction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Standard.Handle_Standard_AbortiveTransaction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Standard_AbortiveTransaction self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Handle_Standard_AbortiveTransaction_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Standard_AbortiveTransaction self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_AbortiveTransaction_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Standard_AbortiveTransaction self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Standard.Handle_Standard_AbortiveTransaction_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Standard_AbortiveTransaction self)
        Reraise(Handle_Standard_AbortiveTransaction self, Standard_CString const aMessage)
        Reraise(Handle_Standard_AbortiveTransaction self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Standard.Handle_Standard_AbortiveTransaction_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Standard_AbortiveTransaction self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Standard.Handle_Standard_AbortiveTransaction_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Standard_AbortiveTransaction self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Standard.Handle_Standard_AbortiveTransaction_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_AbortiveTransaction self)

        Memory deallocator for transient classes


        """
        return _Standard.Handle_Standard_AbortiveTransaction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_AbortiveTransaction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_AbortiveTransaction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_AbortiveTransaction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_AbortiveTransaction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_AbortiveTransaction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Handle_Standard_AbortiveTransaction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_AbortiveTransaction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Standard.Handle_Standard_AbortiveTransaction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_AbortiveTransaction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_AbortiveTransaction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_AbortiveTransaction self)

        Increments the reference counter of this object


        """
        return _Standard.Handle_Standard_AbortiveTransaction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_AbortiveTransaction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Handle_Standard_AbortiveTransaction_DecrementRefCounter(self, *args)

Handle_Standard_AbortiveTransaction_swigregister = _Standard.Handle_Standard_AbortiveTransaction_swigregister
Handle_Standard_AbortiveTransaction_swigregister(Handle_Standard_AbortiveTransaction)

def Handle_Standard_AbortiveTransaction_DownCast(thing):
    return _Standard.Handle_Standard_AbortiveTransaction_DownCast(thing)
Handle_Standard_AbortiveTransaction_DownCast = _Standard.Handle_Standard_AbortiveTransaction_DownCast

class Standard_GUID(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Standard_GUID self) -> Standard_GUID
        __init__(Standard_GUID self, Standard_CString const aGuid) -> Standard_GUID
        __init__(Standard_GUID self, Standard_ExtString const aGuid) -> Standard_GUID
        __init__(Standard_GUID self, Standard_Integer const a32b, Standard_ExtCharacter const a16b1, Standard_ExtCharacter const a16b2, Standard_ExtCharacter const a16b3, Standard_Byte const a8b1, Standard_Byte const a8b2, Standard_Byte const a8b3, Standard_Byte const a8b4, Standard_Byte const a8b5, Standard_Byte const a8b6) -> Standard_GUID
        __init__(Standard_GUID self, Standard_UUID const & aGuid) -> Standard_GUID
        __init__(Standard_GUID self, Standard_GUID aGuid) -> Standard_GUID

        :type aGuid: OCC.wrapper.Standard.Standard_GUID

        """
        this = _Standard.new_Standard_GUID(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ToUUID(self, *args):
        """
        ToUUID(Standard_GUID self) -> Standard_UUID

        :rtype: OCC.wrapper.Standard.Standard_UUID

        """
        return _Standard.Standard_GUID_ToUUID(self, *args)


    def ToCString(self, *args):
        """
        ToCString(Standard_GUID self, Standard_PCharacter const aStrGuid)

        translate the GUID into ascii string
        the aStrGuid is allocated by user.
        the guid have the following format:

        "00000000-0000-0000-0000-000000000000"

        :type aStrGuid: OCC.wrapper.Standard.Standard_PCharacter

        """
        return _Standard.Standard_GUID_ToCString(self, *args)


    def ToExtString(self, *args):
        """
        ToExtString(Standard_GUID self, Standard_PExtCharacter const aStrGuid)

        translate the GUID into unicode string
        the aStrGuid is allocated by user.
        the guid have the following format:

        "00000000-0000-0000-0000-000000000000"

        :type aStrGuid: OCC.wrapper.Standard.Standard_PExtCharacter

        """
        return _Standard.Standard_GUID_ToExtString(self, *args)


    def IsSame(self, *args):
        """
        IsSame(Standard_GUID self, Standard_GUID uid) -> Standard_Boolean

        :type uid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_GUID_IsSame(self, *args)


    def __eq__(self, *args):
        """
        __eq__(Standard_GUID self, Standard_GUID uid) -> Standard_Boolean

        :type uid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_GUID___eq__(self, *args)


    def IsNotSame(self, *args):
        """
        IsNotSame(Standard_GUID self, Standard_GUID uid) -> Standard_Boolean

        :type uid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_GUID_IsNotSame(self, *args)


    def __ne__(self, *args):
        """
        __ne__(Standard_GUID self, Standard_GUID uid) -> Standard_Boolean

        :type uid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_GUID___ne__(self, *args)


    def Assign(self, *args):
        """
        Assign(Standard_GUID self, Standard_GUID uid)
        Assign(Standard_GUID self, Standard_UUID const & uid)

        :type uid: OCC.wrapper.Standard.Standard_UUID

        """
        return _Standard.Standard_GUID_Assign(self, *args)


    def assign(self, *args):
        """
        assign(Standard_GUID self, Standard_GUID uid)
        assign(Standard_GUID self, Standard_UUID const & uid)

        :type uid: OCC.wrapper.Standard.Standard_UUID

        """
        return _Standard.Standard_GUID_assign(self, *args)


    def ShallowDump(self, *args):
        """
        ShallowDump(Standard_GUID self, Standard_OStream & aStream)

        Display the GUID with the following format:

        "00000000-0000-0000-0000-000000000000"

        :type aStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _Standard.Standard_GUID_ShallowDump(self, *args)


    def CheckGUIDFormat(*args):
        """
        CheckGUIDFormat(Standard_CString const aGuid) -> Standard_Boolean

        Check the format of a GUID string.
        It checks the size, the position of the '-' and the correct size of fields.

        :type aGuid: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_GUID_CheckGUIDFormat(*args)

    CheckGUIDFormat = staticmethod(CheckGUIDFormat)

    def Hash(self, *args):
        """
        Hash(Standard_GUID self, Standard_Integer const Upper) -> Standard_Integer

        Hash function for GUID.

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_GUID_Hash(self, *args)


    def HashCode(*args):
        """
        HashCode(Standard_GUID aguid, Standard_Integer const Upper) -> Standard_Integer

        H method used by collections.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Standard.Standard_GUID_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Standard_GUID string1, Standard_GUID string2) -> Standard_Boolean

        Returns True  when the two GUID are the same.

        :type string1: OCC.wrapper.Standard.Standard_GUID
        :type string2: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Standard.Standard_GUID_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)
    __swig_destroy__ = _Standard.delete_Standard_GUID
Standard_GUID_swigregister = _Standard.Standard_GUID_swigregister
Standard_GUID_swigregister(Standard_GUID)

def Standard_GUID_CheckGUIDFormat(*args):
    """
    Standard_GUID_CheckGUIDFormat(Standard_CString const aGuid) -> Standard_Boolean

    Check the format of a GUID string.
    It checks the size, the position of the '-' and the correct size of fields.

    :type aGuid: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Standard.Standard_GUID_CheckGUIDFormat(*args)

def Standard_GUID_HashCode(*args):
    """
    Standard_GUID_HashCode(Standard_GUID aguid, Standard_Integer const Upper) -> Standard_Integer

    H method used by collections.

    :type aguid: OCC.wrapper.Standard.Standard_GUID
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Standard.Standard_GUID_HashCode(*args)

def Standard_GUID_IsEqual(*args):
    """
    Standard_GUID_IsEqual(Standard_GUID string1, Standard_GUID string2) -> Standard_Boolean

    Returns True  when the two GUID are the same.

    :type string1: OCC.wrapper.Standard.Standard_GUID
    :type string2: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Standard.Standard_GUID_IsEqual(*args)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GProp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GProp')
    _GProp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GProp', [dirname(__file__)])
        except ImportError:
            import _GProp
            return _GProp
        try:
            _mod = imp.load_module('_GProp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GProp = swig_import_helper()
    del swig_import_helper
else:
    import _GProp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GProp.delete_SwigPyIterator

    def value(self):
        return _GProp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GProp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GProp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GProp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GProp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GProp.SwigPyIterator_copy(self)

    def next(self):
        return _GProp.SwigPyIterator_next(self)

    def __next__(self):
        return _GProp.SwigPyIterator___next__(self)

    def previous(self):
        return _GProp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GProp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GProp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GProp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GProp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GProp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GProp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GProp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GProp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GProp.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GProp.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GProp.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GProp.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GProp.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GProp.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GProp.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GProp.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GProp.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GProp.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GProp.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GProp.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GProp.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GProp.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GProp.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GProp.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GProp.ptr_to_number(item)
ptr_to_number = _GProp.ptr_to_number

def HashCode(*args):
    return _GProp.HashCode(*args)
HashCode = _GProp.HashCode

def ptr_equal(a, b):
    return _GProp.ptr_equal(a, b)
ptr_equal = _GProp.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
GProp_Plane = _GProp.GProp_Plane
GProp_Line = _GProp.GProp_Line
GProp_Point = _GProp.GProp_Point
GProp_Space = _GProp.GProp_Space
GProp_None = _GProp.GProp_None
GProp_Mass = _GProp.GProp_Mass
GProp_CenterMassX = _GProp.GProp_CenterMassX
GProp_CenterMassY = _GProp.GProp_CenterMassY
GProp_CenterMassZ = _GProp.GProp_CenterMassZ
GProp_InertiaXX = _GProp.GProp_InertiaXX
GProp_InertiaYY = _GProp.GProp_InertiaYY
GProp_InertiaZZ = _GProp.GProp_InertiaZZ
GProp_InertiaXY = _GProp.GProp_InertiaXY
GProp_InertiaXZ = _GProp.GProp_InertiaXZ
GProp_InertiaYZ = _GProp.GProp_InertiaYZ
GProp_Unknown = _GProp.GProp_Unknown
class GProp_UndefinedAxis(Standard.Standard_DomainError):
    """
    This exception is raised when a method makes reference to
    an undefined inertia axis of symmetry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GProp_UndefinedAxis
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GProp_UndefinedAxis(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GProp_UndefinedAxis self) -> GProp_UndefinedAxis
        __init__(GProp_UndefinedAxis self, Standard_CString const theMessage) -> GProp_UndefinedAxis

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _GProp.new_GProp_UndefinedAxis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_GProp_UndefinedAxis

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.GProp.Handle_GProp_UndefinedAxis

        """
        return _GProp.GProp_UndefinedAxis_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GProp.GProp_UndefinedAxis_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GProp.GProp_UndefinedAxis_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GProp.GProp_UndefinedAxis_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GProp.delete_GProp_UndefinedAxis
GProp_UndefinedAxis_swigregister = _GProp.GProp_UndefinedAxis_swigregister
GProp_UndefinedAxis_swigregister(GProp_UndefinedAxis)

def GProp_UndefinedAxis_NewInstance(*args):
    """
    GProp_UndefinedAxis_NewInstance(Standard_CString const theMessage) -> Handle_GProp_UndefinedAxis

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.GProp.Handle_GProp_UndefinedAxis

    """
    return _GProp.GProp_UndefinedAxis_NewInstance(*args)

def GProp_UndefinedAxis_get_type_name(*args):
    """
    GProp_UndefinedAxis_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GProp.GProp_UndefinedAxis_get_type_name(*args)

def GProp_UndefinedAxis_get_type_descriptor(*args):
    """
    GProp_UndefinedAxis_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GProp.GProp_UndefinedAxis_get_type_descriptor(*args)

class GProp_PEquation(object):
    """
    A framework to analyze a collection - or cloud
    - of points and to verify if they are coincident,
    collinear or coplanar within a given precision. If
    so, it also computes the mean point, the mean
    line or the mean plane of the points. If not, it
    computes the minimal box which includes all the points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GProp_PEquation self, NCollection_Array1_gp_Pnt Pnts, Standard_Real const Tol) -> GProp_PEquation

        Constructs a framework to analyze the
        collection of points Pnts and computes:
        -   the mean point if the points in question are
        considered to be coincident within the precision Tol, or
        -   the mean line if they are considered to be
        collinear within the precision Tol, or
        -   the mean plane if they are considered to be
        coplanar within the precision Tol, or
        -   the minimal box which contains all the points. Use :
        -   the functions IsPoint, IsLinear, IsPlanar
        and IsSpace to find the result of the analysis, and
        -   the function Point, Line, Plane or Box to
        access the computed result.

        :type Pnts: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Tol: float

        """
        this = _GProp.new_GProp_PEquation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsPlanar(self, *args):
        """
        IsPlanar(GProp_PEquation self) -> Standard_Boolean

        Returns true if, according to the given
        tolerance, the points analyzed by this framework are  coplanar.
        Use the function  Plane  to access the computed result.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.GProp_PEquation_IsPlanar(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(GProp_PEquation self) -> Standard_Boolean

        Returns true if, according to the given
        tolerance, the points analyzed by this framework are  colinear.
        Use the function  Line  to access the computed result.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.GProp_PEquation_IsLinear(self, *args)


    def IsPoint(self, *args):
        """
        IsPoint(GProp_PEquation self) -> Standard_Boolean

        Returns true if, according to the given
        tolerance, the points analyzed by this framework are  coincident.
        Use the function  Point  to access the computed result.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.GProp_PEquation_IsPoint(self, *args)


    def IsSpace(self, *args):
        """
        IsSpace(GProp_PEquation self) -> Standard_Boolean

        Returns true if, according to the given
        tolerance value, the points analyzed by this
        framework are neither coincident, nor collinear, nor coplanar.
        Use the function Box to query the smallest box
        that includes the collection of points.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.GProp_PEquation_IsSpace(self, *args)


    def Plane(self, *args):
        """
        Plane(GProp_PEquation self) -> gp_Pln

        Returns the mean plane passing near all the
        points analyzed by this framework if, according
        to the given precision, the points are considered to be coplanar.
        Exceptions
        Standard_NoSuchObject if, according to the
        given precision value, the points analyzed by
        this framework are considered to be:
        -   coincident, or
        -   collinear, or
        -   not coplanar.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _GProp.GProp_PEquation_Plane(self, *args)


    def Line(self, *args):
        """
        Line(GProp_PEquation self) -> gp_Lin

        Returns the mean line passing near all the
        points analyzed by this framework if, according
        to the given precision value, the points are considered to be collinear.
        Exceptions
        Standard_NoSuchObject if, according to the
        given precision, the points analyzed by this
        framework are considered to be:
        -   coincident, or
        -   not collinear.

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _GProp.GProp_PEquation_Line(self, *args)


    def Point(self, *args):
        """
        Point(GProp_PEquation self) -> gp_Pnt

        Returns the mean point of all the points
        analyzed by this framework if, according to the
        given precision, the points are considered to be coincident.
        Exceptions
        Standard_NoSuchObject if, according to the
        given precision, the points analyzed by this
        framework are not considered to be coincident.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GProp.GProp_PEquation_Point(self, *args)


    def Box(self, *args):
        """
        Box(GProp_PEquation self, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the definition of the smallest box which
        contains all the points analyzed by this
        framework if, according to the given precision
        value, the points are considered to be neither
        coincident, nor collinear and nor coplanar.
        This box is centered on the barycenter P of the
        collection of points. Its sides are parallel to the
        three vectors V1, V2 and V3, the length of
        which is the length of the box in the corresponding direction.
        Note: Vectors V1, V2 and V3 are parallel to
        the three axes of principal inertia of the system
        composed of the collection of points where each point is of equal mass.
        Exceptions
        Standard_NoSuchObject if, according to the given precision,
        the points analyzed by this framework are considered to be coincident, collinear or coplanar.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _GProp.GProp_PEquation_Box(self, *args)

    __swig_destroy__ = _GProp.delete_GProp_PEquation
GProp_PEquation_swigregister = _GProp.GProp_PEquation_swigregister
GProp_PEquation_swigregister(GProp_PEquation)

class GProp_GProps(object):
    """
    Implements a general mechanism to compute the global properties of
    a "compound geometric system" in 3d space    by composition of the
    global properties of "elementary geometric entities"       such as
    (curve, surface, solid, set of points).  It is possible to compose
    the properties of several "compound geometric systems" too.

    To computes the global properties of a compound geometric
    system you should :
    . declare the GProps using a constructor which initializes the
    GProps and defines the location point used to compute the inertia
    . compose the global properties of your geometric components with
    the properties of your system using the method Add.

    To compute the global properties of the geometric components of
    the system you should  use the services of the following classes :
    - class PGProps for a set of points,
    - class CGProps for a curve,
    - class SGProps for a surface,
    - class VGProps for a "solid".
    The classes CGProps, SGProps, VGProps are generic classes and
    must be instantiated for your application.

    The global properties computed are :
    - the dimension (length, area or volume)
    - the mass,
    - the centre of mass,
    - the moments of inertia (static moments and quadratic moments),
    - the moment about an axis,
    - the radius of gyration about an axis,
    - the principal properties of inertia  :
    (sea also class PrincipalProps)
    . the principal moments,
    . the principal axis of inertia,
    . the principal radius of gyration,

    Example of utilisation in a simplified C++ implementation :

    //declares the GProps, the point (0.0, 0.0, 0.0) of the
    //absolute cartesian coordinate system is used as
    //default reference point to compute the centre of mass
    GProp_GProps System ();

    //computes the inertia of a 3d curve
    Your_CGProps Component1 (curve, ....);

    //computes the inertia of surfaces
    Your_SGprops Component2 (surface1, ....);
    Your_SGprops Component3 (surface2,....);

    //composes the global properties of components 1, 2, 3
    //a density can be associated with the components, the
    //density can be defaulted to 1.
    Real Density1 = 2.0;
    Real Density2 = 3.0;
    System.Add (Component1, Density1);
    System.Add (Component2, Density2);
    System.Add (Component3);

    //returns the centre of mass of the system in the
    //absolute cartesian coordinate system
    gp_Pnt G = System.CentreOfMass ();

    //computes the principales inertia of the system
    GProp_PrincipalProps Pp  = System.PrincipalProperties();

    //returns the principal moments and radius of gyration
    Real Ixx, Iyy, Izz, Rxx, Ryy, Rzz;
    Pp.Moments (Ixx, Iyy, Izz);
    Pp.RadiusOfGyration (Ixx, Iyy, Izz);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GProp_GProps self) -> GProp_GProps
        __init__(GProp_GProps self, gp_Pnt SystemLocation) -> GProp_GProps

        The point SystemLocation is used to compute the gobal properties
        of the system. For more accuracy it is better to define this
        point closed to the location of the system. For example it could
        be a point around the centre of mass of the system.
        This point is referred to as the reference point for
        this framework. For greater accuracy it is better for
        the reference point to be close to the location of the
        system. It can, for example, be a point near the
        center of mass of the system.
        At initialization, the framework is empty; i.e. it
        retains no dimensional information such as mass, or
        inertia. However, it is now able to bring together
        global properties of various other systems, whose
        global properties have already been computed
        using another framework. To do this, use the
        function Add to define the components of the
        system. Use it once per component of the system,
        and then use the interrogation functions available to
        access the computed values.

        :type SystemLocation: OCC.wrapper.gp.gp_Pnt

        """
        this = _GProp.new_GProp_GProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(GProp_GProps self, GProp_GProps Item, Standard_Real const Density=1.0)

        Either
        - initializes the global properties retained by this
        framework from those retained by the framework Item, or
        - brings together the global properties still retained by
        this framework with those retained by the framework Item.
        The value Density, which is 1.0 by default, is used as
        the density of the system analysed by Item.
        Sometimes the density will have already been given at
        the time of construction of the framework Item. This
        may be the case for example, if Item is a
        GProp_PGProps framework built to compute the
        global properties of a set of points ; or another
        GProp_GProps object which already retains
        composite global properties. In these cases the real
        density was perhaps already taken into account at the
        time of construction of Item. Note that this is not
        checked: if the density of parts of the system is taken
        into account two or more times, results of the
        computation will be false.
        Notes :
        - The point relative to which the inertia of Item is
        computed (i.e. the reference point of Item) may be
        different from the reference point in this
        framework. Huygens' theorem is applied
        automatically to transfer inertia values to the
        reference point in this framework.
        - The function Add is used once per component of
        the system. After that, you use the interrogation
        functions available to access values computed for the system.
        - The system whose global properties are already
        brought together by this framework is referred to
        as the current system. However, the current system
        is not retained by this framework, which maintains
        only its global properties.
        Exceptions
        Standard_DomainError if Density is less than or
        equal to gp::Resolution().

        :type Item: OCC.wrapper.GProp.GProp_GProps
        :type Density: float

        """
        return _GProp.GProp_GProps_Add(self, *args)


    def Mass(self, *args):
        """
        Mass(GProp_GProps self) -> Standard_Real

        Returns the mass of the current system.
        If no density is attached to the components of the
        current system the returned value corresponds to :
        - the total length of the edges of the current
        system if this framework retains only linear
        properties, as is the case for example, when
        using only the LinearProperties function to
        combine properties of lines from shapes, or
        - the total area of the faces of the current system if
        this framework retains only surface properties,
        as is the case for example, when using only the
        SurfaceProperties function to combine
        properties of surfaces from shapes, or
        - the total volume of the solids of the current
        system if this framework retains only volume
        properties, as is the case for example, when
        using only the VolumeProperties function to
        combine properties of volumes from solids.
        Warning
        A length, an area, or a volume is computed in the
        current data unit system. The mass of a single
        object is obtained by multiplying its length, its area
        or its volume by the given density. You must be
        consistent with respect to the units used.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GProp.GProp_GProps_Mass(self, *args)


    def CentreOfMass(self, *args):
        """
        CentreOfMass(GProp_GProps self) -> gp_Pnt

        Returns the center of mass of the current system. If
        the gravitational field is uniform, it is the center of gravity.
        The coordinates returned for the center of mass are
        expressed in the absolute Cartesian coordinate system.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GProp.GProp_GProps_CentreOfMass(self, *args)


    def MatrixOfInertia(self, *args):
        """
        MatrixOfInertia(GProp_GProps self) -> gp_Mat

        returns the matrix of inertia. It is a symmetrical matrix.
        The coefficients of the matrix are the quadratic moments of
        inertia.

        | Ixx  Ixy  Ixz |
        matrix =    | Ixy  Iyy  Iyz |
        | Ixz  Iyz  Izz |

        The moments of inertia are denoted by Ixx, Iyy, Izz.
        The products of inertia are denoted by Ixy, Ixz, Iyz.
        The matrix of inertia is returned in the central coordinate
        system (G, Gx, Gy, Gz) where G is the centre of mass of the
        system and Gx, Gy, Gz the directions parallel to the X(1,0,0)
        Y(0,1,0) Z(0,0,1) directions of the absolute cartesian
        coordinate system. It is possible to compute the matrix of
        inertia at another location point using the Huyghens theorem
        (you can use the method of package GProp : HOperator).

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _GProp.GProp_GProps_MatrixOfInertia(self, *args)


    def StaticMoments(self, *args):
        """
        StaticMoments(GProp_GProps self)

        Returns Ix, Iy, Iz, the static moments of inertia of the
        current system; i.e. the moments of inertia about the
        three axes of the Cartesian coordinate system.

        :type Ix: float
        :type Iy: float
        :type Iz: float

        """
        return _GProp.GProp_GProps_StaticMoments(self, *args)


    def MomentOfInertia(self, *args):
        """
        MomentOfInertia(GProp_GProps self, gp_Ax1 A) -> Standard_Real

        computes the moment of inertia of the material system about the
        axis A.

        :type A: OCC.wrapper.gp.gp_Ax1
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GProp.GProp_GProps_MomentOfInertia(self, *args)


    def PrincipalProperties(self, *args):
        """
        PrincipalProperties(GProp_GProps self) -> GProp_PrincipalProps

        Computes the principal properties of inertia of the current system.
        There is always a set of axes for which the products
        of inertia of a geometric system are equal to 0; i.e. the
        matrix of inertia of the system is diagonal. These axes
        are the principal axes of inertia. Their origin is
        coincident with the center of mass of the system. The
        associated moments are called the principal moments of inertia.
        This function computes the eigen values and the
        eigen vectors of the matrix of inertia of the system.
        Results are stored by using a presentation framework
        of principal properties of inertia
        (GProp_PrincipalProps object) which may be
        queried to access the value sought.

        :rtype: OCC.wrapper.GProp.GProp_PrincipalProps

        """
        return _GProp.GProp_GProps_PrincipalProperties(self, *args)


    def RadiusOfGyration(self, *args):
        """
        RadiusOfGyration(GProp_GProps self, gp_Ax1 A) -> Standard_Real

        Returns the radius of gyration of the current system about the axis A.

        :type A: OCC.wrapper.gp.gp_Ax1
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GProp.GProp_GProps_RadiusOfGyration(self, *args)

    __swig_destroy__ = _GProp.delete_GProp_GProps
GProp_GProps_swigregister = _GProp.GProp_GProps_swigregister
GProp_GProps_swigregister(GProp_GProps)

class GProp_SelGProps(GProp_GProps):
    """
    Computes the global properties of a bounded
    elementary surface in 3d (surface of the gp package)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GProp_SelGProps self) -> GProp_SelGProps
        __init__(GProp_SelGProps self, gp_Cylinder S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2, gp_Pnt SLocation) -> GProp_SelGProps
        __init__(GProp_SelGProps self, gp_Cone S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2, gp_Pnt SLocation) -> GProp_SelGProps
        __init__(GProp_SelGProps self, gp_Sphere S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2, gp_Pnt SLocation) -> GProp_SelGProps
        __init__(GProp_SelGProps self, gp_Torus S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2, gp_Pnt SLocation) -> GProp_SelGProps

        :type S: OCC.wrapper.gp.gp_Torus
        :type Teta1: float
        :type Teta2: float
        :type Alpha1: float
        :type Alpha2: float
        :type SLocation: OCC.wrapper.gp.gp_Pnt

        """
        this = _GProp.new_GProp_SelGProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(GProp_SelGProps self, gp_Pnt SLocation)

        :type SLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _GProp.GProp_SelGProps_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(GProp_SelGProps self, gp_Cylinder S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2)
        Perform(GProp_SelGProps self, gp_Cone S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2)
        Perform(GProp_SelGProps self, gp_Sphere S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2)
        Perform(GProp_SelGProps self, gp_Torus S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2)

        :type S: OCC.wrapper.gp.gp_Torus
        :type Teta1: float
        :type Teta2: float
        :type Alpha1: float
        :type Alpha2: float

        """
        return _GProp.GProp_SelGProps_Perform(self, *args)

    __swig_destroy__ = _GProp.delete_GProp_SelGProps
GProp_SelGProps_swigregister = _GProp.GProp_SelGProps_swigregister
GProp_SelGProps_swigregister(GProp_SelGProps)

class Handle_GProp_UndefinedAxis(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GProp_UndefinedAxis self)

        Nullify the handle


        """
        return _GProp.Handle_GProp_UndefinedAxis_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GProp_UndefinedAxis self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GProp.Handle_GProp_UndefinedAxis_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GProp_UndefinedAxis self, GProp_UndefinedAxis thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GProp.Handle_GProp_UndefinedAxis_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GProp_UndefinedAxis self, Handle_GProp_UndefinedAxis theHandle) -> Handle_GProp_UndefinedAxis
        assign(Handle_GProp_UndefinedAxis self, GProp_UndefinedAxis thePtr) -> Handle_GProp_UndefinedAxis
        assign(Handle_GProp_UndefinedAxis self, Handle_GProp_UndefinedAxis theHandle) -> Handle_GProp_UndefinedAxis

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GProp.Handle_GProp_UndefinedAxis_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GProp_UndefinedAxis self) -> GProp_UndefinedAxis

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GProp.Handle_GProp_UndefinedAxis_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GProp_UndefinedAxis self) -> GProp_UndefinedAxis

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GProp.Handle_GProp_UndefinedAxis___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GProp_UndefinedAxis self) -> GProp_UndefinedAxis

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GProp.Handle_GProp_UndefinedAxis___ref__(self, *args)


    def __hash__(self):
        return _GProp.Handle_GProp_UndefinedAxis___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GProp.Handle_GProp_UndefinedAxis___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GProp.new_Handle_GProp_UndefinedAxis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GProp.Handle_GProp_UndefinedAxis_DownCast)
    __swig_destroy__ = _GProp.delete_Handle_GProp_UndefinedAxis

    def NewInstance(self, *args):
        """
        NewInstance(Handle_GProp_UndefinedAxis self, Standard_CString const theMessage) -> Handle_GProp_UndefinedAxis

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.GProp.Handle_GProp_UndefinedAxis

        """
        return _GProp.Handle_GProp_UndefinedAxis_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GProp_UndefinedAxis self) -> char const *

        :rtype: const char *

        """
        return _GProp.Handle_GProp_UndefinedAxis_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GProp.Handle_GProp_UndefinedAxis_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GProp.Handle_GProp_UndefinedAxis_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_GProp_UndefinedAxis self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _GProp.Handle_GProp_UndefinedAxis_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_GProp_UndefinedAxis self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _GProp.Handle_GProp_UndefinedAxis_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_GProp_UndefinedAxis self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _GProp.Handle_GProp_UndefinedAxis_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_GProp_UndefinedAxis self)
        Reraise(Handle_GProp_UndefinedAxis self, Standard_CString const aMessage)
        Reraise(Handle_GProp_UndefinedAxis self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _GProp.Handle_GProp_UndefinedAxis_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_GProp_UndefinedAxis self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _GProp.Handle_GProp_UndefinedAxis_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_GProp_UndefinedAxis self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _GProp.Handle_GProp_UndefinedAxis_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GProp_UndefinedAxis self)

        Memory deallocator for transient classes


        """
        return _GProp.Handle_GProp_UndefinedAxis_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GProp_UndefinedAxis self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GProp_UndefinedAxis self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.Handle_GProp_UndefinedAxis_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GProp_UndefinedAxis self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GProp_UndefinedAxis self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.Handle_GProp_UndefinedAxis_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GProp_UndefinedAxis self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GProp.Handle_GProp_UndefinedAxis_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GProp_UndefinedAxis self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GProp.Handle_GProp_UndefinedAxis_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GProp_UndefinedAxis self)

        Increments the reference counter of this object


        """
        return _GProp.Handle_GProp_UndefinedAxis_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GProp_UndefinedAxis self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GProp.Handle_GProp_UndefinedAxis_DecrementRefCounter(self, *args)

Handle_GProp_UndefinedAxis_swigregister = _GProp.Handle_GProp_UndefinedAxis_swigregister
Handle_GProp_UndefinedAxis_swigregister(Handle_GProp_UndefinedAxis)

def Handle_GProp_UndefinedAxis_DownCast(thing):
    return _GProp.Handle_GProp_UndefinedAxis_DownCast(thing)
Handle_GProp_UndefinedAxis_DownCast = _GProp.Handle_GProp_UndefinedAxis_DownCast

class GProp_PrincipalProps(object):
    """
    A framework to present the principal properties of
    inertia of a system of which global properties are
    computed by a GProp_GProps object.
    There is always a set of axes for which the
    products of inertia of a geometric system are equal
    to 0; i.e. the matrix of inertia of the system is
    diagonal. These axes are the principal axes of
    inertia. Their origin is coincident with the center of
    mass of the system. The associated moments are
    called the principal moments of inertia.
    This sort of presentation object is created, filled and
    returned by the function PrincipalProperties for
    any GProp_GProps object, and can be queried to access the result.
    Note: The system whose principal properties of
    inertia are returned by this framework is referred to
    as the current system. The current system,
    however, is retained neither by this presentation
    framework nor by the GProp_GProps object which activates it.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GProp_PrincipalProps self) -> GProp_PrincipalProps

        creates an undefined PrincipalProps.


        """
        this = _GProp.new_GProp_PrincipalProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def HasSymmetryAxis(self, *args):
        """
        HasSymmetryAxis(GProp_PrincipalProps self) -> Standard_Boolean
        HasSymmetryAxis(GProp_PrincipalProps self, Standard_Real const aTol) -> Standard_Boolean

        returns true if the geometric system has an axis of symmetry.
        aTol  is  relative  tolerance for  cheking  equality  of  moments
        If  aTol  ==  0,  relative  tolerance  is  ~  1.e-16  (Epsilon(I))

        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.GProp_PrincipalProps_HasSymmetryAxis(self, *args)


    def HasSymmetryPoint(self, *args):
        """
        HasSymmetryPoint(GProp_PrincipalProps self) -> Standard_Boolean
        HasSymmetryPoint(GProp_PrincipalProps self, Standard_Real const aTol) -> Standard_Boolean

        returns true if the geometric system has a point of symmetry.
        aTol  is  relative  tolerance for  cheking  equality  of  moments
        If  aTol  ==  0,  relative  tolerance  is  ~  1.e-16  (Epsilon(I))

        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GProp.GProp_PrincipalProps_HasSymmetryPoint(self, *args)


    def Moments(self, *args):
        """
        Moments(GProp_PrincipalProps self)

        Ixx, Iyy and Izz return the principal moments of inertia
        in the current system.
        Notes :
        - If the current system has an axis of symmetry, two
        of the three values Ixx, Iyy and Izz are equal. They
        indicate which eigen vectors define an infinity of
        axes of principal inertia.
        - If the current system has a center of symmetry, Ixx,
        Iyy and Izz are equal.

        :type Ixx: float
        :type Iyy: float
        :type Izz: float

        """
        return _GProp.GProp_PrincipalProps_Moments(self, *args)


    def FirstAxisOfInertia(self, *args):
        """
        returns the first axis of inertia.

        if the system has a point of symmetry there is an infinity of
        solutions. It is not possible to defines the three axis of
        inertia.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _GProp.GProp_PrincipalProps_FirstAxisOfInertia(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondAxisOfInertia(self, *args):
        """
        returns the second axis of inertia.

        if the system has a point of symmetry or an axis of symmetry the
        second and the third axis of symmetry are undefined.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _GProp.GProp_PrincipalProps_SecondAxisOfInertia(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ThirdAxisOfInertia(self, *args):
        """
        returns the third axis of inertia.
        This and the above functions return the first, second or third eigen vector of the
        matrix of inertia of the current system.
        The first, second and third principal axis of inertia
        pass through the center of mass of the current
        system. They are respectively parallel to these three eigen vectors.
        Note that:
        - If the current system has an axis of symmetry, any
        axis is an axis of principal inertia if it passes
        through the center of mass of the system, and runs
        parallel to a linear combination of the two eigen
        vectors of the matrix of inertia, corresponding to the
        two eigen values which are equal. If the current
        system has a center of symmetry, any axis passing
        through the center of mass of the system is an axis
        of principal inertia. Use the functions
        HasSymmetryAxis and HasSymmetryPoint to
        check these particular cases, where the returned
        eigen vectors define an infinity of principal axis of inertia.
        - The Moments function can be used to know which
        of the three eigen vectors corresponds to the two
        eigen values which are equal.

        if the system has a point of symmetry or an axis of symmetry the
        second and the third axis of symmetry are undefined.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _GProp.GProp_PrincipalProps_ThirdAxisOfInertia(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RadiusOfGyration(self, *args):
        """
        RadiusOfGyration(GProp_PrincipalProps self)

        Returns the principal radii of gyration  Rxx, Ryy
        and Rzz are the radii of gyration of the current
        system about its three principal axes of inertia.
        Note that:
        - If the current system has an axis of symmetry,
        two of the three values Rxx, Ryy and Rzz are equal.
        - If the current system has a center of symmetry,
        Rxx, Ryy and Rzz are equal.

        :type Rxx: float
        :type Ryy: float
        :type Rzz: float

        """
        return _GProp.GProp_PrincipalProps_RadiusOfGyration(self, *args)

    __swig_destroy__ = _GProp.delete_GProp_PrincipalProps
GProp_PrincipalProps_swigregister = _GProp.GProp_PrincipalProps_swigregister
GProp_PrincipalProps_swigregister(GProp_PrincipalProps)

class GProp_CelGProps(GProp_GProps):
    """
    Computes the  global properties of bounded curves
    in 3D space.
    It can be an elementary curve from package gp such as
    Lin, Circ, Elips, Parab .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GProp_CelGProps self) -> GProp_CelGProps
        __init__(GProp_CelGProps self, gp_Circ C, gp_Pnt CLocation) -> GProp_CelGProps
        __init__(GProp_CelGProps self, gp_Circ C, Standard_Real const U1, Standard_Real const U2, gp_Pnt CLocation) -> GProp_CelGProps
        __init__(GProp_CelGProps self, gp_Lin C, Standard_Real const U1, Standard_Real const U2, gp_Pnt CLocation) -> GProp_CelGProps

        :type C: OCC.wrapper.gp.gp_Lin
        :type U1: float
        :type U2: float
        :type CLocation: OCC.wrapper.gp.gp_Pnt

        """
        this = _GProp.new_GProp_CelGProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(GProp_CelGProps self, gp_Pnt CLocation)

        :type CLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _GProp.GProp_CelGProps_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(GProp_CelGProps self, gp_Circ C, Standard_Real const U1, Standard_Real const U2)
        Perform(GProp_CelGProps self, gp_Lin C, Standard_Real const U1, Standard_Real const U2)

        :type C: OCC.wrapper.gp.gp_Lin
        :type U1: float
        :type U2: float

        """
        return _GProp.GProp_CelGProps_Perform(self, *args)

    __swig_destroy__ = _GProp.delete_GProp_CelGProps
GProp_CelGProps_swigregister = _GProp.GProp_CelGProps_swigregister
GProp_CelGProps_swigregister(GProp_CelGProps)

class GProp_PGProps(GProp_GProps):
    """
    A framework for computing the global properties of a
    set of points.
    A point mass is attached to each point. The global
    mass of the system is the sum of each individual
    mass. By default, the point mass is equal to 1 and the
    mass of a system composed of N points is equal to N.
    Warning
    A framework of this sort provides functions to handle
    sets of points easily. But, like any GProp_GProps
    object, by using the Add function, it can theoretically
    bring together the computed global properties and
    those of a system more complex than a set of points .
    The mass of each point and the density of each
    component of the composed system must be
    coherent. Note that this coherence cannot be checked.
    Nonetheless, you are advised to restrict your use of a
    GProp_PGProps object to a set of points and to
    create a GProp_GProps object in order to bring
    together global properties of different systems.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddPoint(self, *args):
        """
        AddPoint(GProp_PGProps self, gp_Pnt P)
        AddPoint(GProp_PGProps self, gp_Pnt P, Standard_Real const Density)

        Adds a new point P with its density in the system of points
        Exceptions
        Standard_DomainError if the mass value Density
        is less than gp::Resolution().

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Density: float

        """
        return _GProp.GProp_PGProps_AddPoint(self, *args)


    def __init__(self, *args):
        """
        __init__(GProp_PGProps self) -> GProp_PGProps
        __init__(GProp_PGProps self, NCollection_Array1_gp_Pnt Pnts) -> GProp_PGProps
        __init__(GProp_PGProps self, NCollection_Array2_gp_Pnt Pnts) -> GProp_PGProps
        __init__(GProp_PGProps self, NCollection_Array1_gp_Pnt Pnts, NCollection_Array1_Standard_Real Density) -> GProp_PGProps
        __init__(GProp_PGProps self, NCollection_Array2_gp_Pnt Pnts, NCollection_Array2_Standard_Real Density) -> GProp_PGProps

        computes the global properties of the system of points Pnts.
        A density is associated with each point.

        Raised if a density is lower or equal to Resolution from package
        gp.

        Raised if the length of Pnts and the length of Density
        is not the same.

        :type Pnts: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Density: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        this = _GProp.new_GProp_PGProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Barycentre(*args):
        """
        Barycentre(NCollection_Array1_gp_Pnt Pnts) -> gp_Pnt
        Barycentre(NCollection_Array2_gp_Pnt Pnts) -> gp_Pnt
        Barycentre(NCollection_Array1_gp_Pnt Pnts, NCollection_Array1_Standard_Real Density, gp_Pnt G)
        Barycentre(NCollection_Array2_gp_Pnt Pnts, NCollection_Array2_Standard_Real Density, gp_Pnt G)

        Computes the barycentre of a set of points. A density is associated
        with each point.

        Raised if a density is lower or equal to Resolution from package
        gp.

        Raised if the length of Pnts and the length of Density
        is not the same.

        :type Pnts: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Density: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Mass: float
        :type G: OCC.wrapper.gp.gp_Pnt

        """
        return _GProp.GProp_PGProps_Barycentre(*args)

    Barycentre = staticmethod(Barycentre)
    __swig_destroy__ = _GProp.delete_GProp_PGProps
GProp_PGProps_swigregister = _GProp.GProp_PGProps_swigregister
GProp_PGProps_swigregister(GProp_PGProps)

def GProp_PGProps_Barycentre(*args):
    """
    Barycentre(NCollection_Array1_gp_Pnt Pnts) -> gp_Pnt
    Barycentre(NCollection_Array2_gp_Pnt Pnts) -> gp_Pnt
    Barycentre(NCollection_Array1_gp_Pnt Pnts, NCollection_Array1_Standard_Real Density, gp_Pnt G)
    GProp_PGProps_Barycentre(NCollection_Array2_gp_Pnt Pnts, NCollection_Array2_Standard_Real Density, gp_Pnt G)

    Computes the barycentre of a set of points. A density is associated
    with each point.

    Raised if a density is lower or equal to Resolution from package
    gp.

    Raised if the length of Pnts and the length of Density
    is not the same.

    :type Pnts: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Density: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Mass: float
    :type G: OCC.wrapper.gp.gp_Pnt

    """
    return _GProp.GProp_PGProps_Barycentre(*args)

class GProp_VelGProps(GProp_GProps):
    """
    Computes the global properties and the volume of a geometric solid
    (3D closed region of space)
    The solid can be elementary(definition in the gp package)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GProp_VelGProps self) -> GProp_VelGProps
        __init__(GProp_VelGProps self, gp_Cylinder S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2, gp_Pnt VLocation) -> GProp_VelGProps
        __init__(GProp_VelGProps self, gp_Cone S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2, gp_Pnt VLocation) -> GProp_VelGProps
        __init__(GProp_VelGProps self, gp_Sphere S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2, gp_Pnt VLocation) -> GProp_VelGProps
        __init__(GProp_VelGProps self, gp_Torus S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2, gp_Pnt VLocation) -> GProp_VelGProps

        :type S: OCC.wrapper.gp.gp_Torus
        :type Teta1: float
        :type Teta2: float
        :type Alpha1: float
        :type Alpha2: float
        :type VLocation: OCC.wrapper.gp.gp_Pnt

        """
        this = _GProp.new_GProp_VelGProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(GProp_VelGProps self, gp_Pnt VLocation)

        :type VLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _GProp.GProp_VelGProps_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(GProp_VelGProps self, gp_Cylinder S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2)
        Perform(GProp_VelGProps self, gp_Cone S, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Real const Z1, Standard_Real const Z2)
        Perform(GProp_VelGProps self, gp_Sphere S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2)
        Perform(GProp_VelGProps self, gp_Torus S, Standard_Real const Teta1, Standard_Real const Teta2, Standard_Real const Alpha1, Standard_Real const Alpha2)

        :type S: OCC.wrapper.gp.gp_Torus
        :type Teta1: float
        :type Teta2: float
        :type Alpha1: float
        :type Alpha2: float

        """
        return _GProp.GProp_VelGProps_Perform(self, *args)

    __swig_destroy__ = _GProp.delete_GProp_VelGProps
GProp_VelGProps_swigregister = _GProp.GProp_VelGProps_swigregister
GProp_VelGProps_swigregister(GProp_VelGProps)

class GProp_(object):
    """
    This package defines algorithmes to compute the global properties
    of a set of points, a curve, a surface, a solid (non infinite
    region of space delimited with geometric entities), a compound
    geometric system (heterogeneous composition of the previous
    entities).

    Global properties are :
    . length, area, volume,
    . centre of mass,
    . axis of inertia,
    . moments of inertia,
    . radius of gyration.

    It provides  also a class to  compile the average point or
    line of a set of points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HOperator(*args):
        """
        HOperator(gp_Pnt G, gp_Pnt Q, Standard_Real const Mass, gp_Mat Operator)

        methods of package
        Computes the matrix Operator, referred to as the
        "Huyghens Operator" of a geometric system at the
        point Q of the space, using the following data :
        - Mass, i.e. the mass of the system,
        - G, the center of mass of the system.
        The "Huyghens Operator" is used to compute
        Inertia/Q, the matrix of inertia of the system at
        the point Q using Huyghens' theorem :
        Inertia/Q = Inertia/G + HOperator (Q, G, Mass)
        where Inertia/G is the matrix of inertia of the
        system relative to its center of mass as returned by
        the function MatrixOfInertia on any GProp_GProps object.

        :type G: OCC.wrapper.gp.gp_Pnt
        :type Q: OCC.wrapper.gp.gp_Pnt
        :type Mass: float
        :type Operator: OCC.wrapper.gp.gp_Mat

        """
        return _GProp.GProp__HOperator(*args)

    HOperator = staticmethod(HOperator)

    def __init__(self):
        """
        This package defines algorithmes to compute the global properties
        of a set of points, a curve, a surface, a solid (non infinite
        region of space delimited with geometric entities), a compound
        geometric system (heterogeneous composition of the previous
        entities).

        Global properties are :
        . length, area, volume,
        . centre of mass,
        . axis of inertia,
        . moments of inertia,
        . radius of gyration.

        It provides  also a class to  compile the average point or
        line of a set of points.
        """
        this = _GProp.new_GProp_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GProp.delete_GProp_
GProp__swigregister = _GProp.GProp__swigregister
GProp__swigregister(GProp_)

def GProp__HOperator(*args):
    """
    GProp__HOperator(gp_Pnt G, gp_Pnt Q, Standard_Real const Mass, gp_Mat Operator)

    methods of package
    Computes the matrix Operator, referred to as the
    "Huyghens Operator" of a geometric system at the
    point Q of the space, using the following data :
    - Mass, i.e. the mass of the system,
    - G, the center of mass of the system.
    The "Huyghens Operator" is used to compute
    Inertia/Q, the matrix of inertia of the system at
    the point Q using Huyghens' theorem :
    Inertia/Q = Inertia/G + HOperator (Q, G, Mass)
    where Inertia/G is the matrix of inertia of the
    system relative to its center of mass as returned by
    the function MatrixOfInertia on any GProp_GProps object.

    :type G: OCC.wrapper.gp.gp_Pnt
    :type Q: OCC.wrapper.gp.gp_Pnt
    :type Mass: float
    :type Operator: OCC.wrapper.gp.gp_Mat

    """
    return _GProp.GProp__HOperator(*args)




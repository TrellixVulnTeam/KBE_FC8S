# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ElCLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ElCLib')
    _ElCLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ElCLib', [dirname(__file__)])
        except ImportError:
            import _ElCLib
            return _ElCLib
        try:
            _mod = imp.load_module('_ElCLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ElCLib = swig_import_helper()
    del swig_import_helper
else:
    import _ElCLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ElCLib.delete_SwigPyIterator

    def value(self):
        return _ElCLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ElCLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ElCLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ElCLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ElCLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ElCLib.SwigPyIterator_copy(self)

    def next(self):
        return _ElCLib.SwigPyIterator_next(self)

    def __next__(self):
        return _ElCLib.SwigPyIterator___next__(self)

    def previous(self):
        return _ElCLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ElCLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ElCLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ElCLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ElCLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ElCLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ElCLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ElCLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ElCLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ElCLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ElCLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ElCLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ElCLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ElCLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ElCLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ElCLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ElCLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ElCLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ElCLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ElCLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ElCLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ElCLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ElCLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ElCLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ElCLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ElCLib.ptr_to_number(item)
ptr_to_number = _ElCLib.ptr_to_number

def HashCode(*args):
    return _ElCLib.HashCode(*args)
HashCode = _ElCLib.HashCode

def ptr_equal(a, b):
    return _ElCLib.ptr_equal(a, b)
ptr_equal = _ElCLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class ElCLib_(object):
    """
    Provides functions for basic geometric computations on
    elementary curves such as conics and lines in 2D and 3D space.
    This includes:
    -   calculation of a point or derived vector on a 2D or
    3D curve where:
    -   the curve is provided by the gp package, or
    defined in reference form (as in the gp package),
    and
    -   the point is defined by a parameter,
    -   evaluation of the parameter corresponding to a point
    on a 2D or 3D curve from gp,
    -   various elementary computations which allow you to
    position parameterized values within the period of a curve.
    Notes:
    -   ElCLib stands for Elementary Curves Library.
    -   If the curves provided by the gp package are not
    explicitly parameterized, they still have an implicit
    parameterization, analogous to that which they infer
    for the equivalent Geom or Geom2d curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def InPeriod(*args):
        """
        InPeriod(Standard_Real const U, Standard_Real const UFirst, Standard_Real const ULast) -> Standard_Real

        Return a value in   the  range <UFirst, ULast>  by
        adding or removing the period <ULast -  UFirst> to
        <U>.
        ATTENTION!!!
        It is expected but not checked that (ULast > UFirst)

        :type U: float
        :type UFirst: float
        :type ULast: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__InPeriod(*args)

    InPeriod = staticmethod(InPeriod)

    def AdjustPeriodic(*args):
        """
        AdjustPeriodic(Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const Precision)

        Adjust U1 and  U2 in the  parametric range  UFirst
        Ulast of a periodic curve, where ULast -
        UFirst is its period. To do this, this function:
        -   sets U1 in the range [ UFirst, ULast ] by
        adding/removing the period to/from the value U1, then
        -   sets U2 in the range [ U1, U1 + period ] by
        adding/removing the period to/from the value U2.
        Precision is used to test the equalities.

        :type UFirst: float
        :type ULast: float
        :type Precision: float
        :type U1: float
        :type U2: float

        """
        return _ElCLib.ElCLib__AdjustPeriodic(*args)

    AdjustPeriodic = staticmethod(AdjustPeriodic)

    def Value(*args):
        """
        Value(Standard_Real const U, gp_Lin L) -> gp_Pnt
        Value(Standard_Real const U, gp_Circ C) -> gp_Pnt
        Value(Standard_Real const U, gp_Elips E) -> gp_Pnt
        Value(Standard_Real const U, gp_Hypr H) -> gp_Pnt
        Value(Standard_Real const U, gp_Parab Prb) -> gp_Pnt
        Value(Standard_Real const U, gp_Lin2d L) -> gp_Pnt2d
        Value(Standard_Real const U, gp_Circ2d C) -> gp_Pnt2d
        Value(Standard_Real const U, gp_Elips2d E) -> gp_Pnt2d
        Value(Standard_Real const U, gp_Hypr2d H) -> gp_Pnt2d
        Value(Standard_Real const U, gp_Parab2d Prb) -> gp_Pnt2d

        :type U: float
        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ElCLib.ElCLib__Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(Standard_Real const U, gp_Lin L, gp_Pnt P, gp_Vec V1)
        D1(Standard_Real const U, gp_Circ C, gp_Pnt P, gp_Vec V1)
        D1(Standard_Real const U, gp_Elips E, gp_Pnt P, gp_Vec V1)
        D1(Standard_Real const U, gp_Hypr H, gp_Pnt P, gp_Vec V1)
        D1(Standard_Real const U, gp_Parab Prb, gp_Pnt P, gp_Vec V1)
        D1(Standard_Real const U, gp_Lin2d L, gp_Pnt2d P, gp_Vec2d V1)
        D1(Standard_Real const U, gp_Circ2d C, gp_Pnt2d P, gp_Vec2d V1)
        D1(Standard_Real const U, gp_Elips2d E, gp_Pnt2d P, gp_Vec2d V1)
        D1(Standard_Real const U, gp_Hypr2d H, gp_Pnt2d P, gp_Vec2d V1)
        D1(Standard_Real const U, gp_Parab2d Prb, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Real const U, gp_Circ C, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        D2(Standard_Real const U, gp_Elips E, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        D2(Standard_Real const U, gp_Hypr H, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        D2(Standard_Real const U, gp_Parab Prb, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        D2(Standard_Real const U, gp_Circ2d C, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
        D2(Standard_Real const U, gp_Elips2d E, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
        D2(Standard_Real const U, gp_Hypr2d H, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
        D2(Standard_Real const U, gp_Parab2d Prb, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Standard_Real const U, gp_Circ C, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        D3(Standard_Real const U, gp_Elips E, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        D3(Standard_Real const U, gp_Hypr H, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        D3(Standard_Real const U, gp_Circ2d C, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)
        D3(Standard_Real const U, gp_Elips2d E, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)
        D3(Standard_Real const U, gp_Hypr2d H, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        In the following functions N is the order of derivation
        and should be greater than 0

        :type U: float
        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Standard_Real const U, gp_Lin L, Standard_Integer const N) -> gp_Vec
        DN(Standard_Real const U, gp_Circ C, Standard_Integer const N) -> gp_Vec
        DN(Standard_Real const U, gp_Elips E, Standard_Integer const N) -> gp_Vec
        DN(Standard_Real const U, gp_Hypr H, Standard_Integer const N) -> gp_Vec
        DN(Standard_Real const U, gp_Parab Prb, Standard_Integer const N) -> gp_Vec
        DN(Standard_Real const U, gp_Lin2d L, Standard_Integer const N) -> gp_Vec2d
        DN(Standard_Real const U, gp_Circ2d C, Standard_Integer const N) -> gp_Vec2d
        DN(Standard_Real const U, gp_Elips2d E, Standard_Integer const N) -> gp_Vec2d
        DN(Standard_Real const U, gp_Hypr2d H, Standard_Integer const N) -> gp_Vec2d
        DN(Standard_Real const U, gp_Parab2d Prb, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__DN(*args)

    DN = staticmethod(DN)

    def LineValue(*args):
        """
        LineValue(Standard_Real const U, gp_Ax1 Pos) -> gp_Pnt
        LineValue(Standard_Real const U, gp_Ax2d Pos) -> gp_Pnt2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ElCLib.ElCLib__LineValue(*args)

    LineValue = staticmethod(LineValue)

    def CircleValue(*args):
        """
        CircleValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius) -> gp_Pnt
        CircleValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius) -> gp_Pnt2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ElCLib.ElCLib__CircleValue(*args)

    CircleValue = staticmethod(CircleValue)

    def EllipseValue(*args):
        """
        EllipseValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt
        EllipseValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ElCLib.ElCLib__EllipseValue(*args)

    EllipseValue = staticmethod(EllipseValue)

    def HyperbolaValue(*args):
        """
        HyperbolaValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt
        HyperbolaValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ElCLib.ElCLib__HyperbolaValue(*args)

    HyperbolaValue = staticmethod(HyperbolaValue)

    def ParabolaValue(*args):
        """
        ParabolaValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal) -> gp_Pnt
        ParabolaValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal) -> gp_Pnt2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Focal: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ElCLib.ElCLib__ParabolaValue(*args)

    ParabolaValue = staticmethod(ParabolaValue)

    def LineD1(*args):
        """
        LineD1(Standard_Real const U, gp_Ax1 Pos, gp_Pnt P, gp_Vec V1)
        LineD1(Standard_Real const U, gp_Ax2d Pos, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__LineD1(*args)

    LineD1 = staticmethod(LineD1)

    def CircleD1(*args):
        """
        CircleD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec V1)
        CircleD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__CircleD1(*args)

    CircleD1 = staticmethod(CircleD1)

    def EllipseD1(*args):
        """
        EllipseD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1)
        EllipseD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__EllipseD1(*args)

    EllipseD1 = staticmethod(EllipseD1)

    def HyperbolaD1(*args):
        """
        HyperbolaD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1)
        HyperbolaD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__HyperbolaD1(*args)

    HyperbolaD1 = staticmethod(HyperbolaD1)

    def ParabolaD1(*args):
        """
        ParabolaD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal, gp_Pnt P, gp_Vec V1)
        ParabolaD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Focal: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__ParabolaD1(*args)

    ParabolaD1 = staticmethod(ParabolaD1)

    def CircleD2(*args):
        """
        CircleD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        CircleD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__CircleD2(*args)

    CircleD2 = staticmethod(CircleD2)

    def EllipseD2(*args):
        """
        EllipseD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        EllipseD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__EllipseD2(*args)

    EllipseD2 = staticmethod(EllipseD2)

    def HyperbolaD2(*args):
        """
        HyperbolaD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        HyperbolaD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__HyperbolaD2(*args)

    HyperbolaD2 = staticmethod(HyperbolaD2)

    def ParabolaD2(*args):
        """
        ParabolaD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        ParabolaD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Focal: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__ParabolaD2(*args)

    ParabolaD2 = staticmethod(ParabolaD2)

    def CircleD3(*args):
        """
        CircleD3(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        CircleD3(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__CircleD3(*args)

    CircleD3 = staticmethod(CircleD3)

    def EllipseD3(*args):
        """
        EllipseD3(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        EllipseD3(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__EllipseD3(*args)

    EllipseD3 = staticmethod(EllipseD3)

    def HyperbolaD3(*args):
        """
        HyperbolaD3(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        HyperbolaD3(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        In the following functions N is the order of derivation
        and should be greater than 0

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__HyperbolaD3(*args)

    HyperbolaD3 = staticmethod(HyperbolaD3)

    def LineDN(*args):
        """
        LineDN(Standard_Real const U, gp_Ax1 Pos, Standard_Integer const N) -> gp_Vec
        LineDN(Standard_Real const U, gp_Ax2d Pos, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax2d
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__LineDN(*args)

    LineDN = staticmethod(LineDN)

    def CircleDN(*args):
        """
        CircleDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, Standard_Integer const N) -> gp_Vec
        CircleDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__CircleDN(*args)

    CircleDN = staticmethod(CircleDN)

    def EllipseDN(*args):
        """
        EllipseDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec
        EllipseDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__EllipseDN(*args)

    EllipseDN = staticmethod(EllipseDN)

    def HyperbolaDN(*args):
        """
        HyperbolaDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec
        HyperbolaDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__HyperbolaDN(*args)

    HyperbolaDN = staticmethod(HyperbolaDN)

    def ParabolaDN(*args):
        """
        ParabolaDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal, Standard_Integer const N) -> gp_Vec
        ParabolaDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal, Standard_Integer const N) -> gp_Vec2d

        The following functions compute the parametric value corresponding
        to a given point on a elementary curve. The point should be on the
        curve.

        :type U: float
        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type Focal: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _ElCLib.ElCLib__ParabolaDN(*args)

    ParabolaDN = staticmethod(ParabolaDN)

    def Parameter(*args):
        """
        Parameter(gp_Lin L, gp_Pnt P) -> Standard_Real
        Parameter(gp_Lin2d L, gp_Pnt2d P) -> Standard_Real
        Parameter(gp_Circ C, gp_Pnt P) -> Standard_Real
        Parameter(gp_Circ2d C, gp_Pnt2d P) -> Standard_Real
        Parameter(gp_Elips E, gp_Pnt P) -> Standard_Real
        Parameter(gp_Elips2d E, gp_Pnt2d P) -> Standard_Real
        Parameter(gp_Hypr H, gp_Pnt P) -> Standard_Real
        Parameter(gp_Hypr2d H, gp_Pnt2d P) -> Standard_Real
        Parameter(gp_Parab Prb, gp_Pnt P) -> Standard_Real
        Parameter(gp_Parab2d Prb, gp_Pnt2d P) -> Standard_Real

        parametrization
        In the local coordinate system of the parabola
        Y**2 = (2*P) * X where P is the distance between the focus
        and the directrix.

        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__Parameter(*args)

    Parameter = staticmethod(Parameter)

    def LineParameter(*args):
        """
        LineParameter(gp_Ax1 Pos, gp_Pnt P) -> Standard_Real
        LineParameter(gp_Ax2d Pos, gp_Pnt2d P) -> Standard_Real

        parametrization
        P (U) = L.Location() + U * L.Direction()

        :type Pos: OCC.wrapper.gp.gp_Ax2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__LineParameter(*args)

    LineParameter = staticmethod(LineParameter)

    def CircleParameter(*args):
        """
        CircleParameter(gp_Ax2 Pos, gp_Pnt P) -> Standard_Real
        CircleParameter(gp_Ax22d Pos, gp_Pnt2d P) -> Standard_Real

        Pos is the Axis of the Circle
        parametrization
        In the local coordinate system of the circle
        X (U) = Radius * Cos (U)
        Y (U) = Radius * Sin (U)

        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__CircleParameter(*args)

    CircleParameter = staticmethod(CircleParameter)

    def EllipseParameter(*args):
        """
        EllipseParameter(gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P) -> Standard_Real
        EllipseParameter(gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P) -> Standard_Real

        Pos is the Axis of the Ellipse
        parametrization
        In the local coordinate system of the Ellipse
        X (U) = MajorRadius * Cos (U)
        Y (U) = MinorRadius * Sin (U)

        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__EllipseParameter(*args)

    EllipseParameter = staticmethod(EllipseParameter)

    def HyperbolaParameter(*args):
        """
        HyperbolaParameter(gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P) -> Standard_Real
        HyperbolaParameter(gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P) -> Standard_Real

        Pos is the Axis of the Hyperbola
        parametrization
        In the local coordinate system of the Hyperbola
        X (U) = MajorRadius * Ch (U)
        Y (U) = MinorRadius * Sh (U)

        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__HyperbolaParameter(*args)

    HyperbolaParameter = staticmethod(HyperbolaParameter)

    def ParabolaParameter(*args):
        """
        ParabolaParameter(gp_Ax2 Pos, gp_Pnt P) -> Standard_Real
        ParabolaParameter(gp_Ax22d Pos, gp_Pnt2d P) -> Standard_Real

        Pos is the mirror axis of the parabola
        parametrization
        In the local coordinate system of the parabola
        Y**2 = (2*P) * X where P is the distance between the focus
        and the directrix.
        The following functions build  a 3d curve from a
        2d curve at a given position defined with an Ax2.

        :type Pos: OCC.wrapper.gp.gp_Ax22d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ElCLib.ElCLib__ParabolaParameter(*args)

    ParabolaParameter = staticmethod(ParabolaParameter)

    def To3d(*args):
        """
        To3d(gp_Ax2 Pos, gp_Pnt2d P) -> gp_Pnt
        To3d(gp_Ax2 Pos, gp_Vec2d V) -> gp_Vec
        To3d(gp_Ax2 Pos, gp_Dir2d V) -> gp_Dir
        To3d(gp_Ax2 Pos, gp_Ax2d A) -> gp_Ax1
        To3d(gp_Ax2 Pos, gp_Ax22d A) -> gp_Ax2
        To3d(gp_Ax2 Pos, gp_Lin2d L) -> gp_Lin
        To3d(gp_Ax2 Pos, gp_Circ2d C) -> gp_Circ
        To3d(gp_Ax2 Pos, gp_Elips2d E) -> gp_Elips
        To3d(gp_Ax2 Pos, gp_Hypr2d H) -> gp_Hypr
        To3d(gp_Ax2 Pos, gp_Parab2d Prb) -> gp_Parab

        These functions build a 3D geometric entity from a 2D geometric entity.
        The "X Axis" and the "Y Axis" of the global coordinate
        system (i.e. 2D space) are lined up respectively with the
        "X Axis" and "Y Axis" of the 3D coordinate system, Pos.

        :type Pos: OCC.wrapper.gp.gp_Ax2
        :type Prb: OCC.wrapper.gp.gp_Parab2d
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _ElCLib.ElCLib__To3d(*args)

    To3d = staticmethod(To3d)

    def __init__(self):
        """
        Provides functions for basic geometric computations on
        elementary curves such as conics and lines in 2D and 3D space.
        This includes:
        -   calculation of a point or derived vector on a 2D or
        3D curve where:
        -   the curve is provided by the gp package, or
        defined in reference form (as in the gp package),
        and
        -   the point is defined by a parameter,
        -   evaluation of the parameter corresponding to a point
        on a 2D or 3D curve from gp,
        -   various elementary computations which allow you to
        position parameterized values within the period of a curve.
        Notes:
        -   ElCLib stands for Elementary Curves Library.
        -   If the curves provided by the gp package are not
        explicitly parameterized, they still have an implicit
        parameterization, analogous to that which they infer
        for the equivalent Geom or Geom2d curves.
        """
        this = _ElCLib.new_ElCLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ElCLib.delete_ElCLib_
ElCLib__swigregister = _ElCLib.ElCLib__swigregister
ElCLib__swigregister(ElCLib_)

def ElCLib__InPeriod(*args):
    """
    ElCLib__InPeriod(Standard_Real const U, Standard_Real const UFirst, Standard_Real const ULast) -> Standard_Real

    Return a value in   the  range <UFirst, ULast>  by
    adding or removing the period <ULast -  UFirst> to
    <U>.
    ATTENTION!!!
    It is expected but not checked that (ULast > UFirst)

    :type U: float
    :type UFirst: float
    :type ULast: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__InPeriod(*args)

def ElCLib__AdjustPeriodic(*args):
    """
    ElCLib__AdjustPeriodic(Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const Precision)

    Adjust U1 and  U2 in the  parametric range  UFirst
    Ulast of a periodic curve, where ULast -
    UFirst is its period. To do this, this function:
    -   sets U1 in the range [ UFirst, ULast ] by
    adding/removing the period to/from the value U1, then
    -   sets U2 in the range [ U1, U1 + period ] by
    adding/removing the period to/from the value U2.
    Precision is used to test the equalities.

    :type UFirst: float
    :type ULast: float
    :type Precision: float
    :type U1: float
    :type U2: float

    """
    return _ElCLib.ElCLib__AdjustPeriodic(*args)

def ElCLib__Value(*args):
    """
    Value(Standard_Real const U, gp_Lin L) -> gp_Pnt
    Value(Standard_Real const U, gp_Circ C) -> gp_Pnt
    Value(Standard_Real const U, gp_Elips E) -> gp_Pnt
    Value(Standard_Real const U, gp_Hypr H) -> gp_Pnt
    Value(Standard_Real const U, gp_Parab Prb) -> gp_Pnt
    Value(Standard_Real const U, gp_Lin2d L) -> gp_Pnt2d
    Value(Standard_Real const U, gp_Circ2d C) -> gp_Pnt2d
    Value(Standard_Real const U, gp_Elips2d E) -> gp_Pnt2d
    Value(Standard_Real const U, gp_Hypr2d H) -> gp_Pnt2d
    ElCLib__Value(Standard_Real const U, gp_Parab2d Prb) -> gp_Pnt2d

    :type U: float
    :type Prb: OCC.wrapper.gp.gp_Parab2d
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _ElCLib.ElCLib__Value(*args)

def ElCLib__D1(*args):
    """
    D1(Standard_Real const U, gp_Lin L, gp_Pnt P, gp_Vec V1)
    D1(Standard_Real const U, gp_Circ C, gp_Pnt P, gp_Vec V1)
    D1(Standard_Real const U, gp_Elips E, gp_Pnt P, gp_Vec V1)
    D1(Standard_Real const U, gp_Hypr H, gp_Pnt P, gp_Vec V1)
    D1(Standard_Real const U, gp_Parab Prb, gp_Pnt P, gp_Vec V1)
    D1(Standard_Real const U, gp_Lin2d L, gp_Pnt2d P, gp_Vec2d V1)
    D1(Standard_Real const U, gp_Circ2d C, gp_Pnt2d P, gp_Vec2d V1)
    D1(Standard_Real const U, gp_Elips2d E, gp_Pnt2d P, gp_Vec2d V1)
    D1(Standard_Real const U, gp_Hypr2d H, gp_Pnt2d P, gp_Vec2d V1)
    ElCLib__D1(Standard_Real const U, gp_Parab2d Prb, gp_Pnt2d P, gp_Vec2d V1)

    :type U: float
    :type Prb: OCC.wrapper.gp.gp_Parab2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__D1(*args)

def ElCLib__D2(*args):
    """
    D2(Standard_Real const U, gp_Circ C, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    D2(Standard_Real const U, gp_Elips E, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    D2(Standard_Real const U, gp_Hypr H, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    D2(Standard_Real const U, gp_Parab Prb, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    D2(Standard_Real const U, gp_Circ2d C, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
    D2(Standard_Real const U, gp_Elips2d E, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
    D2(Standard_Real const U, gp_Hypr2d H, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
    ElCLib__D2(Standard_Real const U, gp_Parab2d Prb, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    :type U: float
    :type Prb: OCC.wrapper.gp.gp_Parab2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__D2(*args)

def ElCLib__D3(*args):
    """
    D3(Standard_Real const U, gp_Circ C, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    D3(Standard_Real const U, gp_Elips E, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    D3(Standard_Real const U, gp_Hypr H, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    D3(Standard_Real const U, gp_Circ2d C, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)
    D3(Standard_Real const U, gp_Elips2d E, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)
    ElCLib__D3(Standard_Real const U, gp_Hypr2d H, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    In the following functions N is the order of derivation
    and should be greater than 0

    :type U: float
    :type H: OCC.wrapper.gp.gp_Hypr2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__D3(*args)

def ElCLib__DN(*args):
    """
    DN(Standard_Real const U, gp_Lin L, Standard_Integer const N) -> gp_Vec
    DN(Standard_Real const U, gp_Circ C, Standard_Integer const N) -> gp_Vec
    DN(Standard_Real const U, gp_Elips E, Standard_Integer const N) -> gp_Vec
    DN(Standard_Real const U, gp_Hypr H, Standard_Integer const N) -> gp_Vec
    DN(Standard_Real const U, gp_Parab Prb, Standard_Integer const N) -> gp_Vec
    DN(Standard_Real const U, gp_Lin2d L, Standard_Integer const N) -> gp_Vec2d
    DN(Standard_Real const U, gp_Circ2d C, Standard_Integer const N) -> gp_Vec2d
    DN(Standard_Real const U, gp_Elips2d E, Standard_Integer const N) -> gp_Vec2d
    DN(Standard_Real const U, gp_Hypr2d H, Standard_Integer const N) -> gp_Vec2d
    ElCLib__DN(Standard_Real const U, gp_Parab2d Prb, Standard_Integer const N) -> gp_Vec2d

    :type U: float
    :type Prb: OCC.wrapper.gp.gp_Parab2d
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__DN(*args)

def ElCLib__LineValue(*args):
    """
    LineValue(Standard_Real const U, gp_Ax1 Pos) -> gp_Pnt
    ElCLib__LineValue(Standard_Real const U, gp_Ax2d Pos) -> gp_Pnt2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax2d
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _ElCLib.ElCLib__LineValue(*args)

def ElCLib__CircleValue(*args):
    """
    CircleValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius) -> gp_Pnt
    ElCLib__CircleValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius) -> gp_Pnt2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Radius: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _ElCLib.ElCLib__CircleValue(*args)

def ElCLib__EllipseValue(*args):
    """
    EllipseValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt
    ElCLib__EllipseValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _ElCLib.ElCLib__EllipseValue(*args)

def ElCLib__HyperbolaValue(*args):
    """
    HyperbolaValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt
    ElCLib__HyperbolaValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _ElCLib.ElCLib__HyperbolaValue(*args)

def ElCLib__ParabolaValue(*args):
    """
    ParabolaValue(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal) -> gp_Pnt
    ElCLib__ParabolaValue(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal) -> gp_Pnt2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Focal: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _ElCLib.ElCLib__ParabolaValue(*args)

def ElCLib__LineD1(*args):
    """
    LineD1(Standard_Real const U, gp_Ax1 Pos, gp_Pnt P, gp_Vec V1)
    ElCLib__LineD1(Standard_Real const U, gp_Ax2d Pos, gp_Pnt2d P, gp_Vec2d V1)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__LineD1(*args)

def ElCLib__CircleD1(*args):
    """
    CircleD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec V1)
    ElCLib__CircleD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, gp_Pnt2d P, gp_Vec2d V1)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__CircleD1(*args)

def ElCLib__EllipseD1(*args):
    """
    EllipseD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1)
    ElCLib__EllipseD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__EllipseD1(*args)

def ElCLib__HyperbolaD1(*args):
    """
    HyperbolaD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1)
    ElCLib__HyperbolaD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__HyperbolaD1(*args)

def ElCLib__ParabolaD1(*args):
    """
    ParabolaD1(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal, gp_Pnt P, gp_Vec V1)
    ElCLib__ParabolaD1(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal, gp_Pnt2d P, gp_Vec2d V1)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Focal: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__ParabolaD1(*args)

def ElCLib__CircleD2(*args):
    """
    CircleD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    ElCLib__CircleD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__CircleD2(*args)

def ElCLib__EllipseD2(*args):
    """
    EllipseD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    ElCLib__EllipseD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__EllipseD2(*args)

def ElCLib__HyperbolaD2(*args):
    """
    HyperbolaD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    ElCLib__HyperbolaD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__HyperbolaD2(*args)

def ElCLib__ParabolaD2(*args):
    """
    ParabolaD2(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    ElCLib__ParabolaD2(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Focal: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__ParabolaD2(*args)

def ElCLib__CircleD3(*args):
    """
    CircleD3(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    ElCLib__CircleD3(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__CircleD3(*args)

def ElCLib__EllipseD3(*args):
    """
    EllipseD3(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    ElCLib__EllipseD3(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__EllipseD3(*args)

def ElCLib__HyperbolaD3(*args):
    """
    HyperbolaD3(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    ElCLib__HyperbolaD3(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    In the following functions N is the order of derivation
    and should be greater than 0

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__HyperbolaD3(*args)

def ElCLib__LineDN(*args):
    """
    LineDN(Standard_Real const U, gp_Ax1 Pos, Standard_Integer const N) -> gp_Vec
    ElCLib__LineDN(Standard_Real const U, gp_Ax2d Pos, Standard_Integer const N) -> gp_Vec2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax2d
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__LineDN(*args)

def ElCLib__CircleDN(*args):
    """
    CircleDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Radius, Standard_Integer const N) -> gp_Vec
    ElCLib__CircleDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Radius, Standard_Integer const N) -> gp_Vec2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Radius: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__CircleDN(*args)

def ElCLib__EllipseDN(*args):
    """
    EllipseDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec
    ElCLib__EllipseDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__EllipseDN(*args)

def ElCLib__HyperbolaDN(*args):
    """
    HyperbolaDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec
    ElCLib__HyperbolaDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const N) -> gp_Vec2d

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__HyperbolaDN(*args)

def ElCLib__ParabolaDN(*args):
    """
    ParabolaDN(Standard_Real const U, gp_Ax2 Pos, Standard_Real const Focal, Standard_Integer const N) -> gp_Vec
    ElCLib__ParabolaDN(Standard_Real const U, gp_Ax22d Pos, Standard_Real const Focal, Standard_Integer const N) -> gp_Vec2d

    The following functions compute the parametric value corresponding
    to a given point on a elementary curve. The point should be on the
    curve.

    :type U: float
    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type Focal: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _ElCLib.ElCLib__ParabolaDN(*args)

def ElCLib__Parameter(*args):
    """
    Parameter(gp_Lin L, gp_Pnt P) -> Standard_Real
    Parameter(gp_Lin2d L, gp_Pnt2d P) -> Standard_Real
    Parameter(gp_Circ C, gp_Pnt P) -> Standard_Real
    Parameter(gp_Circ2d C, gp_Pnt2d P) -> Standard_Real
    Parameter(gp_Elips E, gp_Pnt P) -> Standard_Real
    Parameter(gp_Elips2d E, gp_Pnt2d P) -> Standard_Real
    Parameter(gp_Hypr H, gp_Pnt P) -> Standard_Real
    Parameter(gp_Hypr2d H, gp_Pnt2d P) -> Standard_Real
    Parameter(gp_Parab Prb, gp_Pnt P) -> Standard_Real
    ElCLib__Parameter(gp_Parab2d Prb, gp_Pnt2d P) -> Standard_Real

    parametrization
    In the local coordinate system of the parabola
    Y**2 = (2*P) * X where P is the distance between the focus
    and the directrix.

    :type Prb: OCC.wrapper.gp.gp_Parab2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__Parameter(*args)

def ElCLib__LineParameter(*args):
    """
    LineParameter(gp_Ax1 Pos, gp_Pnt P) -> Standard_Real
    ElCLib__LineParameter(gp_Ax2d Pos, gp_Pnt2d P) -> Standard_Real

    parametrization
    P (U) = L.Location() + U * L.Direction()

    :type Pos: OCC.wrapper.gp.gp_Ax2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__LineParameter(*args)

def ElCLib__CircleParameter(*args):
    """
    CircleParameter(gp_Ax2 Pos, gp_Pnt P) -> Standard_Real
    ElCLib__CircleParameter(gp_Ax22d Pos, gp_Pnt2d P) -> Standard_Real

    Pos is the Axis of the Circle
    parametrization
    In the local coordinate system of the circle
    X (U) = Radius * Cos (U)
    Y (U) = Radius * Sin (U)

    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__CircleParameter(*args)

def ElCLib__EllipseParameter(*args):
    """
    EllipseParameter(gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P) -> Standard_Real
    ElCLib__EllipseParameter(gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P) -> Standard_Real

    Pos is the Axis of the Ellipse
    parametrization
    In the local coordinate system of the Ellipse
    X (U) = MajorRadius * Cos (U)
    Y (U) = MinorRadius * Sin (U)

    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__EllipseParameter(*args)

def ElCLib__HyperbolaParameter(*args):
    """
    HyperbolaParameter(gp_Ax2 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P) -> Standard_Real
    ElCLib__HyperbolaParameter(gp_Ax22d Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt2d P) -> Standard_Real

    Pos is the Axis of the Hyperbola
    parametrization
    In the local coordinate system of the Hyperbola
    X (U) = MajorRadius * Ch (U)
    Y (U) = MinorRadius * Sh (U)

    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__HyperbolaParameter(*args)

def ElCLib__ParabolaParameter(*args):
    """
    ParabolaParameter(gp_Ax2 Pos, gp_Pnt P) -> Standard_Real
    ElCLib__ParabolaParameter(gp_Ax22d Pos, gp_Pnt2d P) -> Standard_Real

    Pos is the mirror axis of the parabola
    parametrization
    In the local coordinate system of the parabola
    Y**2 = (2*P) * X where P is the distance between the focus
    and the directrix.
    The following functions build  a 3d curve from a
    2d curve at a given position defined with an Ax2.

    :type Pos: OCC.wrapper.gp.gp_Ax22d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ElCLib.ElCLib__ParabolaParameter(*args)

def ElCLib__To3d(*args):
    """
    To3d(gp_Ax2 Pos, gp_Pnt2d P) -> gp_Pnt
    To3d(gp_Ax2 Pos, gp_Vec2d V) -> gp_Vec
    To3d(gp_Ax2 Pos, gp_Dir2d V) -> gp_Dir
    To3d(gp_Ax2 Pos, gp_Ax2d A) -> gp_Ax1
    To3d(gp_Ax2 Pos, gp_Ax22d A) -> gp_Ax2
    To3d(gp_Ax2 Pos, gp_Lin2d L) -> gp_Lin
    To3d(gp_Ax2 Pos, gp_Circ2d C) -> gp_Circ
    To3d(gp_Ax2 Pos, gp_Elips2d E) -> gp_Elips
    To3d(gp_Ax2 Pos, gp_Hypr2d H) -> gp_Hypr
    ElCLib__To3d(gp_Ax2 Pos, gp_Parab2d Prb) -> gp_Parab

    These functions build a 3D geometric entity from a 2D geometric entity.
    The "X Axis" and the "Y Axis" of the global coordinate
    system (i.e. 2D space) are lined up respectively with the
    "X Axis" and "Y Axis" of the 3D coordinate system, Pos.

    :type Pos: OCC.wrapper.gp.gp_Ax2
    :type Prb: OCC.wrapper.gp.gp_Parab2d
    :rtype: OCC.wrapper.gp.gp_Parab

    """
    return _ElCLib.ElCLib__To3d(*args)




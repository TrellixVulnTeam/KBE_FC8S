# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IGESControl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IGESControl')
    _IGESControl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IGESControl', [dirname(__file__)])
        except ImportError:
            import _IGESControl
            return _IGESControl
        try:
            _mod = imp.load_module('_IGESControl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IGESControl = swig_import_helper()
    del swig_import_helper
else:
    import _IGESControl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IGESControl.delete_SwigPyIterator

    def value(self):
        return _IGESControl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IGESControl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IGESControl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IGESControl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IGESControl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IGESControl.SwigPyIterator_copy(self)

    def next(self):
        return _IGESControl.SwigPyIterator_next(self)

    def __next__(self):
        return _IGESControl.SwigPyIterator___next__(self)

    def previous(self):
        return _IGESControl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IGESControl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IGESControl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IGESControl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IGESControl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IGESControl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IGESControl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IGESControl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IGESControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IGESControl.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IGESControl.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IGESControl.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IGESControl.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IGESControl.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IGESControl.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IGESControl.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IGESControl.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IGESControl.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IGESControl.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IGESControl.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IGESControl.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IGESControl.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IGESControl.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IGESControl.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IGESControl.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IGESControl.ptr_to_number(item)
ptr_to_number = _IGESControl.ptr_to_number

def HashCode(*args):
    return _IGESControl.HashCode(*args)
HashCode = _IGESControl.HashCode

def ptr_equal(a, b):
    return _IGESControl.ptr_equal(a, b)
ptr_equal = _IGESControl.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IGESData
else:
    import IGESData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XSControl
else:
    import XSControl
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IGESToBRep
else:
    import IGESToBRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IGESSolid
else:
    import IGESSolid
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IGESGeom
else:
    import IGESGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IGESBasic
else:
    import IGESBasic
del _swig_python_version_info
class IGESControl_Controller(XSControl.XSControl_Controller):
    """Controller for IGES-5.1"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IGESControl_Controller
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IGESControl_Controller(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IGESControl_Controller self, Standard_Boolean const modefnes) -> IGESControl_Controller

        Initializes the use of IGES Norm (the first time) and returns
        a Controller for IGES-5.1
        If <modefnes> is True, sets it to internal FNES format

        :type modefnes: bool

        """
        this = _IGESControl.new_IGESControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewModel(self, *args):
        """
        NewModel(IGESControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm.
        It is taken from IGES Template Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IGESControl.IGESControl_Controller_NewModel(self, *args)


    def ActorRead(self, *args):
        """
        ActorRead(IGESControl_Controller self, Handle_Interface_InterfaceModel model) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor for Read attached to the pair (norm,appli)
        It is an Actor from IGESToBRep, adapted from an IGESModel :
        Unit, tolerances

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _IGESControl.IGESControl_Controller_ActorRead(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(IGESControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to the InterfaceModel
        (already created by NewModel for instance)
        <modetrans> is to be interpreted by each kind of XstepAdaptor
        Returns a status : 0 OK  1 No result  2 Fail  -1 bad modeshape
        -2 bad model (requires an IGESModel)
        modeshape : 0  groupe of face (version < 5.1)
        1  BREP-version 5.1 of IGES

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IGESControl.IGESControl_Controller_TransferWriteShape(self, *args)


    def Init(*args):
        """
        Init() -> Standard_Boolean

        Standard Initialisation. It creates a Controller for IGES and
        records it to various names, available to select it later
        Returns True when done, False if could not be done
        Also, it creates and records an Adaptor for FNES

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_Controller_Init(*args)

    Init = staticmethod(Init)

    def Customise(self, *args):
        """
        Customise(IGESControl_Controller self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _IGESControl.IGESControl_Controller_Customise(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IGESControl.IGESControl_Controller_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IGESControl.IGESControl_Controller_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.IGESControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IGESControl.delete_IGESControl_Controller
IGESControl_Controller_swigregister = _IGESControl.IGESControl_Controller_swigregister
IGESControl_Controller_swigregister(IGESControl_Controller)

def IGESControl_Controller_Init(*args):
    """
    IGESControl_Controller_Init() -> Standard_Boolean

    Standard Initialisation. It creates a Controller for IGES and
    records it to various names, available to select it later
    Returns True when done, False if could not be done
    Also, it creates and records an Adaptor for FNES

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IGESControl.IGESControl_Controller_Init(*args)

def IGESControl_Controller_get_type_name(*args):
    """
    IGESControl_Controller_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IGESControl.IGESControl_Controller_get_type_name(*args)

def IGESControl_Controller_get_type_descriptor(*args):
    """
    IGESControl_Controller_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IGESControl.IGESControl_Controller_get_type_descriptor(*args)

class IGESControl_ToolContainer(IGESToBRep.IGESToBRep_ToolContainer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IGESControl_ToolContainer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IGESControl_ToolContainer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IGESControl_ToolContainer self) -> IGESControl_ToolContainer

        Empty constructor


        """
        this = _IGESControl.new_IGESControl_ToolContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IGESBoundary(self, *args):
        """
        IGESBoundary(IGESControl_ToolContainer self) -> Handle_IGESToBRep_IGESBoundary

        Returns IGESControl_IGESBoundary

        :rtype: OCC.wrapper.IGESToBRep.Handle_IGESToBRep_IGESBoundary

        """
        return _IGESControl.IGESControl_ToolContainer_IGESBoundary(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IGESControl.IGESControl_ToolContainer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IGESControl.IGESControl_ToolContainer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.IGESControl_ToolContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IGESControl.delete_IGESControl_ToolContainer
IGESControl_ToolContainer_swigregister = _IGESControl.IGESControl_ToolContainer_swigregister
IGESControl_ToolContainer_swigregister(IGESControl_ToolContainer)

def IGESControl_ToolContainer_get_type_name(*args):
    """
    IGESControl_ToolContainer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IGESControl.IGESControl_ToolContainer_get_type_name(*args)

def IGESControl_ToolContainer_get_type_descriptor(*args):
    """
    IGESControl_ToolContainer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IGESControl.IGESControl_ToolContainer_get_type_descriptor(*args)

class Handle_IGESControl_ToolContainer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IGESControl_ToolContainer self)

        Nullify the handle


        """
        return _IGESControl.Handle_IGESControl_ToolContainer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IGESControl_ToolContainer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IGESControl_ToolContainer self, IGESControl_ToolContainer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IGESControl_ToolContainer self, Handle_IGESControl_ToolContainer theHandle) -> Handle_IGESControl_ToolContainer
        assign(Handle_IGESControl_ToolContainer self, IGESControl_ToolContainer thePtr) -> Handle_IGESControl_ToolContainer
        assign(Handle_IGESControl_ToolContainer self, Handle_IGESControl_ToolContainer theHandle) -> Handle_IGESControl_ToolContainer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IGESControl_ToolContainer self) -> IGESControl_ToolContainer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IGESControl_ToolContainer self) -> IGESControl_ToolContainer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_ToolContainer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IGESControl_ToolContainer self) -> IGESControl_ToolContainer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IGESControl.Handle_IGESControl_ToolContainer___ref__(self, *args)


    def __hash__(self):
        return _IGESControl.Handle_IGESControl_ToolContainer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IGESControl.Handle_IGESControl_ToolContainer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IGESControl.new_Handle_IGESControl_ToolContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IGESControl.Handle_IGESControl_ToolContainer_DownCast)
    __swig_destroy__ = _IGESControl.delete_Handle_IGESControl_ToolContainer

    def IGESBoundary(self, *args):
        """
        IGESBoundary(Handle_IGESControl_ToolContainer self) -> Handle_IGESToBRep_IGESBoundary

        Returns IGESControl_IGESBoundary

        :rtype: OCC.wrapper.IGESToBRep.Handle_IGESToBRep_IGESBoundary

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_IGESBoundary(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IGESControl_ToolContainer self) -> char const *

        :rtype: const char *

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_ToolContainer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_ToolContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IGESControl_ToolContainer self)

        Memory deallocator for transient classes


        """
        return _IGESControl.Handle_IGESControl_ToolContainer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IGESControl_ToolContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IGESControl_ToolContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IGESControl_ToolContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IGESControl_ToolContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IGESControl_ToolContainer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IGESControl_ToolContainer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IGESControl_ToolContainer self)

        Increments the reference counter of this object


        """
        return _IGESControl.Handle_IGESControl_ToolContainer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IGESControl_ToolContainer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_ToolContainer_DecrementRefCounter(self, *args)

Handle_IGESControl_ToolContainer_swigregister = _IGESControl.Handle_IGESControl_ToolContainer_swigregister
Handle_IGESControl_ToolContainer_swigregister(Handle_IGESControl_ToolContainer)

def Handle_IGESControl_ToolContainer_DownCast(thing):
    return _IGESControl.Handle_IGESControl_ToolContainer_DownCast(thing)
Handle_IGESControl_ToolContainer_DownCast = _IGESControl.Handle_IGESControl_ToolContainer_DownCast

class Handle_IGESControl_Controller(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IGESControl_Controller self)

        Nullify the handle


        """
        return _IGESControl.Handle_IGESControl_Controller_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IGESControl_Controller self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IGESControl.Handle_IGESControl_Controller_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IGESControl_Controller self, IGESControl_Controller thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IGESControl.Handle_IGESControl_Controller_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IGESControl_Controller self, Handle_IGESControl_Controller theHandle) -> Handle_IGESControl_Controller
        assign(Handle_IGESControl_Controller self, IGESControl_Controller thePtr) -> Handle_IGESControl_Controller
        assign(Handle_IGESControl_Controller self, Handle_IGESControl_Controller theHandle) -> Handle_IGESControl_Controller

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IGESControl.Handle_IGESControl_Controller_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IGESControl_Controller self) -> IGESControl_Controller

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_Controller_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IGESControl_Controller self) -> IGESControl_Controller

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_Controller___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IGESControl_Controller self) -> IGESControl_Controller

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IGESControl.Handle_IGESControl_Controller___ref__(self, *args)


    def __hash__(self):
        return _IGESControl.Handle_IGESControl_Controller___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IGESControl.Handle_IGESControl_Controller___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IGESControl.new_Handle_IGESControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IGESControl.Handle_IGESControl_Controller_DownCast)
    __swig_destroy__ = _IGESControl.delete_Handle_IGESControl_Controller

    def NewModel(self, *args):
        """
        NewModel(Handle_IGESControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm.
        It is taken from IGES Template Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IGESControl.Handle_IGESControl_Controller_NewModel(self, *args)


    def ActorRead(self, *args):
        """
        ActorRead(Handle_IGESControl_Controller self, Handle_Interface_InterfaceModel model) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor for Read attached to the pair (norm,appli)
        It is an Actor from IGESToBRep, adapted from an IGESModel :
        Unit, tolerances

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _IGESControl.Handle_IGESControl_Controller_ActorRead(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(Handle_IGESControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to the InterfaceModel
        (already created by NewModel for instance)
        <modetrans> is to be interpreted by each kind of XstepAdaptor
        Returns a status : 0 OK  1 No result  2 Fail  -1 bad modeshape
        -2 bad model (requires an IGESModel)
        modeshape : 0  groupe of face (version < 5.1)
        1  BREP-version 5.1 of IGES

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IGESControl.Handle_IGESControl_Controller_TransferWriteShape(self, *args)


    def Init(self, *args):
        """
        Init(Handle_IGESControl_Controller self) -> Standard_Boolean

        Standard Initialisation. It creates a Controller for IGES and
        records it to various names, available to select it later
        Returns True when done, False if could not be done
        Also, it creates and records an Adaptor for FNES

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_Init(self, *args)


    def Customise(self, *args):
        """
        Customise(Handle_IGESControl_Controller self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _IGESControl.Handle_IGESControl_Controller_Customise(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IGESControl_Controller self) -> char const *

        :rtype: const char *

        """
        return _IGESControl.Handle_IGESControl_Controller_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_Controller_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNames(self, *args):
        """
        SetNames(Handle_IGESControl_Controller self, Standard_CString const theLongName, Standard_CString const theShortName)

        Changes names
        if a name is empty, the formerly set one remains
        Remark : Does not call Record or AutoRecord

        :type theLongName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString

        """
        return _IGESControl.Handle_IGESControl_Controller_SetNames(self, *args)


    def AutoRecord(self, *args):
        """
        AutoRecord(Handle_IGESControl_Controller self)

        Records <me> is a general dictionary under Short and Long
        Names (see method Name)


        """
        return _IGESControl.Handle_IGESControl_Controller_AutoRecord(self, *args)


    def Record(self, *args):
        """
        Record(Handle_IGESControl_Controller self, Standard_CString const name)

        Records <me> in a general dictionary under a name
        Error if <name> already used for another one

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _IGESControl.Handle_IGESControl_Controller_Record(self, *args)


    def Recorded(self, *args):
        """
        Recorded(Handle_IGESControl_Controller self, Standard_CString const name) -> Handle_XSControl_Controller

        Returns the Controller attached to a given name
        Returns a Null Handle if <name> is unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _IGESControl.Handle_IGESControl_Controller_Recorded(self, *args)


    def Name(self, *args):
        """
        Name(Handle_IGESControl_Controller self, Standard_Boolean const rsc) -> Standard_CString

        Returns a name, as given when initializing :
        rsc = False (D) : True Name attached to the Norm (long name)
        rsc = True : Name of the ressource set (i.e. short name)

        :type rsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IGESControl.Handle_IGESControl_Controller_Name(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol attached to the Norm (from field)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _IGESControl.Handle_IGESControl_Controller_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary attached to the Norm. Remark that it
        has to be in phase with the Protocol  (read from field)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _IGESControl.Handle_IGESControl_Controller_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActorWrite(self, *args):
        """
        ActorWrite(Handle_IGESControl_Controller self) -> Handle_Transfer_ActorOfFinderProcess

        Returns the Actor for Write attached to the pair (norm,appli)
        Read from field. Can be redefined

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfFinderProcess

        """
        return _IGESControl.Handle_IGESControl_Controller_ActorWrite(self, *args)


    def SetModeWrite(self, *args):
        """
        SetModeWrite(Handle_IGESControl_Controller self, Standard_Integer const modemin, Standard_Integer const modemax, Standard_Boolean const shape)

        Sets mininum and maximum values for modetrans (write)
        Erases formerly recorded bounds and values
        Actually only for shape
        Then, for each value a little help can be attached

        :type modemin: int
        :type modemax: int
        :type shape: bool

        """
        return _IGESControl.Handle_IGESControl_Controller_SetModeWrite(self, *args)


    def SetModeWriteHelp(self, *args):
        """
        SetModeWriteHelp(Handle_IGESControl_Controller self, Standard_Integer const modetrans, Standard_CString const help, Standard_Boolean const shape)

        Attaches a short line of help to a value of modetrans (write)

        :type modetrans: int
        :type help: OCC.wrapper.Standard.Standard_CString
        :type shape: bool

        """
        return _IGESControl.Handle_IGESControl_Controller_SetModeWriteHelp(self, *args)


    def ModeWriteBounds(self, *args):
        """
        ModeWriteBounds(Handle_IGESControl_Controller self, Standard_Boolean const shape) -> Standard_Boolean

        Returns recorded min and max values for modetrans (write)
        Actually only for shapes
        Returns True if bounds are set, False else (then, free value)

        :type modemin: int
        :type modemax: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_ModeWriteBounds(self, *args)


    def IsModeWrite(self, *args):
        """
        IsModeWrite(Handle_IGESControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_Boolean

        Tells if a value of <modetrans> is a good value(within bounds)
        Actually only for shapes

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_IsModeWrite(self, *args)


    def ModeWriteHelp(self, *args):
        """
        ModeWriteHelp(Handle_IGESControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_CString

        Returns the help line recorded for a value of modetrans
        empty if help not defined or not within bounds or if values are free

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _IGESControl.Handle_IGESControl_Controller_ModeWriteHelp(self, *args)


    def RecognizeWriteTransient(self, *args):
        """
        RecognizeWriteTransient(Handle_IGESControl_Controller self, Handle_Standard_Transient obj, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if <obj> (an application object) is a valid candidate
        for a transfer to a Model.
        By default, asks the ActorWrite if known (through a
        TransientMapper). Can be redefined

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_RecognizeWriteTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(Handle_IGESControl_Controller self, Handle_Standard_Transient obj, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Transient Object and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        (result is recorded in the model by AddWithRefs)
        FP records produced results and checks

        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        0  OK ,  1 No Result ,  2 Fail (e.g. exception raised)
        -1 bad conditions ,  -2 bad model or null model
        For type of object not recognized : should return 1

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _IGESControl.Handle_IGESControl_Controller_TransferWriteTransient(self, *args)


    def RecognizeWriteShape(self, *args):
        """
        RecognizeWriteShape(Handle_IGESControl_Controller self, TopoDS_Shape shape, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if a shape is valid for a transfer to a model
        Asks the ActorWrite (through a ShapeMapper)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_RecognizeWriteShape(self, *args)


    def AddSessionItem(self, *args):
        """
        AddSessionItem(Handle_IGESControl_Controller self, Handle_Standard_Transient theItem, Standard_CString const theName, Standard_Boolean const toApply)

        Records a Session Item, to be added for customisation of the Work Session.
        It must have a specific name.
        <setapplied> is used if <item> is a GeneralModifier, to decide
        If set to true, <item> will be applied to the hook list "send".
        Else, it is not applied to any hook list.
        Remark : this method is to be called at Create time,
        the recorded items will be used by Customise
        Warning : if <name> conflicts, the last recorded item is kept

        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theName: OCC.wrapper.Standard.Standard_CString
        :type toApply: bool

        """
        return _IGESControl.Handle_IGESControl_Controller_AddSessionItem(self, *args)


    def SessionItem(self, *args):
        """
        SessionItem(Handle_IGESControl_Controller self, Standard_CString const theName) -> Handle_Standard_Transient

        Returns an item given its name to record in a Session
        If <name> is unknown, returns a Null Handle

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_Controller_SessionItem(self, *args)


    def AdaptorSession(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _IGESControl.Handle_IGESControl_Controller_AdaptorSession(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IGESControl_Controller self)

        Memory deallocator for transient classes


        """
        return _IGESControl.Handle_IGESControl_Controller_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IGESControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IGESControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IGESControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IGESControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_Controller_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IGESControl_Controller self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_Controller_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IGESControl_Controller self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_Controller_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IGESControl_Controller self)

        Increments the reference counter of this object


        """
        return _IGESControl.Handle_IGESControl_Controller_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IGESControl_Controller self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_Controller_DecrementRefCounter(self, *args)

Handle_IGESControl_Controller_swigregister = _IGESControl.Handle_IGESControl_Controller_swigregister
Handle_IGESControl_Controller_swigregister(Handle_IGESControl_Controller)

def Handle_IGESControl_Controller_DownCast(thing):
    return _IGESControl.Handle_IGESControl_Controller_DownCast(thing)
Handle_IGESControl_Controller_DownCast = _IGESControl.Handle_IGESControl_Controller_DownCast

class IGESControl_ActorWrite(Transfer.Transfer_ActorOfFinderProcess):
    """Actor to write Shape to IGES"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IGESControl_ActorWrite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IGESControl_ActorWrite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IGESControl_ActorWrite self) -> IGESControl_ActorWrite

        Actor to write Shape to IGES
        """
        this = _IGESControl.new_IGESControl_ActorWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Recognize(self, *args):
        """
        Recognize(IGESControl_ActorWrite self, Handle_Transfer_Finder start) -> Standard_Boolean

        Recognizes a ShapeMapper

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_ActorWrite_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(IGESControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess FP)

        Transfers Shape to IGES Entities

        ModeTrans may be : 0 -> groups of Faces
        or 1 -> BRep

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _IGESControl.IGESControl_ActorWrite_Transfer(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IGESControl.IGESControl_ActorWrite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IGESControl.IGESControl_ActorWrite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.IGESControl_ActorWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IGESControl.delete_IGESControl_ActorWrite
IGESControl_ActorWrite_swigregister = _IGESControl.IGESControl_ActorWrite_swigregister
IGESControl_ActorWrite_swigregister(IGESControl_ActorWrite)

def IGESControl_ActorWrite_get_type_name(*args):
    """
    IGESControl_ActorWrite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IGESControl.IGESControl_ActorWrite_get_type_name(*args)

def IGESControl_ActorWrite_get_type_descriptor(*args):
    """
    IGESControl_ActorWrite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IGESControl.IGESControl_ActorWrite_get_type_descriptor(*args)

class IGESControl_AlgoContainer(IGESToBRep.IGESToBRep_AlgoContainer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IGESControl_AlgoContainer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IGESControl_AlgoContainer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IGESControl_AlgoContainer self) -> IGESControl_AlgoContainer

        Empty constructor


        """
        this = _IGESControl.new_IGESControl_AlgoContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IGESControl.IGESControl_AlgoContainer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IGESControl.IGESControl_AlgoContainer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.IGESControl_AlgoContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IGESControl.delete_IGESControl_AlgoContainer
IGESControl_AlgoContainer_swigregister = _IGESControl.IGESControl_AlgoContainer_swigregister
IGESControl_AlgoContainer_swigregister(IGESControl_AlgoContainer)

def IGESControl_AlgoContainer_get_type_name(*args):
    """
    IGESControl_AlgoContainer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IGESControl.IGESControl_AlgoContainer_get_type_name(*args)

def IGESControl_AlgoContainer_get_type_descriptor(*args):
    """
    IGESControl_AlgoContainer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IGESControl.IGESControl_AlgoContainer_get_type_descriptor(*args)

class Handle_IGESControl_ActorWrite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IGESControl_ActorWrite self)

        Nullify the handle


        """
        return _IGESControl.Handle_IGESControl_ActorWrite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IGESControl_ActorWrite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IGESControl_ActorWrite self, IGESControl_ActorWrite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IGESControl_ActorWrite self, Handle_IGESControl_ActorWrite theHandle) -> Handle_IGESControl_ActorWrite
        assign(Handle_IGESControl_ActorWrite self, IGESControl_ActorWrite thePtr) -> Handle_IGESControl_ActorWrite
        assign(Handle_IGESControl_ActorWrite self, Handle_IGESControl_ActorWrite theHandle) -> Handle_IGESControl_ActorWrite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IGESControl_ActorWrite self) -> IGESControl_ActorWrite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IGESControl_ActorWrite self) -> IGESControl_ActorWrite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_ActorWrite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IGESControl_ActorWrite self) -> IGESControl_ActorWrite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IGESControl.Handle_IGESControl_ActorWrite___ref__(self, *args)


    def __hash__(self):
        return _IGESControl.Handle_IGESControl_ActorWrite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IGESControl.Handle_IGESControl_ActorWrite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IGESControl.new_Handle_IGESControl_ActorWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IGESControl.Handle_IGESControl_ActorWrite_DownCast)
    __swig_destroy__ = _IGESControl.delete_Handle_IGESControl_ActorWrite

    def Recognize(self, *args):
        """
        Recognize(Handle_IGESControl_ActorWrite self, Handle_Transfer_Finder start) -> Standard_Boolean

        Recognizes a ShapeMapper

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_IGESControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess FP)

        Transfers Shape to IGES Entities

        ModeTrans may be : 0 -> groups of Faces
        or 1 -> BRep

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_Transfer(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IGESControl_ActorWrite self) -> char const *

        :rtype: const char *

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_ActorWrite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_ActorWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModeTrans(self, *args):
        """
        ModeTrans(Handle_IGESControl_ActorWrite self) -> Standard_Integer &

        Returns the Transfer Mode, modifiable

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_ModeTrans(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_IGESControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_Transferring(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_IGESControl_ActorWrite self, Handle_Standard_Transient start, Handle_Transfer_FinderProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_TransferTransient(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_IGESControl_ActorWrite self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_IGESControl_ActorWrite self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_IGESControl_ActorWrite self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_IGESControl_ActorWrite self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_IGESControl_ActorWrite self, Handle_Transfer_ActorOfProcessForFinder next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_IGESControl_ActorWrite self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IGESControl_ActorWrite self)

        Memory deallocator for transient classes


        """
        return _IGESControl.Handle_IGESControl_ActorWrite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IGESControl_ActorWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IGESControl_ActorWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IGESControl_ActorWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IGESControl_ActorWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IGESControl_ActorWrite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IGESControl_ActorWrite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IGESControl_ActorWrite self)

        Increments the reference counter of this object


        """
        return _IGESControl.Handle_IGESControl_ActorWrite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IGESControl_ActorWrite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_ActorWrite_DecrementRefCounter(self, *args)

Handle_IGESControl_ActorWrite_swigregister = _IGESControl.Handle_IGESControl_ActorWrite_swigregister
Handle_IGESControl_ActorWrite_swigregister(Handle_IGESControl_ActorWrite)

def Handle_IGESControl_ActorWrite_DownCast(thing):
    return _IGESControl.Handle_IGESControl_ActorWrite_DownCast(thing)
Handle_IGESControl_ActorWrite_DownCast = _IGESControl.Handle_IGESControl_ActorWrite_DownCast

class Handle_IGESControl_AlgoContainer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IGESControl_AlgoContainer self)

        Nullify the handle


        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IGESControl_AlgoContainer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IGESControl_AlgoContainer self, IGESControl_AlgoContainer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IGESControl_AlgoContainer self, Handle_IGESControl_AlgoContainer theHandle) -> Handle_IGESControl_AlgoContainer
        assign(Handle_IGESControl_AlgoContainer self, IGESControl_AlgoContainer thePtr) -> Handle_IGESControl_AlgoContainer
        assign(Handle_IGESControl_AlgoContainer self, Handle_IGESControl_AlgoContainer theHandle) -> Handle_IGESControl_AlgoContainer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IGESControl_AlgoContainer self) -> IGESControl_AlgoContainer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IGESControl_AlgoContainer self) -> IGESControl_AlgoContainer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IGESControl_AlgoContainer self) -> IGESControl_AlgoContainer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer___ref__(self, *args)


    def __hash__(self):
        return _IGESControl.Handle_IGESControl_AlgoContainer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IGESControl.Handle_IGESControl_AlgoContainer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IGESControl.new_Handle_IGESControl_AlgoContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IGESControl.Handle_IGESControl_AlgoContainer_DownCast)
    __swig_destroy__ = _IGESControl.delete_Handle_IGESControl_AlgoContainer

    def get_type_name(self, *args):
        """
        get_type_name(Handle_IGESControl_AlgoContainer self) -> char const *

        :rtype: const char *

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_AlgoContainer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_AlgoContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetToolContainer(self, *args):
        """
        SetToolContainer(Handle_IGESControl_AlgoContainer self, Handle_IGESToBRep_ToolContainer TC)

        Sets ToolContainer

        :type TC: OCC.wrapper.IGESToBRep.Handle_IGESToBRep_ToolContainer

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_SetToolContainer(self, *args)


    def ToolContainer(self, *args):
        """
        ToolContainer(Handle_IGESControl_AlgoContainer self) -> Handle_IGESToBRep_ToolContainer

        Returns ToolContainer

        :rtype: OCC.wrapper.IGESToBRep.Handle_IGESToBRep_ToolContainer

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_ToolContainer(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IGESControl_AlgoContainer self)

        Memory deallocator for transient classes


        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IGESControl_AlgoContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IGESControl_AlgoContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IGESControl_AlgoContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IGESControl_AlgoContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IGESControl_AlgoContainer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IGESControl_AlgoContainer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IGESControl_AlgoContainer self)

        Increments the reference counter of this object


        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IGESControl_AlgoContainer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_AlgoContainer_DecrementRefCounter(self, *args)

Handle_IGESControl_AlgoContainer_swigregister = _IGESControl.Handle_IGESControl_AlgoContainer_swigregister
Handle_IGESControl_AlgoContainer_swigregister(Handle_IGESControl_AlgoContainer)

def Handle_IGESControl_AlgoContainer_DownCast(thing):
    return _IGESControl.Handle_IGESControl_AlgoContainer_DownCast(thing)
Handle_IGESControl_AlgoContainer_DownCast = _IGESControl.Handle_IGESControl_AlgoContainer_DownCast

class IGESControl_Writer(object):
    """
    This class creates and writes
    IGES files from CAS.CADE models. An IGES file can be written to
    an existing IGES file or to a new one.
    The translation can be performed in one or several
    operations. Each translation operation
    outputs a distinct root entity in the IGES file.
    To write an IGES file it is possible to use the following sequence:
    To modify the IGES file header or to change translation
    parameters it is necessary to use class Interface_Static (see
    IGESParameters and GeneralParameters).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IGESControl_Writer self) -> IGESControl_Writer
        __init__(IGESControl_Writer self, Standard_CString const unit, Standard_Integer const modecr=0) -> IGESControl_Writer
        __init__(IGESControl_Writer self, Handle_IGESData_IGESModel model, Standard_Integer const modecr=0) -> IGESControl_Writer

        Creates a writer object with the
        prepared IGES model model in write mode.
        modecr defines the write mode and may be:
        - 0: Faces (default)
        - 1: BRep.

        :type model: OCC.wrapper.IGESData.Handle_IGESData_IGESModel
        :type modecr: int

        """
        this = _IGESControl.new_IGESControl_Writer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args):
        """
        Returns the IGES model to be written in output.

        :rtype: OCC.wrapper.IGESData.Handle_IGESData_IGESModel

        """
        res = _IGESControl.IGESControl_Writer_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransferProcess(self, *args):
        """
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        res = _IGESControl.IGESControl_Writer_TransferProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransferProcess(self, *args):
        """
        SetTransferProcess(IGESControl_Writer self, Handle_Transfer_FinderProcess TP)

        Returns/Sets the TransferProcess : it contains final results
        and if some, check messages

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        return _IGESControl.IGESControl_Writer_SetTransferProcess(self, *args)


    def AddShape(self, *args):
        """
        AddShape(IGESControl_Writer self, TopoDS_Shape sh) -> Standard_Boolean

        Translates a Shape to IGES Entities and adds them to the model
        Returns True if done, False if Shape not suitable for IGES or null

        :type sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_Writer_AddShape(self, *args)


    def AddGeom(self, *args):
        """
        AddGeom(IGESControl_Writer self, Handle_Standard_Transient geom) -> Standard_Boolean

        Translates a Geometry (Surface or Curve) to IGES Entities and
        adds them to the model
        Returns True if done, False if geom is neither a Surface or
        a Curve suitable for IGES or is null

        :type geom: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_Writer_AddGeom(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(IGESControl_Writer self, Handle_IGESData_IGESEntity ent) -> Standard_Boolean

        Adds an IGES entity (and the ones it references) to the model

        :type ent: OCC.wrapper.IGESData.Handle_IGESData_IGESEntity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_Writer_AddEntity(self, *args)


    def ComputeModel(self, *args):
        """
        ComputeModel(IGESControl_Writer self)

        Computes the entities found in
        the model, which is ready to be written.
        This contrasts with the default computation of headers only.


        """
        return _IGESControl.IGESControl_Writer_ComputeModel(self, *args)


    def Write(self, *args):
        """
        Write(IGESControl_Writer self, Standard_OStream & S, Standard_Boolean const fnes) -> Standard_Boolean
        Write(IGESControl_Writer self, Standard_CString const file, Standard_Boolean const fnes) -> Standard_Boolean

        Prepares and writes an IGES model
        either to an OStream, S or to a file name,CString.
        Returns True if the operation was performed correctly and
        False if an error occurred (for instance,
        if the processor could not create the file).

        :type file: OCC.wrapper.Standard.Standard_CString
        :type fnes: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_Writer_Write(self, *args)

    __swig_destroy__ = _IGESControl.delete_IGESControl_Writer
IGESControl_Writer_swigregister = _IGESControl.IGESControl_Writer_swigregister
IGESControl_Writer_swigregister(IGESControl_Writer)

class IGESControl_IGESBoundary(IGESToBRep.IGESToBRep_IGESBoundary):
    """
    Translates IGES boundary entity (types 141, 142 and 508)
    in Advanced Data Exchange.
    Redefines translation and treatment methods from inherited
    open class IGESToBRep_IGESBoundary.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IGESControl_IGESBoundary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IGESControl_IGESBoundary(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IGESControl_IGESBoundary self) -> IGESControl_IGESBoundary
        __init__(IGESControl_IGESBoundary self, IGESToBRep_CurveAndSurface CS) -> IGESControl_IGESBoundary

        Creates an object and calls inherited constuctor.

        :type CS: OCC.wrapper.IGESToBRep.IGESToBRep_CurveAndSurface

        """
        this = _IGESControl.new_IGESControl_IGESBoundary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Check(self, *args):
        """
        Check(IGESControl_IGESBoundary self, Standard_Boolean const result, Standard_Boolean const checkclosure, Standard_Boolean const okCurve3d, Standard_Boolean const okCurve2d)

        Checks result of translation of IGES boundary entities
        (types 141, 142 or 508).
        Checks consistency of 2D and 3D representations and keeps
        only one if they are inconsistent.
        Checks the closure of resulting wire and if it is not closed,
        checks 2D and 3D representation and updates the resulting
        wire to contain only closed representation.

        :type result: bool
        :type checkclosure: bool
        :type okCurve3d: bool
        :type okCurve2d: bool

        """
        return _IGESControl.IGESControl_IGESBoundary_Check(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IGESControl.IGESControl_IGESBoundary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IGESControl.IGESControl_IGESBoundary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.IGESControl_IGESBoundary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IGESControl.delete_IGESControl_IGESBoundary
IGESControl_IGESBoundary_swigregister = _IGESControl.IGESControl_IGESBoundary_swigregister
IGESControl_IGESBoundary_swigregister(IGESControl_IGESBoundary)

def IGESControl_IGESBoundary_get_type_name(*args):
    """
    IGESControl_IGESBoundary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IGESControl.IGESControl_IGESBoundary_get_type_name(*args)

def IGESControl_IGESBoundary_get_type_descriptor(*args):
    """
    IGESControl_IGESBoundary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IGESControl.IGESControl_IGESBoundary_get_type_descriptor(*args)

class Handle_IGESControl_IGESBoundary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IGESControl_IGESBoundary self)

        Nullify the handle


        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IGESControl_IGESBoundary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IGESControl_IGESBoundary self, IGESControl_IGESBoundary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IGESControl_IGESBoundary self, Handle_IGESControl_IGESBoundary theHandle) -> Handle_IGESControl_IGESBoundary
        assign(Handle_IGESControl_IGESBoundary self, IGESControl_IGESBoundary thePtr) -> Handle_IGESControl_IGESBoundary
        assign(Handle_IGESControl_IGESBoundary self, Handle_IGESControl_IGESBoundary theHandle) -> Handle_IGESControl_IGESBoundary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IGESControl_IGESBoundary self) -> IGESControl_IGESBoundary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IGESControl_IGESBoundary self) -> IGESControl_IGESBoundary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IGESControl_IGESBoundary self) -> IGESControl_IGESBoundary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary___ref__(self, *args)


    def __hash__(self):
        return _IGESControl.Handle_IGESControl_IGESBoundary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IGESControl.Handle_IGESControl_IGESBoundary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IGESControl.new_Handle_IGESControl_IGESBoundary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IGESControl.Handle_IGESControl_IGESBoundary_DownCast)
    __swig_destroy__ = _IGESControl.delete_Handle_IGESControl_IGESBoundary

    def Check(self, *args):
        """
        Check(Handle_IGESControl_IGESBoundary self, Standard_Boolean const result, Standard_Boolean const checkclosure, Standard_Boolean const okCurve3d, Standard_Boolean const okCurve2d)

        Checks result of translation of IGES boundary entities
        (types 141, 142 or 508).
        Checks consistency of 2D and 3D representations and keeps
        only one if they are inconsistent.
        Checks the closure of resulting wire and if it is not closed,
        checks 2D and 3D representation and updates the resulting
        wire to contain only closed representation.

        :type result: bool
        :type checkclosure: bool
        :type okCurve3d: bool
        :type okCurve2d: bool

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_Check(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IGESControl_IGESBoundary self) -> char const *

        :rtype: const char *

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_IGESBoundary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IGESControl.Handle_IGESControl_IGESBoundary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_IGESControl_IGESBoundary self, IGESToBRep_CurveAndSurface CS, Handle_IGESData_IGESEntity entity, TopoDS_Face face, gp_Trsf2d trans, Standard_Real const uFact, Standard_Integer const filepreference)

        Inits the object with parameters common for all
        types of IGES boundaries.
        <CS>: object to be used for retrieving translation parameters
        and sending messages,
        <entity>: boundary entity to be processed,
        <face>, <trans>, <uFact>: as for IGESToBRep_TopoCurve
        <filepreference>: preferred representation (2 or 3) given
        in the IGES file

        :type CS: OCC.wrapper.IGESToBRep.IGESToBRep_CurveAndSurface
        :type entity: OCC.wrapper.IGESData.Handle_IGESData_IGESEntity
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type trans: OCC.wrapper.gp.gp_Trsf2d
        :type uFact: float
        :type filepreference: int

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_Init(self, *args)


    def WireData(self, *args):
        """
        WireData(Handle_IGESControl_IGESBoundary self) -> Handle_ShapeExtend_WireData

        Returns the resulting wire

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_WireData(self, *args)


    def WireData3d(self, *args):
        """
        WireData3d(Handle_IGESControl_IGESBoundary self) -> Handle_ShapeExtend_WireData

        Returns the wire from 3D curves (edges contain 3D curves
        and may contain pcurves)

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_WireData3d(self, *args)


    def WireData2d(self, *args):
        """
        WireData2d(Handle_IGESControl_IGESBoundary self) -> Handle_ShapeExtend_WireData

        Returns the the wire from 2D curves (edges contain pcurves
        only)

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_WireData2d(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IGESControl_IGESBoundary self)

        Memory deallocator for transient classes


        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IGESControl_IGESBoundary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IGESControl_IGESBoundary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IGESControl_IGESBoundary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IGESControl_IGESBoundary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IGESControl_IGESBoundary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IGESControl_IGESBoundary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IGESControl_IGESBoundary self)

        Increments the reference counter of this object


        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IGESControl_IGESBoundary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.Handle_IGESControl_IGESBoundary_DecrementRefCounter(self, *args)

Handle_IGESControl_IGESBoundary_swigregister = _IGESControl.Handle_IGESControl_IGESBoundary_swigregister
Handle_IGESControl_IGESBoundary_swigregister(Handle_IGESControl_IGESBoundary)

def Handle_IGESControl_IGESBoundary_DownCast(thing):
    return _IGESControl.Handle_IGESControl_IGESBoundary_DownCast(thing)
Handle_IGESControl_IGESBoundary_DownCast = _IGESControl.Handle_IGESControl_IGESBoundary_DownCast

class IGESControl_Reader(XSControl.XSControl_Reader):
    """
    Reads IGES files, checks them and translates their contents into Open CASCADE models.
    The IGES data can be that of a whole model or that of a specific list of entities in the model.
    As in XSControl_Reader, you specify the list using a selection.
    For translation of iges files it is possible to use the following sequence:
    To change parameters of translation
    class Interface_Static should be used before the beginning of translation
    (see IGES Parameters and General Parameters)
    Creation of reader
    IGESControl_Reader reader;
    To load a file in a model use method:
    reader.ReadFile("filename.igs")
    To check a loading file use method Check:
    reader.Check(failsonly); where failsonly is equal to Standard_True or
    Standard_False;
    To print the results of load:
    reader.PrintCheckLoad(failsonly,mode) where mode is equal to the value of
    enumeration IFSelect_PrintCount
    To transfer entities from a model the following methods can be used:
    for the whole model
    reader.TransferRoots(onlyvisible); where onlyvisible is equal to
    Standard_True or Standard_False;
    To transfer a list of entities:
    reader.TransferList(list);
    To transfer one entity
    reader.TransferEntity(ent) or reader.Transfer(num);
    To obtain a result the following method can be used:
    reader.IsDone()
    reader.NbShapes() and reader.Shape(num); or reader.OneShape();
    To print the results of transfer use method:
    reader.PrintTransferInfo(failwarn,mode); where printfail is equal to the
    value of enumeration IFSelect_PrintFail, mode see above.
    Gets correspondence between an IGES entity and a result shape obtained therefrom.
    reader.TransientProcess();
    TopoDS_Shape shape =
    TransferBRep::ShapeResult(reader.TransientProcess(),ent);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IGESControl_Reader self) -> IGESControl_Reader
        __init__(IGESControl_Reader self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> IGESControl_Reader

        Creates a Reader from an already existing Session

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _IGESControl.new_IGESControl_Reader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetReadVisible(self, *args):
        """
        SetReadVisible(IGESControl_Reader self, Standard_Boolean const ReadRoot)

        Set the transion of ALL Roots (if theReadOnlyVisible is False)
        or of Visible Roots (if theReadOnlyVisible is True)

        :type ReadRoot: bool

        """
        return _IGESControl.IGESControl_Reader_SetReadVisible(self, *args)


    def GetReadVisible(self, *args):
        """
        GetReadVisible(IGESControl_Reader self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IGESControl.IGESControl_Reader_GetReadVisible(self, *args)


    def IGESModel(self, *args):
        """
        IGESModel(IGESControl_Reader self) -> Handle_IGESData_IGESModel

        Returns the model as a IGESModel.
        It can then be consulted (header, product)

        :rtype: OCC.wrapper.IGESData.Handle_IGESData_IGESModel

        """
        return _IGESControl.IGESControl_Reader_IGESModel(self, *args)


    def NbRootsForTransfer(self, *args):
        """
        NbRootsForTransfer(IGESControl_Reader self) -> Standard_Integer

        Determines the list of root entities from Model which are candidate for
        a transfer to a Shape (type of entities is PRODUCT)
        <theReadOnlyVisible> is taken into account to define roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IGESControl.IGESControl_Reader_NbRootsForTransfer(self, *args)


    def PrintTransferInfo(self, *args):
        """
        PrintTransferInfo(IGESControl_Reader self, IFSelect_PrintFail const failwarn, IFSelect_PrintCount const mode)

        Prints Statistics and check list for Transfer

        :type failwarn: OCC.wrapper.IFSelect.IFSelect_PrintFail
        :type mode: OCC.wrapper.IFSelect.IFSelect_PrintCount

        """
        return _IGESControl.IGESControl_Reader_PrintTransferInfo(self, *args)

    __swig_destroy__ = _IGESControl.delete_IGESControl_Reader
IGESControl_Reader_swigregister = _IGESControl.IGESControl_Reader_swigregister
IGESControl_Reader_swigregister(IGESControl_Reader)




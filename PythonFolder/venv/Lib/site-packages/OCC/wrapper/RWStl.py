# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_RWStl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_RWStl')
    _RWStl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_RWStl', [dirname(__file__)])
        except ImportError:
            import _RWStl
            return _RWStl
        try:
            _mod = imp.load_module('_RWStl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _RWStl = swig_import_helper()
    del swig_import_helper
else:
    import _RWStl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _RWStl.delete_SwigPyIterator

    def value(self):
        return _RWStl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _RWStl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _RWStl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _RWStl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _RWStl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _RWStl.SwigPyIterator_copy(self)

    def next(self):
        return _RWStl.SwigPyIterator_next(self)

    def __next__(self):
        return _RWStl.SwigPyIterator___next__(self)

    def previous(self):
        return _RWStl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _RWStl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _RWStl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _RWStl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _RWStl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _RWStl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _RWStl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _RWStl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _RWStl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _RWStl.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_RWStl.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _RWStl.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _RWStl.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _RWStl.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _RWStl.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _RWStl.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _RWStl.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _RWStl.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_RWStl.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _RWStl.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _RWStl.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _RWStl.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _RWStl.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _RWStl.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _RWStl.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _RWStl.ptr_to_number(item)
ptr_to_number = _RWStl.ptr_to_number

def HashCode(*args):
    return _RWStl.HashCode(*args)
HashCode = _RWStl.HashCode

def ptr_equal(a, b):
    return _RWStl.ptr_equal(a, b)
ptr_equal = _RWStl.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class RWStl_(object):
    """This class provides methods to read and write triangulation from / to the STL files."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def WriteBinary(*args):
        """
        WriteBinary(Handle_Poly_Triangulation theMesh, OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Standard_Boolean

        Write triangulation to binary STL file.
        binary format of an STL file.
        Returns false if the cannot be opened;

        :type theMesh: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type thePath: OCC.wrapper.OSD.OSD_Path
        :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWStl.RWStl__WriteBinary(*args)

    WriteBinary = staticmethod(WriteBinary)

    def WriteAscii(*args):
        """
        WriteAscii(Handle_Poly_Triangulation theMesh, OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Standard_Boolean

        write the meshing in a file following the
        Ascii  format of an STL file.
        Returns false if the cannot be opened;

        :type theMesh: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type thePath: OCC.wrapper.OSD.OSD_Path
        :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWStl.RWStl__WriteAscii(*args)

    WriteAscii = staticmethod(WriteAscii)

    def ReadFile(*args):
        """
        ReadFile(OSD_Path theFile, Handle_Message_ProgressIndicator aProgInd) -> Handle_Poly_Triangulation
        ReadFile(Standard_CString const theFile, Handle_Message_ProgressIndicator aProgInd) -> Handle_Poly_Triangulation

        Read specified STL file and returns its content as triangulation.
        In case of error, returns Null handle.

        :type theFile: OCC.wrapper.Standard.Standard_CString
        :type aProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _RWStl.RWStl__ReadFile(*args)

    ReadFile = staticmethod(ReadFile)

    def ReadBinary(*args):
        """
        ReadBinary(OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Handle_Poly_Triangulation

        Read triangulation from a binary STL file
        In case of error, returns Null handle.

        :type thePath: OCC.wrapper.OSD.OSD_Path
        :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _RWStl.RWStl__ReadBinary(*args)

    ReadBinary = staticmethod(ReadBinary)

    def ReadAscii(*args):
        """
        ReadAscii(OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Handle_Poly_Triangulation

        Read triangulation from an Ascii STL file
        In case of error, returns Null handle.

        :type thePath: OCC.wrapper.OSD.OSD_Path
        :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _RWStl.RWStl__ReadAscii(*args)

    ReadAscii = staticmethod(ReadAscii)

    def __init__(self):
        """This class provides methods to read and write triangulation from / to the STL files."""
        this = _RWStl.new_RWStl_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _RWStl.delete_RWStl_
RWStl__swigregister = _RWStl.RWStl__swigregister
RWStl__swigregister(RWStl_)

def RWStl__WriteBinary(*args):
    """
    RWStl__WriteBinary(Handle_Poly_Triangulation theMesh, OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Standard_Boolean

    Write triangulation to binary STL file.
    binary format of an STL file.
    Returns false if the cannot be opened;

    :type theMesh: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type thePath: OCC.wrapper.OSD.OSD_Path
    :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _RWStl.RWStl__WriteBinary(*args)

def RWStl__WriteAscii(*args):
    """
    RWStl__WriteAscii(Handle_Poly_Triangulation theMesh, OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Standard_Boolean

    write the meshing in a file following the
    Ascii  format of an STL file.
    Returns false if the cannot be opened;

    :type theMesh: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type thePath: OCC.wrapper.OSD.OSD_Path
    :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _RWStl.RWStl__WriteAscii(*args)

def RWStl__ReadFile(*args):
    """
    ReadFile(OSD_Path theFile, Handle_Message_ProgressIndicator aProgInd) -> Handle_Poly_Triangulation
    RWStl__ReadFile(Standard_CString const theFile, Handle_Message_ProgressIndicator aProgInd) -> Handle_Poly_Triangulation

    Read specified STL file and returns its content as triangulation.
    In case of error, returns Null handle.

    :type theFile: OCC.wrapper.Standard.Standard_CString
    :type aProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _RWStl.RWStl__ReadFile(*args)

def RWStl__ReadBinary(*args):
    """
    RWStl__ReadBinary(OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Handle_Poly_Triangulation

    Read triangulation from a binary STL file
    In case of error, returns Null handle.

    :type thePath: OCC.wrapper.OSD.OSD_Path
    :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _RWStl.RWStl__ReadBinary(*args)

def RWStl__ReadAscii(*args):
    """
    RWStl__ReadAscii(OSD_Path thePath, Handle_Message_ProgressIndicator theProgInd) -> Handle_Poly_Triangulation

    Read triangulation from an Ascii STL file
    In case of error, returns Null handle.

    :type thePath: OCC.wrapper.OSD.OSD_Path
    :type theProgInd: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _RWStl.RWStl__ReadAscii(*args)

class RWStl_Reader(Standard.Standard_Transient):
    """
    An abstract class implementing procedure to read STL file.

    This class is not bound to particular data structure and can be used to read the file directly into arbitrary data model.
    To use it, create descendant class and implement methods addNode() and addTriangle().

    Call method Read() to read the file. In the process of reading, the tool will call methods addNode() and addTriangle() to fill the mesh data structure.

    The nodes with equal coordinates are merged automatically  on the fly.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_RWStl_Reader
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_RWStl_Reader(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _RWStl.RWStl_Reader_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _RWStl.RWStl_Reader_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWStl.RWStl_Reader_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Read(self, *args):
        """
        Read(RWStl_Reader self, char const * theFile, Handle_Message_ProgressIndicator theProgress) -> Standard_Boolean

        Reads data from STL file (either binary or Ascii).
        This function supports reading multi-domain STL files formed by concatenation of several "plain" files.
        The mesh nodes are not merged between domains.
        Unicode paths can be given in UTF-8 encoding.
        Format is recognized automatically by analysis of the file header.
        Returns true if success, false on error or user break.

        :type theFile: const char *
        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWStl.RWStl_Reader_Read(self, *args)


    def IsAscii(self, *args):
        """
        IsAscii(RWStl_Reader self, Standard_IStream & theStream) -> Standard_Boolean

        Guess whether the stream is an Ascii STL file, by analysis of the first bytes (~200).
        The function attempts to put back the read symbols to the stream which thus must support ungetc().
        Returns true if the stream seems to contain Ascii STL.

        :type theStream: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWStl.RWStl_Reader_IsAscii(self, *args)


    def ReadBinary(self, *args):
        """
        ReadBinary(RWStl_Reader self, Standard_IStream & theStream, Handle_Message_ProgressIndicator theProgress) -> Standard_Boolean

        Reads STL data from binary stream.
        The stream must be opened in binary mode.
        Stops after reading the number of triangles recorded in the file header.
        Returns true if success, false on error or user break.

        :type theStream: OCC.wrapper.Standard.Standard_IStream
        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWStl.RWStl_Reader_ReadBinary(self, *args)


    def ReadAscii(self, *args):
        """
        ReadAscii(RWStl_Reader self, Standard_IStream & theStream, std::streampos const theUntilPos, Handle_Message_ProgressIndicator theProgress) -> Standard_Boolean

        Reads data from the stream assumed to contain Ascii STL data.
        The stream can be opened either in binary or in Ascii mode.
        Reading stops at the position specified by theUntilPos,
        or end of file is reached, or when keyword "endsolid" is found.
        Empty lines are not supported and will read to reading failure.
        If theUntilPos is non-zero, reads not more than until that position.
        Returns true if success, false on error or user break.

        :type theStream: OCC.wrapper.Standard.Standard_IStream
        :type theUntilPos: streampos
        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWStl.RWStl_Reader_ReadAscii(self, *args)


    def AddNode(self, *args):
        """
        AddNode(RWStl_Reader self, gp_XYZ thePnt) -> Standard_Integer

        Callback function to be implemented in descendant.
        Should create new node with specified coordinates in the target model, and return its ID as integer.

        :type thePnt: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWStl.RWStl_Reader_AddNode(self, *args)


    def AddTriangle(self, *args):
        """
        AddTriangle(RWStl_Reader self, Standard_Integer theN1, Standard_Integer theN2, Standard_Integer theN3)

        Callback function to be implemented in descendant.
        Should create new triangle built on specified nodes in the target model.

        :type theN1: int
        :type theN2: int
        :type theN3: int

        """
        return _RWStl.RWStl_Reader_AddTriangle(self, *args)

    __swig_destroy__ = _RWStl.delete_RWStl_Reader
RWStl_Reader_swigregister = _RWStl.RWStl_Reader_swigregister
RWStl_Reader_swigregister(RWStl_Reader)

def RWStl_Reader_get_type_name(*args):
    """
    RWStl_Reader_get_type_name() -> char const *

    :rtype: const char *

    """
    return _RWStl.RWStl_Reader_get_type_name(*args)

def RWStl_Reader_get_type_descriptor(*args):
    """
    RWStl_Reader_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _RWStl.RWStl_Reader_get_type_descriptor(*args)




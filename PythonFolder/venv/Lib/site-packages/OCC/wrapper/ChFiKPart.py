# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ChFiKPart')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ChFiKPart')
    _ChFiKPart = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ChFiKPart', [dirname(__file__)])
        except ImportError:
            import _ChFiKPart
            return _ChFiKPart
        try:
            _mod = imp.load_module('_ChFiKPart', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ChFiKPart = swig_import_helper()
    del swig_import_helper
else:
    import _ChFiKPart
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ChFiKPart.delete_SwigPyIterator

    def value(self):
        return _ChFiKPart.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ChFiKPart.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ChFiKPart.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ChFiKPart.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ChFiKPart.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ChFiKPart.SwigPyIterator_copy(self)

    def next(self):
        return _ChFiKPart.SwigPyIterator_next(self)

    def __next__(self):
        return _ChFiKPart.SwigPyIterator___next__(self)

    def previous(self):
        return _ChFiKPart.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ChFiKPart.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ChFiKPart.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ChFiKPart.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ChFiKPart.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ChFiKPart.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ChFiKPart.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ChFiKPart.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ChFiKPart.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ChFiKPart.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ChFiKPart.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ChFiKPart.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ChFiKPart.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiKPart.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ChFiKPart.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ChFiKPart.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ChFiKPart.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ChFiKPart.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ChFiKPart.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ChFiKPart.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ChFiKPart.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiKPart.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ChFiKPart.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ChFiKPart.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ChFiKPart.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ChFiKPart.ptr_to_number(item)
ptr_to_number = _ChFiKPart.ptr_to_number

def HashCode(*args):
    return _ChFiKPart.HashCode(*args)
HashCode = _ChFiKPart.HashCode

def ptr_equal(a, b):
    return _ChFiKPart.ptr_equal(a, b)
ptr_equal = _ChFiKPart.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepDS
else:
    import TopOpeBRepDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ChFiDS
else:
    import ChFiDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
class NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Adaptor2d_HCurve2d >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Adaptor2d_HCurve2d >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Adaptor2d_HCurve2d >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Adaptor2d_HCurve2d >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _ChFiKPart.new_NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey, Handle_Adaptor2d_HCurve2d theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey, Handle_Adaptor2d_HCurve2d theItem) -> Handle_Adaptor2d_HCurve2d

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_Adaptor2d_HCurve2d

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_Adaptor2d_HCurve2d

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_Adaptor2d_HCurve2d

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _ChFiKPart.delete_NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_swigregister = _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiKPart.new_NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiKPart.delete_NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _ChFiKPart.NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher_IteratorHelper)


try:
	ChFiKPart_RstMap = NCollection_DataMap_Standard_Integer_Handle_Adaptor2d_HCurve2d_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class ChFiKPart_ComputeData(object):
    """
    Methodes de classe   permettant de  remplir    une
    SurfData dans  les cas  particuliers  de  conges
    suivants:
    - cylindre entre 2 surfaces planes,
    - tore/sphere entre un plan et un cylindre othogonal,
    - tore/sphere entre un plan et un cone othogonal,

    - tore entre un plan et une droite orthogonale (rotule).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Compute(*args):
        """
        Compute(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2, Handle_ChFiDS_Spine Sp, Standard_Integer const Iedge) -> Standard_Boolean

        Computes a simple fillet in several particular
        cases.

        :type DStr: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type Data: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData
        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Or1: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Or2: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Sp: OCC.wrapper.ChFiDS.Handle_ChFiDS_Spine
        :type Iedge: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiKPart.ChFiKPart_ComputeData_Compute(*args)

    Compute = staticmethod(Compute)

    def ComputeCorner(*args):
        """
        ComputeCorner(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const OrFace1, TopAbs_Orientation const OrFace2, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2, Standard_Real const minRad, Standard_Real const majRad, gp_Pnt2d P1S1, gp_Pnt2d P2S1, gp_Pnt2d P1S2, gp_Pnt2d P2S2) -> Standard_Boolean
        ComputeCorner(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const OrFace1, TopAbs_Orientation const OrFace2, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2, Standard_Real const Rad, gp_Pnt2d PS1, gp_Pnt2d P1S2, gp_Pnt2d P2S2) -> Standard_Boolean
        ComputeCorner(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const OfS, TopAbs_Orientation const OS, TopAbs_Orientation const OS1, TopAbs_Orientation const OS2, Standard_Real const Radius) -> Standard_Boolean

        Computes a toric corner rotule.

        :type DStr: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type Data: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type OfS: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type OS: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type OS1: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type OS2: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Radius: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiKPart.ChFiKPart_ComputeData_ComputeCorner(*args)

    ComputeCorner = staticmethod(ComputeCorner)

    def __init__(self):
        """
        Methodes de classe   permettant de  remplir    une
        SurfData dans  les cas  particuliers  de  conges
        suivants:
        - cylindre entre 2 surfaces planes,
        - tore/sphere entre un plan et un cylindre othogonal,
        - tore/sphere entre un plan et un cone othogonal,

        - tore entre un plan et une droite orthogonale (rotule).
        """
        this = _ChFiKPart.new_ChFiKPart_ComputeData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiKPart.delete_ChFiKPart_ComputeData
ChFiKPart_ComputeData_swigregister = _ChFiKPart.ChFiKPart_ComputeData_swigregister
ChFiKPart_ComputeData_swigregister(ChFiKPart_ComputeData)

def ChFiKPart_ComputeData_Compute(*args):
    """
    ChFiKPart_ComputeData_Compute(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2, Handle_ChFiDS_Spine Sp, Standard_Integer const Iedge) -> Standard_Boolean

    Computes a simple fillet in several particular
    cases.

    :type DStr: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
    :type Data: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData
    :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type Or1: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type Or2: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type Sp: OCC.wrapper.ChFiDS.Handle_ChFiDS_Spine
    :type Iedge: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ChFiKPart.ChFiKPart_ComputeData_Compute(*args)

def ChFiKPart_ComputeData_ComputeCorner(*args):
    """
    ComputeCorner(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const OrFace1, TopAbs_Orientation const OrFace2, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2, Standard_Real const minRad, Standard_Real const majRad, gp_Pnt2d P1S1, gp_Pnt2d P2S1, gp_Pnt2d P1S2, gp_Pnt2d P2S2) -> Standard_Boolean
    ComputeCorner(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const OrFace1, TopAbs_Orientation const OrFace2, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2, Standard_Real const Rad, gp_Pnt2d PS1, gp_Pnt2d P1S2, gp_Pnt2d P2S2) -> Standard_Boolean
    ChFiKPart_ComputeData_ComputeCorner(TopOpeBRepDS_DataStructure DStr, Handle_ChFiDS_SurfData Data, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, TopAbs_Orientation const OfS, TopAbs_Orientation const OS, TopAbs_Orientation const OS1, TopAbs_Orientation const OS2, Standard_Real const Radius) -> Standard_Boolean

    Computes a toric corner rotule.

    :type DStr: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
    :type Data: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData
    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type OfS: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type OS: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type OS1: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type OS2: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type Radius: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ChFiKPart.ChFiKPart_ComputeData_ComputeCorner(*args)




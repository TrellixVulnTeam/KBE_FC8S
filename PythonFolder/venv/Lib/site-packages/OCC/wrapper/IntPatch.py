# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntPatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntPatch')
    _IntPatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntPatch', [dirname(__file__)])
        except ImportError:
            import _IntPatch
            return _IntPatch
        try:
            _mod = imp.load_module('_IntPatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntPatch = swig_import_helper()
    del swig_import_helper
else:
    import _IntPatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntPatch.delete_SwigPyIterator

    def value(self):
        return _IntPatch.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntPatch.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntPatch.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntPatch.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntPatch.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntPatch.SwigPyIterator_copy(self)

    def next(self):
        return _IntPatch.SwigPyIterator_next(self)

    def __next__(self):
        return _IntPatch.SwigPyIterator___next__(self)

    def previous(self):
        return _IntPatch.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntPatch.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntPatch.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntPatch.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntPatch.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntPatch.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntPatch.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntPatch.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntPatch.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntPatch.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntPatch.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntPatch.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntPatch.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntPatch.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntPatch.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntPatch.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntPatch.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntPatch.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntPatch.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntPatch.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntPatch.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntPatch.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntPatch.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntPatch.ptr_to_number(item)
ptr_to_number = _IntPatch.ptr_to_number

def HashCode(*args):
    return _IntPatch.HashCode(*args)
HashCode = _IntPatch.HashCode

def ptr_equal(a, b):
    return _IntPatch.ptr_equal(a, b)
ptr_equal = _IntPatch.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
IntPatch_Lin = _IntPatch.IntPatch_Lin
IntPatch_Circle = _IntPatch.IntPatch_Circle
IntPatch_Ellipse = _IntPatch.IntPatch_Ellipse
IntPatch_Parabola = _IntPatch.IntPatch_Parabola
IntPatch_Hyperbola = _IntPatch.IntPatch_Hyperbola
IntPatch_Analytic = _IntPatch.IntPatch_Analytic
IntPatch_Walking = _IntPatch.IntPatch_Walking
IntPatch_Restriction = _IntPatch.IntPatch_Restriction
IntPatch_SPntNone = _IntPatch.IntPatch_SPntNone
IntPatch_SPntSeamU = _IntPatch.IntPatch_SPntSeamU
IntPatch_SPntSeamV = _IntPatch.IntPatch_SPntSeamV
IntPatch_SPntSeamUV = _IntPatch.IntPatch_SPntSeamUV
IntPatch_SPntPoleSeamU = _IntPatch.IntPatch_SPntPoleSeamU
IntPatch_SPntPole = _IntPatch.IntPatch_SPntPole
class IntPatch_Line(Standard.Standard_Transient):
    """
    Definition of an intersection line between two
    surfaces.
    A line may be either geometric : line, circle, ellipse,
    parabola, hyperbola, as defined in the class GLine,
    or analytic, as defined in the class ALine, or defined
    by a set of points (coming from a walking algorithm) as
    defined in the class WLine.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_Line
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_Line(self) 
            return h


    def SetValue(self, *args):
        """
        SetValue(IntPatch_Line self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.IntPatch_Line_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(IntPatch_Line self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.IntPatch_Line_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Line_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(IntPatch_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.IntPatch_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(IntPatch_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.IntPatch_Line_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(IntPatch_Line self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.IntPatch_Line_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(IntPatch_Line self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.IntPatch_Line_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_Line_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_Line_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_Line
IntPatch_Line_swigregister = _IntPatch.IntPatch_Line_swigregister
IntPatch_Line_swigregister(IntPatch_Line)

def IntPatch_Line_get_type_name(*args):
    """
    IntPatch_Line_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_Line_get_type_name(*args)

def IntPatch_Line_get_type_descriptor(*args):
    """
    IntPatch_Line_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_Line_get_type_descriptor(*args)

class IntPatch_PointLine(IntPatch_Line):
    """
    Definition of an intersection line between two
    surfaces.
    A line defined by a set of points
    (e.g. coming from a walking algorithm) as
    defined in the class WLine or RLine (Restriction line).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_PointLine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_PointLine(self) 
            return h


    def AddVertex(self, *args):
        """
        AddVertex(IntPatch_PointLine self, IntPatch_Point Pnt, Standard_Boolean const theIsPrepend)

        Adds a vertex in the list. If theIsPrepend == TRUE the new
        vertex will be added before the first element of vertices sequence.
        Otherwise, to the end of the sequence

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point
        :type theIsPrepend: bool

        """
        return _IntPatch.IntPatch_PointLine_AddVertex(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(IntPatch_PointLine self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PointLine_NbPnts(self, *args)


    def NbVertex(self, *args):
        """
        NbVertex(IntPatch_PointLine self) -> Standard_Integer

        Returns number of vertices (IntPatch_Point) of the line

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PointLine_NbVertex(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.IntPatch_PointLine_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_PointLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(IntPatch_PointLine self, Standard_Integer const Index) -> IntPatch_Point

        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_PointLine_ChangeVertex(self, *args)


    def ClearVertexes(self, *args):
        """
        ClearVertexes(IntPatch_PointLine self)

        Removes vertices from the line


        """
        return _IntPatch.IntPatch_PointLine_ClearVertexes(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(IntPatch_PointLine self, Standard_Integer const theIndex)

        Removes single vertex from the line

        :type theIndex: int

        """
        return _IntPatch.IntPatch_PointLine_RemoveVertex(self, *args)


    def Curve(self, *args):
        """
        Curve(IntPatch_PointLine self) -> Handle_IntSurf_LineOn2S

        Returns set of intersection points

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_PointLine_Curve(self, *args)


    def CurvatureRadiusOfIntersLine(*args):
        """
        CurvatureRadiusOfIntersLine(Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, IntSurf_PntOn2S theUVPoint) -> Standard_Real

        Returns the radius of curvature of
        the intersection line in given point.
        Returns negative value if computation is not possible.

        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUVPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args)

    CurvatureRadiusOfIntersLine = staticmethod(CurvatureRadiusOfIntersLine)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_PointLine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_PointLine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_PointLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_PointLine
IntPatch_PointLine_swigregister = _IntPatch.IntPatch_PointLine_swigregister
IntPatch_PointLine_swigregister(IntPatch_PointLine)

def IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args):
    """
    IntPatch_PointLine_CurvatureRadiusOfIntersLine(Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, IntSurf_PntOn2S theUVPoint) -> Standard_Real

    Returns the radius of curvature of
    the intersection line in given point.
    Returns negative value if computation is not possible.

    :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theUVPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args)

def IntPatch_PointLine_get_type_name(*args):
    """
    IntPatch_PointLine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_PointLine_get_type_name(*args)

def IntPatch_PointLine_get_type_descriptor(*args):
    """
    IntPatch_PointLine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_PointLine_get_type_descriptor(*args)

class IntPatch_ThePathPointOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_ThePathPointOfTheSOnBounds self) -> IntPatch_ThePathPointOfTheSOnBounds
        __init__(IntPatch_ThePathPointOfTheSOnBounds self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter) -> IntPatch_ThePathPointOfTheSOnBounds
        __init__(IntPatch_ThePathPointOfTheSOnBounds self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter) -> IntPatch_ThePathPointOfTheSOnBounds

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Parameter: float

        """
        this = _IntPatch.new_IntPatch_ThePathPointOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntPatch_ThePathPointOfTheSOnBounds self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter)
        SetValue(IntPatch_ThePathPointOfTheSOnBounds self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Parameter: float

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_SetValue(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Tolerance(self, *args)


    def IsNew(self, *args):
        """
        IsNew(IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_IsNew(self, *args)


    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        res = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Arc(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Parameter(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_ThePathPointOfTheSOnBounds
IntPatch_ThePathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_swigregister
IntPatch_ThePathPointOfTheSOnBounds_swigregister(IntPatch_ThePathPointOfTheSOnBounds)

class IntPatch_RLine(IntPatch_PointLine):
    """
    Implementation of an intersection line described by a
    restriction line on one of the surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_RLine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_RLine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntPatch_RLine self, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_RLine
        __init__(IntPatch_RLine self, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_RLine
        __init__(IntPatch_RLine self, Standard_Boolean const Tang) -> IntPatch_RLine

        Creates a restriction as an intersection line
        when the transitions are Undecided.

        :type Tang: bool

        """
        this = _IntPatch.new_IntPatch_RLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddVertex(self, *args):
        """
        AddVertex(IntPatch_RLine self, IntPatch_Point Pnt, Standard_Boolean const theIsPrepend)

        Adds a vertex in the list. If theIsPrepend == TRUE the new
        vertex will be added before the first element of vertices sequence.
        Otherwise, to the end of the sequence

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point
        :type theIsPrepend: bool

        """
        return _IntPatch.IntPatch_RLine_AddVertex(self, *args)


    def Replace(self, *args):
        """
        Replace(IntPatch_RLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Replaces the element of range Index in the list
        of points.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(IntPatch_RLine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.IntPatch_RLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(IntPatch_RLine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.IntPatch_RLine_SetLastPoint(self, *args)


    def Add(self, *args):
        """
        Add(IntPatch_RLine self, Handle_IntSurf_LineOn2S L)

        :type L: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_RLine_Add(self, *args)


    def IsArcOnS1(self, *args):
        """
        IsArcOnS1(IntPatch_RLine self) -> Standard_Boolean

        Returns True if the intersection is on the domain of the
        first patch.
        Returns False if the intersection is on the domain of
        the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_RLine_IsArcOnS1(self, *args)


    def IsArcOnS2(self, *args):
        """
        IsArcOnS2(IntPatch_RLine self) -> Standard_Boolean

        Returns True if the intersection is on the domain of the
        first patch.
        Returns False if the intersection is on the domain of
        the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_RLine_IsArcOnS2(self, *args)


    def SetArcOnS1(self, *args):
        """
        SetArcOnS1(IntPatch_RLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_RLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args):
        """
        SetArcOnS2(IntPatch_RLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_RLine_SetArcOnS2(self, *args)


    def ArcOnS1(self, *args):
        """
        Returns the concerned arc.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_RLine_ArcOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ArcOnS2(self, *args):
        """
        Returns the concerned arc.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_RLine_ArcOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamOnS1(self, *args):
        """
        ParamOnS1(IntPatch_RLine self)

        :type p1: float
        :type p2: float

        """
        return _IntPatch.IntPatch_RLine_ParamOnS1(self, *args)


    def ParamOnS2(self, *args):
        """
        ParamOnS2(IntPatch_RLine self)

        :type p1: float
        :type p2: float

        """
        return _IntPatch.IntPatch_RLine_ParamOnS2(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntPatch_RLine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_RLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntPatch_RLine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_RLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the IntPoint corresponding to the FirstPoint.
        An exception is raised when HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_RLine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the IntPoint corresponding to the LastPoint.
        An exception is raised when HasLastPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_RLine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(IntPatch_RLine self) -> Standard_Integer

        Returns number of vertices (IntPatch_Point) of the line

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_RLine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_RLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(IntPatch_RLine self, Standard_Integer const Index) -> IntPatch_Point

        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_ChangeVertex(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(IntPatch_RLine self, Standard_Integer const theIndex)

        Removes single vertex from the line

        :type theIndex: int

        """
        return _IntPatch.IntPatch_RLine_RemoveVertex(self, *args)


    def HasPolygon(self, *args):
        """
        HasPolygon(IntPatch_RLine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_RLine_HasPolygon(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(IntPatch_RLine self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_RLine_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.IntPatch_RLine_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPoint(self, *args):
        """
        SetPoint(IntPatch_RLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Set the Point of index <Index> in the LineOn2S

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_SetPoint(self, *args)


    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(IntPatch_RLine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.IntPatch_RLine_ComputeVertexParameters(self, *args)


    def Curve(self, *args):
        """
        Curve(IntPatch_RLine self) -> Handle_IntSurf_LineOn2S

        Returns set of intersection points

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_RLine_Curve(self, *args)


    def ClearVertexes(self, *args):
        """
        ClearVertexes(IntPatch_RLine self)

        Removes vertices from the line (i.e. cleans svtx member)


        """
        return _IntPatch.IntPatch_RLine_ClearVertexes(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(IntPatch_RLine self, Handle_IntSurf_LineOn2S theNewCurve)

        :type theNewCurve: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_RLine_SetCurve(self, *args)


    def Dump(self, *args):
        """
        Dump(IntPatch_RLine self, Standard_Integer const theMode)

        if (theMode == 0) then prints the information about WLine
        if (theMode == 1) then prints the list of 3d-points
        if (theMode == 2) then prints the list of 2d-points on the 1st surface
        Otherwise,             prints list of 2d-points on the 2nd surface

        :type theMode: int

        """
        return _IntPatch.IntPatch_RLine_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_RLine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_RLine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_RLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_RLine
IntPatch_RLine_swigregister = _IntPatch.IntPatch_RLine_swigregister
IntPatch_RLine_swigregister(IntPatch_RLine)

def IntPatch_RLine_get_type_name(*args):
    """
    IntPatch_RLine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_RLine_get_type_name(*args)

def IntPatch_RLine_get_type_descriptor(*args):
    """
    IntPatch_RLine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_RLine_get_type_descriptor(*args)

class IntPatch_TheIWLineOfTheIWalking(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_TheIWLineOfTheIWalking
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_TheIWLineOfTheIWalking(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntPatch_TheIWLineOfTheIWalking self, Handle_NCollection_BaseAllocator theAllocator=0) -> IntPatch_TheIWLineOfTheIWalking

        :type theAllocator: OCC.wrapper.IntSurf.IntSurf_Allocator

        """
        this = _IntPatch.new_IntPatch_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """
        Reverse(IntPatch_TheIWLineOfTheIWalking self)

        reverse the points in the line. Hasfirst, HasLast are kept.


        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Cut(self, *args):
        """
        Cut(IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        Cut the line at the point of rank Index.

        :type Index: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Cut(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(IntPatch_TheIWLineOfTheIWalking self, IntSurf_PntOn2S P)

        Add a point in the line.

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args):
        """
        AddStatusFirst(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst)
        AddStatusFirst(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type Closed: bool
        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args):
        """
        AddStatusFirstLast(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst, Standard_Boolean const HasLast)

        :type Closed: bool
        :type HasFirst: bool
        :type HasLast: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args):
        """
        AddStatusLast(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast)
        AddStatusLast(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def AddIndexPassing(self, *args):
        """
        AddIndexPassing(IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        associer a l 'indice du point sur la ligne l'indice du point
        passant dans l'iterateur de depart

        :type Index: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def SetTangentVector(self, *args):
        """
        SetTangentVector(IntPatch_TheIWLineOfTheIWalking self, gp_Vec V, Standard_Integer const Index)

        :type V: OCC.wrapper.gp.gp_Vec
        :type Index: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def SetTangencyAtBegining(self, *args):
        """
        SetTangencyAtBegining(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args):
        """
        SetTangencyAtEnd(IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the number of points of the line (including first
        point and end point : see HasLastPoint and HasFirstPoint).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index.
        If index <= 0 or Index > NbPoints, an exception is raised.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.IntPatch_TheIWLineOfTheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        Returns the LineOn2S contained in the walking line.

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        res = _IntPatch.IntPatch_TheIWLineOfTheIWalking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsClosed(self, *args):
        """
        IsClosed(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the line is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the first point of the line is a
        marching point . when is HasFirstPoint==False ,the line
        begins on the natural bound of the surface.the line can be
        too long

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the end point of the line is a
        marching point (Point from IntWS).
        when is HasFirstPoint==False ,the line ends
        on the natural bound of the surface.the line can be
        too long.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point of the line when it is a
        marching point.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstPointIndex(self, *args):
        """
        FirstPointIndex(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the Index of first point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point of the line when it is a
        marching point.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPointIndex(self, *args):
        """
        LastPointIndex(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the index of last point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def NbPassingPoint(self, *args):
        """
        NbPassingPoint(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        returns the number of points belonging to Pnts1 which are
        passing point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def PassingPoint(self, *args):
        """
        PassingPoint(IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        returns the index of the point belonging to the line which
        is associated to the passing point belonging to Pnts1
        an exception is raised if Index > NbPassingPoint()

        :type Index: int
        :type IndexLine: int
        :type IndexPnts: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def TangentVector(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _IntPatch.IntPatch_TheIWLineOfTheIWalking_TangentVector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentAtBegining(self, *args):
        """
        IsTangentAtBegining(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args):
        """
        IsTangentAtEnd(IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_TheIWLineOfTheIWalking_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWLineOfTheIWalking
IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_TheIWLineOfTheIWalking_swigregister
IntPatch_TheIWLineOfTheIWalking_swigregister(IntPatch_TheIWLineOfTheIWalking)

def IntPatch_TheIWLineOfTheIWalking_get_type_name(*args):
    """
    IntPatch_TheIWLineOfTheIWalking_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_TheIWLineOfTheIWalking_get_type_name(*args)

def IntPatch_TheIWLineOfTheIWalking_get_type_descriptor(*args):
    """
    IntPatch_TheIWLineOfTheIWalking_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_TheIWLineOfTheIWalking_get_type_descriptor(*args)

class IntPatch_TheSegmentOfTheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_TheSegmentOfTheSOnBounds self) -> IntPatch_TheSegmentOfTheSOnBounds

        Empty constructor.


        """
        this = _IntPatch.new_IntPatch_TheSegmentOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntPatch_TheSegmentOfTheSOnBounds self, Handle_Adaptor2d_HCurve2d A)

        Defines the concerned arc.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetValue(self, *args)


    def SetLimitPoint(self, *args):
        """
        SetLimitPoint(IntPatch_TheSegmentOfTheSOnBounds self, IntPatch_ThePathPointOfTheSOnBounds V, Standard_Boolean const First)

        Defines the first point or the last point,
        depending on the value of the boolean First.

        :type V: OCC.wrapper.IntPatch.IntPatch_ThePathPointOfTheSOnBounds
        :type First: bool

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetLimitPoint(self, *args)


    def Curve(self, *args):
        """
        Returns the geometric curve on the surface 's domain
        which is solution.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Boolean

        Returns True if there is a vertex (ThePathPoint) defining
        the lowest valid parameter on the arc.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasFirstPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point.

        :rtype: OCC.wrapper.IntPatch.IntPatch_ThePathPointOfTheSOnBounds

        """
        res = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Boolean

        Returns True if there is a vertex (ThePathPoint) defining
        the greatest valid parameter on the arc.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasLastPoint(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point.

        :rtype: OCC.wrapper.IntPatch.IntPatch_ThePathPointOfTheSOnBounds

        """
        res = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSegmentOfTheSOnBounds
IntPatch_TheSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_swigregister
IntPatch_TheSegmentOfTheSOnBounds_swigregister(IntPatch_TheSegmentOfTheSOnBounds)

class IntPatch_GLine(IntPatch_Line):
    """
    Implementation of an intersection line represented
    by a conic.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_GLine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_GLine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntPatch_GLine self, gp_Lin L, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Lin L, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Lin L, Standard_Boolean const Tang) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Circ C, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Circ C, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Circ C, Standard_Boolean const Tang) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Elips E, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Elips E, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Elips E, Standard_Boolean const Tang) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Parab P, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Parab P, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Parab P, Standard_Boolean const Tang) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Hypr H, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Hypr H, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_GLine
        __init__(IntPatch_GLine self, gp_Hypr H, Standard_Boolean const Tang) -> IntPatch_GLine

        Creates an hyperbola as  intersection line
        when the transitions are Undecided.

        :type H: OCC.wrapper.gp.gp_Hypr
        :type Tang: bool

        """
        this = _IntPatch.new_IntPatch_GLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddVertex(self, *args):
        """
        AddVertex(IntPatch_GLine self, IntPatch_Point Pnt)

        To add a vertex in the list.

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_AddVertex(self, *args)


    def Replace(self, *args):
        """
        Replace(IntPatch_GLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        To replace the element of range Index in the list
        of points.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(IntPatch_GLine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.IntPatch_GLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(IntPatch_GLine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.IntPatch_GLine_SetLastPoint(self, *args)


    def Line(self, *args):
        """
        Line(IntPatch_GLine self) -> gp_Lin

        Returns the Lin from gp corresponding to the intersection
        when ArcType returns IntPatch_Line.

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _IntPatch.IntPatch_GLine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(IntPatch_GLine self) -> gp_Circ

        Returns the Circ from gp corrsponding to the intersection
        when ArcType returns IntPatch_Circle.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _IntPatch.IntPatch_GLine_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(IntPatch_GLine self) -> gp_Elips

        Returns the Elips from gp corrsponding to the intersection
        when ArcType returns IntPatch_Ellipse.

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _IntPatch.IntPatch_GLine_Ellipse(self, *args)


    def Parabola(self, *args):
        """
        Parabola(IntPatch_GLine self) -> gp_Parab

        Returns the Parab from gp corrsponding to the intersection
        when ArcType returns IntPatch_Parabola.

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _IntPatch.IntPatch_GLine_Parabola(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(IntPatch_GLine self) -> gp_Hypr

        Returns the Hypr from gp corrsponding to the intersection
        when ArcType returns IntPatch_Hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _IntPatch.IntPatch_GLine_Hyperbola(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntPatch_GLine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_GLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntPatch_GLine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_GLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the IntPoint corresponding to the FirstPoint.
        An exception is raised when HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_GLine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the IntPoint corresponding to the LastPoint.
        An exception is raised when HasLastPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_GLine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(IntPatch_GLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_GLine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_GLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(IntPatch_GLine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.IntPatch_GLine_ComputeVertexParameters(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_GLine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_GLine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_GLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_GLine
IntPatch_GLine_swigregister = _IntPatch.IntPatch_GLine_swigregister
IntPatch_GLine_swigregister(IntPatch_GLine)

def IntPatch_GLine_get_type_name(*args):
    """
    IntPatch_GLine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_GLine_get_type_name(*args)

def IntPatch_GLine_get_type_descriptor(*args):
    """
    IntPatch_GLine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_GLine_get_type_descriptor(*args)

class IntPatch_ImpPrmIntersection(object):
    """
    Implementation of the intersection between a natural
    quadric patch : Plane, Cone, Cylinder or Sphere and
    a bi-parametrised surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_ImpPrmIntersection self) -> IntPatch_ImpPrmIntersection
        __init__(IntPatch_ImpPrmIntersection self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang, Standard_Real const Fleche, Standard_Real const Pas) -> IntPatch_ImpPrmIntersection

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolArc: float
        :type TolTang: float
        :type Fleche: float
        :type Pas: float

        """
        this = _IntPatch.new_IntPatch_ImpPrmIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetStartPoint(self, *args):
        """
        SetStartPoint(IntPatch_ImpPrmIntersection self, Standard_Real const U, Standard_Real const V)

        to search for solution from the given point

        :type U: float
        :type V: float

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_SetStartPoint(self, *args)


    def Perform(self, *args):
        """
        Perform(IntPatch_ImpPrmIntersection self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface Surf2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang, Standard_Real const Fleche, Standard_Real const Pas)

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolArc: float
        :type TolTang: float
        :type Fleche: float
        :type Pas: float

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_ImpPrmIntersection self) -> Standard_Boolean

        Returns true if the calculus was succesfull.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntPatch_ImpPrmIntersection self) -> Standard_Boolean

        Returns true if the is no intersection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsEmpty(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(IntPatch_ImpPrmIntersection self) -> Standard_Integer

        Returns the number of "single" points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the point of range Index.
        An exception is raised if Index<=0 or Index>NbPnt.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_ImpPrmIntersection_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLines(self, *args):
        """
        NbLines(IntPatch_ImpPrmIntersection self) -> Standard_Integer

        Returns the number of intersection lines.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns the line of range Index.
        An exception is raised if Index<=0 or Index>NbLine.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        res = _IntPatch.IntPatch_ImpPrmIntersection_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpPrmIntersection
IntPatch_ImpPrmIntersection_swigregister = _IntPatch.IntPatch_ImpPrmIntersection_swigregister
IntPatch_ImpPrmIntersection_swigregister(IntPatch_ImpPrmIntersection)

class Handle_IntPatch_GLine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_GLine self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_GLine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_GLine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_GLine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_GLine self, IntPatch_GLine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_GLine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_GLine self, Handle_IntPatch_GLine theHandle) -> Handle_IntPatch_GLine
        assign(Handle_IntPatch_GLine self, IntPatch_GLine thePtr) -> Handle_IntPatch_GLine
        assign(Handle_IntPatch_GLine self, Handle_IntPatch_GLine theHandle) -> Handle_IntPatch_GLine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_GLine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_GLine self) -> IntPatch_GLine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_GLine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_GLine self) -> IntPatch_GLine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_GLine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_GLine self) -> IntPatch_GLine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_GLine___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_GLine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_GLine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_GLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_GLine_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_GLine

    def AddVertex(self, *args):
        """
        AddVertex(Handle_IntPatch_GLine self, IntPatch_Point Pnt)

        To add a vertex in the list.

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_GLine_AddVertex(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_IntPatch_GLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        To replace the element of range Index in the list
        of points.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_GLine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(Handle_IntPatch_GLine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.Handle_IntPatch_GLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(Handle_IntPatch_GLine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.Handle_IntPatch_GLine_SetLastPoint(self, *args)


    def Line(self, *args):
        """
        Line(Handle_IntPatch_GLine self) -> gp_Lin

        Returns the Lin from gp corresponding to the intersection
        when ArcType returns IntPatch_Line.

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _IntPatch.Handle_IntPatch_GLine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_IntPatch_GLine self) -> gp_Circ

        Returns the Circ from gp corrsponding to the intersection
        when ArcType returns IntPatch_Circle.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _IntPatch.Handle_IntPatch_GLine_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Handle_IntPatch_GLine self) -> gp_Elips

        Returns the Elips from gp corrsponding to the intersection
        when ArcType returns IntPatch_Ellipse.

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _IntPatch.Handle_IntPatch_GLine_Ellipse(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Handle_IntPatch_GLine self) -> gp_Parab

        Returns the Parab from gp corrsponding to the intersection
        when ArcType returns IntPatch_Parabola.

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _IntPatch.Handle_IntPatch_GLine_Parabola(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Handle_IntPatch_GLine self) -> gp_Hypr

        Returns the Hypr from gp corrsponding to the intersection
        when ArcType returns IntPatch_Hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _IntPatch.Handle_IntPatch_GLine_Hyperbola(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the IntPoint corresponding to the FirstPoint.
        An exception is raised when HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_GLine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the IntPoint corresponding to the LastPoint.
        An exception is raised when HasLastPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_GLine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(Handle_IntPatch_GLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_GLine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_GLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(Handle_IntPatch_GLine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.Handle_IntPatch_GLine_ComputeVertexParameters(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_GLine self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_GLine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_GLine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_GLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Handle_IntPatch_GLine self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.Handle_IntPatch_GLine_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(Handle_IntPatch_GLine self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.Handle_IntPatch_GLine_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_IntPatch_GLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_GLine_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_IntPatch_GLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_GLine_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(Handle_IntPatch_GLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_GLine_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(Handle_IntPatch_GLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_GLine_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(Handle_IntPatch_GLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsVIsoOnS2(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_GLine self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_GLine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_GLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_GLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_GLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_GLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_GLine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_GLine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_GLine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_GLine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_GLine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_GLine self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_GLine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_GLine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_GLine_DecrementRefCounter(self, *args)

Handle_IntPatch_GLine_swigregister = _IntPatch.Handle_IntPatch_GLine_swigregister
Handle_IntPatch_GLine_swigregister(Handle_IntPatch_GLine)

def Handle_IntPatch_GLine_DownCast(thing):
    return _IntPatch.Handle_IntPatch_GLine_DownCast(thing)
Handle_IntPatch_GLine_DownCast = _IntPatch.Handle_IntPatch_GLine_DownCast

class IntPatch_PrmPrmIntersection(object):
    """
    Implementation  of   the Intersection      between two
    bi-parametrised surfaces.

    To  avoid  multiple constructions of  the approximated
    polyhedron  of the    surfaces, the algorithm  can  be
    called whith the  two  surfaces  and their  associated
    polyhedron.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_PrmPrmIntersection self) -> IntPatch_PrmPrmIntersection

        Empty Constructor


        """
        this = _IntPatch.new_IntPatch_PrmPrmIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, IntPatch_Polyhedron Polyhedron1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Caro2, IntPatch_Polyhedron Polyhedron2, Handle_Adaptor3d_TopolTool Domain2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, IntPatch_Polyhedron Polyhedron1, Handle_Adaptor3d_TopolTool Domain1, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Caro2, Handle_Adaptor3d_TopolTool Domain2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment, Standard_Boolean const ClearFlag)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Caro2, Handle_Adaptor3d_TopolTool Domain2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment, IntSurf_ListOfPntOn2S & ListOfPnts)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Caro2, Handle_Adaptor3d_TopolTool Domain2, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_TopolTool Domain1, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Caro2, IntPatch_Polyhedron Polyhedron2, Handle_Adaptor3d_TopolTool Domain2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment)
        Perform(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, IntPatch_Polyhedron Polyhedron1, Handle_Adaptor3d_TopolTool Domain1, Handle_Adaptor3d_HSurface Caro2, Handle_Adaptor3d_TopolTool Domain2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment)

        Performs  the intersection between <Caro1> and
        <Caro2>.

        The polyhedron which approximates     <Caro1>,
        <Polyhedron1> is given. The other one is
        computed.

        :type Caro1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Polyhedron1: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :type Domain1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Caro2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolTangency: float
        :type Epsilon: float
        :type Deflection: float
        :type Increment: float

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_PrmPrmIntersection self) -> Standard_Boolean

        Returns true if the calculus was succesfull.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntPatch_PrmPrmIntersection self) -> Standard_Boolean

        Returns true if the is no intersection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsEmpty(self, *args)


    def NbLines(self, *args):
        """
        NbLines(IntPatch_PrmPrmIntersection self) -> Standard_Integer

        Returns the number of intersection lines.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns the line of range Index.
        An exception is raised if Index<=0 or Index>NbLine.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        res = _IntPatch.IntPatch_PrmPrmIntersection_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewLine(self, *args):
        """
        NewLine(IntPatch_PrmPrmIntersection self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_HSurface Caro2, Standard_Integer const IndexLine, Standard_Integer const LowPoint, Standard_Integer const HighPoint, Standard_Integer const NbPoints) -> Handle_IntPatch_Line

        Computes about <NbPoints>  Intersection Points  on
        the Line <IndexLine> between  the Points of  Index
        <LowPoint> and <HighPoint>.

        All  the points  of the line  of index <IndexLine>
        with an index  between <LowPoint>  and <HighPoint>
        are in the returned  line. New Points are inserted
        between existing points  if  those  points are not
        too closed.

        An exception is raised if Index<=0 or Index>NbLine.
        or if IsDone returns False

        :type Caro1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Caro2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type IndexLine: int
        :type LowPoint: int
        :type HighPoint: int
        :type NbPoints: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NewLine(self, *args)


    def GrilleInteger(self, *args):
        """
        GrilleInteger(IntPatch_PrmPrmIntersection self, Standard_Integer const ix, Standard_Integer const iy, Standard_Integer const iz) -> Standard_Integer

        :type ix: int
        :type iy: int
        :type iz: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_GrilleInteger(self, *args)


    def IntegerGrille(self, *args):
        """
        IntegerGrille(IntPatch_PrmPrmIntersection self, Standard_Integer const t)

        :type t: int
        :type ix: int
        :type iy: int
        :type iz: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IntegerGrille(self, *args)


    def DansGrille(self, *args):
        """
        DansGrille(IntPatch_PrmPrmIntersection self, Standard_Integer const t) -> Standard_Integer

        :type t: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_DansGrille(self, *args)


    def NbPointsGrille(self, *args):
        """
        NbPointsGrille(IntPatch_PrmPrmIntersection self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbPointsGrille(self, *args)


    def RemplitLin(self, *args):
        """
        RemplitLin(IntPatch_PrmPrmIntersection self, Standard_Integer const x1, Standard_Integer const y1, Standard_Integer const z1, Standard_Integer const x2, Standard_Integer const y2, Standard_Integer const z2, IntPatch_PrmPrmIntersection_T3Bits Map)

        :type x1: int
        :type y1: int
        :type z1: int
        :type x2: int
        :type y2: int
        :type z2: int
        :type Map: OCC.wrapper.IntPatch.IntPatch_PrmPrmIntersection_T3Bits

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitLin(self, *args)


    def RemplitTri(self, *args):
        """
        RemplitTri(IntPatch_PrmPrmIntersection self, Standard_Integer const x1, Standard_Integer const y1, Standard_Integer const z1, Standard_Integer const x2, Standard_Integer const y2, Standard_Integer const z2, Standard_Integer const x3, Standard_Integer const y3, Standard_Integer const z3, IntPatch_PrmPrmIntersection_T3Bits Map)

        :type x1: int
        :type y1: int
        :type z1: int
        :type x2: int
        :type y2: int
        :type z2: int
        :type x3: int
        :type y3: int
        :type z3: int
        :type Map: OCC.wrapper.IntPatch.IntPatch_PrmPrmIntersection_T3Bits

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitTri(self, *args)


    def Remplit(self, *args):
        """
        Remplit(IntPatch_PrmPrmIntersection self, Standard_Integer const a, Standard_Integer const b, Standard_Integer const c, IntPatch_PrmPrmIntersection_T3Bits Map)

        :type a: int
        :type b: int
        :type c: int
        :type Map: OCC.wrapper.IntPatch.IntPatch_PrmPrmIntersection_T3Bits

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Remplit(self, *args)


    def CodeReject(self, *args):
        """
        CodeReject(IntPatch_PrmPrmIntersection self, Standard_Real const x1, Standard_Real const y1, Standard_Real const z1, Standard_Real const x2, Standard_Real const y2, Standard_Real const z2, Standard_Real const x3, Standard_Real const y3, Standard_Real const z3) -> Standard_Integer

        :type x1: float
        :type y1: float
        :type z1: float
        :type x2: float
        :type y2: float
        :type z2: float
        :type x3: float
        :type y3: float
        :type z3: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_CodeReject(self, *args)


    def PointDepart(self, *args):
        """
        PointDepart(IntPatch_PrmPrmIntersection self, Handle_IntSurf_LineOn2S LineOn2S, Handle_Adaptor3d_HSurface S1, Standard_Integer const SU1, Standard_Integer const SV1, Handle_Adaptor3d_HSurface S2, Standard_Integer const SU2, Standard_Integer const SV2)

        :type LineOn2S: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S
        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type SU1: int
        :type SV1: int
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type SU2: int
        :type SV2: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_PointDepart(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection
IntPatch_PrmPrmIntersection_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_swigregister
IntPatch_PrmPrmIntersection_swigregister(IntPatch_PrmPrmIntersection)

class IntPatch_PolyhedronTool(object):
    """
    Describe  the signature  of  a  polyedral surface with
    only triangular  facets and the necessary informations
    to compute the interferences.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args):
        """
        Bounding(IntPatch_Polyhedron thePolyh) -> Bnd_Box

        Give the bounding box of the Polyhedron.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntPatch.IntPatch_PolyhedronTool_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args):
        """
        ComponentsBounding(IntPatch_Polyhedron thePolyh) -> Handle_Bnd_HArray1OfBox

        Give the array of boxes. The box <n> corresponding
        to the triangle <n>.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        return _IntPatch.IntPatch_PolyhedronTool_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args):
        """
        DeflectionOverEstimation(IntPatch_Polyhedron thePolyh) -> Standard_Real

        Give the tolerance of the polygon.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_PolyhedronTool_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def NbTriangles(*args):
        """
        NbTriangles(IntPatch_Polyhedron thePolyh) -> Standard_Integer

        Give the number of triangles in this polyedral surface.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PolyhedronTool_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Triangle(*args):
        """
        Triangle(IntPatch_Polyhedron thePolyh, Standard_Integer const Index)

        Give the indices  of  the 3 points of  the triangle of
        address Index in the Polyhedron.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :type Index: int
        :type P1: int
        :type P2: int
        :type P3: int

        """
        return _IntPatch.IntPatch_PolyhedronTool_Triangle(*args)

    Triangle = staticmethod(Triangle)

    def Point(*args):
        """
        Point(IntPatch_Polyhedron thePolyh, Standard_Integer const Index) -> gp_Pnt

        Give the point of index i in the polyedral surface.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntPatch.IntPatch_PolyhedronTool_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args):
        """
        TriConnex(IntPatch_Polyhedron thePolyh, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

        Gives the  addresse Tricon of   the triangle connexe to
        the triangle of address Triang by the edge Pivot Pedge
        and the third point of this  connexe triangle. When we
        are on  a free edge TriCon==0  but the function return
        the value of  the triangle in the  other side of Pivot
        on the free edge.  Used to turn around a vertex.

        :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
        :type Triang: int
        :type Pivot: int
        :type Pedge: int
        :type TriCon: int
        :type OtherP: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PolyhedronTool_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def __init__(self):
        """
        Describe  the signature  of  a  polyedral surface with
        only triangular  facets and the necessary informations
        to compute the interferences.
        """
        this = _IntPatch.new_IntPatch_PolyhedronTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyhedronTool
IntPatch_PolyhedronTool_swigregister = _IntPatch.IntPatch_PolyhedronTool_swigregister
IntPatch_PolyhedronTool_swigregister(IntPatch_PolyhedronTool)

def IntPatch_PolyhedronTool_Bounding(*args):
    """
    IntPatch_PolyhedronTool_Bounding(IntPatch_Polyhedron thePolyh) -> Bnd_Box

    Give the bounding box of the Polyhedron.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :rtype: OCC.wrapper.Bnd.Bnd_Box

    """
    return _IntPatch.IntPatch_PolyhedronTool_Bounding(*args)

def IntPatch_PolyhedronTool_ComponentsBounding(*args):
    """
    IntPatch_PolyhedronTool_ComponentsBounding(IntPatch_Polyhedron thePolyh) -> Handle_Bnd_HArray1OfBox

    Give the array of boxes. The box <n> corresponding
    to the triangle <n>.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

    """
    return _IntPatch.IntPatch_PolyhedronTool_ComponentsBounding(*args)

def IntPatch_PolyhedronTool_DeflectionOverEstimation(*args):
    """
    IntPatch_PolyhedronTool_DeflectionOverEstimation(IntPatch_Polyhedron thePolyh) -> Standard_Real

    Give the tolerance of the polygon.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_PolyhedronTool_DeflectionOverEstimation(*args)

def IntPatch_PolyhedronTool_NbTriangles(*args):
    """
    IntPatch_PolyhedronTool_NbTriangles(IntPatch_Polyhedron thePolyh) -> Standard_Integer

    Give the number of triangles in this polyedral surface.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_PolyhedronTool_NbTriangles(*args)

def IntPatch_PolyhedronTool_Triangle(*args):
    """
    IntPatch_PolyhedronTool_Triangle(IntPatch_Polyhedron thePolyh, Standard_Integer const Index)

    Give the indices  of  the 3 points of  the triangle of
    address Index in the Polyhedron.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :type Index: int
    :type P1: int
    :type P2: int
    :type P3: int

    """
    return _IntPatch.IntPatch_PolyhedronTool_Triangle(*args)

def IntPatch_PolyhedronTool_Point(*args):
    """
    IntPatch_PolyhedronTool_Point(IntPatch_Polyhedron thePolyh, Standard_Integer const Index) -> gp_Pnt

    Give the point of index i in the polyedral surface.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntPatch.IntPatch_PolyhedronTool_Point(*args)

def IntPatch_PolyhedronTool_TriConnex(*args):
    """
    IntPatch_PolyhedronTool_TriConnex(IntPatch_Polyhedron thePolyh, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

    Gives the  addresse Tricon of   the triangle connexe to
    the triangle of address Triang by the edge Pivot Pedge
    and the third point of this  connexe triangle. When we
    are on  a free edge TriCon==0  but the function return
    the value of  the triangle in the  other side of Pivot
    on the free edge.  Used to turn around a vertex.

    :type thePolyh: OCC.wrapper.IntPatch.IntPatch_Polyhedron
    :type Triang: int
    :type Pivot: int
    :type Pedge: int
    :type TriCon: int
    :type OtherP: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_PolyhedronTool_TriConnex(*args)

class NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntPatch.new_NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self)

        Reverse sequence


        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theOther) -> NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theOther) -> NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, IntPatch_ThePathPointOfTheSOnBounds theItem)
        Append(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, IntPatch_ThePathPointOfTheSOnBounds theItem)
        Prepend(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex, IntPatch_ThePathPointOfTheSOnBounds theItem)
        InsertBefore(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::Iterator & thePosition, IntPatch_ThePathPointOfTheSOnBounds theItem)
        InsertAfter(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theSeq)
        InsertAfter(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex, IntPatch_ThePathPointOfTheSOnBounds theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> IntPatch_ThePathPointOfTheSOnBounds

        First item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self) -> IntPatch_ThePathPointOfTheSOnBounds

        Last item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex) -> IntPatch_ThePathPointOfTheSOnBounds

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds self, Standard_Integer const theIndex, IntPatch_ThePathPointOfTheSOnBounds theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_SetValue(self, *args)


    def __iter__(self):
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds___iter__(self)
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds
NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_swigregister = _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_swigregister
NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_swigregister(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds)

def NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_delNode(*args):
    """
    NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_delNode(*args)

class NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPatch.new_NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper

    def __next__(self):
        return _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper___next__(self)
NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper_swigregister = _IntPatch.NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper_swigregister
NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper_swigregister(NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds_IteratorHelper)


try:
	IntPatch_SequenceOfPathPointOfTheSOnBounds = NCollection_Sequence_IntPatch_ThePathPointOfTheSOnBounds
except NameError:
	pass # does not exist, probably ignored

class IntPatch_Polygo(Intf.Intf_Polygon2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Error(self, *args):
        """
        Error(IntPatch_Polygo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Polygo_Error(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_Polygo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Polygo_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(IntPatch_Polygo self, Standard_Integer const Index) -> gp_Pnt2d

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntPatch.IntPatch_Polygo_Point(self, *args)


    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(IntPatch_Polygo self) -> Standard_Real

        Returns the tolerance of the polygon.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Polygo_DeflectionOverEstimation(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(IntPatch_Polygo self) -> Standard_Integer

        Returns the number of Segments in the polyline.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Polygo_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Segment(IntPatch_Polygo self, Standard_Integer const theIndex, gp_Pnt2d theBegin, gp_Pnt2d theEnd)

        Returns the points of the segment <Index> in the Polygon.

        :type theIndex: int
        :type theBegin: OCC.wrapper.gp.gp_Pnt2d
        :type theEnd: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntPatch.IntPatch_Polygo_Segment(self, *args)


    def Dump(self, *args):
        """Dump(IntPatch_Polygo self)"""
        return _IntPatch.IntPatch_Polygo_Dump(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_Polygo
IntPatch_Polygo_swigregister = _IntPatch.IntPatch_Polygo_swigregister
IntPatch_Polygo_swigregister(IntPatch_Polygo)

class Handle_IntPatch_TheIWLineOfTheIWalking(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_TheIWLineOfTheIWalking self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_TheIWLineOfTheIWalking self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_TheIWLineOfTheIWalking self, IntPatch_TheIWLineOfTheIWalking thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_IntPatch_TheIWLineOfTheIWalking theHandle) -> Handle_IntPatch_TheIWLineOfTheIWalking
        assign(Handle_IntPatch_TheIWLineOfTheIWalking self, IntPatch_TheIWLineOfTheIWalking thePtr) -> Handle_IntPatch_TheIWLineOfTheIWalking
        assign(Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_IntPatch_TheIWLineOfTheIWalking theHandle) -> Handle_IntPatch_TheIWLineOfTheIWalking

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_TheIWLineOfTheIWalking self) -> IntPatch_TheIWLineOfTheIWalking

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_TheIWLineOfTheIWalking self) -> IntPatch_TheIWLineOfTheIWalking

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_TheIWLineOfTheIWalking self) -> IntPatch_TheIWLineOfTheIWalking

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_TheIWLineOfTheIWalking

    def Reverse(self, *args):
        """
        Reverse(Handle_IntPatch_TheIWLineOfTheIWalking self)

        reverse the points in the line. Hasfirst, HasLast are kept.


        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Cut(self, *args):
        """
        Cut(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        Cut the line at the point of rank Index.

        :type Index: int

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Cut(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(Handle_IntPatch_TheIWLineOfTheIWalking self, IntSurf_PntOn2S P)

        Add a point in the line.

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args):
        """
        AddStatusFirst(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst)
        AddStatusFirst(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type Closed: bool
        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args):
        """
        AddStatusFirstLast(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst, Standard_Boolean const HasLast)

        :type Closed: bool
        :type HasFirst: bool
        :type HasLast: bool

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args):
        """
        AddStatusLast(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast)
        AddStatusLast(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def AddIndexPassing(self, *args):
        """
        AddIndexPassing(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        associer a l 'indice du point sur la ligne l'indice du point
        passant dans l'iterateur de depart

        :type Index: int

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def SetTangentVector(self, *args):
        """
        SetTangentVector(Handle_IntPatch_TheIWLineOfTheIWalking self, gp_Vec V, Standard_Integer const Index)

        :type V: OCC.wrapper.gp.gp_Vec
        :type Index: int

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def SetTangencyAtBegining(self, *args):
        """
        SetTangencyAtBegining(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args):
        """
        SetTangencyAtEnd(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the number of points of the line (including first
        point and end point : see HasLastPoint and HasFirstPoint).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index.
        If index <= 0 or Index > NbPoints, an exception is raised.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        Returns the LineOn2S contained in the walking line.

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsClosed(self, *args):
        """
        IsClosed(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the line is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the first point of the line is a
        marching point . when is HasFirstPoint==False ,the line
        begins on the natural bound of the surface.the line can be
        too long

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the end point of the line is a
        marching point (Point from IntWS).
        when is HasFirstPoint==False ,the line ends
        on the natural bound of the surface.the line can be
        too long.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point of the line when it is a
        marching point.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstPointIndex(self, *args):
        """
        FirstPointIndex(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the Index of first point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point of the line when it is a
        marching point.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPointIndex(self, *args):
        """
        LastPointIndex(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the index of last point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def NbPassingPoint(self, *args):
        """
        NbPassingPoint(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        returns the number of points belonging to Pnts1 which are
        passing point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def PassingPoint(self, *args):
        """
        PassingPoint(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        returns the index of the point belonging to the line which
        is associated to the passing point belonging to Pnts1
        an exception is raised if Index > NbPassingPoint()

        :type Index: int
        :type IndexLine: int
        :type IndexPnts: int

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def TangentVector(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_TangentVector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentAtBegining(self, *args):
        """
        IsTangentAtBegining(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args):
        """
        IsTangentAtEnd(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_TheIWLineOfTheIWalking self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_TheIWLineOfTheIWalking self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_TheIWLineOfTheIWalking self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DecrementRefCounter(self, *args)

Handle_IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_swigregister
Handle_IntPatch_TheIWLineOfTheIWalking_swigregister(Handle_IntPatch_TheIWLineOfTheIWalking)

def Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(thing):
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(thing)
Handle_IntPatch_TheIWLineOfTheIWalking_DownCast = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast

class IntPatch_ALineToWLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_ALineToWLine self, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Standard_Integer const theNbPoints=200) -> IntPatch_ALineToWLine

        Constructor

        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theNbPoints: int

        """
        this = _IntPatch.new_IntPatch_ALineToWLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolOpenDomain(self, *args):
        """
        SetTolOpenDomain(IntPatch_ALineToWLine self, Standard_Real const aT)

        :type aT: float

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolOpenDomain(self, *args)


    def TolOpenDomain(self, *args):
        """
        TolOpenDomain(IntPatch_ALineToWLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ALineToWLine_TolOpenDomain(self, *args)


    def SetTolTransition(self, *args):
        """
        SetTolTransition(IntPatch_ALineToWLine self, Standard_Real const aT)

        :type aT: float

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolTransition(self, *args)


    def TolTransition(self, *args):
        """
        TolTransition(IntPatch_ALineToWLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ALineToWLine_TolTransition(self, *args)


    def SetTol3D(self, *args):
        """
        SetTol3D(IntPatch_ALineToWLine self, Standard_Real const aT)

        :type aT: float

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTol3D(self, *args)


    def Tol3D(self, *args):
        """
        Tol3D(IntPatch_ALineToWLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ALineToWLine_Tol3D(self, *args)


    def MakeWLine(self, *args):
        """
        MakeWLine(IntPatch_ALineToWLine self, Handle_IntPatch_ALine aline, NCollection_Sequence_Handle_IntPatch_Line theLines)
        MakeWLine(IntPatch_ALineToWLine self, Handle_IntPatch_ALine aline, Standard_Real const paraminf, Standard_Real const paramsup, NCollection_Sequence_Handle_IntPatch_Line theLines)

        Converts aline (limitted by paraminf and paramsup) to the set of 
        Walking-lines and adds them in theLines.

        :type aline: OCC.wrapper.IntPatch.Handle_IntPatch_ALine
        :type paraminf: float
        :type paramsup: float
        :type theLines: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine

        """
        return _IntPatch.IntPatch_ALineToWLine_MakeWLine(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALineToWLine
IntPatch_ALineToWLine_swigregister = _IntPatch.IntPatch_ALineToWLine_swigregister
IntPatch_ALineToWLine_swigregister(IntPatch_ALineToWLine)

class NCollection_Sequence_Handle_IntPatch_Line(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_IntPatch_Line self) -> NCollection_Sequence< opencascade::handle< IntPatch_Line > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_IntPatch_Line self) -> NCollection_Sequence< opencascade::handle< IntPatch_Line > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_IntPatch_Line self) -> NCollection_Sequence< opencascade::handle< IntPatch_Line > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_IntPatch_Line self) -> NCollection_Sequence< opencascade::handle< IntPatch_Line > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntPatch.new_NCollection_Sequence_Handle_IntPatch_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_IntPatch_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_IntPatch_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_IntPatch_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_IntPatch_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_IntPatch_Line self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_IntPatch_Line self)

        Reverse sequence


        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_IntPatch_Line self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_IntPatch_Line self, NCollection_Sequence_Handle_IntPatch_Line theOther) -> NCollection_Sequence_Handle_IntPatch_Line

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_IntPatch_Line self, NCollection_Sequence_Handle_IntPatch_Line theOther) -> NCollection_Sequence_Handle_IntPatch_Line

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_IntPatch_Line self, NCollection_Sequence< opencascade::handle< IntPatch_Line > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_IntPatch_Line self, Handle_IntPatch_Line theItem)
        Append(NCollection_Sequence_Handle_IntPatch_Line self, NCollection_Sequence_Handle_IntPatch_Line theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_IntPatch_Line self, Handle_IntPatch_Line theItem)
        Prepend(NCollection_Sequence_Handle_IntPatch_Line self, NCollection_Sequence_Handle_IntPatch_Line theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex, Handle_IntPatch_Line theItem)
        InsertBefore(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IntPatch_Line theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_IntPatch_Line self, NCollection_Sequence< opencascade::handle< IntPatch_Line > >::Iterator & thePosition, Handle_IntPatch_Line theItem)
        InsertAfter(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IntPatch_Line theSeq)
        InsertAfter(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex, Handle_IntPatch_Line theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IntPatch_Line theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_IntPatch_Line self) -> Handle_IntPatch_Line

        First item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_IntPatch_Line self) -> Handle_IntPatch_Line

        Last item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex) -> Handle_IntPatch_Line

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_Line___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_IntPatch_Line self, Standard_Integer const theIndex, Handle_IntPatch_Line theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_SetValue(self, *args)


    def __iter__(self):
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line___iter__(self)
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_Handle_IntPatch_Line
NCollection_Sequence_Handle_IntPatch_Line_swigregister = _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_swigregister
NCollection_Sequence_Handle_IntPatch_Line_swigregister(NCollection_Sequence_Handle_IntPatch_Line)

def NCollection_Sequence_Handle_IntPatch_Line_delNode(*args):
    """
    NCollection_Sequence_Handle_IntPatch_Line_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_delNode(*args)

class NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPatch.new_NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper

    def __next__(self):
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper___next__(self)
NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper_swigregister = _IntPatch.NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper_swigregister
NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper_swigregister(NCollection_Sequence_Handle_IntPatch_Line_IteratorHelper)


try:
	IntPatch_SequenceOfLine = NCollection_Sequence_Handle_IntPatch_Line
except NameError:
	pass # does not exist, probably ignored

class IntPatch_WLine(IntPatch_PointLine):
    """
    Definition of set of points as a result of the intersection
    between 2 parametrised patches.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_WLine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_WLine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntPatch_WLine self, Handle_IntSurf_LineOn2S Line, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_WLine
        __init__(IntPatch_WLine self, Handle_IntSurf_LineOn2S Line, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_WLine
        __init__(IntPatch_WLine self, Handle_IntSurf_LineOn2S Line, Standard_Boolean const Tang) -> IntPatch_WLine

        Creates a WLine as an intersection when the
        transitions are Undecided.

        :type Line: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S
        :type Tang: bool

        """
        this = _IntPatch.new_IntPatch_WLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddVertex(self, *args):
        """
        AddVertex(IntPatch_WLine self, IntPatch_Point Pnt, Standard_Boolean const theIsPrepend)

        Adds a vertex in the list. If theIsPrepend == TRUE the new
        vertex will be added before the first element of vertices sequence.
        Otherwise, to the end of the sequence

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point
        :type theIsPrepend: bool

        """
        return _IntPatch.IntPatch_WLine_AddVertex(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(IntPatch_WLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Set the Point of index <Index> in the LineOn2S

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_SetPoint(self, *args)


    def Replace(self, *args):
        """
        Replace(IntPatch_WLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Replaces the element of range Index in the list
        of points.
        The exception OutOfRange is raised when
        Index <= 0 or Index > NbVertex.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(IntPatch_WLine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.IntPatch_WLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(IntPatch_WLine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.IntPatch_WLine_SetLastPoint(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(IntPatch_WLine self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_WLine_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.IntPatch_WLine_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntPatch_WLine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntPatch_WLine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the Point corresponding to the FirstPoint.
        Indfirst is the index of the first in the list
        of vertices.

        :type Indfirst: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_WLine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the Point corresponding to the LastPoint.
        Indlast is the index of the last in the list
        of vertices.

        :type Indlast: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_WLine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(IntPatch_WLine self) -> Standard_Integer

        Returns number of vertices (IntPatch_Point) of the line

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_WLine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_WLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(IntPatch_WLine self, Standard_Integer const Index) -> IntPatch_Point

        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(IntPatch_WLine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.IntPatch_WLine_ComputeVertexParameters(self, *args)


    def Curve(self, *args):
        """
        Curve(IntPatch_WLine self) -> Handle_IntSurf_LineOn2S

        Returns set of intersection points

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.IntPatch_WLine_Curve(self, *args)


    def IsOutSurf1Box(self, *args):
        """
        IsOutSurf1Box(IntPatch_WLine self, gp_Pnt2d P1) -> Standard_Boolean

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_IsOutSurf1Box(self, *args)


    def IsOutSurf2Box(self, *args):
        """
        IsOutSurf2Box(IntPatch_WLine self, gp_Pnt2d P1) -> Standard_Boolean

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_IsOutSurf2Box(self, *args)


    def IsOutBox(self, *args):
        """
        IsOutBox(IntPatch_WLine self, gp_Pnt P) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_IsOutBox(self, *args)


    def SetPeriod(self, *args):
        """
        SetPeriod(IntPatch_WLine self, Standard_Real const pu1, Standard_Real const pv1, Standard_Real const pu2, Standard_Real const pv2)

        :type pu1: float
        :type pv1: float
        :type pu2: float
        :type pv2: float

        """
        return _IntPatch.IntPatch_WLine_SetPeriod(self, *args)


    def U1Period(self, *args):
        """
        U1Period(IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_WLine_U1Period(self, *args)


    def V1Period(self, *args):
        """
        V1Period(IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_WLine_V1Period(self, *args)


    def U2Period(self, *args):
        """
        U2Period(IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_WLine_U2Period(self, *args)


    def V2Period(self, *args):
        """
        V2Period(IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_WLine_V2Period(self, *args)


    def SetArcOnS1(self, *args):
        """
        SetArcOnS1(IntPatch_WLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_WLine_SetArcOnS1(self, *args)


    def HasArcOnS1(self, *args):
        """
        HasArcOnS1(IntPatch_WLine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_HasArcOnS1(self, *args)


    def GetArcOnS1(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_WLine_GetArcOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArcOnS2(self, *args):
        """
        SetArcOnS2(IntPatch_WLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.IntPatch_WLine_SetArcOnS2(self, *args)


    def HasArcOnS2(self, *args):
        """
        HasArcOnS2(IntPatch_WLine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_HasArcOnS2(self, *args)


    def GetArcOnS2(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_WLine_GetArcOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClearVertexes(self, *args):
        """
        ClearVertexes(IntPatch_WLine self)

        Removes vertices from the line (i.e. cleans svtx member)


        """
        return _IntPatch.IntPatch_WLine_ClearVertexes(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(IntPatch_WLine self, Standard_Integer const theIndex)

        Removes single vertex from the line

        :type theIndex: int

        """
        return _IntPatch.IntPatch_WLine_RemoveVertex(self, *args)


    def InsertVertexBefore(self, *args):
        """
        InsertVertexBefore(IntPatch_WLine self, Standard_Integer const theIndex, IntPatch_Point thePnt)

        :type theIndex: int
        :type thePnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_WLine_InsertVertexBefore(self, *args)


    def Dump(self, *args):
        """
        Dump(IntPatch_WLine self, Standard_Integer const theMode)

        if (theMode == 0) then prints the information about WLine
        if (theMode == 1) then prints the list of 3d-points
        if (theMode == 2) then prints the list of 2d-points on the 1st surface
        Otherwise,             prints list of 2d-points on the 2nd surface

        :type theMode: int

        """
        return _IntPatch.IntPatch_WLine_Dump(self, *args)


    def EnablePurging(self, *args):
        """
        EnablePurging(IntPatch_WLine self, Standard_Boolean const theIsEnabled)

        Allows or forbides purging of existing WLine

        :type theIsEnabled: bool

        """
        return _IntPatch.IntPatch_WLine_EnablePurging(self, *args)


    def IsPurgingAllowed(self, *args):
        """
        IsPurgingAllowed(IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if purging is allowed or forbiden for existing WLine

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_WLine_IsPurgingAllowed(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_WLine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_WLine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_WLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_WLine
IntPatch_WLine_swigregister = _IntPatch.IntPatch_WLine_swigregister
IntPatch_WLine_swigregister(IntPatch_WLine)

def IntPatch_WLine_get_type_name(*args):
    """
    IntPatch_WLine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_WLine_get_type_name(*args)

def IntPatch_WLine_get_type_descriptor(*args):
    """
    IntPatch_WLine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_WLine_get_type_descriptor(*args)

class IntPatch_WLineTool(object):
    """IntPatch_WLineTool provides set of static methods related to walking lines."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputePurgedWLine(*args):
        """
        ComputePurgedWLine(Handle_IntPatch_WLine theWLine, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Handle_Adaptor3d_TopolTool theDom1, Handle_Adaptor3d_TopolTool theDom2) -> Handle_IntPatch_WLine

        I
        Removes equal points (leave one of equal points) from theWLine
        and recompute vertex parameters.

        II
        Removes point out of borders in case of non periodic surfaces.

        III
        Removes exceed points using tube criteria:
        delete 7D point if it lies near to expected lines in 2d and 3d.
        Each task (2d, 2d, 3d) have its own tolerance and checked separately.

        Returns new WLine or null WLine if the number
        of the points is less than 2.

        :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theDom1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type theDom2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_WLine

        """
        return _IntPatch.IntPatch_WLineTool_ComputePurgedWLine(*args)

    ComputePurgedWLine = staticmethod(ComputePurgedWLine)

    def JoinWLines(*args):
        """
        JoinWLines(NCollection_Sequence_Handle_IntPatch_Line theSlin, NCollection_Sequence_IntPatch_Point theSPnt, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Standard_Real const theTol3D)

        Joins all WLines from theSlin to one if it is possible and records 
        the result into theSlin again. Lines will be kept to be split if:
        a) they are separated (has no common points);
        b) resulted line (after joining) go through seam-edges or surface boundaries.

        In addition, if points in theSPnt lies at least in one of the line in theSlin,
        this point will be deleted.

        :type theSlin: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
        :type theSPnt: OCC.wrapper.IntPatch.IntPatch_SequenceOfPoint
        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theTol3D: float

        """
        return _IntPatch.IntPatch_WLineTool_JoinWLines(*args)

    JoinWLines = staticmethod(JoinWLines)

    def ExtendTwoWLines(*args):
        """
        ExtendTwoWLines(NCollection_Sequence_Handle_IntPatch_Line theSlin, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Standard_Real const theToler3D, Standard_Real const *const theArrPeriods, Bnd_Box2d theBoxS1, Bnd_Box2d theBoxS2, NCollection_List< gp_Pnt > const & theListOfCriticalPoints)

        Extends every line from theSlin (if it is possible) to be started/finished
        in strictly determined point (in the place of joint of two lines).
        As result, some gaps between two lines will vanish.
        The Walking lines are supposed (algorithm will do nothing for not-Walking line)
        to be computed as a result of intersection. Both theS1 and theS2 
        must be quadrics. Other cases are not supported.
        theArrPeriods must be filled as follows (every value must not be negative;
        if the surface is not periodic the period must be equal to 0.0 strictly):
        {<U-period of 1st surface>, <V-period of 1st surface>,
        <U-period of 2nd surface>, <V-period of 2nd surface>}.
        theListOfCriticalPoints must contain 3D-points where joining is disabled.

        :type theSlin: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theToler3D: float
        :type theArrPeriods: float
        :type theBoxS1: OCC.wrapper.Bnd.Bnd_Box2d
        :type theBoxS2: OCC.wrapper.Bnd.Bnd_Box2d
        :type theListOfCriticalPoints: OCC.wrapper.IntPatch.NCollection_List_gp_Pnt

        """
        return _IntPatch.IntPatch_WLineTool_ExtendTwoWLines(*args)

    ExtendTwoWLines = staticmethod(ExtendTwoWLines)

    def __init__(self):
        """IntPatch_WLineTool provides set of static methods related to walking lines."""
        this = _IntPatch.new_IntPatch_WLineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_WLineTool
IntPatch_WLineTool_swigregister = _IntPatch.IntPatch_WLineTool_swigregister
IntPatch_WLineTool_swigregister(IntPatch_WLineTool)

def IntPatch_WLineTool_ComputePurgedWLine(*args):
    """
    IntPatch_WLineTool_ComputePurgedWLine(Handle_IntPatch_WLine theWLine, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Handle_Adaptor3d_TopolTool theDom1, Handle_Adaptor3d_TopolTool theDom2) -> Handle_IntPatch_WLine

    I
    Removes equal points (leave one of equal points) from theWLine
    and recompute vertex parameters.

    II
    Removes point out of borders in case of non periodic surfaces.

    III
    Removes exceed points using tube criteria:
    delete 7D point if it lies near to expected lines in 2d and 3d.
    Each task (2d, 2d, 3d) have its own tolerance and checked separately.

    Returns new WLine or null WLine if the number
    of the points is less than 2.

    :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
    :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theDom1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
    :type theDom2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
    :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_WLine

    """
    return _IntPatch.IntPatch_WLineTool_ComputePurgedWLine(*args)

def IntPatch_WLineTool_JoinWLines(*args):
    """
    IntPatch_WLineTool_JoinWLines(NCollection_Sequence_Handle_IntPatch_Line theSlin, NCollection_Sequence_IntPatch_Point theSPnt, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Standard_Real const theTol3D)

    Joins all WLines from theSlin to one if it is possible and records 
    the result into theSlin again. Lines will be kept to be split if:
    a) they are separated (has no common points);
    b) resulted line (after joining) go through seam-edges or surface boundaries.

    In addition, if points in theSPnt lies at least in one of the line in theSlin,
    this point will be deleted.

    :type theSlin: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
    :type theSPnt: OCC.wrapper.IntPatch.IntPatch_SequenceOfPoint
    :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theTol3D: float

    """
    return _IntPatch.IntPatch_WLineTool_JoinWLines(*args)

def IntPatch_WLineTool_ExtendTwoWLines(*args):
    """
    IntPatch_WLineTool_ExtendTwoWLines(NCollection_Sequence_Handle_IntPatch_Line theSlin, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, Standard_Real const theToler3D, Standard_Real const *const theArrPeriods, Bnd_Box2d theBoxS1, Bnd_Box2d theBoxS2, NCollection_List< gp_Pnt > const & theListOfCriticalPoints)

    Extends every line from theSlin (if it is possible) to be started/finished
    in strictly determined point (in the place of joint of two lines).
    As result, some gaps between two lines will vanish.
    The Walking lines are supposed (algorithm will do nothing for not-Walking line)
    to be computed as a result of intersection. Both theS1 and theS2 
    must be quadrics. Other cases are not supported.
    theArrPeriods must be filled as follows (every value must not be negative;
    if the surface is not periodic the period must be equal to 0.0 strictly):
    {<U-period of 1st surface>, <V-period of 1st surface>,
    <U-period of 2nd surface>, <V-period of 2nd surface>}.
    theListOfCriticalPoints must contain 3D-points where joining is disabled.

    :type theSlin: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
    :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theToler3D: float
    :type theArrPeriods: float
    :type theBoxS1: OCC.wrapper.Bnd.Bnd_Box2d
    :type theBoxS2: OCC.wrapper.Bnd.Bnd_Box2d
    :type theListOfCriticalPoints: OCC.wrapper.IntPatch.NCollection_List_gp_Pnt

    """
    return _IntPatch.IntPatch_WLineTool_ExtendTwoWLines(*args)

class Handle_IntPatch_PointLine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_PointLine self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_PointLine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_PointLine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_PointLine self, IntPatch_PointLine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_PointLine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_PointLine self, Handle_IntPatch_PointLine theHandle) -> Handle_IntPatch_PointLine
        assign(Handle_IntPatch_PointLine self, IntPatch_PointLine thePtr) -> Handle_IntPatch_PointLine
        assign(Handle_IntPatch_PointLine self, Handle_IntPatch_PointLine theHandle) -> Handle_IntPatch_PointLine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_PointLine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_PointLine self) -> IntPatch_PointLine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_PointLine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_PointLine self) -> IntPatch_PointLine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_PointLine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_PointLine self) -> IntPatch_PointLine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_PointLine___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_PointLine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_PointLine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_PointLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_PointLine_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_PointLine

    def AddVertex(self, *args):
        """
        AddVertex(Handle_IntPatch_PointLine self, IntPatch_Point Pnt, Standard_Boolean const theIsPrepend)

        Adds a vertex in the list. If theIsPrepend == TRUE the new
        vertex will be added before the first element of vertices sequence.
        Otherwise, to the end of the sequence

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point
        :type theIsPrepend: bool

        """
        return _IntPatch.Handle_IntPatch_PointLine_AddVertex(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(Handle_IntPatch_PointLine self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_PointLine_NbPnts(self, *args)


    def NbVertex(self, *args):
        """
        NbVertex(Handle_IntPatch_PointLine self) -> Standard_Integer

        Returns number of vertices (IntPatch_Point) of the line

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_PointLine_NbVertex(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.Handle_IntPatch_PointLine_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_PointLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(Handle_IntPatch_PointLine self, Standard_Integer const Index) -> IntPatch_Point

        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_PointLine_ChangeVertex(self, *args)


    def ClearVertexes(self, *args):
        """
        ClearVertexes(Handle_IntPatch_PointLine self)

        Removes vertices from the line


        """
        return _IntPatch.Handle_IntPatch_PointLine_ClearVertexes(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(Handle_IntPatch_PointLine self, Standard_Integer const theIndex)

        Removes single vertex from the line

        :type theIndex: int

        """
        return _IntPatch.Handle_IntPatch_PointLine_RemoveVertex(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_IntPatch_PointLine self) -> Handle_IntSurf_LineOn2S

        Returns set of intersection points

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.Handle_IntPatch_PointLine_Curve(self, *args)


    def CurvatureRadiusOfIntersLine(self, *args):
        """
        CurvatureRadiusOfIntersLine(Handle_IntPatch_PointLine self, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, IntSurf_PntOn2S theUVPoint) -> Standard_Real

        Returns the radius of curvature of
        the intersection line in given point.
        Returns negative value if computation is not possible.

        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUVPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_PointLine_CurvatureRadiusOfIntersLine(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_PointLine self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_PointLine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_PointLine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_PointLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Handle_IntPatch_PointLine self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.Handle_IntPatch_PointLine_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(Handle_IntPatch_PointLine self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.Handle_IntPatch_PointLine_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Handle_IntPatch_PointLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_IntPatch_PointLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_PointLine_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_IntPatch_PointLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_PointLine_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(Handle_IntPatch_PointLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_PointLine_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(Handle_IntPatch_PointLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_PointLine_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(Handle_IntPatch_PointLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(Handle_IntPatch_PointLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(Handle_IntPatch_PointLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(Handle_IntPatch_PointLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsVIsoOnS2(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_PointLine self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_PointLine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_PointLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_PointLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_PointLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_PointLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_PointLine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_PointLine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_PointLine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_PointLine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_PointLine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_PointLine self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_PointLine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_PointLine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_PointLine_DecrementRefCounter(self, *args)

Handle_IntPatch_PointLine_swigregister = _IntPatch.Handle_IntPatch_PointLine_swigregister
Handle_IntPatch_PointLine_swigregister(Handle_IntPatch_PointLine)

def Handle_IntPatch_PointLine_DownCast(thing):
    return _IntPatch.Handle_IntPatch_PointLine_DownCast(thing)
Handle_IntPatch_PointLine_DownCast = _IntPatch.Handle_IntPatch_PointLine_DownCast

class IntPatch_TheIWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_TheIWalking self, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Step, Standard_Boolean const theToFillHoles) -> IntPatch_TheIWalking

        Deflection is the maximum deflection admitted between two
        consecutive points on a resulting polyline.
        Step is the maximum increment admitted between two
        consecutive points (in 2d space).
        Epsilon is the tolerance beyond which 2 points
        are confused.
        theToFillHoles is the flag defining whether possible holes
        between resulting curves are filled or not
        in case of IntPatch walking theToFillHoles is False

        :type Epsilon: float
        :type Deflection: float
        :type Step: float
        :type theToFillHoles: bool

        """
        this = _IntPatch.new_IntPatch_TheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerance(self, *args):
        """
        SetTolerance(IntPatch_TheIWalking self, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Step)

        Deflection is the maximum deflection admitted between two
        consecutive points on a resulting polyline.
        Step is the maximum increment admitted between two
        consecutive points (in 2d space).
        Epsilon is the tolerance beyond which 2 points
        are confused

        :type Epsilon: float
        :type Deflection: float
        :type Step: float

        """
        return _IntPatch.IntPatch_TheIWalking_SetTolerance(self, *args)


    def Perform(self, *args):
        """
        Perform(IntPatch_TheIWalking self, NCollection_Sequence_IntSurf_PathPoint Pnts1, NCollection_Sequence_IntSurf_InteriorPoint Pnts2, IntPatch_TheSurfFunction Func, Handle_Adaptor3d_HSurface S, Standard_Boolean const Reversed)
        Perform(IntPatch_TheIWalking self, NCollection_Sequence_IntSurf_PathPoint Pnts1, IntPatch_TheSurfFunction Func, Handle_Adaptor3d_HSurface S, Standard_Boolean const Reversed)

        Searches a set of polylines starting on a point of Pnts1.
        Each point on a resulting polyline verifies F(u,v)=0

        :type Pnts1: OCC.wrapper.IntSurf.IntSurf_SequenceOfPathPoint
        :type Func: OCC.wrapper.IntPatch.IntPatch_TheSurfFunction
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Reversed: bool

        """
        return _IntPatch.IntPatch_TheIWalking_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_TheIWalking self) -> Standard_Boolean

        Returns true if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheIWalking_IsDone(self, *args)


    def NbLines(self, *args):
        """
        NbLines(IntPatch_TheIWalking self) -> Standard_Integer

        Returns the number of resulting polylines.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheIWalking_NbLines(self, *args)


    def Value(self, *args):
        """
        Returns the polyline of range Index.
        An exception is raised if IsDone is False.
        An exception is raised if Index<=0 or Index>NbLines.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking

        """
        res = _IntPatch.IntPatch_TheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSinglePnts(self, *args):
        """
        NbSinglePnts(IntPatch_TheIWalking self) -> Standard_Integer

        Returns the number of points belonging to Pnts on which no
        line starts or ends.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheIWalking_NbSinglePnts(self, *args)


    def SinglePnt(self, *args):
        """
        Returns the point of range Index .
        An exception is raised if IsDone returns False.
        An exception is raised if Index<=0 or
        Index > NbSinglePnts.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _IntPatch.IntPatch_TheIWalking_SinglePnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWalking
IntPatch_TheIWalking_swigregister = _IntPatch.IntPatch_TheIWalking_swigregister
IntPatch_TheIWalking_swigregister(IntPatch_TheIWalking)

class Handle_IntPatch_RLine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_RLine self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_RLine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_RLine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_RLine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_RLine self, IntPatch_RLine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_RLine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_RLine self, Handle_IntPatch_RLine theHandle) -> Handle_IntPatch_RLine
        assign(Handle_IntPatch_RLine self, IntPatch_RLine thePtr) -> Handle_IntPatch_RLine
        assign(Handle_IntPatch_RLine self, Handle_IntPatch_RLine theHandle) -> Handle_IntPatch_RLine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_RLine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_RLine self) -> IntPatch_RLine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_RLine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_RLine self) -> IntPatch_RLine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_RLine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_RLine self) -> IntPatch_RLine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_RLine___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_RLine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_RLine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_RLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_RLine_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_RLine

    def AddVertex(self, *args):
        """
        AddVertex(Handle_IntPatch_RLine self, IntPatch_Point Pnt, Standard_Boolean const theIsPrepend)

        Adds a vertex in the list. If theIsPrepend == TRUE the new
        vertex will be added before the first element of vertices sequence.
        Otherwise, to the end of the sequence

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point
        :type theIsPrepend: bool

        """
        return _IntPatch.Handle_IntPatch_RLine_AddVertex(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_IntPatch_RLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Replaces the element of range Index in the list
        of points.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_RLine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(Handle_IntPatch_RLine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.Handle_IntPatch_RLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(Handle_IntPatch_RLine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.Handle_IntPatch_RLine_SetLastPoint(self, *args)


    def Add(self, *args):
        """
        Add(Handle_IntPatch_RLine self, Handle_IntSurf_LineOn2S L)

        :type L: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.Handle_IntPatch_RLine_Add(self, *args)


    def IsArcOnS1(self, *args):
        """
        IsArcOnS1(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns True if the intersection is on the domain of the
        first patch.
        Returns False if the intersection is on the domain of
        the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsArcOnS1(self, *args)


    def IsArcOnS2(self, *args):
        """
        IsArcOnS2(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns True if the intersection is on the domain of the
        first patch.
        Returns False if the intersection is on the domain of
        the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsArcOnS2(self, *args)


    def SetArcOnS1(self, *args):
        """
        SetArcOnS1(Handle_IntPatch_RLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.Handle_IntPatch_RLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args):
        """
        SetArcOnS2(Handle_IntPatch_RLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.Handle_IntPatch_RLine_SetArcOnS2(self, *args)


    def ArcOnS1(self, *args):
        """
        Returns the concerned arc.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.Handle_IntPatch_RLine_ArcOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ArcOnS2(self, *args):
        """
        Returns the concerned arc.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.Handle_IntPatch_RLine_ArcOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamOnS1(self, *args):
        """
        ParamOnS1(Handle_IntPatch_RLine self)

        :type p1: float
        :type p2: float

        """
        return _IntPatch.Handle_IntPatch_RLine_ParamOnS1(self, *args)


    def ParamOnS2(self, *args):
        """
        ParamOnS2(Handle_IntPatch_RLine self)

        :type p1: float
        :type p2: float

        """
        return _IntPatch.Handle_IntPatch_RLine_ParamOnS2(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the IntPoint corresponding to the FirstPoint.
        An exception is raised when HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_RLine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the IntPoint corresponding to the LastPoint.
        An exception is raised when HasLastPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_RLine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(Handle_IntPatch_RLine self) -> Standard_Integer

        Returns number of vertices (IntPatch_Point) of the line

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_RLine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_RLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(Handle_IntPatch_RLine self, Standard_Integer const Index) -> IntPatch_Point

        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_RLine_ChangeVertex(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(Handle_IntPatch_RLine self, Standard_Integer const theIndex)

        Removes single vertex from the line

        :type theIndex: int

        """
        return _IntPatch.Handle_IntPatch_RLine_RemoveVertex(self, *args)


    def HasPolygon(self, *args):
        """
        HasPolygon(Handle_IntPatch_RLine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_HasPolygon(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(Handle_IntPatch_RLine self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_RLine_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.Handle_IntPatch_RLine_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPoint(self, *args):
        """
        SetPoint(Handle_IntPatch_RLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Set the Point of index <Index> in the LineOn2S

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_RLine_SetPoint(self, *args)


    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(Handle_IntPatch_RLine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.Handle_IntPatch_RLine_ComputeVertexParameters(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_IntPatch_RLine self) -> Handle_IntSurf_LineOn2S

        Returns set of intersection points

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.Handle_IntPatch_RLine_Curve(self, *args)


    def ClearVertexes(self, *args):
        """
        ClearVertexes(Handle_IntPatch_RLine self)

        Removes vertices from the line (i.e. cleans svtx member)


        """
        return _IntPatch.Handle_IntPatch_RLine_ClearVertexes(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_IntPatch_RLine self, Handle_IntSurf_LineOn2S theNewCurve)

        :type theNewCurve: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.Handle_IntPatch_RLine_SetCurve(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_IntPatch_RLine self, Standard_Integer const theMode)

        if (theMode == 0) then prints the information about WLine
        if (theMode == 1) then prints the list of 3d-points
        if (theMode == 2) then prints the list of 2d-points on the 1st surface
        Otherwise,             prints list of 2d-points on the 2nd surface

        :type theMode: int

        """
        return _IntPatch.Handle_IntPatch_RLine_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_RLine self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_RLine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_RLine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_RLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurvatureRadiusOfIntersLine(self, *args):
        """
        CurvatureRadiusOfIntersLine(Handle_IntPatch_RLine self, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, IntSurf_PntOn2S theUVPoint) -> Standard_Real

        Returns the radius of curvature of
        the intersection line in given point.
        Returns negative value if computation is not possible.

        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUVPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_RLine_CurvatureRadiusOfIntersLine(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_IntPatch_RLine self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.Handle_IntPatch_RLine_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(Handle_IntPatch_RLine self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.Handle_IntPatch_RLine_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_IntPatch_RLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_RLine_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_IntPatch_RLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_RLine_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(Handle_IntPatch_RLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_RLine_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(Handle_IntPatch_RLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_RLine_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(Handle_IntPatch_RLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsVIsoOnS2(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_RLine self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_RLine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_RLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_RLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_RLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_RLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_RLine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_RLine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_RLine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_RLine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_RLine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_RLine self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_RLine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_RLine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_RLine_DecrementRefCounter(self, *args)

Handle_IntPatch_RLine_swigregister = _IntPatch.Handle_IntPatch_RLine_swigregister
Handle_IntPatch_RLine_swigregister(Handle_IntPatch_RLine)

def Handle_IntPatch_RLine_DownCast(thing):
    return _IntPatch.Handle_IntPatch_RLine_DownCast(thing)
Handle_IntPatch_RLine_DownCast = _IntPatch.Handle_IntPatch_RLine_DownCast

class IntPatch_CurvIntSurf(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_CurvIntSurf self, Standard_Real const U, Standard_Real const V, Standard_Real const W, IntPatch_CSFunction F, Standard_Real const TolTangency, Standard_Real const MarginCoef=0.0) -> IntPatch_CurvIntSurf
        __init__(IntPatch_CurvIntSurf self, IntPatch_CSFunction F, Standard_Real const TolTangency) -> IntPatch_CurvIntSurf

        initialize the parameters to compute the solution

        :type F: OCC.wrapper.IntPatch.IntPatch_CSFunction
        :type TolTangency: float

        """
        this = _IntPatch.new_IntPatch_CurvIntSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_CurvIntSurf self, Standard_Real const U, Standard_Real const V, Standard_Real const W, math_FunctionSetRoot Rsnld, Standard_Real const u0, Standard_Real const v0, Standard_Real const u1, Standard_Real const v1, Standard_Real const w0, Standard_Real const w1)

        compute the solution
        it's possible to write to optimize:
        IntImp_IntCS inter(S1,C1,Toltangency)
        math_FunctionSetRoot rsnld(Inter.function())
        while ...{
        u=...
        v=...
        w=...
        inter.Perform(u,v,w,rsnld)
        }
        or
        IntImp_IntCS inter(Toltangency)
        inter.SetSurface(S);
        math_FunctionSetRoot rsnld(Inter.function())
        while ...{
        C=...
        inter.SetCurve(C);
        u=...
        v=...
        w=...
        inter.Perform(u,v,w,rsnld)
        }

        :type U: float
        :type V: float
        :type W: float
        :type Rsnld: OCC.wrapper.math.math_FunctionSetRoot
        :type u0: float
        :type v0: float
        :type u1: float
        :type v1: float
        :type w0: float
        :type w1: float

        """
        return _IntPatch.IntPatch_CurvIntSurf_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_CurvIntSurf self) -> Standard_Boolean

        Returns TRUE if the creation completed without failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_CurvIntSurf_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntPatch_CurvIntSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_CurvIntSurf_IsEmpty(self, *args)


    def Point(self, *args):
        """
        returns the intersection point
        The exception NotDone is raised if IsDone is false.
        The exception DomainError is raised if IsEmpty is true.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_CurvIntSurf_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnCurve(self, *args):
        """
        ParameterOnCurve(IntPatch_CurvIntSurf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args):
        """
        ParameterOnSurface(IntPatch_CurvIntSurf self)

        :type U: float
        :type V: float

        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnSurface(self, *args)


    def Function(self, *args):
        """
        Function(IntPatch_CurvIntSurf self) -> IntPatch_CSFunction

        return the math function which
        is used to compute the intersection

        :rtype: OCC.wrapper.IntPatch.IntPatch_CSFunction

        """
        return _IntPatch.IntPatch_CurvIntSurf_Function(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_CurvIntSurf
IntPatch_CurvIntSurf_swigregister = _IntPatch.IntPatch_CurvIntSurf_swigregister
IntPatch_CurvIntSurf_swigregister(IntPatch_CurvIntSurf)

class IntPatch_InterferencePolyhedron(Intf.Intf_Interference):
    """
    Computes the  interference between two polyhedra or the
    self interference of a polyhedron. Points of intersection,
    polylines  of intersection and zones of tangence.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_InterferencePolyhedron self) -> IntPatch_InterferencePolyhedron
        __init__(IntPatch_InterferencePolyhedron self, IntPatch_Polyhedron Obje1, IntPatch_Polyhedron Obje2) -> IntPatch_InterferencePolyhedron
        __init__(IntPatch_InterferencePolyhedron self, IntPatch_Polyhedron Obje) -> IntPatch_InterferencePolyhedron

        Constructs  and  computes   the self   interference  of   a
        Polyhedron.

        :type Obje: OCC.wrapper.IntPatch.IntPatch_Polyhedron

        """
        this = _IntPatch.new_IntPatch_InterferencePolyhedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_InterferencePolyhedron self, IntPatch_Polyhedron Obje1, IntPatch_Polyhedron Obje2)
        Perform(IntPatch_InterferencePolyhedron self, IntPatch_Polyhedron Obje)

        Computes the self interference of a Polyhedron.

        :type Obje: OCC.wrapper.IntPatch.IntPatch_Polyhedron

        """
        return _IntPatch.IntPatch_InterferencePolyhedron_Perform(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_InterferencePolyhedron
IntPatch_InterferencePolyhedron_swigregister = _IntPatch.IntPatch_InterferencePolyhedron_swigregister
IntPatch_InterferencePolyhedron_swigregister(IntPatch_InterferencePolyhedron)

class Handle_IntPatch_WLine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_WLine self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_WLine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_WLine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_WLine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_WLine self, IntPatch_WLine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_WLine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_WLine self, Handle_IntPatch_WLine theHandle) -> Handle_IntPatch_WLine
        assign(Handle_IntPatch_WLine self, IntPatch_WLine thePtr) -> Handle_IntPatch_WLine
        assign(Handle_IntPatch_WLine self, Handle_IntPatch_WLine theHandle) -> Handle_IntPatch_WLine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_WLine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_WLine self) -> IntPatch_WLine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_WLine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_WLine self) -> IntPatch_WLine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_WLine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_WLine self) -> IntPatch_WLine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_WLine___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_WLine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_WLine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_WLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_WLine_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_WLine

    def AddVertex(self, *args):
        """
        AddVertex(Handle_IntPatch_WLine self, IntPatch_Point Pnt, Standard_Boolean const theIsPrepend)

        Adds a vertex in the list. If theIsPrepend == TRUE the new
        vertex will be added before the first element of vertices sequence.
        Otherwise, to the end of the sequence

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point
        :type theIsPrepend: bool

        """
        return _IntPatch.Handle_IntPatch_WLine_AddVertex(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Handle_IntPatch_WLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Set the Point of index <Index> in the LineOn2S

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_WLine_SetPoint(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_IntPatch_WLine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Replaces the element of range Index in the list
        of points.
        The exception OutOfRange is raised when
        Index <= 0 or Index > NbVertex.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_WLine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(Handle_IntPatch_WLine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.Handle_IntPatch_WLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(Handle_IntPatch_WLine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.Handle_IntPatch_WLine_SetLastPoint(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(Handle_IntPatch_WLine self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_WLine_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.Handle_IntPatch_WLine_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the Point corresponding to the FirstPoint.
        Indfirst is the index of the first in the list
        of vertices.

        :type Indfirst: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_WLine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the Point corresponding to the LastPoint.
        Indlast is the index of the last in the list
        of vertices.

        :type Indlast: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_WLine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(Handle_IntPatch_WLine self) -> Standard_Integer

        Returns number of vertices (IntPatch_Point) of the line

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_WLine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_WLine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(Handle_IntPatch_WLine self, Standard_Integer const Index) -> IntPatch_Point

        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_WLine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(Handle_IntPatch_WLine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.Handle_IntPatch_WLine_ComputeVertexParameters(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_IntPatch_WLine self) -> Handle_IntSurf_LineOn2S

        Returns set of intersection points

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntPatch.Handle_IntPatch_WLine_Curve(self, *args)


    def IsOutSurf1Box(self, *args):
        """
        IsOutSurf1Box(Handle_IntPatch_WLine self, gp_Pnt2d P1) -> Standard_Boolean

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsOutSurf1Box(self, *args)


    def IsOutSurf2Box(self, *args):
        """
        IsOutSurf2Box(Handle_IntPatch_WLine self, gp_Pnt2d P1) -> Standard_Boolean

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsOutSurf2Box(self, *args)


    def IsOutBox(self, *args):
        """
        IsOutBox(Handle_IntPatch_WLine self, gp_Pnt P) -> Standard_Boolean

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsOutBox(self, *args)


    def SetPeriod(self, *args):
        """
        SetPeriod(Handle_IntPatch_WLine self, Standard_Real const pu1, Standard_Real const pv1, Standard_Real const pu2, Standard_Real const pv2)

        :type pu1: float
        :type pv1: float
        :type pu2: float
        :type pv2: float

        """
        return _IntPatch.Handle_IntPatch_WLine_SetPeriod(self, *args)


    def U1Period(self, *args):
        """
        U1Period(Handle_IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_WLine_U1Period(self, *args)


    def V1Period(self, *args):
        """
        V1Period(Handle_IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_WLine_V1Period(self, *args)


    def U2Period(self, *args):
        """
        U2Period(Handle_IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_WLine_U2Period(self, *args)


    def V2Period(self, *args):
        """
        V2Period(Handle_IntPatch_WLine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_WLine_V2Period(self, *args)


    def SetArcOnS1(self, *args):
        """
        SetArcOnS1(Handle_IntPatch_WLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.Handle_IntPatch_WLine_SetArcOnS1(self, *args)


    def HasArcOnS1(self, *args):
        """
        HasArcOnS1(Handle_IntPatch_WLine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_HasArcOnS1(self, *args)


    def GetArcOnS1(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.Handle_IntPatch_WLine_GetArcOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArcOnS2(self, *args):
        """
        SetArcOnS2(Handle_IntPatch_WLine self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _IntPatch.Handle_IntPatch_WLine_SetArcOnS2(self, *args)


    def HasArcOnS2(self, *args):
        """
        HasArcOnS2(Handle_IntPatch_WLine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_HasArcOnS2(self, *args)


    def GetArcOnS2(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.Handle_IntPatch_WLine_GetArcOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClearVertexes(self, *args):
        """
        ClearVertexes(Handle_IntPatch_WLine self)

        Removes vertices from the line (i.e. cleans svtx member)


        """
        return _IntPatch.Handle_IntPatch_WLine_ClearVertexes(self, *args)


    def RemoveVertex(self, *args):
        """
        RemoveVertex(Handle_IntPatch_WLine self, Standard_Integer const theIndex)

        Removes single vertex from the line

        :type theIndex: int

        """
        return _IntPatch.Handle_IntPatch_WLine_RemoveVertex(self, *args)


    def InsertVertexBefore(self, *args):
        """
        InsertVertexBefore(Handle_IntPatch_WLine self, Standard_Integer const theIndex, IntPatch_Point thePnt)

        :type theIndex: int
        :type thePnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_WLine_InsertVertexBefore(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_IntPatch_WLine self, Standard_Integer const theMode)

        if (theMode == 0) then prints the information about WLine
        if (theMode == 1) then prints the list of 3d-points
        if (theMode == 2) then prints the list of 2d-points on the 1st surface
        Otherwise,             prints list of 2d-points on the 2nd surface

        :type theMode: int

        """
        return _IntPatch.Handle_IntPatch_WLine_Dump(self, *args)


    def EnablePurging(self, *args):
        """
        EnablePurging(Handle_IntPatch_WLine self, Standard_Boolean const theIsEnabled)

        Allows or forbides purging of existing WLine

        :type theIsEnabled: bool

        """
        return _IntPatch.Handle_IntPatch_WLine_EnablePurging(self, *args)


    def IsPurgingAllowed(self, *args):
        """
        IsPurgingAllowed(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if purging is allowed or forbiden for existing WLine

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsPurgingAllowed(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_WLine self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_WLine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_WLine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_WLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurvatureRadiusOfIntersLine(self, *args):
        """
        CurvatureRadiusOfIntersLine(Handle_IntPatch_WLine self, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2, IntSurf_PntOn2S theUVPoint) -> Standard_Real

        Returns the radius of curvature of
        the intersection line in given point.
        Returns negative value if computation is not possible.

        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUVPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_WLine_CurvatureRadiusOfIntersLine(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_IntPatch_WLine self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.Handle_IntPatch_WLine_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(Handle_IntPatch_WLine self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.Handle_IntPatch_WLine_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_IntPatch_WLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_WLine_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_IntPatch_WLine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_WLine_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(Handle_IntPatch_WLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_WLine_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(Handle_IntPatch_WLine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_WLine_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(Handle_IntPatch_WLine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsVIsoOnS2(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_WLine self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_WLine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_WLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_WLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_WLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_WLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_WLine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_WLine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_WLine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_WLine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_WLine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_WLine self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_WLine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_WLine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_WLine_DecrementRefCounter(self, *args)

Handle_IntPatch_WLine_swigregister = _IntPatch.Handle_IntPatch_WLine_swigregister
Handle_IntPatch_WLine_swigregister(Handle_IntPatch_WLine)

def Handle_IntPatch_WLine_DownCast(thing):
    return _IntPatch.Handle_IntPatch_WLine_DownCast(thing)
Handle_IntPatch_WLine_DownCast = _IntPatch.Handle_IntPatch_WLine_DownCast

class IntPatch_ALine(IntPatch_Line):
    """
    Implementation of an intersection line described by a
    parametrized curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntPatch_ALine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntPatch_ALine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntPatch_ALine self, IntAna_Curve C, Standard_Boolean const Tang, IntSurf_TypeTrans const Trans1, IntSurf_TypeTrans const Trans2) -> IntPatch_ALine
        __init__(IntPatch_ALine self, IntAna_Curve C, Standard_Boolean const Tang, IntSurf_Situation const Situ1, IntSurf_Situation const Situ2) -> IntPatch_ALine
        __init__(IntPatch_ALine self, IntAna_Curve C, Standard_Boolean const Tang) -> IntPatch_ALine

        Creates an analytic intersection line
        when the transitions are Undecided.

        :type C: OCC.wrapper.IntAna.IntAna_Curve
        :type Tang: bool

        """
        this = _IntPatch.new_IntPatch_ALine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddVertex(self, *args):
        """
        AddVertex(IntPatch_ALine self, IntPatch_Point Pnt)

        To add a vertex in the list.

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_AddVertex(self, *args)


    def Replace(self, *args):
        """
        Replace(IntPatch_ALine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Replaces the element of range Index in the list
        of points.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(IntPatch_ALine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.IntPatch_ALine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(IntPatch_ALine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.IntPatch_ALine_SetLastPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(IntPatch_ALine self) -> Standard_Real

        Returns the first parameter on the intersection line.
        If IsIncluded returns True, Value and D1 methods can
        be call with a parameter equal to FirstParamater.
        Otherwise, the parameter must be greater than
        FirstParameter.

        :type IsIncluded: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ALine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(IntPatch_ALine self) -> Standard_Real

        Returns the last parameter on the intersection line.
        If IsIncluded returns True, Value and D1 methods can
        be call with a parameter equal to LastParamater.
        Otherwise, the parameter must be less than LastParameter.

        :type IsIncluded: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_ALine_LastParameter(self, *args)


    def Value(self, *args):
        """
        Value(IntPatch_ALine self, Standard_Real const U) -> gp_Pnt

        Returns the point of parameter U on the analytic
        intersection line.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntPatch.IntPatch_ALine_Value(self, *args)


    def D1(self, *args):
        """
        D1(IntPatch_ALine self, Standard_Real const U, gp_Pnt P, gp_Vec Du) -> Standard_Boolean

        Returns Standard_True when the derivative at parameter U
        is defined on the analytic intersection line.
        In that case, Du is the derivative.
        Returns Standard_False when it is not possible to
        evaluate the derivative.
        In both cases, P is the point at parameter U on the
        intersection.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Du: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ALine_D1(self, *args)


    def FindParameter(self, *args):
        """
        FindParameter(IntPatch_ALine self, gp_Pnt P, NCollection_List_Standard_Real theParams)

        Tries to find the parameters of the point P on the curve.
        If the method returns False, the "projection" is
        impossible.
        If the method returns True at least one parameter has been found.
        theParams is always sorted in ascending order.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type theParams: OCC.wrapper.TColStd.TColStd_ListOfReal

        """
        return _IntPatch.IntPatch_ALine_FindParameter(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(IntPatch_ALine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ALine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(IntPatch_ALine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ALine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the IntPoint corresponding to the FirstPoint.
        An exception is raised when HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_ALine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the IntPoint corresponding to the LastPoint.
        An exception is raised when HasLastPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_ALine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(IntPatch_ALine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ALine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_ALine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(IntPatch_ALine self, Standard_Integer const theIndex) -> IntPatch_Point

        Allows modifying the vertex with index theIndex on the line.

        :type theIndex: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(IntPatch_ALine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.IntPatch_ALine_ComputeVertexParameters(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.IntAna.IntAna_Curve

        """
        res = _IntPatch.IntPatch_ALine_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntPatch.IntPatch_ALine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntPatch.IntPatch_ALine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.IntPatch_ALine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_ALine
IntPatch_ALine_swigregister = _IntPatch.IntPatch_ALine_swigregister
IntPatch_ALine_swigregister(IntPatch_ALine)

def IntPatch_ALine_get_type_name(*args):
    """
    IntPatch_ALine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntPatch.IntPatch_ALine_get_type_name(*args)

def IntPatch_ALine_get_type_descriptor(*args):
    """
    IntPatch_ALine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntPatch.IntPatch_ALine_get_type_descriptor(*args)

class IntPatch_TheSearchInside(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_TheSearchInside self) -> IntPatch_TheSearchInside
        __init__(IntPatch_TheSearchInside self, IntPatch_TheSurfFunction F, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool T, Standard_Real const Epsilon) -> IntPatch_TheSearchInside

        :type F: OCC.wrapper.IntPatch.IntPatch_TheSurfFunction
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type T: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Epsilon: float

        """
        this = _IntPatch.new_IntPatch_TheSearchInside(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_TheSearchInside self, IntPatch_TheSurfFunction F, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool T, Standard_Real const Epsilon)
        Perform(IntPatch_TheSearchInside self, IntPatch_TheSurfFunction F, Handle_Adaptor3d_HSurface Surf, Standard_Real const UStart, Standard_Real const VStart)

        :type F: OCC.wrapper.IntPatch.IntPatch_TheSurfFunction
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type UStart: float
        :type VStart: float

        """
        return _IntPatch.IntPatch_TheSearchInside_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_TheSearchInside self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSearchInside_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_TheSearchInside self) -> Standard_Integer

        Returns the number of points.
        The exception NotDone if raised if IsDone
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheSearchInside_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index.
        The exception NotDone if raised if IsDone
        returns False.
        The exception OutOfRange if raised if
        Index <= 0 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_InteriorPoint

        """
        res = _IntPatch.IntPatch_TheSearchInside_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSearchInside
IntPatch_TheSearchInside_swigregister = _IntPatch.IntPatch_TheSearchInside_swigregister
IntPatch_TheSearchInside_swigregister(IntPatch_TheSearchInside)

class IntPatch_PolyArc(IntPatch_Polygo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_PolyArc self, Handle_Adaptor2d_HCurve2d A, Standard_Integer const NbSample, Standard_Real const Pfirst, Standard_Real const Plast, Bnd_Box2d BoxOtherPolygon) -> IntPatch_PolyArc

        Creates the polygon of the arc A on the surface S.
        The arc is limited by the parameters Pfirst and Plast.
        None of these parameters can be infinite.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type NbSample: int
        :type Pfirst: float
        :type Plast: float
        :type BoxOtherPolygon: OCC.wrapper.Bnd.Bnd_Box2d

        """
        this = _IntPatch.new_IntPatch_PolyArc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Closed(self, *args):
        """
        Closed(IntPatch_PolyArc self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_PolyArc_Closed(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_PolyArc self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PolyArc_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(IntPatch_PolyArc self, Standard_Integer const Index) -> gp_Pnt2d

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntPatch.IntPatch_PolyArc_Point(self, *args)


    def Parameter(self, *args):
        """
        Parameter(IntPatch_PolyArc self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_PolyArc_Parameter(self, *args)


    def SetOffset(self, *args):
        """
        SetOffset(IntPatch_PolyArc self, Standard_Real const OffsetX, Standard_Real const OffsetY)

        :type OffsetX: float
        :type OffsetY: float

        """
        return _IntPatch.IntPatch_PolyArc_SetOffset(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyArc
IntPatch_PolyArc_swigregister = _IntPatch.IntPatch_PolyArc_swigregister
IntPatch_PolyArc_swigregister(IntPatch_PolyArc)

class IntPatch_Polyhedron(object):
    """
    This class provides a linear approximation of the PSurface.
    preview a constructor on a zone of  a surface
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_Polyhedron self, Handle_Adaptor3d_HSurface Surface, Standard_Integer const nbdU, Standard_Integer const nbdV) -> IntPatch_Polyhedron
        __init__(IntPatch_Polyhedron self, Handle_Adaptor3d_HSurface Surface) -> IntPatch_Polyhedron

        :type Surface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _IntPatch.new_IntPatch_Polyhedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """Destroy(IntPatch_Polyhedron self)"""
        return _IntPatch.IntPatch_Polyhedron_Destroy(self, *args)


    def DeflectionOnTriangle(self, *args):
        """
        DeflectionOnTriangle(IntPatch_Polyhedron self, Handle_Adaptor3d_HSurface Surface, Standard_Integer const Index) -> Standard_Real

        :type Surface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Polyhedron_DeflectionOnTriangle(self, *args)


    def Size(self, *args):
        """
        Size(IntPatch_Polyhedron self)

        Get the size of the MaTriangle.

        :type nbdu: int
        :type nbdv: int

        """
        return _IntPatch.IntPatch_Polyhedron_Size(self, *args)


    def NbTriangles(self, *args):
        """
        NbTriangles(IntPatch_Polyhedron self) -> Standard_Integer

        Give the number of triangles in this double array of
        triangles (nbdu*nbdv*2).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Polyhedron_NbTriangles(self, *args)


    def Triangle(self, *args):
        """
        Triangle(IntPatch_Polyhedron self, Standard_Integer const Index)

        Give the 3 points of the triangle of addresse Index in
        the double array of triangles.

        :type Index: int
        :type P1: int
        :type P2: int
        :type P3: int

        """
        return _IntPatch.IntPatch_Polyhedron_Triangle(self, *args)


    def TriConnex(self, *args):
        """
        TriConnex(IntPatch_Polyhedron self, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

        Give the addresse Tricon of the triangle connexe to the
        triangle of address Triang by the edge Pivot Pedge and
        the third point of this connexe triangle. When we are
        on a free edge TriCon==0 but the function return the
        value of the triangle in the other side of Pivot on
        the free edge. Used to turn around a vertex.

        :type Triang: int
        :type Pivot: int
        :type Pedge: int
        :type TriCon: int
        :type OtherP: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Polyhedron_TriConnex(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_Polyhedron self) -> Standard_Integer

        Give the number of point in the double array of
        triangles ((nbdu+1)*(nbdv+1)).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Polyhedron_NbPoints(self, *args)


    def Point(self, *args):
        """
        Give the point of index i in the MaTriangle.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_Polyhedron_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bounding(self, *args):
        """
        Give the bounding box of the MaTriangle.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _IntPatch.IntPatch_Polyhedron_Bounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillBounding(self, *args):
        """
        FillBounding(IntPatch_Polyhedron self)

        Compute the array of boxes. The box <n> corresponding
        to the triangle <n>.


        """
        return _IntPatch.IntPatch_Polyhedron_FillBounding(self, *args)


    def ComponentsBounding(self, *args):
        """
        Give the array of boxes. The box <n> corresponding
        to the triangle <n>.

        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        res = _IntPatch.IntPatch_Polyhedron_ComponentsBounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(IntPatch_Polyhedron self, Standard_Real const flec)
        DeflectionOverEstimation(IntPatch_Polyhedron self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Polyhedron_DeflectionOverEstimation(self, *args)


    def PlaneEquation(self, *args):
        """
        PlaneEquation(IntPatch_Polyhedron self, Standard_Integer const Triang, gp_XYZ NormalVector)

        Give the plane equation of the triangle of addresse Triang.

        :type Triang: int
        :type NormalVector: OCC.wrapper.gp.gp_XYZ
        :type PolarDistance: float

        """
        return _IntPatch.IntPatch_Polyhedron_PlaneEquation(self, *args)


    def Contain(self, *args):
        """
        Contain(IntPatch_Polyhedron self, Standard_Integer const Triang, gp_Pnt ThePnt) -> Standard_Boolean

        Give the plane equation of the triangle of addresse Triang.

        :type Triang: int
        :type ThePnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Polyhedron_Contain(self, *args)


    def Parameters(self, *args):
        """
        Parameters(IntPatch_Polyhedron self, Standard_Integer const Index)

        :type Index: int
        :type U: float
        :type V: float

        """
        return _IntPatch.IntPatch_Polyhedron_Parameters(self, *args)


    def Dump(self, *args):
        """Dump(IntPatch_Polyhedron self)"""
        return _IntPatch.IntPatch_Polyhedron_Dump(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_Polyhedron
IntPatch_Polyhedron_swigregister = _IntPatch.IntPatch_Polyhedron_swigregister
IntPatch_Polyhedron_swigregister(IntPatch_Polyhedron)

class IntPatch_ImpImpIntersection(object):
    """
    Implementation of the intersection between two
    quadric patches : Plane, Cone, Cylinder or Sphere.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    IntStatus_OK = _IntPatch.IntPatch_ImpImpIntersection_IntStatus_OK
    IntStatus_InfiniteSectionCurve = _IntPatch.IntPatch_ImpImpIntersection_IntStatus_InfiniteSectionCurve
    IntStatus_Fail = _IntPatch.IntPatch_ImpImpIntersection_IntStatus_Fail

    def __init__(self, *args):
        """
        __init__(IntPatch_ImpImpIntersection self) -> IntPatch_ImpImpIntersection
        __init__(IntPatch_ImpImpIntersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang, Standard_Boolean const theIsReqToKeepRLine) -> IntPatch_ImpImpIntersection

        Flag theIsReqToKeepRLine has been entered only for
        compatibility with TopOpeBRep package. It shall be deleted
        after deleting TopOpeBRep.
        When intersection result returns IntPatch_RLine and another
        IntPatch_Line (not restriction) we (in case of theIsReqToKeepRLine==TRUE)
        will always keep both lines even if they are coincided.

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolArc: float
        :type TolTang: float
        :type theIsReqToKeepRLine: bool

        """
        this = _IntPatch.new_IntPatch_ImpImpIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_ImpImpIntersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang, Standard_Boolean const theIsReqToKeepRLine)

        Flag theIsReqToKeepRLine has been entered only for
        compatibility with TopOpeBRep package. It shall be deleted
        after deleting TopOpeBRep.
        When intersection result returns IntPatch_RLine and another
        IntPatch_Line (not restriction) we (in case of theIsReqToKeepRLine==TRUE)
        will always keep both lines even if they are coincided.

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolArc: float
        :type TolTang: float
        :type theIsReqToKeepRLine: bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_ImpImpIntersection self) -> Standard_Boolean

        Returns True if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsDone(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(IntPatch_ImpImpIntersection self) -> IntPatch_ImpImpIntersection::IntStatus

        Returns status

        :rtype: IntStatus

        """
        return _IntPatch.IntPatch_ImpImpIntersection_GetStatus(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntPatch_ImpImpIntersection self) -> Standard_Boolean

        Returns true if the is no intersection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsEmpty(self, *args)


    def TangentFaces(self, *args):
        """
        TangentFaces(IntPatch_ImpImpIntersection self) -> Standard_Boolean

        Returns True if the two patches are considered as
        entirely tangent, i.e every restriction arc of one
        patch is inside the geometric base of the other patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ImpImpIntersection_TangentFaces(self, *args)


    def OppositeFaces(self, *args):
        """
        OppositeFaces(IntPatch_ImpImpIntersection self) -> Standard_Boolean

        Returns True when the TangentFaces returns True and the
        normal vectors evaluated at a point on the first and the
        second surface are opposite.
        The exception DomainError is raised if TangentFaces
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ImpImpIntersection_OppositeFaces(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(IntPatch_ImpImpIntersection self) -> Standard_Integer

        Returns the number of "single" points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the point of range Index.
        An exception is raised if Index<=0 or Index>NbPnt.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_ImpImpIntersection_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLines(self, *args):
        """
        NbLines(IntPatch_ImpImpIntersection self) -> Standard_Integer

        Returns the number of intersection lines.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns the line of range Index.
        An exception is raised if Index<=0 or Index>NbLine.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        res = _IntPatch.IntPatch_ImpImpIntersection_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpImpIntersection
IntPatch_ImpImpIntersection_swigregister = _IntPatch.IntPatch_ImpImpIntersection_swigregister
IntPatch_ImpImpIntersection_swigregister(IntPatch_ImpImpIntersection)

class Handle_IntPatch_ALine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_ALine self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_ALine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_ALine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_ALine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_ALine self, IntPatch_ALine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_ALine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_ALine self, Handle_IntPatch_ALine theHandle) -> Handle_IntPatch_ALine
        assign(Handle_IntPatch_ALine self, IntPatch_ALine thePtr) -> Handle_IntPatch_ALine
        assign(Handle_IntPatch_ALine self, Handle_IntPatch_ALine theHandle) -> Handle_IntPatch_ALine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_ALine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_ALine self) -> IntPatch_ALine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_ALine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_ALine self) -> IntPatch_ALine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_ALine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_ALine self) -> IntPatch_ALine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_ALine___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_ALine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_ALine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_ALine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_ALine_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_ALine

    def AddVertex(self, *args):
        """
        AddVertex(Handle_IntPatch_ALine self, IntPatch_Point Pnt)

        To add a vertex in the list.

        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_ALine_AddVertex(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_IntPatch_ALine self, Standard_Integer const Index, IntPatch_Point Pnt)

        Replaces the element of range Index in the list
        of points.

        :type Index: int
        :type Pnt: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_ALine_Replace(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(Handle_IntPatch_ALine self, Standard_Integer const IndFirst)

        :type IndFirst: int

        """
        return _IntPatch.Handle_IntPatch_ALine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args):
        """
        SetLastPoint(Handle_IntPatch_ALine self, Standard_Integer const IndLast)

        :type IndLast: int

        """
        return _IntPatch.Handle_IntPatch_ALine_SetLastPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_IntPatch_ALine self) -> Standard_Real

        Returns the first parameter on the intersection line.
        If IsIncluded returns True, Value and D1 methods can
        be call with a parameter equal to FirstParamater.
        Otherwise, the parameter must be greater than
        FirstParameter.

        :type IsIncluded: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_ALine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_IntPatch_ALine self) -> Standard_Real

        Returns the last parameter on the intersection line.
        If IsIncluded returns True, Value and D1 methods can
        be call with a parameter equal to LastParamater.
        Otherwise, the parameter must be less than LastParameter.

        :type IsIncluded: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.Handle_IntPatch_ALine_LastParameter(self, *args)


    def Value(self, *args):
        """
        Value(Handle_IntPatch_ALine self, Standard_Real const U) -> gp_Pnt

        Returns the point of parameter U on the analytic
        intersection line.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntPatch.Handle_IntPatch_ALine_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_IntPatch_ALine self, Standard_Real const U, gp_Pnt P, gp_Vec Du) -> Standard_Boolean

        Returns Standard_True when the derivative at parameter U
        is defined on the analytic intersection line.
        In that case, Du is the derivative.
        Returns Standard_False when it is not possible to
        evaluate the derivative.
        In both cases, P is the point at parameter U on the
        intersection.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Du: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_D1(self, *args)


    def FindParameter(self, *args):
        """
        FindParameter(Handle_IntPatch_ALine self, gp_Pnt P, NCollection_List_Standard_Real theParams)

        Tries to find the parameters of the point P on the curve.
        If the method returns False, the "projection" is
        impossible.
        If the method returns True at least one parameter has been found.
        theParams is always sorted in ascending order.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type theParams: OCC.wrapper.TColStd.TColStd_ListOfReal

        """
        return _IntPatch.Handle_IntPatch_ALine_FindParameter(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns True if the line has a known First point.
        This point is given by the method FirstPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns True if the line has a known Last point.
        This point is given by the method LastPoint().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the IntPoint corresponding to the FirstPoint.
        An exception is raised when HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_ALine_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPoint(self, *args):
        """
        Returns the IntPoint corresponding to the LastPoint.
        An exception is raised when HasLastPoint returns False.

        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_ALine_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbVertex(self, *args):
        """
        NbVertex(Handle_IntPatch_ALine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_ALine_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex of range Index on the line.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.Handle_IntPatch_ALine_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(Handle_IntPatch_ALine self, Standard_Integer const theIndex) -> IntPatch_Point

        Allows modifying the vertex with index theIndex on the line.

        :type theIndex: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.Handle_IntPatch_ALine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args):
        """
        ComputeVertexParameters(Handle_IntPatch_ALine self, Standard_Real const Tol)

        Set the parameters of all the vertex on the line.
        if a vertex is already in the line,
        its parameter is modified
        else a new point in the line is inserted.

        :type Tol: float

        """
        return _IntPatch.Handle_IntPatch_ALine_ComputeVertexParameters(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.IntAna.IntAna_Curve

        """
        res = _IntPatch.Handle_IntPatch_ALine_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_ALine self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_ALine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_ALine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_ALine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Handle_IntPatch_ALine self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.Handle_IntPatch_ALine_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(Handle_IntPatch_ALine self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.Handle_IntPatch_ALine_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_IntPatch_ALine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_ALine_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_IntPatch_ALine self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_ALine_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(Handle_IntPatch_ALine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_ALine_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(Handle_IntPatch_ALine self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_ALine_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(Handle_IntPatch_ALine self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsVIsoOnS2(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_ALine self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_ALine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_ALine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_ALine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_ALine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_ALine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_ALine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_ALine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_ALine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_ALine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_ALine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_ALine self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_ALine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_ALine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_ALine_DecrementRefCounter(self, *args)

Handle_IntPatch_ALine_swigregister = _IntPatch.Handle_IntPatch_ALine_swigregister
Handle_IntPatch_ALine_swigregister(Handle_IntPatch_ALine)

def Handle_IntPatch_ALine_DownCast(thing):
    return _IntPatch.Handle_IntPatch_ALine_DownCast(thing)
Handle_IntPatch_ALine_DownCast = _IntPatch.Handle_IntPatch_ALine_DownCast

class IntPatch_ArcFunction(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(IntPatch_ArcFunction self) -> IntPatch_ArcFunction"""
        this = _IntPatch.new_IntPatch_ArcFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetQuadric(self, *args):
        """
        SetQuadric(IntPatch_ArcFunction self, IntSurf_Quadric Q)

        :type Q: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        return _IntPatch.IntPatch_ArcFunction_SetQuadric(self, *args)


    def Set(self, *args):
        """
        Set(IntPatch_ArcFunction self, Handle_Adaptor2d_HCurve2d A)
        Set(IntPatch_ArcFunction self, Handle_Adaptor3d_HSurface S)

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _IntPatch.IntPatch_ArcFunction_Set(self, *args)


    def Value(self, *args):
        """
        Value(IntPatch_ArcFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ArcFunction_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(IntPatch_ArcFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ArcFunction_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(IntPatch_ArcFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_ArcFunction_Values(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(IntPatch_ArcFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ArcFunction_NbSamples(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(IntPatch_ArcFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_ArcFunction_GetStateNumber(self, *args)


    def Valpoint(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_ArcFunction_Valpoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Quadric(self, *args):
        """
        :rtype: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        res = _IntPatch.IntPatch_ArcFunction_Quadric(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Arc(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_ArcFunction_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _IntPatch.IntPatch_ArcFunction_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastComputedPoint(self, *args):
        """
        Returns the point, which has been computed
        while the last calling Value() method

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_ArcFunction_LastComputedPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_ArcFunction
IntPatch_ArcFunction_swigregister = _IntPatch.IntPatch_ArcFunction_swigregister
IntPatch_ArcFunction_swigregister(IntPatch_ArcFunction)

class IntPatch_TheSurfFunction(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_TheSurfFunction self) -> IntPatch_TheSurfFunction
        __init__(IntPatch_TheSurfFunction self, Handle_Adaptor3d_HSurface PS, IntSurf_Quadric IS) -> IntPatch_TheSurfFunction
        __init__(IntPatch_TheSurfFunction self, IntSurf_Quadric IS) -> IntPatch_TheSurfFunction

        :type IS: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        this = _IntPatch.new_IntPatch_TheSurfFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetImplicitSurface(self, *args):
        """
        SetImplicitSurface(IntPatch_TheSurfFunction self, IntSurf_Quadric IS)

        :type IS: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        return _IntPatch.IntPatch_TheSurfFunction_SetImplicitSurface(self, *args)


    def Set(self, *args):
        """
        Set(IntPatch_TheSurfFunction self, Handle_Adaptor3d_HSurface PS)
        Set(IntPatch_TheSurfFunction self, Standard_Real const Tolerance)

        :type Tolerance: float

        """
        return _IntPatch.IntPatch_TheSurfFunction_Set(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(IntPatch_TheSurfFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheSurfFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(IntPatch_TheSurfFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheSurfFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(IntPatch_TheSurfFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSurfFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(IntPatch_TheSurfFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSurfFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(IntPatch_TheSurfFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSurfFunction_Values(self, *args)


    def Root(self, *args):
        """
        Root(IntPatch_TheSurfFunction self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_TheSurfFunction_Root(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(IntPatch_TheSurfFunction self) -> Standard_Real

        Returns the value Tol so that if Abs(Func.Root())<Tol
        the function is considered null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_TheSurfFunction_Tolerance(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_TheSurfFunction_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(IntPatch_TheSurfFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSurfFunction_IsTangent(self, *args)


    def Direction3d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _IntPatch.IntPatch_TheSurfFunction_Direction3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _IntPatch.IntPatch_TheSurfFunction_Direction2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PSurface(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _IntPatch.IntPatch_TheSurfFunction_PSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ISurface(self, *args):
        """
        :rtype: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        res = _IntPatch.IntPatch_TheSurfFunction_ISurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSurfFunction
IntPatch_TheSurfFunction_swigregister = _IntPatch.IntPatch_TheSurfFunction_swigregister
IntPatch_TheSurfFunction_swigregister(IntPatch_TheSurfFunction)

class IntPatch_LineConstructor(object):
    """
    The intersections  algorithms compute the intersection
    on two surfaces and  return the intersections lines as
    IntPatch_Line.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_LineConstructor self, Standard_Integer const mode) -> IntPatch_LineConstructor

        :type mode: int

        """
        this = _IntPatch.new_IntPatch_LineConstructor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_LineConstructor self, NCollection_Sequence_Handle_IntPatch_Line SL, Handle_IntPatch_Line L, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const Tol)

        :type SL: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Tol: float

        """
        return _IntPatch.IntPatch_LineConstructor_Perform(self, *args)


    def NbLines(self, *args):
        """
        NbLines(IntPatch_LineConstructor self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_LineConstructor_NbLines(self, *args)


    def Line(self, *args):
        """
        Line(IntPatch_LineConstructor self, Standard_Integer const index) -> Handle_IntPatch_Line

        :type index: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        return _IntPatch.IntPatch_LineConstructor_Line(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_LineConstructor
IntPatch_LineConstructor_swigregister = _IntPatch.IntPatch_LineConstructor_swigregister
IntPatch_LineConstructor_swigregister(IntPatch_LineConstructor)

class NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntPatch.new_NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self)

        Reverse sequence


        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theOther) -> NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theOther) -> NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, IntPatch_TheSegmentOfTheSOnBounds theItem)
        Append(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, IntPatch_TheSegmentOfTheSOnBounds theItem)
        Prepend(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex, IntPatch_TheSegmentOfTheSOnBounds theItem)
        InsertBefore(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::Iterator & thePosition, IntPatch_TheSegmentOfTheSOnBounds theItem)
        InsertAfter(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theSeq)
        InsertAfter(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex, IntPatch_TheSegmentOfTheSOnBounds theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> IntPatch_TheSegmentOfTheSOnBounds

        First item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self) -> IntPatch_TheSegmentOfTheSOnBounds

        Last item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex) -> IntPatch_TheSegmentOfTheSOnBounds

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds self, Standard_Integer const theIndex, IntPatch_TheSegmentOfTheSOnBounds theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_SetValue(self, *args)


    def __iter__(self):
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds___iter__(self)
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds
NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_swigregister = _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_swigregister
NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_swigregister(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds)

def NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_delNode(*args):
    """
    NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_delNode(*args)

class NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPatch.new_NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper

    def __next__(self):
        return _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper___next__(self)
NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper_swigregister = _IntPatch.NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper_swigregister
NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper_swigregister(NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds_IteratorHelper)


try:
	IntPatch_SequenceOfSegmentOfTheSOnBounds = NCollection_Sequence_IntPatch_TheSegmentOfTheSOnBounds
except NameError:
	pass # does not exist, probably ignored

class IntPatch_Point(object):
    """
    Definition of an intersection point between two surfaces.
    Such a point is contains geometrical informations (see
    the Value method) and logical informations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_Point self) -> IntPatch_Point

        Empty constructor.


        """
        this = _IntPatch.new_IntPatch_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntPatch_Point self, gp_Pnt Pt, Standard_Real const Tol, Standard_Boolean const Tangent)
        SetValue(IntPatch_Point self, gp_Pnt Pt)
        SetValue(IntPatch_Point self, IntSurf_PntOn2S thePOn2S)

        Sets the value of <pt> member

        :type thePOn2S: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_Point_SetValue(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(IntPatch_Point self, Standard_Real const Tol)

        :type Tol: float

        """
        return _IntPatch.IntPatch_Point_SetTolerance(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(IntPatch_Point self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2)

        Sets the values of the parameters of the point
        on each surface.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _IntPatch.IntPatch_Point_SetParameters(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(IntPatch_Point self, Standard_Real const Para)

        Set the value of the parameter on the intersection line.

        :type Para: float

        """
        return _IntPatch.IntPatch_Point_SetParameter(self, *args)


    def SetVertex(self, *args):
        """
        SetVertex(IntPatch_Point self, Standard_Boolean const OnFirst, Handle_Adaptor3d_HVertex V)

        Sets the values of a point which is a vertex on
        the initial facet of restriction of one
        of the surface.
        If OnFirst is True, the point is on the domain of the
        first patch, otherwise the point is on the domain of the
        second surface.

        :type OnFirst: bool
        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        return _IntPatch.IntPatch_Point_SetVertex(self, *args)


    def SetArc(self, *args):
        """
        SetArc(IntPatch_Point self, Standard_Boolean const OnFirst, Handle_Adaptor2d_HCurve2d A, Standard_Real const Param, IntSurf_Transition TLine, IntSurf_Transition TArc)

        Sets the values of a point which is on one of the domain,
        when both surfaces are implicit ones.
        If OnFirst is True, the point is on the domain of the
        first patch, otherwise the point is on the domain of the
        second surface.

        :type OnFirst: bool
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Param: float
        :type TLine: OCC.wrapper.IntSurf.IntSurf_Transition
        :type TArc: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_SetArc(self, *args)


    def SetMultiple(self, *args):
        """
        SetMultiple(IntPatch_Point self, Standard_Boolean const IsMult)

        Sets (or unsets) the point as a point on several
        intersection line.

        :type IsMult: bool

        """
        return _IntPatch.IntPatch_Point_SetMultiple(self, *args)


    def Value(self, *args):
        """
        Returns the intersection point (geometric information).

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_Point_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnLine(self, *args):
        """
        ParameterOnLine(IntPatch_Point self) -> Standard_Real

        This method returns the parameter of the point
        on the intersection line.
        If the points does not belong to an intersection line,
        the value returned does not have any sens.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Point_ParameterOnLine(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(IntPatch_Point self) -> Standard_Real

        This method returns the fuzziness on the point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Point_Tolerance(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(IntPatch_Point self) -> Standard_Boolean

        Returns True if the Point is a tangency point between
        the surfaces.
        If the Point is on one of the domain (IsOnDomS1 returns
        True or IsOnDomS2 returns True), an exception is raised.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Point_IsTangencyPoint(self, *args)


    def ParametersOnS1(self, *args):
        """
        ParametersOnS1(IntPatch_Point self)

        Returns the parameters on the first surface of the point.

        :type U1: float
        :type V1: float

        """
        return _IntPatch.IntPatch_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args):
        """
        ParametersOnS2(IntPatch_Point self)

        Returns the parameters on the second surface of the point.

        :type U2: float
        :type V2: float

        """
        return _IntPatch.IntPatch_Point_ParametersOnS2(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(IntPatch_Point self) -> Standard_Boolean

        Returns True if the point belongs to several intersection
        lines.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Point_IsMultiple(self, *args)


    def IsOnDomS1(self, *args):
        """
        IsOnDomS1(IntPatch_Point self) -> Standard_Boolean

        Returns TRUE if the point is on a boundary of the domain
        of the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Point_IsOnDomS1(self, *args)


    def IsVertexOnS1(self, *args):
        """
        IsVertexOnS1(IntPatch_Point self) -> Standard_Boolean

        Returns TRUE if the point is a vertex on the initial
        restriction facet of the first surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Point_IsVertexOnS1(self, *args)


    def VertexOnS1(self, *args):
        """
        Returns the information about the point when it is
        on the domain of the first patch, i-e when the function
        IsVertexOnS1 returns True.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        res = _IntPatch.IntPatch_Point_VertexOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ArcOnS1(self, *args):
        """
        Returns the arc of restriction containing the
        vertex.
        The exception DomainError is raised if
        IsOnDomS1 returns False.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_Point_ArcOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionLineArc1(self, *args):
        """
        Returns the transition of the point on the
        intersection line with the arc on S1.
        The exception DomainError is raised if IsOnDomS1
        returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _IntPatch.IntPatch_Point_TransitionLineArc1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS1(self, *args):
        """
        Returns the transition between the intersection line
        returned by the method Line and the arc on S1 returned
        by ArcOnS1().
        The exception DomainError is raised if
        IsOnDomS1 returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _IntPatch.IntPatch_Point_TransitionOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnArc1(self, *args):
        """
        ParameterOnArc1(IntPatch_Point self) -> Standard_Real

        Returns the parameter of the point on the
        arc returned by the method ArcOnS2.
        The exception DomainError is raised if
        IsOnDomS1 returns False.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Point_ParameterOnArc1(self, *args)


    def IsOnDomS2(self, *args):
        """
        IsOnDomS2(IntPatch_Point self) -> Standard_Boolean

        Returns TRUE if the point is on a boundary of the domain
        of the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Point_IsOnDomS2(self, *args)


    def IsVertexOnS2(self, *args):
        """
        IsVertexOnS2(IntPatch_Point self) -> Standard_Boolean

        Returns TRUE if the point is a vertex on the initial
        restriction facet of the first surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Point_IsVertexOnS2(self, *args)


    def VertexOnS2(self, *args):
        """
        Returns the information about the point when it is
        on the domain of the second patch, i-e when the function
        IsVertexOnS2 returns True.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        res = _IntPatch.IntPatch_Point_VertexOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ArcOnS2(self, *args):
        """
        Returns the arc of restriction containing the
        vertex.
        The exception DomainError is raised if
        IsOnDomS2 returns False.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_Point_ArcOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionLineArc2(self, *args):
        """
        Returns the transition of the point on the
        intersection line with the arc on S2.
        The exception DomainError is raised if IsOnDomS2
        returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _IntPatch.IntPatch_Point_TransitionLineArc2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS2(self, *args):
        """
        Returns the transition between the intersection line
        returned by the method Line and the arc on S2 returned
        by ArcOnS2.
        The exception DomainError is raised if
        IsOnDomS2 returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _IntPatch.IntPatch_Point_TransitionOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnArc2(self, *args):
        """
        ParameterOnArc2(IntPatch_Point self) -> Standard_Real

        Returns the parameter of the point on the
        arc returned by the method ArcOnS2.
        The exception DomainError is raised if
        IsOnDomS2 returns False.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_Point_ParameterOnArc2(self, *args)


    def PntOn2S(self, *args):
        """
        Returns the PntOn2S
        (geometric Point and the parameters)

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntPatch.IntPatch_Point_PntOn2S(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameters(self, *args):
        """
        Parameters(IntPatch_Point self)

        Returns the parameters on the first and on the
        second surface of the point.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _IntPatch.IntPatch_Point_Parameters(self, *args)


    def ReverseTransition(self, *args):
        """ReverseTransition(IntPatch_Point self)"""
        return _IntPatch.IntPatch_Point_ReverseTransition(self, *args)


    def Dump(self, *args):
        """Dump(IntPatch_Point self)"""
        return _IntPatch.IntPatch_Point_Dump(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_Point
IntPatch_Point_swigregister = _IntPatch.IntPatch_Point_swigregister
IntPatch_Point_swigregister(IntPatch_Point)

class NCollection_Sequence_IntPatch_Point(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntPatch_Point self) -> NCollection_Sequence< IntPatch_Point >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntPatch_Point self) -> NCollection_Sequence< IntPatch_Point >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntPatch_Point self) -> NCollection_Sequence< IntPatch_Point >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntPatch_Point self) -> NCollection_Sequence< IntPatch_Point >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntPatch.new_NCollection_Sequence_IntPatch_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntPatch_Point self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntPatch_Point self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntPatch_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntPatch_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntPatch_Point self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntPatch_Point self)

        Reverse sequence


        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntPatch_Point self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntPatch_Point self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntPatch_Point self, NCollection_Sequence_IntPatch_Point theOther) -> NCollection_Sequence_IntPatch_Point

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntPatch_Point self, NCollection_Sequence_IntPatch_Point theOther) -> NCollection_Sequence_IntPatch_Point

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntPatch_Point self, NCollection_Sequence< IntPatch_Point >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntPatch_Point self, IntPatch_Point theItem)
        Append(NCollection_Sequence_IntPatch_Point self, NCollection_Sequence_IntPatch_Point theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntPatch_Point self, IntPatch_Point theItem)
        Prepend(NCollection_Sequence_IntPatch_Point self, NCollection_Sequence_IntPatch_Point theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex, IntPatch_Point theItem)
        InsertBefore(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_Point theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntPatch_Point self, NCollection_Sequence< IntPatch_Point >::Iterator & thePosition, IntPatch_Point theItem)
        InsertAfter(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_Point theSeq)
        InsertAfter(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex, IntPatch_Point theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex, NCollection_Sequence_IntPatch_Point theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_Point_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntPatch_Point self) -> IntPatch_Point

        First item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_Point_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntPatch_Point self) -> IntPatch_Point

        Last item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_Point_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex) -> IntPatch_Point

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_IntPatch_Point___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntPatch_Point self, Standard_Integer const theIndex, IntPatch_Point theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_IntPatch_Point_SetValue(self, *args)


    def __iter__(self):
        return _IntPatch.NCollection_Sequence_IntPatch_Point___iter__(self)
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_IntPatch_Point
NCollection_Sequence_IntPatch_Point_swigregister = _IntPatch.NCollection_Sequence_IntPatch_Point_swigregister
NCollection_Sequence_IntPatch_Point_swigregister(NCollection_Sequence_IntPatch_Point)

def NCollection_Sequence_IntPatch_Point_delNode(*args):
    """
    NCollection_Sequence_IntPatch_Point_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntPatch.NCollection_Sequence_IntPatch_Point_delNode(*args)

class NCollection_Sequence_IntPatch_Point_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPatch.new_NCollection_Sequence_IntPatch_Point_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_IntPatch_Point_IteratorHelper

    def __next__(self):
        return _IntPatch.NCollection_Sequence_IntPatch_Point_IteratorHelper___next__(self)
NCollection_Sequence_IntPatch_Point_IteratorHelper_swigregister = _IntPatch.NCollection_Sequence_IntPatch_Point_IteratorHelper_swigregister
NCollection_Sequence_IntPatch_Point_IteratorHelper_swigregister(NCollection_Sequence_IntPatch_Point_IteratorHelper)


try:
	IntPatch_SequenceOfPoint = NCollection_Sequence_IntPatch_Point
except NameError:
	pass # does not exist, probably ignored

class IntPatch_TheSOnBounds(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_TheSOnBounds self) -> IntPatch_TheSOnBounds

        Empty constructor.


        """
        this = _IntPatch.new_IntPatch_TheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntPatch_TheSOnBounds self, IntPatch_ArcFunction F, Handle_Adaptor3d_TopolTool Domain, Standard_Real const TolBoundary, Standard_Real const TolTangency, Standard_Boolean const RecheckOnRegularity)

        Algorithm to find the points and parts of curves of Domain
        (domain of of restriction of a surface) which verify
        F = 0.
        TolBoundary defines if a curve is on Q.
        TolTangency defines if a point is on Q.

        :type F: OCC.wrapper.IntPatch.IntPatch_ArcFunction
        :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolBoundary: float
        :type TolTangency: float
        :type RecheckOnRegularity: bool

        """
        return _IntPatch.IntPatch_TheSOnBounds_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_TheSOnBounds self) -> Standard_Boolean

        Returns True if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSOnBounds_IsDone(self, *args)


    def AllArcSolution(self, *args):
        """
        AllArcSolution(IntPatch_TheSOnBounds self) -> Standard_Boolean

        Returns true if all arc of the Arcs are solution (inside
        the surface).
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_TheSOnBounds_AllArcSolution(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_TheSOnBounds self) -> Standard_Integer

        Returns the number of resulting points.
        An exception is raised if IsDone returns False (NotDone).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheSOnBounds_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the resulting point of range Index.
        The exception NotDone is raised if IsDone() returns
        False.
        The exception OutOfRange is raised if
        Index <= 0 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_ThePathPointOfTheSOnBounds

        """
        res = _IntPatch.IntPatch_TheSOnBounds_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSegments(self, *args):
        """
        NbSegments(IntPatch_TheSOnBounds self) -> Standard_Integer

        Returns the number of the resulting segments.
        An exception is raised if IsDone returns False (NotDone).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_TheSOnBounds_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Returns the resulting segment of range Index.
        The exception NotDone is raised if IsDone() returns
        False.
        The exception OutOfRange is raised if
        Index <= 0 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_TheSegmentOfTheSOnBounds

        """
        res = _IntPatch.IntPatch_TheSOnBounds_Segment(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSOnBounds
IntPatch_TheSOnBounds_swigregister = _IntPatch.IntPatch_TheSOnBounds_swigregister
IntPatch_TheSOnBounds_swigregister(IntPatch_TheSOnBounds)

class Handle_IntPatch_Line(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntPatch_Line self)

        Nullify the handle


        """
        return _IntPatch.Handle_IntPatch_Line_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntPatch_Line self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntPatch.Handle_IntPatch_Line_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntPatch_Line self, IntPatch_Line thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntPatch.Handle_IntPatch_Line_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntPatch_Line self, Handle_IntPatch_Line theHandle) -> Handle_IntPatch_Line
        assign(Handle_IntPatch_Line self, IntPatch_Line thePtr) -> Handle_IntPatch_Line
        assign(Handle_IntPatch_Line self, Handle_IntPatch_Line theHandle) -> Handle_IntPatch_Line

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntPatch.Handle_IntPatch_Line_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntPatch_Line self) -> IntPatch_Line

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_Line_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntPatch_Line self) -> IntPatch_Line

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntPatch.Handle_IntPatch_Line___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntPatch_Line self) -> IntPatch_Line

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntPatch.Handle_IntPatch_Line___ref__(self, *args)


    def __hash__(self):
        return _IntPatch.Handle_IntPatch_Line___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntPatch.Handle_IntPatch_Line___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntPatch.new_Handle_IntPatch_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntPatch.Handle_IntPatch_Line_DownCast)
    __swig_destroy__ = _IntPatch.delete_Handle_IntPatch_Line

    def SetValue(self, *args):
        """
        SetValue(Handle_IntPatch_Line self, Standard_Boolean const Uiso1, Standard_Boolean const Viso1, Standard_Boolean const Uiso2, Standard_Boolean const Viso2)

        To set the values returned by IsUIsoS1,....
        The default values are False.

        :type Uiso1: bool
        :type Viso1: bool
        :type Uiso2: bool
        :type Viso2: bool

        """
        return _IntPatch.Handle_IntPatch_Line_SetValue(self, *args)


    def ArcType(self, *args):
        """
        ArcType(Handle_IntPatch_Line self) -> IntPatch_IType

        Returns the type of geometry 3d (Line, Circle, Parabola,
        Hyperbola, Ellipse, Analytic, Walking, Restriction)

        :rtype: OCC.wrapper.IntPatch.IntPatch_IType

        """
        return _IntPatch.Handle_IntPatch_Line_ArcType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(Handle_IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a line of tangency
        between the 2 patches.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsTangent(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(Handle_IntPatch_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the first surface. The transition is "constant"
        along the line.
        The transition is IN if the line is oriented in such
        a way that the system of vector (N1,N2,T) is right-handed,
        where N1 is the normal to the first surface at a point P,
        N2 is the normal to the second surface at a point P,
        T  is the tangent to the intersection line at P.
        If the system of vector is left-handed, the transition
        is OUT.
        When N1 and N2 are colinear all along the intersection
        line, the transition will be
        - TOUCH, if it is possible to use the 2nd derivatives
        to determine the position of one surafce compared
        to the other (see Situation)
        - UNDECIDED otherwise.

        If one of the transition is TOUCH or UNDECIDED, the other
        one has got the same value.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(Handle_IntPatch_Line self) -> IntSurf_TypeTrans

        Returns the type of the transition of the line
        for the second surface. The transition is "constant"
        along the line.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntPatch.Handle_IntPatch_Line_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(Handle_IntPatch_Line self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the first patch compared to the second one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_Line_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(Handle_IntPatch_Line self) -> IntSurf_Situation

        Returns the situation (INSIDE/OUTSIDE/UNKNOWN) of
        the second patch compared to the first one, when
        TransitionOnS1 or TransitionOnS2 returns TOUCH.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntPatch.Handle_IntPatch_Line_SituationS2(self, *args)


    def IsUIsoOnS1(self, *args):
        """
        IsUIsoOnS1(Handle_IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsUIsoOnS1(self, *args)


    def IsVIsoOnS1(self, *args):
        """
        IsVIsoOnS1(Handle_IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the first patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsVIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args):
        """
        IsUIsoOnS2(Handle_IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a U isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsUIsoOnS2(self, *args)


    def IsVIsoOnS2(self, *args):
        """
        IsVIsoOnS2(Handle_IntPatch_Line self) -> Standard_Boolean

        Returns TRUE if the intersection is a V isoparametric curve
        on the second patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsVIsoOnS2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntPatch_Line self) -> char const *

        :rtype: const char *

        """
        return _IntPatch.Handle_IntPatch_Line_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_Line_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntPatch.Handle_IntPatch_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IntPatch_Line self)

        Memory deallocator for transient classes


        """
        return _IntPatch.Handle_IntPatch_Line_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntPatch_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntPatch_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntPatch_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntPatch_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.Handle_IntPatch_Line_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntPatch_Line self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntPatch.Handle_IntPatch_Line_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntPatch_Line self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_Line_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntPatch_Line self)

        Increments the reference counter of this object


        """
        return _IntPatch.Handle_IntPatch_Line_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntPatch_Line self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.Handle_IntPatch_Line_DecrementRefCounter(self, *args)

Handle_IntPatch_Line_swigregister = _IntPatch.Handle_IntPatch_Line_swigregister
Handle_IntPatch_Line_swigregister(Handle_IntPatch_Line)

def Handle_IntPatch_Line_DownCast(thing):
    return _IntPatch.Handle_IntPatch_Line_DownCast(thing)
Handle_IntPatch_Line_DownCast = _IntPatch.Handle_IntPatch_Line_DownCast

class IntPatch_SpecialPoints(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddCrossUVIsoPoint(*args):
        """
        AddCrossUVIsoPoint(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S theRefPt, Standard_Real const theTol3d, IntSurf_PntOn2S theAddedPoint, Standard_Boolean const theIsReversed) -> Standard_Boolean

        Adds the point defined as intersection
        of two isolines (U = 0 and V = 0) on theQSurf in theLine.
        theRefPt is used to correct adjusting parameters.
        If theIsReversed is TRUE then theQSurf correspond to the 
        second (otherwise, the first) surface while forming
        intersection point IntSurf_PntOn2S.

        :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theRefPt: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theTol3d: float
        :type theAddedPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theIsReversed: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args)

    AddCrossUVIsoPoint = staticmethod(AddCrossUVIsoPoint)

    def AddPointOnUorVIso(*args):
        """
        AddPointOnUorVIso(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S theRefPt, Standard_Boolean const theIsU, Standard_Real const theIsoParameter, math_Vector theToler, math_Vector theInitPoint, math_Vector theInfBound, math_Vector theSupBound, IntSurf_PntOn2S theAddedPoint, Standard_Boolean const theIsReversed) -> Standard_Boolean

        Adds the point lain strictly in the isoline U = 0 or V = 0 of theQSurf,
        in theLine.
        theRefPt is used to correct adjusting parameters.
        If theIsReversed is TRUE then theQSurf corresponds to the 
        second (otherwise, the first) surface while forming
        intersection point IntSurf_PntOn2S.
        All math_Vector-objects must be filled as follows:
        [1] - U-parameter of thePSurf;
        [2] - V-parameter of thePSurf;
        [3] - U- (if V-isoline is considered) or V-parameter
        (if U-isoline is considered) of theQSurf.

        :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theRefPt: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theIsU: bool
        :type theIsoParameter: float
        :type theToler: OCC.wrapper.math.math_Vector
        :type theInitPoint: OCC.wrapper.math.math_Vector
        :type theInfBound: OCC.wrapper.math.math_Vector
        :type theSupBound: OCC.wrapper.math.math_Vector
        :type theAddedPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theIsReversed: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_SpecialPoints_AddPointOnUorVIso(*args)

    AddPointOnUorVIso = staticmethod(AddPointOnUorVIso)

    def AddSingularPole(*args):
        """
        AddSingularPole(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S thePtIso, IntPatch_Point theVertex, IntSurf_PntOn2S theAddedPoint, Standard_Boolean const theIsReversed, Standard_Boolean const theIsReqRefCheck) -> Standard_Boolean

        Computes the pole of sphere to add it in the intersection line.
        Stores the result in theAddedPoint variable (does not add in the line).
        At that, cone and sphere (with singularity) must be set in theQSurf parameter.
        By default (if theIsReversed == FALSE), theQSurf is the first surface of the
        Walking line. If it is not, theIsReversed parameter must be set to TRUE.
        theIsReqRefCheck is TRUE if and only if 3D-point of theRefPt must be pole or apex
        for check (e.g. if it is vertex).
        thePtIso is the reference point for obtaining isoline where must be placed the Apex/Pole.

        ATTENTION!!!
        theVertex must be initialized before calling the method .

        :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type thePtIso: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theVertex: OCC.wrapper.IntPatch.IntPatch_Point
        :type theAddedPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theIsReversed: bool
        :type theIsReqRefCheck: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_SpecialPoints_AddSingularPole(*args)

    AddSingularPole = staticmethod(AddSingularPole)

    def ContinueAfterSpecialPoint(*args):
        """
        ContinueAfterSpecialPoint(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S theRefPt, IntPatch_SpecPntType const theSPType, Standard_Real const theTol2D, IntSurf_PntOn2S theNewPoint, Standard_Boolean const theIsReversed) -> Standard_Boolean

        Special point has already been added in the line. Now, we need in correct
        prolongation of the line or in start new line. This function returns new point.

        ATTENTION!!!
        theNewPoint is not only Output parameter. It is Input/Output one. I.e. 
        theNewPoint is reference point together with theRefPt.

        :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theRefPt: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theSPType: OCC.wrapper.IntPatch.IntPatch_SpecPntType
        :type theTol2D: float
        :type theNewPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theIsReversed: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args)

    ContinueAfterSpecialPoint = staticmethod(ContinueAfterSpecialPoint)

    def AdjustPointAndVertex(*args):
        """
        AdjustPointAndVertex(IntSurf_PntOn2S theRefPoint, Standard_Real const * theArrPeriods, IntSurf_PntOn2S theNewPoint, IntPatch_Point theVertex=None)

        Sets theNewPoint parameters in 2D-space the closest to
        theRefPoint with help of adding/subtracting corresponding periods.
        theArrPeriods must be filled as follows:
        {<U-period of 1st surface>, <V-period of 1st surface>,
        <U-period of 2nd surface>, <V-period of 2nd surface>}.
        If theVertex != 0 then its parameters will be filled as
        corresponding parameters of theNewPoint.

        ATTENTION!!!
        theNewPoint is not only Output parameter. It is Input/Output one. I.e. 
        theNewPoint is reference point together with theRefPt.

        :type theRefPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theArrPeriods: const Standard_Real [4]
        :type theNewPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theVertex: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _IntPatch.IntPatch_SpecialPoints_AdjustPointAndVertex(*args)

    AdjustPointAndVertex = staticmethod(AdjustPointAndVertex)

    def __init__(self):
        this = _IntPatch.new_IntPatch_SpecialPoints()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_SpecialPoints
IntPatch_SpecialPoints_swigregister = _IntPatch.IntPatch_SpecialPoints_swigregister
IntPatch_SpecialPoints_swigregister(IntPatch_SpecialPoints)

def IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args):
    """
    IntPatch_SpecialPoints_AddCrossUVIsoPoint(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S theRefPt, Standard_Real const theTol3d, IntSurf_PntOn2S theAddedPoint, Standard_Boolean const theIsReversed) -> Standard_Boolean

    Adds the point defined as intersection
    of two isolines (U = 0 and V = 0) on theQSurf in theLine.
    theRefPt is used to correct adjusting parameters.
    If theIsReversed is TRUE then theQSurf correspond to the 
    second (otherwise, the first) surface while forming
    intersection point IntSurf_PntOn2S.

    :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theRefPt: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theTol3d: float
    :type theAddedPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theIsReversed: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args)

def IntPatch_SpecialPoints_AddPointOnUorVIso(*args):
    """
    IntPatch_SpecialPoints_AddPointOnUorVIso(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S theRefPt, Standard_Boolean const theIsU, Standard_Real const theIsoParameter, math_Vector theToler, math_Vector theInitPoint, math_Vector theInfBound, math_Vector theSupBound, IntSurf_PntOn2S theAddedPoint, Standard_Boolean const theIsReversed) -> Standard_Boolean

    Adds the point lain strictly in the isoline U = 0 or V = 0 of theQSurf,
    in theLine.
    theRefPt is used to correct adjusting parameters.
    If theIsReversed is TRUE then theQSurf corresponds to the 
    second (otherwise, the first) surface while forming
    intersection point IntSurf_PntOn2S.
    All math_Vector-objects must be filled as follows:
    [1] - U-parameter of thePSurf;
    [2] - V-parameter of thePSurf;
    [3] - U- (if V-isoline is considered) or V-parameter
    (if U-isoline is considered) of theQSurf.

    :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theRefPt: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theIsU: bool
    :type theIsoParameter: float
    :type theToler: OCC.wrapper.math.math_Vector
    :type theInitPoint: OCC.wrapper.math.math_Vector
    :type theInfBound: OCC.wrapper.math.math_Vector
    :type theSupBound: OCC.wrapper.math.math_Vector
    :type theAddedPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theIsReversed: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_SpecialPoints_AddPointOnUorVIso(*args)

def IntPatch_SpecialPoints_AddSingularPole(*args):
    """
    IntPatch_SpecialPoints_AddSingularPole(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S thePtIso, IntPatch_Point theVertex, IntSurf_PntOn2S theAddedPoint, Standard_Boolean const theIsReversed, Standard_Boolean const theIsReqRefCheck) -> Standard_Boolean

    Computes the pole of sphere to add it in the intersection line.
    Stores the result in theAddedPoint variable (does not add in the line).
    At that, cone and sphere (with singularity) must be set in theQSurf parameter.
    By default (if theIsReversed == FALSE), theQSurf is the first surface of the
    Walking line. If it is not, theIsReversed parameter must be set to TRUE.
    theIsReqRefCheck is TRUE if and only if 3D-point of theRefPt must be pole or apex
    for check (e.g. if it is vertex).
    thePtIso is the reference point for obtaining isoline where must be placed the Apex/Pole.

    ATTENTION!!!
    theVertex must be initialized before calling the method .

    :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type thePtIso: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theVertex: OCC.wrapper.IntPatch.IntPatch_Point
    :type theAddedPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theIsReversed: bool
    :type theIsReqRefCheck: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_SpecialPoints_AddSingularPole(*args)

def IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args):
    """
    IntPatch_SpecialPoints_ContinueAfterSpecialPoint(Handle_Adaptor3d_HSurface theQSurf, Handle_Adaptor3d_HSurface thePSurf, IntSurf_PntOn2S theRefPt, IntPatch_SpecPntType const theSPType, Standard_Real const theTol2D, IntSurf_PntOn2S theNewPoint, Standard_Boolean const theIsReversed) -> Standard_Boolean

    Special point has already been added in the line. Now, we need in correct
    prolongation of the line or in start new line. This function returns new point.

    ATTENTION!!!
    theNewPoint is not only Output parameter. It is Input/Output one. I.e. 
    theNewPoint is reference point together with theRefPt.

    :type theQSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type thePSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theRefPt: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theSPType: OCC.wrapper.IntPatch.IntPatch_SpecPntType
    :type theTol2D: float
    :type theNewPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theIsReversed: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args)

def IntPatch_SpecialPoints_AdjustPointAndVertex(*args):
    """
    IntPatch_SpecialPoints_AdjustPointAndVertex(IntSurf_PntOn2S theRefPoint, Standard_Real const * theArrPeriods, IntSurf_PntOn2S theNewPoint, IntPatch_Point theVertex=None)

    Sets theNewPoint parameters in 2D-space the closest to
    theRefPoint with help of adding/subtracting corresponding periods.
    theArrPeriods must be filled as follows:
    {<U-period of 1st surface>, <V-period of 1st surface>,
    <U-period of 2nd surface>, <V-period of 2nd surface>}.
    If theVertex != 0 then its parameters will be filled as
    corresponding parameters of theNewPoint.

    ATTENTION!!!
    theNewPoint is not only Output parameter. It is Input/Output one. I.e. 
    theNewPoint is reference point together with theRefPt.

    :type theRefPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theArrPeriods: const Standard_Real [4]
    :type theNewPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
    :type theVertex: OCC.wrapper.IntPatch.IntPatch_Point

    """
    return _IntPatch.IntPatch_SpecialPoints_AdjustPointAndVertex(*args)

class IntPatch_HCurve2dTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Handle_Adaptor2d_HCurve2d C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Handle_Adaptor2d_HCurve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args):
        """
        IsClosed(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Handle_Adaptor2d_HCurve2d C, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Handle_Adaptor2d_HCurve2d C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Handle_Adaptor2d_HCurve2d C) -> gp_Lin2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Handle_Adaptor2d_HCurve2d C) -> gp_Circ2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Handle_Adaptor2d_HCurve2d C) -> gp_Elips2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Handle_Adaptor2d_HCurve2d C) -> gp_Hypr2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Handle_Adaptor2d_HCurve2d C) -> gp_Parab2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BezierCurve

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BSplineCurve

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def NbSamples(*args):
        """
        NbSamples(Handle_Adaptor2d_HCurve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def __init__(self):
        this = _IntPatch.new_IntPatch_HCurve2dTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_HCurve2dTool
IntPatch_HCurve2dTool_swigregister = _IntPatch.IntPatch_HCurve2dTool_swigregister
IntPatch_HCurve2dTool_swigregister(IntPatch_HCurve2dTool)

def IntPatch_HCurve2dTool_FirstParameter(*args):
    """
    IntPatch_HCurve2dTool_FirstParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

def IntPatch_HCurve2dTool_LastParameter(*args):
    """
    IntPatch_HCurve2dTool_LastParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

def IntPatch_HCurve2dTool_Continuity(*args):
    """
    IntPatch_HCurve2dTool_Continuity(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

def IntPatch_HCurve2dTool_NbIntervals(*args):
    """
    IntPatch_HCurve2dTool_NbIntervals(Handle_Adaptor2d_HCurve2d C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

def IntPatch_HCurve2dTool_Intervals(*args):
    """
    IntPatch_HCurve2dTool_Intervals(Handle_Adaptor2d_HCurve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

def IntPatch_HCurve2dTool_IsClosed(*args):
    """
    IntPatch_HCurve2dTool_IsClosed(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

def IntPatch_HCurve2dTool_IsPeriodic(*args):
    """
    IntPatch_HCurve2dTool_IsPeriodic(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

def IntPatch_HCurve2dTool_Period(*args):
    """
    IntPatch_HCurve2dTool_Period(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

def IntPatch_HCurve2dTool_Value(*args):
    """
    IntPatch_HCurve2dTool_Value(Handle_Adaptor2d_HCurve2d C, Standard_Real const U) -> gp_Pnt2d

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

def IntPatch_HCurve2dTool_D0(*args):
    """
    IntPatch_HCurve2dTool_D0(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

def IntPatch_HCurve2dTool_D1(*args):
    """
    IntPatch_HCurve2dTool_D1(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

    Computes the point of parameter U on the curve with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

def IntPatch_HCurve2dTool_D2(*args):
    """
    IntPatch_HCurve2dTool_D2(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

def IntPatch_HCurve2dTool_D3(*args):
    """
    IntPatch_HCurve2dTool_D3(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

def IntPatch_HCurve2dTool_DN(*args):
    """
    IntPatch_HCurve2dTool_DN(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

def IntPatch_HCurve2dTool_Resolution(*args):
    """
    IntPatch_HCurve2dTool_Resolution(Handle_Adaptor2d_HCurve2d C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

def IntPatch_HCurve2dTool_GetType(*args):
    """
    IntPatch_HCurve2dTool_GetType(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

def IntPatch_HCurve2dTool_Line(*args):
    """
    IntPatch_HCurve2dTool_Line(Handle_Adaptor2d_HCurve2d C) -> gp_Lin2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Lin2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

def IntPatch_HCurve2dTool_Circle(*args):
    """
    IntPatch_HCurve2dTool_Circle(Handle_Adaptor2d_HCurve2d C) -> gp_Circ2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Circ2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

def IntPatch_HCurve2dTool_Ellipse(*args):
    """
    IntPatch_HCurve2dTool_Ellipse(Handle_Adaptor2d_HCurve2d C) -> gp_Elips2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Elips2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

def IntPatch_HCurve2dTool_Hyperbola(*args):
    """
    IntPatch_HCurve2dTool_Hyperbola(Handle_Adaptor2d_HCurve2d C) -> gp_Hypr2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Hypr2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

def IntPatch_HCurve2dTool_Parabola(*args):
    """
    IntPatch_HCurve2dTool_Parabola(Handle_Adaptor2d_HCurve2d C) -> gp_Parab2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Parab2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

def IntPatch_HCurve2dTool_Bezier(*args):
    """
    IntPatch_HCurve2dTool_Bezier(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BezierCurve

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

    """
    return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

def IntPatch_HCurve2dTool_BSpline(*args):
    """
    IntPatch_HCurve2dTool_BSpline(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BSplineCurve

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

def IntPatch_HCurve2dTool_NbSamples(*args):
    """
    IntPatch_HCurve2dTool_NbSamples(Handle_Adaptor2d_HCurve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

class IntPatch_PrmPrmIntersection_T3Bits(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_PrmPrmIntersection_T3Bits self, Standard_Integer const size) -> IntPatch_PrmPrmIntersection_T3Bits

        :type size: int

        """
        this = _IntPatch.new_IntPatch_PrmPrmIntersection_T3Bits(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """Destroy(IntPatch_PrmPrmIntersection_T3Bits self)"""
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Destroy(self, *args)


    def Add(self, *args):
        """
        Add(IntPatch_PrmPrmIntersection_T3Bits self, Standard_Integer const t)

        :type t: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Add(self, *args)


    def Val(self, *args):
        """
        Val(IntPatch_PrmPrmIntersection_T3Bits self, Standard_Integer const t) -> Standard_Integer

        :type t: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Val(self, *args)


    def Raz(self, *args):
        """
        Raz(IntPatch_PrmPrmIntersection_T3Bits self, Standard_Integer const t)

        :type t: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Raz(self, *args)


    def ResetAnd(self, *args):
        """ResetAnd(IntPatch_PrmPrmIntersection_T3Bits self)"""
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_ResetAnd(self, *args)


    def And(self, *args):
        """
        And(IntPatch_PrmPrmIntersection_T3Bits self, IntPatch_PrmPrmIntersection_T3Bits Oth) -> Standard_Integer

        :type Oth: OCC.wrapper.IntPatch.IntPatch_PrmPrmIntersection_T3Bits
        :type indiceprecedent: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_And(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection_T3Bits
IntPatch_PrmPrmIntersection_T3Bits_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_swigregister
IntPatch_PrmPrmIntersection_T3Bits_swigregister(IntPatch_PrmPrmIntersection_T3Bits)

class IntPatch_Intersection(object):
    """
    This class provides a generic algorithm to intersect
    2 surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_Intersection self) -> IntPatch_Intersection
        __init__(IntPatch_Intersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang) -> IntPatch_Intersection
        __init__(IntPatch_Intersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Standard_Real const TolArc, Standard_Real const TolTang) -> IntPatch_Intersection

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolArc: float
        :type TolTang: float

        """
        this = _IntPatch.new_IntPatch_Intersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerances(self, *args):
        """
        SetTolerances(IntPatch_Intersection self, Standard_Real const TolArc, Standard_Real const TolTang, Standard_Real const UVMaxStep, Standard_Real const Fleche)

        Set the tolerances used by the algorithms:
        --- Implicit   - Parametric
        --- Parametric - Parametric
        --- Implicit   - Implicit

        TolArc   is  used  to   compute  the intersections
        between the restrictions   of  a  surface   and  a
        walking line.

        TolTang is used to compute the points on a walking
        line, and in geometric algorithms.

        Fleche  is  a  parameter   used in    the  walking
        algorithms to provide small curvatures on a line.

        UVMaxStep is  a  parameter   used in  the  walking
        algorithms  to    compute the  distance between to
        points in their respective parametric spaces.

        :type TolArc: float
        :type TolTang: float
        :type UVMaxStep: float
        :type Fleche: float

        """
        return _IntPatch.IntPatch_Intersection_SetTolerances(self, *args)


    def Perform(self, *args):
        """
        Perform(IntPatch_Intersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang, Standard_Boolean const isGeomInt, Standard_Boolean const theIsReqToKeepRLine, Standard_Boolean const theIsReqToPostWLProc)
        Perform(IntPatch_Intersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const TolArc, Standard_Real const TolTang, IntSurf_ListOfPntOn2S & LOfPnts, Standard_Boolean const isGeomInt, Standard_Boolean const theIsReqToKeepRLine, Standard_Boolean const theIsReqToPostWLProc)
        Perform(IntPatch_Intersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const TolArc, Standard_Real const TolTang)
        Perform(IntPatch_Intersection self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Standard_Real const TolArc, Standard_Real const TolTang)

        Uses for finding self-intersected surfaces.

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolArc: float
        :type TolTang: float

        """
        return _IntPatch.IntPatch_Intersection_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntPatch_Intersection self) -> Standard_Boolean

        Returns True if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Intersection_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntPatch_Intersection self) -> Standard_Boolean

        Returns true if the is no intersection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Intersection_IsEmpty(self, *args)


    def TangentFaces(self, *args):
        """
        TangentFaces(IntPatch_Intersection self) -> Standard_Boolean

        Returns True if the two patches are considered as
        entirely tangent, i-e every restriction arc of one
        patch is inside the geometric base of the other patch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Intersection_TangentFaces(self, *args)


    def OppositeFaces(self, *args):
        """
        OppositeFaces(IntPatch_Intersection self) -> Standard_Boolean

        Returns True when the TangentFaces returns True and the
        normal vectors evaluated at a point on the first and the
        second surface are opposite.
        The exception DomainError is raised if TangentFaces
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_Intersection_OppositeFaces(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(IntPatch_Intersection self) -> Standard_Integer

        Returns the number of "single" points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Intersection_NbPnts(self, *args)


    def Point(self, *args):
        """
        Returns the point of range Index.
        An exception is raised if Index<=0 or Index>NbPnt.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        res = _IntPatch.IntPatch_Intersection_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbLines(self, *args):
        """
        NbLines(IntPatch_Intersection self) -> Standard_Integer

        Returns the number of intersection lines.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_Intersection_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns the line of range Index.
        An exception is raised if Index<=0 or Index>NbLine.

        :type Index: int
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        res = _IntPatch.IntPatch_Intersection_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SequenceOfLine(self, *args):
        """
        :rtype: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine

        """
        res = _IntPatch.IntPatch_Intersection_SequenceOfLine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(IntPatch_Intersection self, Standard_Integer const Mode, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_HSurface S2, Handle_Adaptor3d_TopolTool D2)

        Dump of each result line.
        Mode for more accurate dumps.

        :type Mode: int
        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool

        """
        return _IntPatch.IntPatch_Intersection_Dump(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_Intersection
IntPatch_Intersection_swigregister = _IntPatch.IntPatch_Intersection_swigregister
IntPatch_Intersection_swigregister(IntPatch_Intersection)

class IntPatch_RstInt(object):
    """
    trouver les points d intersection entre la ligne de
    cheminement et les arcs de restriction
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def PutVertexOnLine(*args):
        """
        PutVertexOnLine(Handle_IntPatch_Line L, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, Handle_Adaptor3d_HSurface OtherSurf, Standard_Boolean const OnFirst, Standard_Real const Tol)

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type OtherSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type OnFirst: bool
        :type Tol: float

        """
        return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

    PutVertexOnLine = staticmethod(PutVertexOnLine)

    def __init__(self):
        """
        trouver les points d intersection entre la ligne de
        cheminement et les arcs de restriction
        """
        this = _IntPatch.new_IntPatch_RstInt()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_RstInt
IntPatch_RstInt_swigregister = _IntPatch.IntPatch_RstInt_swigregister
IntPatch_RstInt_swigregister(IntPatch_RstInt)

def IntPatch_RstInt_PutVertexOnLine(*args):
    """
    IntPatch_RstInt_PutVertexOnLine(Handle_IntPatch_Line L, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, Handle_Adaptor3d_HSurface OtherSurf, Standard_Boolean const OnFirst, Standard_Real const Tol)

    :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
    :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
    :type OtherSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type OnFirst: bool
    :type Tol: float

    """
    return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

class IntPatch_PolyLine(IntPatch_Polygo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_PolyLine self) -> IntPatch_PolyLine
        __init__(IntPatch_PolyLine self, Standard_Real const InitDefle) -> IntPatch_PolyLine

        :type InitDefle: float

        """
        this = _IntPatch.new_IntPatch_PolyLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetWLine(self, *args):
        """
        SetWLine(IntPatch_PolyLine self, Standard_Boolean const OnFirst, Handle_IntPatch_WLine Line)

        :type OnFirst: bool
        :type Line: OCC.wrapper.IntPatch.Handle_IntPatch_WLine

        """
        return _IntPatch.IntPatch_PolyLine_SetWLine(self, *args)


    def SetRLine(self, *args):
        """
        SetRLine(IntPatch_PolyLine self, Standard_Boolean const OnFirst, Handle_IntPatch_RLine Line)

        :type OnFirst: bool
        :type Line: OCC.wrapper.IntPatch.Handle_IntPatch_RLine

        """
        return _IntPatch.IntPatch_PolyLine_SetRLine(self, *args)


    def ResetError(self, *args):
        """ResetError(IntPatch_PolyLine self)"""
        return _IntPatch.IntPatch_PolyLine_ResetError(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntPatch_PolyLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_PolyLine_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(IntPatch_PolyLine self, Standard_Integer const Index) -> gp_Pnt2d

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntPatch.IntPatch_PolyLine_Point(self, *args)

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyLine
IntPatch_PolyLine_swigregister = _IntPatch.IntPatch_PolyLine_swigregister
IntPatch_PolyLine_swigregister(IntPatch_PolyLine)

class IntPatch_CSFunction(math.math_FunctionSetWithDerivatives):
    """
    this function is associated to the intersection between
    a curve on surface and a surface  .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_CSFunction self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor2d_HCurve2d C, Handle_Adaptor3d_HSurface S2) -> IntPatch_CSFunction

        S1 is the surface on which the intersection is searched.
        C is a curve on the surface S2.

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _IntPatch.new_IntPatch_CSFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(IntPatch_CSFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_CSFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(IntPatch_CSFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_CSFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(IntPatch_CSFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_CSFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(IntPatch_CSFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_CSFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(IntPatch_CSFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_CSFunction_Values(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntPatch.IntPatch_CSFunction_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Root(self, *args):
        """
        Root(IntPatch_CSFunction self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_CSFunction_Root(self, *args)


    def AuxillarSurface(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _IntPatch.IntPatch_CSFunction_AuxillarSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AuxillarCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _IntPatch.IntPatch_CSFunction_AuxillarCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntPatch.delete_IntPatch_CSFunction
IntPatch_CSFunction_swigregister = _IntPatch.IntPatch_CSFunction_swigregister
IntPatch_CSFunction_swigregister(IntPatch_CSFunction)

class IntPatch_HInterTool(object):
    """
    Tool for the intersection between 2 surfaces.
    Regroupe pour l instant les methodes hors Adaptor3d...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPatch_HInterTool self) -> IntPatch_HInterTool

        Tool for the intersection between 2 surfaces.
        Regroupe pour l instant les methodes hors Adaptor3d...
        """
        this = _IntPatch.new_IntPatch_HInterTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SingularOnUMin(*args):
        """
        SingularOnUMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

    SingularOnUMin = staticmethod(SingularOnUMin)

    def SingularOnUMax(*args):
        """
        SingularOnUMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

    SingularOnUMax = staticmethod(SingularOnUMax)

    def SingularOnVMin(*args):
        """
        SingularOnVMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

    SingularOnVMin = staticmethod(SingularOnVMin)

    def SingularOnVMax(*args):
        """
        SingularOnVMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

    SingularOnVMax = staticmethod(SingularOnVMax)

    def NbSamplesU(*args):
        """
        NbSamplesU(Handle_Adaptor3d_HSurface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type u1: float
        :type u2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args):
        """
        NbSamplesV(Handle_Adaptor3d_HSurface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def NbSamplePoints(self, *args):
        """
        NbSamplePoints(IntPatch_HInterTool self, Handle_Adaptor3d_HSurface S) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplePoints(self, *args)


    def SamplePoint(self, *args):
        """
        SamplePoint(IntPatch_HInterTool self, Handle_Adaptor3d_HSurface S, Standard_Integer const Index)

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Index: int
        :type U: float
        :type V: float

        """
        return _IntPatch.IntPatch_HInterTool_SamplePoint(self, *args)


    def HasBeenSeen(*args):
        """
        HasBeenSeen(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        Returns True if all the intersection point and edges
        are known on the Arc.
        The intersection point are given as vertices.
        The intersection edges are given as intervals between
        two vertices.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

    HasBeenSeen = staticmethod(HasBeenSeen)

    def NbSamplesOnArc(*args):
        """
        NbSamplesOnArc(Handle_Adaptor2d_HCurve2d A) -> Standard_Integer

        returns the number of points which is used to make
        a sample on the arc. this number is a function of
        the Surface and the CurveOnSurface complexity.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

    NbSamplesOnArc = staticmethod(NbSamplesOnArc)

    def Bounds(*args):
        """
        Bounds(Handle_Adaptor2d_HCurve2d C)

        Returns the parametric limits on the arc C.
        These limits must be finite : they are either
        the real limits of the arc, for a finite arc,
        or a bounding box for an infinite arc.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Ufirst: float
        :type Ulast: float

        """
        return _IntPatch.IntPatch_HInterTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def Project(*args):
        """
        Project(Handle_Adaptor2d_HCurve2d C, gp_Pnt2d P, gp_Pnt2d Ptproj) -> Standard_Boolean

        Projects the point P on the arc C.
        If the methods returns Standard_True, the projection is
        successful, and Paramproj is the parameter on the arc
        of the projected point, Ptproj is the projected Point.
        If the method returns Standard_False, Param proj and Ptproj
        are not significant.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Paramproj: float
        :type Ptproj: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_Project(*args)

    Project = staticmethod(Project)

    def Tolerance(*args):
        """
        Tolerance(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        Returns the parametric tolerance used to consider
        that the vertex and another point meet, i-e
        if Abs(parameter(Vertex) - parameter(OtherPnt))<=
        Tolerance, the points are "merged".

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Parameter(*args):
        """
        Parameter(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        Returns the parameter of the vertex V on the arc A.

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPatch.IntPatch_HInterTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def NbPoints(*args):
        """
        NbPoints(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

        Returns the number of intersection points on the arc A.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

    NbPoints = staticmethod(NbPoints)

    def Value(*args):
        """
        Value(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, gp_Pnt Pt)

        Returns the value (Pt), the tolerance (Tol), and
        the parameter (U) on the arc A , of the intersection
        point of range Index.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :type U: float

        """
        return _IntPatch.IntPatch_HInterTool_Value(*args)

    Value = staticmethod(Value)

    def IsVertex(*args):
        """
        IsVertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the intersection point of range Index
        corresponds with a vertex on the arc A.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

    IsVertex = staticmethod(IsVertex)

    def Vertex(*args):
        """
        Vertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, Handle_Adaptor3d_HVertex V)

        When IsVertex returns True, this method returns the
        vertex on the arc A.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        return _IntPatch.IntPatch_HInterTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    def NbSegments(*args):
        """
        NbSegments(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

        returns the number of part of A solution of the
        of intersection problem.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def HasFirstPoint(*args):
        """
        HasFirstPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

        Returns True when the segment of range Index is not
        open at the left side. In that case, IndFirst is the
        range in the list intersection points (see NbPoints)
        of the one which defines the left bound of the segment.
        Otherwise, the method has to return False, and IndFirst
        has no meaning.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type IndFirst: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

    HasFirstPoint = staticmethod(HasFirstPoint)

    def HasLastPoint(*args):
        """
        HasLastPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

        Returns True when the segment of range Index is not
        open at the right side. In that case, IndLast is the
        range in the list intersection points (see NbPoints)
        of the one which defines the right bound of the segment.
        Otherwise, the method has to return False, and IndLast
        has no meaning.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type IndLast: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

    HasLastPoint = staticmethod(HasLastPoint)

    def IsAllSolution(*args):
        """
        IsAllSolution(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        Returns True when the whole restriction is solution
        of the intersection problem.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

    IsAllSolution = staticmethod(IsAllSolution)
    __swig_destroy__ = _IntPatch.delete_IntPatch_HInterTool
IntPatch_HInterTool_swigregister = _IntPatch.IntPatch_HInterTool_swigregister
IntPatch_HInterTool_swigregister(IntPatch_HInterTool)

def IntPatch_HInterTool_SingularOnUMin(*args):
    """
    IntPatch_HInterTool_SingularOnUMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

def IntPatch_HInterTool_SingularOnUMax(*args):
    """
    IntPatch_HInterTool_SingularOnUMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

def IntPatch_HInterTool_SingularOnVMin(*args):
    """
    IntPatch_HInterTool_SingularOnVMin(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

def IntPatch_HInterTool_SingularOnVMax(*args):
    """
    IntPatch_HInterTool_SingularOnVMax(Handle_Adaptor3d_HSurface S) -> Standard_Boolean

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

def IntPatch_HInterTool_NbSamplesU(*args):
    """
    IntPatch_HInterTool_NbSamplesU(Handle_Adaptor3d_HSurface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type u1: float
    :type u2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

def IntPatch_HInterTool_NbSamplesV(*args):
    """
    IntPatch_HInterTool_NbSamplesV(Handle_Adaptor3d_HSurface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type v1: float
    :type v2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

def IntPatch_HInterTool_HasBeenSeen(*args):
    """
    IntPatch_HInterTool_HasBeenSeen(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    Returns True if all the intersection point and edges
    are known on the Arc.
    The intersection point are given as vertices.
    The intersection edges are given as intervals between
    two vertices.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

def IntPatch_HInterTool_NbSamplesOnArc(*args):
    """
    IntPatch_HInterTool_NbSamplesOnArc(Handle_Adaptor2d_HCurve2d A) -> Standard_Integer

    returns the number of points which is used to make
    a sample on the arc. this number is a function of
    the Surface and the CurveOnSurface complexity.

    :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

def IntPatch_HInterTool_Bounds(*args):
    """
    IntPatch_HInterTool_Bounds(Handle_Adaptor2d_HCurve2d C)

    Returns the parametric limits on the arc C.
    These limits must be finite : they are either
    the real limits of the arc, for a finite arc,
    or a bounding box for an infinite arc.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Ufirst: float
    :type Ulast: float

    """
    return _IntPatch.IntPatch_HInterTool_Bounds(*args)

def IntPatch_HInterTool_Project(*args):
    """
    IntPatch_HInterTool_Project(Handle_Adaptor2d_HCurve2d C, gp_Pnt2d P, gp_Pnt2d Ptproj) -> Standard_Boolean

    Projects the point P on the arc C.
    If the methods returns Standard_True, the projection is
    successful, and Paramproj is the parameter on the arc
    of the projected point, Ptproj is the projected Point.
    If the method returns Standard_False, Param proj and Ptproj
    are not significant.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type Paramproj: float
    :type Ptproj: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_Project(*args)

def IntPatch_HInterTool_Tolerance(*args):
    """
    IntPatch_HInterTool_Tolerance(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    Returns the parametric tolerance used to consider
    that the vertex and another point meet, i-e
    if Abs(parameter(Vertex) - parameter(OtherPnt))<=
    Tolerance, the points are "merged".

    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

def IntPatch_HInterTool_Parameter(*args):
    """
    IntPatch_HInterTool_Parameter(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    Returns the parameter of the vertex V on the arc A.

    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPatch.IntPatch_HInterTool_Parameter(*args)

def IntPatch_HInterTool_NbPoints(*args):
    """
    IntPatch_HInterTool_NbPoints(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

    Returns the number of intersection points on the arc A.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

def IntPatch_HInterTool_Value(*args):
    """
    IntPatch_HInterTool_Value(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, gp_Pnt Pt)

    Returns the value (Pt), the tolerance (Tol), and
    the parameter (U) on the arc A , of the intersection
    point of range Index.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type Pt: OCC.wrapper.gp.gp_Pnt
    :type Tol: float
    :type U: float

    """
    return _IntPatch.IntPatch_HInterTool_Value(*args)

def IntPatch_HInterTool_IsVertex(*args):
    """
    IntPatch_HInterTool_IsVertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

    Returns True if the intersection point of range Index
    corresponds with a vertex on the arc A.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

def IntPatch_HInterTool_Vertex(*args):
    """
    IntPatch_HInterTool_Vertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, Handle_Adaptor3d_HVertex V)

    When IsVertex returns True, this method returns the
    vertex on the arc A.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

    """
    return _IntPatch.IntPatch_HInterTool_Vertex(*args)

def IntPatch_HInterTool_NbSegments(*args):
    """
    IntPatch_HInterTool_NbSegments(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

    returns the number of part of A solution of the
    of intersection problem.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

def IntPatch_HInterTool_HasFirstPoint(*args):
    """
    IntPatch_HInterTool_HasFirstPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

    Returns True when the segment of range Index is not
    open at the left side. In that case, IndFirst is the
    range in the list intersection points (see NbPoints)
    of the one which defines the left bound of the segment.
    Otherwise, the method has to return False, and IndFirst
    has no meaning.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type IndFirst: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

def IntPatch_HInterTool_HasLastPoint(*args):
    """
    IntPatch_HInterTool_HasLastPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

    Returns True when the segment of range Index is not
    open at the right side. In that case, IndLast is the
    range in the list intersection points (see NbPoints)
    of the one which defines the right bound of the segment.
    Otherwise, the method has to return False, and IndLast
    has no meaning.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type IndLast: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

def IntPatch_HInterTool_IsAllSolution(*args):
    """
    IntPatch_HInterTool_IsAllSolution(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    Returns True when the whole restriction is solution
    of the intersection problem.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

class NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntPatch.new_NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self)

        Reverse sequence


        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theOther) -> NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theOther) -> NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_IntPatch_TheIWLineOfTheIWalking theItem)
        Append(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Handle_IntPatch_TheIWLineOfTheIWalking theItem)
        Prepend(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, Handle_IntPatch_TheIWLineOfTheIWalking theItem)
        InsertBefore(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::Iterator & thePosition, Handle_IntPatch_TheIWLineOfTheIWalking theItem)
        InsertAfter(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theSeq)
        InsertAfter(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, Handle_IntPatch_TheIWLineOfTheIWalking theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Handle_IntPatch_TheIWLineOfTheIWalking

        First item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self) -> Handle_IntPatch_TheIWLineOfTheIWalking

        Last item access

        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex) -> Handle_IntPatch_TheIWLineOfTheIWalking

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, Handle_IntPatch_TheIWLineOfTheIWalking theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_SetValue(self, *args)


    def __iter__(self):
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking___iter__(self)
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking
NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_swigregister
NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_swigregister(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking)

def NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_delNode(*args):
    """
    NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_delNode(*args)

class NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPatch.new_NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper

    def __next__(self):
        return _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper___next__(self)
NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper_swigregister = _IntPatch.NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper_swigregister
NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper_swigregister(NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking_IteratorHelper)


try:
	IntPatch_SequenceOfIWLineOfTheIWalking = NCollection_Sequence_Handle_IntPatch_TheIWLineOfTheIWalking
except NameError:
	pass # does not exist, probably ignored




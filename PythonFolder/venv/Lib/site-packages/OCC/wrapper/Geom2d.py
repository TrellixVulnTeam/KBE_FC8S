# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom2d')
    _Geom2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2d', [dirname(__file__)])
        except ImportError:
            import _Geom2d
            return _Geom2d
        try:
            _mod = imp.load_module('_Geom2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom2d = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2d.delete_SwigPyIterator

    def value(self):
        return _Geom2d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom2d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom2d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom2d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom2d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom2d.SwigPyIterator_copy(self)

    def next(self):
        return _Geom2d.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom2d.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom2d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom2d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom2d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom2d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom2d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom2d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom2d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom2d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom2d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom2d.ptr_to_number(item)
ptr_to_number = _Geom2d.ptr_to_number

def HashCode(*args):
    return _Geom2d.HashCode(*args)
HashCode = _Geom2d.HashCode

def ptr_equal(a, b):
    return _Geom2d.ptr_equal(a, b)
ptr_equal = _Geom2d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class Geom2d_Geometry(Standard.Standard_Transient):
    """
    The general abstract class Geometry in 2D space describes
    the common behaviour of all the geometric entities.

    All the objects derived from this class can be move with a
    geometric transformation. Only the transformations which
    doesn't modify the nature of the geometry are available in
    this package.
    The method Transform which defines a general transformation
    is deferred. The other specifics transformations used the
    method Transform.
    All the following transformations modify the object itself.
    Warning
    Only transformations which do not modify the nature
    of the geometry can be applied to Geom2d objects:
    this is the case with translations, rotations,
    symmetries and scales; this is also the case with
    gp_Trsf2d composite transformations which are
    used to define the geometric transformations applied
    using the Transform or Transformed functions.
    Note: Geometry defines the "prototype" of the
    abstract method Transform which is defined for each
    concrete type of derived object. All other
    transformations are implemented using the Transform method.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Geometry
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Geometry(self) 
            return h


    def Mirror(self, *args):
        """
        Mirror(Geom2d_Geometry self, gp_Pnt2d P)
        Mirror(Geom2d_Geometry self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Geometry_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Geom2d_Geometry_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Geom2d_Geometry_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Geom2d_Geometry self, gp_Vec2d V)
        Translate(Geom2d_Geometry self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Geometry_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Geometry self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Geometry_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Geom2d_Geometry self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Geom2d_Geometry self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Geometry_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Geometry_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Geometry_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Geom2d_Geometry self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Geometry_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Geom2d_Geometry self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Geom2d_Geometry self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Geometry_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Geometry self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Geometry_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Geometry_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Geometry_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Geometry_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Geometry
Geom2d_Geometry_swigregister = _Geom2d.Geom2d_Geometry_swigregister
Geom2d_Geometry_swigregister(Geom2d_Geometry)

def Geom2d_Geometry_get_type_name(*args):
    """
    Geom2d_Geometry_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Geometry_get_type_name(*args)

def Geom2d_Geometry_get_type_descriptor(*args):
    """
    Geom2d_Geometry_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Geometry_get_type_descriptor(*args)

class Geom2d_Curve(Geom2d_Geometry):
    """
    The abstract class Curve describes the common
    behavior of curves in 2D space. The Geom2d
    package provides numerous concrete classes of
    derived curves, including lines, circles, conics, Bezier
    or BSpline curves, etc.
    The main characteristic of these curves is that they
    are parameterized. The Geom2d_Curve class shows:
    - how to work with the parametric equation of a
    curve in order to calculate the point of parameter
    u, together with the vector tangent and the
    derivative vectors of order 2, 3,..., N at this point;
    - how to obtain general information about the curve
    (for example, level of continuity, closed
    characteristics, periodicity, bounds of the parameter field);
    - how the parameter changes when a geometric
    transformation is applied to the curve or when the
    orientation of the curve is inverted.
    All curves must have a geometric continuity: a curve is
    at least "C0". Generally, this property is checked at
    the time of construction or when the curve is edited.
    Where this is not the case, the documentation
    explicitly states so.
    Warning
    The Geom2d package does not prevent the
    construction of curves with null length or curves which
    self-intersect.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Curve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Curve(self) 
            return h


    def Reverse(self, *args):
        """
        Reverse(Geom2d_Curve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Geom2d.Geom2d_Curve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Curve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this curve.
        Note: The point of parameter U on this curve is
        identical to the point of parameter
        ReversedParameter(U) on the reversed curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Curve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom2d_Curve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Curve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom2d_Curve self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Curve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Geom2d_Curve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Geom2d_Curve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_Curve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Curve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_Curve self) -> Standard_Real

        Value of the last parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Curve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_Curve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Examples :
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_Curve self) -> Standard_Boolean

        Returns true if the parameter of the curve is periodic.
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Curve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Geom2d_Curve self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Curve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_Curve self) -> GeomAbs_Shape

        It is the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_Curve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_Curve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Curve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Curve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Curve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Curve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Curve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_Curve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this curve, computes
        the vector corresponding to the Nth derivative.
        Exceptions
        StdFail_UndefinedDerivative if:
        - the continuity of the curve is not "CN", or
        - the derivative vector cannot be computed easily;
        this is the case with specific types of curve (for
        example, a rational BSpline curve where N is greater than 3).
        Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Curve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Geom2d_Curve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Curve_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Curve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Curve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Curve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Curve
Geom2d_Curve_swigregister = _Geom2d.Geom2d_Curve_swigregister
Geom2d_Curve_swigregister(Geom2d_Curve)

def Geom2d_Curve_get_type_name(*args):
    """
    Geom2d_Curve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Curve_get_type_name(*args)

def Geom2d_Curve_get_type_descriptor(*args):
    """
    Geom2d_Curve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Curve_get_type_descriptor(*args)

class Geom2d_Vector(Geom2d_Geometry):
    """
    The abstract class Vector describes the common
    behavior of vectors in 2D space.
    The Geom2d package provides two concrete
    classes of vectors: Geom2d_Direction (unit vector)
    and Geom2d_VectorWithMagnitude.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Vector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Vector(self) 
            return h


    def Reverse(self, *args):
        """
        Reverse(Geom2d_Vector self)

        Reverses the vector <me>.


        """
        return _Geom2d.Geom2d_Vector_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Geom2d_Vector self) -> Handle_Geom2d_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Geom2d_Vector_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Geom2d_Vector self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The orientation is from this
        vector to vector Other.
        Raises VectorWithNullMagnitude if one of the two vectors is a vector with
        null magnitude because the angular value is indefinite.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_Angle(self, *args)


    def Coord(self, *args):
        """
        Coord(Geom2d_Vector self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_Vector_Coord(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Geom2d_Vector self) -> Standard_Real

        Returns the  Magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Geom2d_Vector self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_SquareMagnitude(self, *args)


    def X(self, *args):
        """
        X(Geom2d_Vector self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_X(self, *args)


    def Y(self, *args):
        """
        Y(Geom2d_Vector self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_Y(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Geom2d_Vector self, Handle_Geom2d_Vector Other) -> Standard_Real

        Cross product of <me> with the vector <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_Crossed(self, *args)


    def Dot(self, *args):
        """
        Dot(Geom2d_Vector self, Handle_Geom2d_Vector Other) -> Standard_Real

        Returns the scalar product of 2 Vectors.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Vector_Dot(self, *args)


    def Vec2d(self, *args):
        """
        Vec2d(Geom2d_Vector self) -> gp_Vec2d

        Returns a non persistent copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Vector_Vec2d(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Vector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Vector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Vector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Vector
Geom2d_Vector_swigregister = _Geom2d.Geom2d_Vector_swigregister
Geom2d_Vector_swigregister(Geom2d_Vector)

def Geom2d_Vector_get_type_name(*args):
    """
    Geom2d_Vector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Vector_get_type_name(*args)

def Geom2d_Vector_get_type_descriptor(*args):
    """
    Geom2d_Vector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Vector_get_type_descriptor(*args)

class Geom2d_Conic(Geom2d_Curve):
    """
    The abstract class Conic describes the common
    behavior of conic curves in 2D space and, in
    particular, their general characteristics. The Geom2d
    package provides four specific classes of conics:
    Geom2d_Circle, Geom2d_Ellipse,
    Geom2d_Hyperbola and Geom2d_Parabola.
    A conic is positioned in the plane with a coordinate
    system (gp_Ax22d object), where the origin is the
    center of the conic (or the apex in case of a parabola).
    This coordinate system is the local coordinate
    system of the conic. It gives the conic an explicit
    orientation, determining the direction in which the
    parameter increases along the conic. The "X Axis" of
    the local coordinate system also defines the origin of
    the parameter of the conic.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Conic
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Conic(self) 
            return h


    def SetAxis(self, *args):
        """
        SetAxis(Geom2d_Conic self, gp_Ax22d A)

        Modifies this conic, redefining its local coordinate system
        partially, by assigning P as its origin

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _Geom2d.Geom2d_Conic_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(Geom2d_Conic self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Conic_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(Geom2d_Conic self, gp_Ax2d A)

        Assigns the origin and unit vector of axis A to the
        origin of the local coordinate system of this conic and either:
        - its "X Direction", or
        - its "Y Direction".
        The other unit vector of the local coordinate system
        of this conic is recomputed normal to A, without
        changing the orientation of the local coordinate
        system (right-handed or left-handed).

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Conic_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom2d_Conic self, gp_Pnt2d P)

        Modifies this conic, redefining its local coordinate
        system fully, by assigning A as this coordinate system.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Conic_SetLocation(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Geom2d_Conic self) -> gp_Ax2d

        Returns the "XAxis" of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis and the "Yaxis" define the local coordinate system
        of the conic.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Conic_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Geom2d_Conic self) -> gp_Ax2d

        Returns the "YAxis" of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Conic_YAxis(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom2d_Conic self) -> Standard_Real

        returns the eccentricity value of the conic e.
        e = 0 for a circle
        0 < e < 1 for an ellipse  (e = 0 if MajorRadius = MinorRadius)
        e > 1 for a hyperbola
        e = 1 for a parabola

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Conic_Eccentricity(self, *args)


    def Location(self, *args):
        """
        Location(Geom2d_Conic self) -> gp_Pnt2d

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Conic_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _Geom2d.Geom2d_Conic_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Geom2d_Conic self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom2d.Geom2d_Conic_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Conic self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Conic_ReversedParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_Conic self) -> GeomAbs_Shape

        Returns GeomAbs_CN which is the global continuity of any conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_Conic_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_Conic self, Standard_Integer const N) -> Standard_Boolean

        Returns True, the order of continuity of a conic is infinite.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Conic_IsCN(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Conic_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Conic_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Conic_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Conic
Geom2d_Conic_swigregister = _Geom2d.Geom2d_Conic_swigregister
Geom2d_Conic_swigregister(Geom2d_Conic)

def Geom2d_Conic_get_type_name(*args):
    """
    Geom2d_Conic_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Conic_get_type_name(*args)

def Geom2d_Conic_get_type_descriptor(*args):
    """
    Geom2d_Conic_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Conic_get_type_descriptor(*args)

class Geom2d_Direction(Geom2d_Vector):
    """
    The class Direction specifies a vector that is never null.
    It is a unit vector.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Direction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Direction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Direction self, Standard_Real const X, Standard_Real const Y) -> Geom2d_Direction
        __init__(Geom2d_Direction self, gp_Dir2d V) -> Geom2d_Direction

        Creates a persistent copy of <me>.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        this = _Geom2d.new_Geom2d_Direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCoord(self, *args):
        """
        SetCoord(Geom2d_Direction self, Standard_Real const X, Standard_Real const Y)

        Assigns the coordinates X and Y to this unit vector,
        then normalizes it.
        Exceptions
        Standard_ConstructionError if Sqrt(X*X +
        Y*Y) is less than or equal to gp::Resolution().

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_Direction_SetCoord(self, *args)


    def SetDir2d(self, *args):
        """
        SetDir2d(Geom2d_Direction self, gp_Dir2d V)

        Converts the gp_Dir2d unit vector V into this unit vector.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Geom2d_Direction_SetDir2d(self, *args)


    def SetX(self, *args):
        """
        SetX(Geom2d_Direction self, Standard_Real const X)

        Assigns a value to the X coordinate of this unit vector, then normalizes it.
        Exceptions
        Standard_ConstructionError if the value assigned
        causes the magnitude of the vector to become less
        than or equal to gp::Resolution().

        :type X: float

        """
        return _Geom2d.Geom2d_Direction_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Geom2d_Direction self, Standard_Real const Y)

        Assigns a value to the Y coordinate of this unit vector, then normalizes it.
        Exceptions
        Standard_ConstructionError if the value assigned
        causes the magnitude of the vector to become less
        than or equal to gp::Resolution().

        :type Y: float

        """
        return _Geom2d.Geom2d_Direction_SetY(self, *args)


    def Dir2d(self, *args):
        """
        Dir2d(Geom2d_Direction self) -> gp_Dir2d

        Converts this unit vector into a gp_Dir2d unit vector.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Geom2d_Direction_Dir2d(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Geom2d_Direction self) -> Standard_Real

        returns 1.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Direction_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Geom2d_Direction self) -> Standard_Real

        returns 1.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Direction_SquareMagnitude(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Geom2d_Direction self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the cross product between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Direction_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(Geom2d_Direction self, Handle_Geom2d_Vector Other) -> Standard_Real

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Direction___xor__(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Direction self, gp_Trsf2d T)

        Applies the transformation T to this unit vector, then normalizes it.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Direction_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Direction self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this unit vector.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Direction_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Direction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Direction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Direction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Direction
Geom2d_Direction_swigregister = _Geom2d.Geom2d_Direction_swigregister
Geom2d_Direction_swigregister(Geom2d_Direction)

def Geom2d_Direction_get_type_name(*args):
    """
    Geom2d_Direction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Direction_get_type_name(*args)

def Geom2d_Direction_get_type_descriptor(*args):
    """
    Geom2d_Direction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Direction_get_type_descriptor(*args)

class Geom2d_UndefinedValue(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_UndefinedValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_UndefinedValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_UndefinedValue self) -> Geom2d_UndefinedValue
        __init__(Geom2d_UndefinedValue self, Standard_CString const theMessage) -> Geom2d_UndefinedValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Geom2d.new_Geom2d_UndefinedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Geom2d_UndefinedValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_UndefinedValue

        """
        return _Geom2d.Geom2d_UndefinedValue_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_UndefinedValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_UndefinedValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_UndefinedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_UndefinedValue
Geom2d_UndefinedValue_swigregister = _Geom2d.Geom2d_UndefinedValue_swigregister
Geom2d_UndefinedValue_swigregister(Geom2d_UndefinedValue)

def Geom2d_UndefinedValue_NewInstance(*args):
    """
    Geom2d_UndefinedValue_NewInstance(Standard_CString const theMessage) -> Handle_Geom2d_UndefinedValue

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_UndefinedValue

    """
    return _Geom2d.Geom2d_UndefinedValue_NewInstance(*args)

def Geom2d_UndefinedValue_get_type_name(*args):
    """
    Geom2d_UndefinedValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_UndefinedValue_get_type_name(*args)

def Geom2d_UndefinedValue_get_type_descriptor(*args):
    """
    Geom2d_UndefinedValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_UndefinedValue_get_type_descriptor(*args)

class Geom2d_Transformation(Standard.Standard_Transient):
    """
    The class Transformation allows to create Translation,
    Rotation, Symmetry, Scaling and complex transformations
    obtained by combination of the previous elementary
    transformations.
    The Transformation class can also be used to
    construct complex transformations by combining
    these elementary transformations.
    However, these transformations can never change
    the type of an object. For example, the projection
    transformation can change a circle into an ellipse,
    and therefore change the real type of the object.
    Such a transformation is forbidden in this
    environment and cannot be a Geom2d_Transformation.
    The transformation can be represented as follow :

    V1   V2     T
    | a11  a12    a14 |   | x |      | x'|
    | a21  a22    a24 |   | y |      | y'|
    |  0    0      1  |   | 1 |      | 1 |

    where {V1, V2} defines the vectorial part of the
    transformation and T defines the translation part of
    the transformation.
    - Geom2d_Transformation transformations provide
    the same kind of "geometric" services as
    gp_Trsf2d ones but have more complex data
    structures. The geometric objects provided by the
    Geom2d package use gp_Trsf2d transformations
    in the syntaxes Transform and Transformed.
    - Geom2d_Transformation transformations are
    used in a context where they can be shared by
    several objects contained inside a common data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Transformation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Transformation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Transformation self) -> Geom2d_Transformation
        __init__(Geom2d_Transformation self, gp_Trsf2d T) -> Geom2d_Transformation

        Creates a persistent copy of T.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        this = _Geom2d.new_Geom2d_Transformation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMirror(self, *args):
        """
        SetMirror(Geom2d_Transformation self, gp_Pnt2d P)
        SetMirror(Geom2d_Transformation self, gp_Ax2d A)

        Makes the transformation into a symmetrical transformation
        with respect to an axis A.
        A is the center of the axial symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Transformation_SetMirror(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(Geom2d_Transformation self, gp_Pnt2d P, Standard_Real const Ang)

        Assigns to this transformation the geometric
        properties of a rotation at angle Ang (in radians) about point P.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Geom2d_Transformation_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Geom2d_Transformation self, gp_Pnt2d P, Standard_Real const S)

        Makes the transformation into a scale. P is the center of
        the scale and S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Geom2d_Transformation_SetScale(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Geom2d_Transformation self, gp_Ax2d FromSystem1, gp_Ax2d ToSystem2)
        SetTransformation(Geom2d_Transformation self, gp_Ax2d ToSystem)

        Makes the transformation allowing passage from the basic
        coordinate system
        {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.)}
        to the local coordinate system defined with the Ax2d ToSystem.

        :type ToSystem: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Transformation_SetTransformation(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(Geom2d_Transformation self, gp_Vec2d V)
        SetTranslation(Geom2d_Transformation self, gp_Pnt2d P1, gp_Pnt2d P2)

        Makes the transformation into a translation from the point
        P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Transformation_SetTranslation(self, *args)


    def SetTrsf2d(self, *args):
        """
        SetTrsf2d(Geom2d_Transformation self, gp_Trsf2d T)

        Makes the transformation into a transformation T from
        package gp.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Transformation_SetTrsf2d(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(Geom2d_Transformation self) -> Standard_Boolean

        Checks whether this transformation is an indirect
        transformation: returns true if the determinant of the
        matrix of the vectorial part of the transformation is less than 0.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Transformation_IsNegative(self, *args)


    def Form(self, *args):
        """
        Form(Geom2d_Transformation self) -> gp_TrsfForm

        Returns the nature of this transformation as a value
        of the gp_TrsfForm enumeration.
        Returns the nature of the transformation. It can be
        Identity, Rotation, Translation, PntMirror, Ax1Mirror,
        Scale, CompoundTrsf

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _Geom2d.Geom2d_Transformation_Form(self, *args)


    def ScaleFactor(self, *args):
        """
        ScaleFactor(Geom2d_Transformation self) -> Standard_Real

        Returns the scale value of the transformation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Transformation_ScaleFactor(self, *args)


    def Trsf2d(self, *args):
        """
        Trsf2d(Geom2d_Transformation self) -> gp_Trsf2d

        Converts this transformation into a gp_Trsf2d transformation.
        Returns a non persistent copy of <me>.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Transformation_Trsf2d(self, *args)


    def Value(self, *args):
        """
        Value(Geom2d_Transformation self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        Returns the coefficients of the global matrix of tranformation.
        It is a 2 rows X 3 columns matrix.

        Raised if  Row < 1 or Row > 2  or  Col < 1 or Col > 2

        Computes the reverse transformation.

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Transformation_Value(self, *args)


    def Invert(self, *args):
        """
        Invert(Geom2d_Transformation self)

        Computes the inverse of this transformation.
        and  assigns the result to this transformatio

        Raised if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from
        package gp.


        """
        return _Geom2d.Geom2d_Transformation_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(Geom2d_Transformation self) -> Handle_Geom2d_Transformation

        Computes the inverse of this transformation and creates a new one.
        Raises ConstructionError  if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from package gp.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Geom2d_Transformation self, Handle_Geom2d_Transformation Other) -> Handle_Geom2d_Transformation

        Computes the transformation composed with Other and <me>.
        <me> * Other.
        Returns a new transformation

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(Geom2d_Transformation self, Handle_Geom2d_Transformation Other) -> Handle_Geom2d_Transformation

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Geom2d_Transformation self, Handle_Geom2d_Transformation Other)

        Computes the transformation composed with Other and <me> .
        <me> = <me> * Other.

        Computes the following composition of transformations
        if N > 0  <me> * <me> * .......* <me>.
        if N = 0  Identity
        if N < 0  <me>.Invert() * .........* <me>.Invert()

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(Geom2d_Transformation self, Handle_Geom2d_Transformation Other)

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation___imul__(self, *args)


    def Power(self, *args):
        """
        Power(Geom2d_Transformation self, Standard_Integer const N)

        Raised if N < 0 and if the transformation is not inversible

        :type N: int

        """
        return _Geom2d.Geom2d_Transformation_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(Geom2d_Transformation self, Standard_Integer const N) -> Handle_Geom2d_Transformation

        Raised if N < 0 and if the transformation is not inversible

        :type N: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation_Powered(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(Geom2d_Transformation self, Handle_Geom2d_Transformation Other)

        Computes the matrix of the transformation composed with
        <me> and Other.     <me> = Other * <me>

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation_PreMultiply(self, *args)


    def Transforms(self, *args):
        """
        Transforms(Geom2d_Transformation self)

        Applies the transformation <me> to the triplet {X, Y}.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_Transformation_Transforms(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Transformation self) -> Handle_Geom2d_Transformation

        Creates a new object, which is a copy of this transformation.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Geom2d_Transformation_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Transformation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Transformation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Transformation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Transformation
Geom2d_Transformation_swigregister = _Geom2d.Geom2d_Transformation_swigregister
Geom2d_Transformation_swigregister(Geom2d_Transformation)

def Geom2d_Transformation_get_type_name(*args):
    """
    Geom2d_Transformation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Transformation_get_type_name(*args)

def Geom2d_Transformation_get_type_descriptor(*args):
    """
    Geom2d_Transformation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Transformation_get_type_descriptor(*args)

class Geom2d_VectorWithMagnitude(Geom2d_Vector):
    """
    Defines a vector with magnitude.
    A vector with magnitude can have a zero length.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_VectorWithMagnitude
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_VectorWithMagnitude(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_VectorWithMagnitude self, gp_Vec2d V) -> Geom2d_VectorWithMagnitude
        __init__(Geom2d_VectorWithMagnitude self, Standard_Real const X, Standard_Real const Y) -> Geom2d_VectorWithMagnitude
        __init__(Geom2d_VectorWithMagnitude self, gp_Pnt2d P1, gp_Pnt2d P2) -> Geom2d_VectorWithMagnitude

        Creates a vector from the point P1 to the point P2.
        The magnitude of the vector is the distance between P1 and P2

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _Geom2d.new_Geom2d_VectorWithMagnitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCoord(self, *args):
        """
        SetCoord(Geom2d_VectorWithMagnitude self, Standard_Real const X, Standard_Real const Y)

        Set <me> to X, Y coordinates.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_SetCoord(self, *args)


    def SetVec2d(self, *args):
        """
        SetVec2d(Geom2d_VectorWithMagnitude self, gp_Vec2d V)

        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_SetVec2d(self, *args)


    def SetX(self, *args):
        """
        SetX(Geom2d_VectorWithMagnitude self, Standard_Real const X)

        Changes the X coordinate of <me>.

        :type X: float

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Geom2d_VectorWithMagnitude self, Standard_Real const Y)

        Changes the Y coordinate of <me>

        :type Y: float

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_SetY(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Geom2d_VectorWithMagnitude self) -> Standard_Real

        Returns the magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Geom2d_VectorWithMagnitude self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_SquareMagnitude(self, *args)


    def Add(self, *args):
        """
        Add(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        Adds the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Geom2d_VectorWithMagnitude___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        Adds the vector Other to <me>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude___add__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the cross product  between <me> and Other
        <me> ^ Other. A new vector is returned.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Standard_Real

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_VectorWithMagnitude___xor__(self, *args)


    def Divide(self, *args):
        """
        Divide(Geom2d_VectorWithMagnitude self, Standard_Real const Scalar)

        Divides <me> by a scalar.

        :type Scalar: float

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Divide(self, *args)


    def __itruediv__(self, *args):
        return _Geom2d.Geom2d_VectorWithMagnitude___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(Geom2d_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom2d_VectorWithMagnitude

        Divides <me> by a scalar. A new vector is returned.

        :type Scalar: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Divided(self, *args)


    def __truediv__(self, *args):
        return _Geom2d.Geom2d_VectorWithMagnitude___truediv__(self, *args)
    __div__ = __truediv__



    def Multiplied(self, *args):
        """
        Multiplied(Geom2d_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom2d_VectorWithMagnitude

        Computes the product of the vector <me> by a scalar.
        A new vector is returned.

        -C++: alias operator *
        Collision with same operator defined for the class Vector!

        :type Scalar: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Multiplied(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Geom2d_VectorWithMagnitude self, Standard_Real const Scalar)

        Computes the product of the vector <me> by a scalar.

        :type Scalar: float

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(Geom2d_VectorWithMagnitude self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _Geom2d.Geom2d_VectorWithMagnitude___imul__(self, *args)


    def Normalize(self, *args):
        """
        Normalize(Geom2d_VectorWithMagnitude self)

        Normalizes <me>.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.


        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(Geom2d_VectorWithMagnitude self) -> Handle_Geom2d_VectorWithMagnitude

        Returns a copy of <me> Normalized.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Normalized(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        Subtracts the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Geom2d_VectorWithMagnitude___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        Subtracts the vector Other to <me>. A new vector is returned.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Geom2d_VectorWithMagnitude___sub__(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_VectorWithMagnitude self, gp_Trsf2d T)

        Applies the transformation T to this vector.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_VectorWithMagnitude self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this vector.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_VectorWithMagnitude_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_VectorWithMagnitude_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_VectorWithMagnitude
Geom2d_VectorWithMagnitude_swigregister = _Geom2d.Geom2d_VectorWithMagnitude_swigregister
Geom2d_VectorWithMagnitude_swigregister(Geom2d_VectorWithMagnitude)

def Geom2d_VectorWithMagnitude_get_type_name(*args):
    """
    Geom2d_VectorWithMagnitude_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_VectorWithMagnitude_get_type_name(*args)

def Geom2d_VectorWithMagnitude_get_type_descriptor(*args):
    """
    Geom2d_VectorWithMagnitude_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_VectorWithMagnitude_get_type_descriptor(*args)

class Geom2d_Line(Geom2d_Curve):
    """
    Describes an infinite line in the plane (2D space).
    A line is defined and positioned in the plane with an
    axis (gp_Ax2d object) which gives it an origin and a unit vector.
    The Geom2d_Line line is parameterized as follows:
    P (U) = O + U*Dir
    where:
    - P is the point of parameter U,
    - O is the origin and Dir the unit vector of its positioning axis.
    The parameter range is ] -infinite, +infinite [.
    The orientation of the line is given by the unit vector
    of its positioning axis.
    See Also
    GCE2d_MakeLine which provides functions for more
    complex line constructions
    gp_Ax2d
    gp_Lin2d for an equivalent, non-parameterized data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Line
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Line(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Line self, gp_Ax2d A) -> Geom2d_Line
        __init__(Geom2d_Line self, gp_Lin2d L) -> Geom2d_Line
        __init__(Geom2d_Line self, gp_Pnt2d P, gp_Dir2d V) -> Geom2d_Line

        Constructs a line passing through point P and parallel to
        vector V (P and V are, respectively, the origin
        and the unit vector of the positioning axis of the line).

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        this = _Geom2d.new_Geom2d_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetLin2d(self, *args):
        """
        SetLin2d(Geom2d_Line self, gp_Lin2d L)

        Set <me> so that <me> has the same geometric properties as L.

        :type L: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2d.Geom2d_Line_SetLin2d(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom2d_Line self, gp_Dir2d V)

        changes the direction of the line.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Geom2d_Line_SetDirection(self, *args)


    def Direction(self, *args):
        """
        changes the direction of the line.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _Geom2d.Geom2d_Line_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocation(self, *args):
        """
        SetLocation(Geom2d_Line self, gp_Pnt2d P)

        Changes the "Location" point (origin) of the line.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Line_SetLocation(self, *args)


    def Location(self, *args):
        """
        Changes the "Location" point (origin) of the line.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Geom2d.Geom2d_Line_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Geom2d_Line self, gp_Ax2d A)

        Changes the "Location" and a the "Direction" of <me>.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Line_SetPosition(self, *args)


    def Position(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        res = _Geom2d.Geom2d_Line_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Lin2d(self, *args):
        """
        Lin2d(Geom2d_Line self) -> gp_Lin2d

        Returns non persistent line from gp with the same geometric
        properties as <me>

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2d.Geom2d_Line_Lin2d(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Geom2d_Line self)

        Changes the orientation of this line. As a result, the
        unit vector of the positioning axis of this line is reversed.


        """
        return _Geom2d.Geom2d_Line_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Line self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed line for the
        point of parameter U on this line.
        For a line, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Line_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_Line self) -> Standard_Real

        Returns RealFirst  from  Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Line_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_Line self) -> Standard_Real

        Returns RealLast  from Standard

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Line_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_Line self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Line_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_Line self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Line_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_Line self) -> GeomAbs_Shape

        Returns GeomAbs_CN, which is the global continuity of any line.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_Line_Continuity(self, *args)


    def Distance(self, *args):
        """
        Distance(Geom2d_Line self, gp_Pnt2d P) -> Standard_Real

        Computes the distance between <me> and the point P.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Line_Distance(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_Line self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Line_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_Line self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P (U) = O + U * Dir where O is the "Location" point of the
        line and Dir the direction of the line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Line_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_Line self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter u and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Line_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_Line self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2. V2 is a vector with null magnitude
        for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Line_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_Line self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        V2 and V3 are vectors with null magnitude for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Line_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_Line self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this line, computes
        the vector corresponding to the Nth derivative.
        Note: if N is greater than or equal to 2, the result is a
        vector with null magnitude.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Line_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Line self, gp_Trsf2d T)

        Applies the transformation T to this line.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Line_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom2d_Line self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the line transformed by
        T for the point of parameter U on this line.
        For a line, the returned value is equal to U multiplied
        by the scale factor of transformation T.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Line_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom2d_Line self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this line when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this line
        and the parameter of the transformed point on the
        new line transformed by T.
        For a line, the returned value is the scale factor of the transformation T.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Line_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Line self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this line.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Line_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Line_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Line_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Line
Geom2d_Line_swigregister = _Geom2d.Geom2d_Line_swigregister
Geom2d_Line_swigregister(Geom2d_Line)

def Geom2d_Line_get_type_name(*args):
    """
    Geom2d_Line_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Line_get_type_name(*args)

def Geom2d_Line_get_type_descriptor(*args):
    """
    Geom2d_Line_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Line_get_type_descriptor(*args)

class Geom2d_Ellipse(Geom2d_Conic):
    """
    Describes an ellipse in the plane (2D space).
    An ellipse is defined by its major and minor radii and,
    as with any conic curve, is positioned in the plane
    with a coordinate system (gp_Ax22d object) where:
    - the origin is the center of the ellipse,
    - the "X Direction" defines the major axis, and
    - the "Y Direction" defines the minor axis.
    This coordinate system is the local coordinate system of the ellipse.
    The orientation (direct or indirect) of the local
    coordinate system gives an explicit orientation to the
    ellipse, determining the direction in which the
    parameter increases along the ellipse.
    The Geom2d_Ellipse ellipse is parameterized by an angle:
    P(U) = O + MajorRad*Cos(U)*XDir + MinorRad*Sin(U)*YDir
    where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - MajorRad and MinorRad are the major and
    minor radii of the ellipse.
    The "X Axis" of the local coordinate system therefore
    defines the origin of the parameter of the ellipse.
    An ellipse is a closed and periodic curve. The period
    is 2.*Pi and the parameter range is [ 0,2.*Pi [.
    See Also
    GCE2d_MakeEllipse which provides functions for
    more complex ellipse constructions
    gp_Ax22d
    gp_Elips2d for an equivalent, non-parameterized data structure
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Ellipse
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Ellipse(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Ellipse self, gp_Elips2d E) -> Geom2d_Ellipse
        __init__(Geom2d_Ellipse self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> Geom2d_Ellipse
        __init__(Geom2d_Ellipse self, gp_Ax22d Axis, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> Geom2d_Ellipse

        Creates an ellipse defined by its major and minor radii,
        MajorRadius and MinorRadius, where the
        coordinate system Axis locates the ellipse and
        defines its orientation in the plane such that:
        - the center of the ellipse is the origin of Axis,
        - the "X Direction" of Axis defines the major
        axis of the ellipse,
        - the "Y Direction" of Axis defines the minor
        axis of the ellipse,
        - the orientation of Axis (direct or indirect)
        gives the orientation of the ellipse.
        Warnings :
        It is not forbidden to create an ellipse with MajorRadius =
        MinorRadius.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than MinorRadius, or
        - MinorRadius is less than 0.

        :type Axis: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _Geom2d.new_Geom2d_Ellipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetElips2d(self, *args):
        """
        SetElips2d(Geom2d_Ellipse self, gp_Elips2d E)

        Converts the gp_Elips2d ellipse E into this ellipse.

        :type E: OCC.wrapper.gp.gp_Elips2d

        """
        return _Geom2d.Geom2d_Ellipse_SetElips2d(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Geom2d_Ellipse self, Standard_Real const MajorRadius)

        Assigns a value to the major radius of this ellipse.
        Exceptions
        Standard_ConstructionError if:
        - the major radius of this ellipse becomes less than
        the minor radius, or
        - MinorRadius is less than 0.

        :type MajorRadius: float

        """
        return _Geom2d.Geom2d_Ellipse_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Geom2d_Ellipse self, Standard_Real const MinorRadius)

        Assigns a value to the minor radius of this ellipse.
        Exceptions
        Standard_ConstructionError if:
        - the major radius of this ellipse becomes less than
        the minor radius, or
        - MinorRadius is less than 0.

        :type MinorRadius: float

        """
        return _Geom2d.Geom2d_Ellipse_SetMinorRadius(self, *args)


    def Elips2d(self, *args):
        """
        Elips2d(Geom2d_Ellipse self) -> gp_Elips2d

        Converts this ellipse into a gp_Elips2d ellipse.

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Geom2d.Geom2d_Ellipse_Elips2d(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Ellipse self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed ellipse for
        the point of parameter U on this ellipse.
        For an ellipse, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_ReversedParameter(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Geom2d_Ellipse self) -> gp_Ax2d

        Computes the directrices of this ellipse.
        This directrix is the line normal to the XAxis of the ellipse
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the ellipse, where e is the eccentricity of
        the ellipse.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the "Location" point
        of the directrix1. This point is on the positive side of
        the "XAxis".
        Raises ConstructionError if Eccentricity = 0.0. (The ellipse degenerates
        into a circle)

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Ellipse_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Geom2d_Ellipse self) -> gp_Ax2d

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the ellipse.
        Raises ConstructionError if Eccentricity = 0.0. (The ellipse degenerates into a
        circle).

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Ellipse_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom2d_Ellipse self) -> Standard_Real

        Returns the eccentricity of the ellipse  between 0.0 and 1.0
        If f is the distance between the center of the ellipse and
        the Focus1 then the eccentricity e = f / MajorRadius.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Geom2d_Ellipse self) -> Standard_Real

        Computes the focal distance. The focal distance is the distance between the center
        and a focus of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Geom2d_Ellipse self) -> gp_Pnt2d

        Returns the first focus of the ellipse. This focus is on the
        positive side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Ellipse_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Geom2d_Ellipse self) -> gp_Pnt2d

        Returns the second focus of the ellipse. This focus is on
        the negative side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Ellipse_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Geom2d_Ellipse self) -> Standard_Real

        Returns the major radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Geom2d_Ellipse self) -> Standard_Real

        Returns the minor radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_MinorRadius(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom2d_Ellipse self) -> Standard_Real

        Computes the parameter of this ellipse. This value is
        given by the formula p = (1 - e * e) * MajorRadius where e is the eccentricity
        of the ellipse.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_Parameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_Ellipse self) -> Standard_Real

        Returns the value of the first parameter of this
        ellipse. This is  0.0, which gives the start point of this ellipse.
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_Ellipse self) -> Standard_Real

        Returns the value of the  last parameter of this
        ellipse. This is  2.*Pi, which gives the end point of this ellipse.
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Ellipse_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Ellipse_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Ellipse_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cos (U) * XDir + MinorRadius * Sin (U) * YDir
        where C is the center of the ellipse , XDir the direction of
        the "XAxis" and "YDir" the "YAxis" of the ellipse.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Ellipse_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Ellipse_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U. The vectors V1 and V2
        are the first and second derivatives at this point.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Ellipse_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Ellipse_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_Ellipse self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this ellipse,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Ellipse_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Ellipse self, gp_Trsf2d T)

        Applies the transformation T to this ellipse.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Ellipse_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Ellipse self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this ellipse.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Ellipse_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Ellipse_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Ellipse_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Ellipse_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Ellipse
Geom2d_Ellipse_swigregister = _Geom2d.Geom2d_Ellipse_swigregister
Geom2d_Ellipse_swigregister(Geom2d_Ellipse)

def Geom2d_Ellipse_get_type_name(*args):
    """
    Geom2d_Ellipse_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Ellipse_get_type_name(*args)

def Geom2d_Ellipse_get_type_descriptor(*args):
    """
    Geom2d_Ellipse_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Ellipse_get_type_descriptor(*args)

class Geom2d_Point(Geom2d_Geometry):
    """
    The abstract class Point describes the common
    behavior of geometric points in 2D space.
    The Geom2d package also provides the concrete
    class Geom2d_CartesianPoint.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Point
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Point(self) 
            return h


    def Coord(self, *args):
        """
        Coord(Geom2d_Point self)

        returns the Coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_Point_Coord(self, *args)


    def Pnt2d(self, *args):
        """
        Pnt2d(Geom2d_Point self) -> gp_Pnt2d

        returns a non persistent copy of <me>

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Point_Pnt2d(self, *args)


    def X(self, *args):
        """
        X(Geom2d_Point self) -> Standard_Real

        returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Point_X(self, *args)


    def Y(self, *args):
        """
        Y(Geom2d_Point self) -> Standard_Real

        returns  the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Point_Y(self, *args)


    def Distance(self, *args):
        """
        Distance(Geom2d_Point self, Handle_Geom2d_Point Other) -> Standard_Real

        computes the distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Point_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Geom2d_Point self, Handle_Geom2d_Point Other) -> Standard_Real

        computes the square distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Point_SquareDistance(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Point_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Point_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Point_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Point
Geom2d_Point_swigregister = _Geom2d.Geom2d_Point_swigregister
Geom2d_Point_swigregister(Geom2d_Point)

def Geom2d_Point_get_type_name(*args):
    """
    Geom2d_Point_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Point_get_type_name(*args)

def Geom2d_Point_get_type_descriptor(*args):
    """
    Geom2d_Point_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Point_get_type_descriptor(*args)

class Geom2d_BoundedCurve(Geom2d_Curve):
    """
    The abstract class BoundedCurve describes the
    common behavior of bounded curves in 2D space. A
    bounded curve is limited by two finite values of the
    parameter, termed respectively "first parameter" and
    "last parameter". The "first parameter" gives the "start
    point" of the bounded curve, and the "last parameter"
    gives the "end point" of the bounded curve.
    The length of a bounded curve is finite.
    The Geom2d package provides three concrete
    classes of bounded curves:
    - two frequently used mathematical formulations of complex curves:
    - Geom2d_BezierCurve,
    - Geom2d_BSplineCurve, and
    - Geom2d_TrimmedCurve to trim a curve, i.e. to
    only take part of the curve limited by two values of
    the parameter of the basis curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_BoundedCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_BoundedCurve(self) 
            return h


    def EndPoint(self, *args):
        """
        EndPoint(Geom2d_BoundedCurve self) -> gp_Pnt2d

        Returns the end point of the curve.
        The end point is the value of the curve for the
        "LastParameter" of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BoundedCurve_EndPoint(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Geom2d_BoundedCurve self) -> gp_Pnt2d

        Returns the start point of the curve.
        The start point is the value of the curve for the
        "FirstParameter" of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BoundedCurve_StartPoint(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_BoundedCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_BoundedCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_BoundedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_BoundedCurve
Geom2d_BoundedCurve_swigregister = _Geom2d.Geom2d_BoundedCurve_swigregister
Geom2d_BoundedCurve_swigregister(Geom2d_BoundedCurve)

def Geom2d_BoundedCurve_get_type_name(*args):
    """
    Geom2d_BoundedCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_BoundedCurve_get_type_name(*args)

def Geom2d_BoundedCurve_get_type_descriptor(*args):
    """
    Geom2d_BoundedCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_BoundedCurve_get_type_descriptor(*args)

class Geom2d_UndefinedDerivative(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_UndefinedDerivative
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_UndefinedDerivative(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_UndefinedDerivative self) -> Geom2d_UndefinedDerivative
        __init__(Geom2d_UndefinedDerivative self, Standard_CString const theMessage) -> Geom2d_UndefinedDerivative

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Geom2d.new_Geom2d_UndefinedDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Geom2d_UndefinedDerivative

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_UndefinedDerivative

        """
        return _Geom2d.Geom2d_UndefinedDerivative_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_UndefinedDerivative_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_UndefinedDerivative_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_UndefinedDerivative_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_UndefinedDerivative
Geom2d_UndefinedDerivative_swigregister = _Geom2d.Geom2d_UndefinedDerivative_swigregister
Geom2d_UndefinedDerivative_swigregister(Geom2d_UndefinedDerivative)

def Geom2d_UndefinedDerivative_NewInstance(*args):
    """
    Geom2d_UndefinedDerivative_NewInstance(Standard_CString const theMessage) -> Handle_Geom2d_UndefinedDerivative

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_UndefinedDerivative

    """
    return _Geom2d.Geom2d_UndefinedDerivative_NewInstance(*args)

def Geom2d_UndefinedDerivative_get_type_name(*args):
    """
    Geom2d_UndefinedDerivative_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_UndefinedDerivative_get_type_name(*args)

def Geom2d_UndefinedDerivative_get_type_descriptor(*args):
    """
    Geom2d_UndefinedDerivative_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_UndefinedDerivative_get_type_descriptor(*args)

class Geom2d_BezierCurve(Geom2d_BoundedCurve):
    """
    Describes a rational or non-rational Bezier curve
    - a non-rational Bezier curve is defined by a table
    of poles (also called control points),
    - a rational Bezier curve is defined by a table of
    poles with varying weights.
    These data are manipulated by two parallel arrays:
    - the poles table, which is an array of gp_Pnt2d points, and
    - the weights table, which is an array of reals.
    The bounds of these arrays are 1 and "the number of poles" of the curve.
    The poles of the curve are "control points" used to deform the curve.
    The first pole is the start point of the curve, and the
    last pole is the end point of the curve. The segment
    which joins the first pole to the second pole is the
    tangent to the curve at its start point, and the
    segment which joins the last pole to the
    second-from-last pole is the tangent to the curve
    at its end point.
    It is more difficult to give a geometric signification
    to the weights but they are useful for providing
    exact representations of the arcs of a circle or
    ellipse. Moreover, if the weights of all the poles are
    equal, the curve is polynomial; it is therefore a
    non-rational curve. The non-rational curve is a
    special and frequently used case. The weights are
    defined and used only in case of a rational curve.
    The degree of a Bezier curve is equal to the
    number of poles, minus 1. It must be greater than or
    equal to 1. However, the degree of a
    Geom2d_BezierCurve curve is limited to a value
    (25) which is defined and controlled by the system.
    This value is returned by the function MaxDegree.
    The parameter range for a Bezier curve is [ 0, 1 ].
    If the first and last control points of the Bezier
    curve are the same point then the curve is closed.
    For example, to create a closed Bezier curve with
    four control points, you have to give a set of control
    points P1, P2, P3 and P1.
    The continuity of a Bezier curve is infinite.
    It is not possible to build a Bezier curve with
    negative weights. We consider that a weight value
    is zero if it is less than or equal to
    gp::Resolution(). We also consider that
    two weight values W1 and W2 are equal if:
    |W2 - W1| <= gp::Resolution().
    Warning
    - When considering the continuity of a closed
    Bezier curve at the junction point, remember that
    a curve of this type is never periodic. This means
    that the derivatives for the parameter u = 0
    have no reason to be the same as the
    derivatives for the parameter u = 1 even if the curve is closed.
    - The length of a Bezier curve can be null.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_BezierCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_BezierCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_BezierCurve self, NCollection_Array1_gp_Pnt2d CurvePoles) -> Geom2d_BezierCurve
        __init__(Geom2d_BezierCurve self, NCollection_Array1_gp_Pnt2d CurvePoles, NCollection_Array1_Standard_Real PoleWeights) -> Geom2d_BezierCurve

        Creates a rational Bezier curve with the set of poles
        CurvePoles and the set of weights  PoleWeights .
        If all the weights are identical the curve is considered
        as non rational.  Raises ConstructionError if
        the number of poles is greater than  MaxDegree + 1 or lower
        than 2 or CurvePoles and CurveWeights have not the same length
        or one weight value is lower or equal to Resolution from
        package gp.

        :type CurvePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type PoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _Geom2d.new_Geom2d_BezierCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Increase(self, *args):
        """
        Increase(Geom2d_BezierCurve self, Standard_Integer const Degree)

        Increases the degree of a bezier curve. Degree is the new
        degree of <me>.
        raises ConstructionError if Degree is greater than MaxDegree or lower than 2
        or lower than the initial degree of <me>.

        :type Degree: int

        """
        return _Geom2d.Geom2d_BezierCurve_Increase(self, *args)


    def InsertPoleAfter(self, *args):
        """
        InsertPoleAfter(Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        Inserts a pole with its weight in the set of poles after the
        pole of range Index. If the curve was non rational it can
        become rational if all the weights are not identical.
        Raised if Index is not in the range [0, NbPoles]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Geom2d_BezierCurve_InsertPoleAfter(self, *args)


    def InsertPoleBefore(self, *args):
        """
        InsertPoleBefore(Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        Inserts a pole with its weight in the set of poles after
        the pole of range Index. If the curve was non rational it
        can become rational if all the weights are not identical.
        Raised if Index is not in the range [1, NbPoles+1]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Geom2d_BezierCurve_InsertPoleBefore(self, *args)


    def RemovePole(self, *args):
        """
        RemovePole(Geom2d_BezierCurve self, Standard_Integer const Index)

        Removes the pole of range Index.
        If the curve was rational it can become non rational.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int

        """
        return _Geom2d.Geom2d_BezierCurve_RemovePole(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Geom2d_BezierCurve self)

        Reverses the direction of parametrization of <me>
        Value (NewU) =  Value (1 - OldU)


        """
        return _Geom2d.Geom2d_BezierCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_BezierCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns 1-U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BezierCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom2d_BezierCurve self, Standard_Real const U1, Standard_Real const U2)

        Segments the curve between U1 and U2 which can be out
        of the bounds of the curve. The curve is oriented from U1
        to U2.
        The control points are modified, the first and the last point
        are not the same but the parametrization range is [0, 1]
        else it could not be a Bezier curve.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.

        :type U1: float
        :type U2: float

        """
        return _Geom2d.Geom2d_BezierCurve_Segment(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P)
        SetPole(Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight)

        Substitutes the pole and the weights of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Geom2d_BezierCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Geom2d_BezierCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight of the pole of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type Weight: float

        """
        return _Geom2d.Geom2d_BezierCurve_SetWeight(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_BezierCurve self) -> Standard_Boolean

        Returns True if the distance between the first point
        and the last point of the curve is lower or equal to
        the Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BezierCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_BezierCurve self, Standard_Integer const N) -> Standard_Boolean

        Continuity of the curve, returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BezierCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_BezierCurve self) -> Standard_Boolean

        Returns False. A BezierCurve cannot be periodic in this
        package

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BezierCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Geom2d_BezierCurve self) -> Standard_Boolean

        Returns false if all the weights are identical. The tolerance
        criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BezierCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_BezierCurve self) -> GeomAbs_Shape

        Returns GeomAbs_CN, which is the continuity of any Bezier curve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_BezierCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Geom2d_BezierCurve self) -> Standard_Integer

        Returns the polynomial degree of the curve. It is the number
        of poles less one.  In this package the Degree of a Bezier
        curve cannot be greater than "MaxDegree".

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BezierCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BezierCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BezierCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BezierCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BezierCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_BezierCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For this Bezier curve, computes
        - the point P of parameter U, or
        - the point P and one or more of the following values:
        - V1, the first derivative vector,
        - V2, the second derivative vector,
        - V3, the third derivative vector.
        Note: the parameter U can be outside the bounds of the curve.
        Raises RangeError if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BezierCurve_DN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Geom2d_BezierCurve self) -> gp_Pnt2d

        Returns the end point or start point of this Bezier curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BezierCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_BezierCurve self) -> Standard_Real

        Returns the value of the first  parameter of this
        Bezier curve. This is  0.0, which gives the start point of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BezierCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_BezierCurve self) -> Standard_Real

        Returns the value of the last  parameter of this
        Bezier curve. This is  1.0, which gives the end point of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BezierCurve_LastParameter(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Geom2d_BezierCurve self) -> Standard_Integer

        Returns the number of poles for this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BezierCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Geom2d.Geom2d_BezierCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns all the poles of the curve.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Geom2d.Geom2d_BezierCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPoint(self, *args):
        """
        StartPoint(Geom2d_BezierCurve self) -> gp_Pnt2d

        Returns Value (U=1), it is the first control point
        of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BezierCurve_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Geom2d_BezierCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BezierCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Geom2d_BezierCurve self, NCollection_Array1_Standard_Real W)
        Weights(Geom2d_BezierCurve self) -> NCollection_Array1_Standard_Real

        Returns all the weights of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2d.Geom2d_BezierCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_BezierCurve self, gp_Trsf2d T)

        Applies the transformation T to this Bezier curve.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_BezierCurve_Transform(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum polynomial degree of a
        BezierCurve. This value is 25.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BezierCurve_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def Resolution(self, *args):
        """
        Resolution(Geom2d_BezierCurve self, Standard_Real const ToleranceUV)

        Computes for this Bezier curve the parametric
        tolerance UTolerance for a given tolerance
        Tolerance3D (relative to dimensions in the plane).
        If f(t) is the equation of this Bezier curve,
        UTolerance ensures that
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < ToleranceUV

        :type ToleranceUV: float
        :type UTolerance: float

        """
        return _Geom2d.Geom2d_BezierCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_BezierCurve self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this Bezier curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_BezierCurve_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_BezierCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_BezierCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_BezierCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_BezierCurve
Geom2d_BezierCurve_swigregister = _Geom2d.Geom2d_BezierCurve_swigregister
Geom2d_BezierCurve_swigregister(Geom2d_BezierCurve)

def Geom2d_BezierCurve_MaxDegree(*args):
    """
    Geom2d_BezierCurve_MaxDegree() -> Standard_Integer

    Returns the value of the maximum polynomial degree of a
    BezierCurve. This value is 25.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom2d.Geom2d_BezierCurve_MaxDegree(*args)

def Geom2d_BezierCurve_get_type_name(*args):
    """
    Geom2d_BezierCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_BezierCurve_get_type_name(*args)

def Geom2d_BezierCurve_get_type_descriptor(*args):
    """
    Geom2d_BezierCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_BezierCurve_get_type_descriptor(*args)

class Geom2d_OffsetCurve(Geom2d_Curve):
    """
    This class implements the basis services for the creation,
    edition, modification and evaluation of planar offset curve.
    The offset curve is obtained by offsetting by distance along
    the normal to a basis curve defined in 2D space.
    The offset curve in this package can be a self intersecting
    curve even if the basis curve does not self-intersect.
    The self intersecting portions are not deleted at the
    construction time.
    An offset curve is a curve at constant distance (Offset) from a
    basis curve and the offset curve takes its parametrization from
    the basis curve. The Offset curve is in the direction of the
    normal to the basis curve N.
    The distance offset may be positive or negative to indicate the
    preferred side of the curve :
    . distance offset >0 => the curve is in the direction of N
    . distance offset >0 => the curve is in the direction of - N
    On the Offset curve :
    Value(u) = BasisCurve.Value(U) + (Offset * (T ^ Z)) / ||T ^ Z||
    where T is the tangent vector to the basis curve and Z the
    direction of the normal vector to the plane of the curve,
    N = T ^ Z defines the offset direction and should not have
    null length.

    Warnings :
    In this package we suppose that the continuity of the offset
    curve is one degree less than the continuity of the
    basis curve and we don't check that at any point ||T^Z|| != 0.0

    So to evaluate the curve it is better to check that the offset
    curve is well defined at any point because an exception could
    be raised. The check is not done in this package at the creation
    of the offset curve because the control needs the use of an
    algorithm which cannot be implemented in this package.
    The OffsetCurve is closed if the first point and the last point
    are the same (The distance between these two points is lower or
    equal to the Resolution sea package gp) . The OffsetCurve can be
    closed even if the basis curve is not closed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_OffsetCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_OffsetCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_OffsetCurve self, Handle_Geom2d_Curve C, Standard_Real const Offset, Standard_Boolean const isNotCheckC0) -> Geom2d_OffsetCurve

        Constructs a curve offset from the basis curve C,
        where Offset is the distance between the offset
        curve and the basis curve at any point.
        A point on the offset curve is built by measuring the
        offset value along a normal vector at a point on C.
        This normal vector is obtained by rotating the
        vector tangential to C at 90 degrees in the
        anti-trigonometric sense. The side of C on which
        the offset value is measured is indicated by this
        normal vector if Offset is positive, or in the inverse
        sense if Offset is negative.
        If isNotCheckC0 = TRUE checking if basis curve has C0-continuity
        is not made.
        Warnings :
        In this package the entities are not shared. The OffsetCurve is
        built with a copy of the curve C. So when C is modified the
        OffsetCurve is not modified
        Warning!  if isNotCheckC0 = false,
        ConstructionError  raised if the basis curve C is not at least C1.
        No check is done to know if ||V^Z|| != 0.0 at any point.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Offset: float
        :type isNotCheckC0: bool

        """
        this = _Geom2d.new_Geom2d_OffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """
        Reverse(Geom2d_OffsetCurve self)

        Changes the direction of parametrization of <me>.
        As a result:
        - the basis curve is reversed,
        - the start point of the initial curve becomes the end
        point of the reversed curve,
        - the end point of the initial curve becomes the start
        point of the reversed curve, and
        - the first and last parameters are recomputed.


        """
        return _Geom2d.Geom2d_OffsetCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_OffsetCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this offset curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_ReversedParameter(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Geom2d_OffsetCurve self, Handle_Geom2d_Curve C, Standard_Boolean const isNotCheckC0)

        Changes this offset curve by assigning C as the
        basis curve from which it is built.
        If isNotCheckC0 = TRUE checking if basis curve has C0-continuity
        is not made.
        Exceptions
        if isNotCheckC0 = false,
        Standard_ConstructionError if the curve C is not at least "C1" continuous.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type isNotCheckC0: bool

        """
        return _Geom2d.Geom2d_OffsetCurve_SetBasisCurve(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(Geom2d_OffsetCurve self, Standard_Real const D)

        Changes this offset curve by assigning D as the offset value.

        :type D: float

        """
        return _Geom2d.Geom2d_OffsetCurve_SetOffsetValue(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Geom2d_OffsetCurve self) -> Handle_Geom2d_Curve

        Returns the basis curve of this offset curve. The basis curve can be an offset curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Geom2d_OffsetCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_OffsetCurve self) -> GeomAbs_Shape

        Continuity of the Offset curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.
        Warnings :
        Returns the continuity of the basis curve - 1.
        The offset curve must have a unique normal direction defined
        at any point.
        Value and derivatives

        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.
        If T is the first derivative with not null length and
        Z the direction normal to the plane of the curve, the
        relation ||T(U) ^ Z|| != 0  must be satisfied to evaluate
        the offset curve.
        No check is done at the creation time and we suppose
        in this package that the offset curve is well defined.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_OffsetCurve_Continuity(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P)

        Warning! this should not be called
        if the basis curve is not at least C1. Nevertheless
        if used on portion where the curve is C1, it is OK

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_OffsetCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Warning! this should not be called
        if the continuity of the basis curve is not C2.
        Nevertheless, it's OK to use it  on portion
        where the curve is C2

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_OffsetCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Warning!  This  should  not  be called
        if the continuity of the basis curve is not C3.
        Nevertheless, it's OK to use it  on portion
        where the curve is C3

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_OffsetCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Warning! This should not be called
        if the continuity of the basis curve is not C4.
        Nevertheless, it's OK to use it  on portion
        where the curve is C4

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_OffsetCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_OffsetCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative
        for the order of derivation N.
        Warning! this should not be called
        raises  UndefunedDerivative   if the continuity of the basis curve is not CN+1.
        Nevertheless, it's OK to use it  on portion
        where the curve is CN+1
        raises  RangeError if N < 1.
        raises  NotImplemented if N > 3.
        The following functions compute the value and derivatives
        on the offset curve and returns the derivatives on the
        basis curve too.
        The computation of the value and derivatives on the basis
        curve are used to evaluate the offset curve
        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset direction.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_OffsetCurve_DN(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_OffsetCurve self) -> Standard_Real

        Returns the value of the first parameter of this
        offset curve. The first parameter corresponds to the
        start point of the curve.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_OffsetCurve self) -> Standard_Real

        Returns the value of the last parameter of this
        offset curve. The last parameter
        corresponds to the end point.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_LastParameter(self, *args)


    def Offset(self, *args):
        """
        Offset(Geom2d_OffsetCurve self) -> Standard_Real

        Returns the offset value of this offset curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_Offset(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_OffsetCurve self) -> Standard_Boolean

        Returns True if the distance between the start point
        and the end point of the curve is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_OffsetCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_OffsetCurve self, Standard_Integer const N) -> Standard_Boolean

        Is the order of continuity of the curve N ?
        Warnings :
        This method answer True if the continuity of the basis curve
        is N + 1.  We suppose in this class that a normal direction
        to the basis curve (used to compute the offset curve) is
        defined at any point on the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_OffsetCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_OffsetCurve self) -> Standard_Boolean

        Is the parametrization of a curve is periodic ?
        If the basis curve is a circle or an ellipse the corresponding
        OffsetCurve is periodic. If the basis curve can't be periodic
        (for example BezierCurve) the OffsetCurve can't be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_OffsetCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Geom2d_OffsetCurve self) -> Standard_Real

        Returns the period of this offset curve, i.e. the period
        of the basis curve of this offset curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_Period(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_OffsetCurve self, gp_Trsf2d T)

        Applies the transformation T to this offset curve.
        Note: the basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_OffsetCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom2d_OffsetCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom2d_OffsetCurve self, gp_Trsf2d T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_OffsetCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_OffsetCurve self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this offset curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_OffsetCurve_Copy(self, *args)


    def GetBasisCurveContinuity(self, *args):
        """
        GetBasisCurveContinuity(Geom2d_OffsetCurve self) -> GeomAbs_Shape

        Returns continuity of the basis curve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_OffsetCurve_GetBasisCurveContinuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_OffsetCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_OffsetCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_OffsetCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_OffsetCurve
Geom2d_OffsetCurve_swigregister = _Geom2d.Geom2d_OffsetCurve_swigregister
Geom2d_OffsetCurve_swigregister(Geom2d_OffsetCurve)

def Geom2d_OffsetCurve_get_type_name(*args):
    """
    Geom2d_OffsetCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_OffsetCurve_get_type_name(*args)

def Geom2d_OffsetCurve_get_type_descriptor(*args):
    """
    Geom2d_OffsetCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_OffsetCurve_get_type_descriptor(*args)

class Geom2d_Parabola(Geom2d_Conic):
    """
    Describes a parabola in the plane (2D space).
    A parabola is defined by its focal length (i.e. the
    distance between its focus and its apex) and is
    positioned in the plane with a coordinate system
    (gp_Ax22d object) where:
    - the origin is the apex of the parabola, and
    - the "X Axis" defines the axis of symmetry; the
    parabola is on the positive side of this axis.
    This coordinate system is the local coordinate
    system of the parabola.
    The orientation (direct or indirect) of the local
    coordinate system gives an explicit orientation to the
    parabola, determining the direction in which the
    parameter increases along the parabola.
    The Geom_Parabola parabola is parameterized as follows:
    P(U) = O + U*U/(4.*F)*XDir + U*YDir, where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - F is the focal length of the parabola.
    The parameter of the parabola is therefore its Y
    coordinate in the local coordinate system, with the "X
    Axis" of the local coordinate system defining the
    origin of the parameter.
    The parameter range is ] -infinite,+infinite [.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Parabola
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Parabola(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Parabola self, gp_Parab2d Prb) -> Geom2d_Parabola
        __init__(Geom2d_Parabola self, gp_Ax2d MirrorAxis, Standard_Real const Focal, Standard_Boolean const Sense) -> Geom2d_Parabola
        __init__(Geom2d_Parabola self, gp_Ax22d Axis, Standard_Real const Focal) -> Geom2d_Parabola
        __init__(Geom2d_Parabola self, gp_Ax2d D, gp_Pnt2d F) -> Geom2d_Parabola

        D is the directrix of the parabola and F the focus point.
        The symmetry axis "XAxis" of the parabola is normal to the
        directrix and pass through the focus point F, but its
        "Location" point is the vertex of the parabola.
        The "YAxis" of the parabola is parallel to D and its "Location"
        point is the vertex of the parabola.

        :type D: OCC.wrapper.gp.gp_Ax2d
        :type F: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _Geom2d.new_Geom2d_Parabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetFocal(self, *args):
        """
        SetFocal(Geom2d_Parabola self, Standard_Real const Focal)

        Assigns the value Focal to the focal length of this parabola.
        Exceptions Standard_ConstructionError if Focal is negative.

        :type Focal: float

        """
        return _Geom2d.Geom2d_Parabola_SetFocal(self, *args)


    def SetParab2d(self, *args):
        """
        SetParab2d(Geom2d_Parabola self, gp_Parab2d Prb)

        Converts the gp_Parab2d parabola Prb into this parabola.

        :type Prb: OCC.wrapper.gp.gp_Parab2d

        """
        return _Geom2d.Geom2d_Parabola_SetParab2d(self, *args)


    def Parab2d(self, *args):
        """
        Parab2d(Geom2d_Parabola self) -> gp_Parab2d

        Returns the non persistent parabola from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Geom2d.Geom2d_Parabola_Parab2d(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Parabola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed parabola
        for the point of parameter U on this parabola.
        For a parabola, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_Parabola self) -> Standard_Real

        Returns RealFirst from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_Parabola self) -> Standard_Real

        Returns  RealLast from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Parabola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Parabola_IsPeriodic(self, *args)


    def Directrix(self, *args):
        """
        Directrix(Geom2d_Parabola self) -> gp_Ax2d

        The directrix is parallel to the "YAxis" of the parabola.
        The "Location" point of the directrix is the intersection
        point between the directrix and the symmetry axis ("XAxis") of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Parabola_Directrix(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom2d_Parabola self) -> Standard_Real

        Returns the eccentricity e = 1.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_Eccentricity(self, *args)


    def Focus(self, *args):
        """
        Focus(Geom2d_Parabola self) -> gp_Pnt2d

        Computes the focus of this parabola The focus is on the
        positive side of the "X Axis" of the local coordinate system of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Parabola_Focus(self, *args)


    def Focal(self, *args):
        """
        Focal(Geom2d_Parabola self) -> Standard_Real

        Computes the focal length of this parabola.
        The focal length is the distance between the apex and the focus of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_Focal(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom2d_Parabola self) -> Standard_Real

        Computes the parameter of this parabola, which is
        the distance between its focus and its directrix. This
        distance is twice the focal length.
        If P is the parameter of the parabola, the equation of
        the parabola in its local coordinate system is: Y**2 = 2.*P*X.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If U = 0 the returned point is the origin of the XAxis and
        the YAxis of the parabola and it is the vertex of the parabola.
        P = S + F * (U * U * XDir +  * U * YDir)
        where S is the vertex of the parabola, XDir the XDirection and
        YDir the YDirection of the parabola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Parabola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Parabola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Parabola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Parabola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_Parabola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this parabola,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Parabola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Parabola self, gp_Trsf2d T)

        Applies the transformation T to this parabola.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Parabola_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom2d_Parabola self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the transformed
        parabola, for the point of parameter U on this parabola.
        For a parabola, the returned value is equal to U
        multiplied by the scale factor of transformation T.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom2d_Parabola self, gp_Trsf2d T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Parabola_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Parabola self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this parabola.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Parabola_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Parabola_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Parabola_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Parabola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Parabola
Geom2d_Parabola_swigregister = _Geom2d.Geom2d_Parabola_swigregister
Geom2d_Parabola_swigregister(Geom2d_Parabola)

def Geom2d_Parabola_get_type_name(*args):
    """
    Geom2d_Parabola_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Parabola_get_type_name(*args)

def Geom2d_Parabola_get_type_descriptor(*args):
    """
    Geom2d_Parabola_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Parabola_get_type_descriptor(*args)

class Handle_Geom2d_OffsetCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_OffsetCurve self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_OffsetCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_OffsetCurve self, Geom2d_OffsetCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_OffsetCurve self, Handle_Geom2d_OffsetCurve theHandle) -> Handle_Geom2d_OffsetCurve
        assign(Handle_Geom2d_OffsetCurve self, Geom2d_OffsetCurve thePtr) -> Handle_Geom2d_OffsetCurve
        assign(Handle_Geom2d_OffsetCurve self, Handle_Geom2d_OffsetCurve theHandle) -> Handle_Geom2d_OffsetCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_OffsetCurve self) -> Geom2d_OffsetCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_OffsetCurve self) -> Geom2d_OffsetCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_OffsetCurve self) -> Geom2d_OffsetCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_OffsetCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_OffsetCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_OffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_OffsetCurve_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_OffsetCurve

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_OffsetCurve self)

        Changes the direction of parametrization of <me>.
        As a result:
        - the basis curve is reversed,
        - the start point of the initial curve becomes the end
        point of the reversed curve,
        - the end point of the initial curve becomes the start
        point of the reversed curve, and
        - the first and last parameters are recomputed.


        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_OffsetCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this offset curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_ReversedParameter(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Handle_Geom2d_OffsetCurve self, Handle_Geom2d_Curve C, Standard_Boolean const isNotCheckC0)

        Changes this offset curve by assigning C as the
        basis curve from which it is built.
        If isNotCheckC0 = TRUE checking if basis curve has C0-continuity
        is not made.
        Exceptions
        if isNotCheckC0 = false,
        Standard_ConstructionError if the curve C is not at least "C1" continuous.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type isNotCheckC0: bool

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_SetBasisCurve(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(Handle_Geom2d_OffsetCurve self, Standard_Real const D)

        Changes this offset curve by assigning D as the offset value.

        :type D: float

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_SetOffsetValue(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom2d_OffsetCurve self) -> Handle_Geom2d_Curve

        Returns the basis curve of this offset curve. The basis curve can be an offset curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_OffsetCurve self) -> GeomAbs_Shape

        Continuity of the Offset curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.
        Warnings :
        Returns the continuity of the basis curve - 1.
        The offset curve must have a unique normal direction defined
        at any point.
        Value and derivatives

        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.
        If T is the first derivative with not null length and
        Z the direction normal to the plane of the curve, the
        relation ||T(U) ^ Z|| != 0  must be satisfied to evaluate
        the offset curve.
        No check is done at the creation time and we suppose
        in this package that the offset curve is well defined.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Continuity(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P)

        Warning! this should not be called
        if the basis curve is not at least C1. Nevertheless
        if used on portion where the curve is C1, it is OK

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Warning! this should not be called
        if the continuity of the basis curve is not C2.
        Nevertheless, it's OK to use it  on portion
        where the curve is C2

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Warning!  This  should  not  be called
        if the continuity of the basis curve is not C3.
        Nevertheless, it's OK to use it  on portion
        where the curve is C3

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Warning! This should not be called
        if the continuity of the basis curve is not C4.
        Nevertheless, it's OK to use it  on portion
        where the curve is C4

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_OffsetCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative
        for the order of derivation N.
        Warning! this should not be called
        raises  UndefunedDerivative   if the continuity of the basis curve is not CN+1.
        Nevertheless, it's OK to use it  on portion
        where the curve is CN+1
        raises  RangeError if N < 1.
        raises  NotImplemented if N > 3.
        The following functions compute the value and derivatives
        on the offset curve and returns the derivatives on the
        basis curve too.
        The computation of the value and derivatives on the basis
        curve are used to evaluate the offset curve
        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset direction.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_DN(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_OffsetCurve self) -> Standard_Real

        Returns the value of the first parameter of this
        offset curve. The first parameter corresponds to the
        start point of the curve.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_OffsetCurve self) -> Standard_Real

        Returns the value of the last parameter of this
        offset curve. The last parameter
        corresponds to the end point.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_LastParameter(self, *args)


    def Offset(self, *args):
        """
        Offset(Handle_Geom2d_OffsetCurve self) -> Standard_Real

        Returns the offset value of this offset curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Offset(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_OffsetCurve self) -> Standard_Boolean

        Returns True if the distance between the start point
        and the end point of the curve is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_OffsetCurve self, Standard_Integer const N) -> Standard_Boolean

        Is the order of continuity of the curve N ?
        Warnings :
        This method answer True if the continuity of the basis curve
        is N + 1.  We suppose in this class that a normal direction
        to the basis curve (used to compute the offset curve) is
        defined at any point on the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_OffsetCurve self) -> Standard_Boolean

        Is the parametrization of a curve is periodic ?
        If the basis curve is a circle or an ellipse the corresponding
        OffsetCurve is periodic. If the basis curve can't be periodic
        (for example BezierCurve) the OffsetCurve can't be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_OffsetCurve self) -> Standard_Real

        Returns the period of this offset curve, i.e. the period
        of the basis curve of this offset curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Period(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_OffsetCurve self, gp_Trsf2d T)

        Applies the transformation T to this offset curve.
        Note: the basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_OffsetCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_OffsetCurve self, gp_Trsf2d T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_OffsetCurve self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this offset curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Copy(self, *args)


    def GetBasisCurveContinuity(self, *args):
        """
        GetBasisCurveContinuity(Handle_Geom2d_OffsetCurve self) -> GeomAbs_Shape

        Returns continuity of the basis curve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_GetBasisCurveContinuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_OffsetCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_OffsetCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_OffsetCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_OffsetCurve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Reversed(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_OffsetCurve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_OffsetCurve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_OffsetCurve self, gp_Vec2d V)
        Translate(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_OffsetCurve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_OffsetCurve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_OffsetCurve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_OffsetCurve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_OffsetCurve self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_OffsetCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_OffsetCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_OffsetCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_OffsetCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_OffsetCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_OffsetCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_OffsetCurve self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_OffsetCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_OffsetCurve_DecrementRefCounter(self, *args)

Handle_Geom2d_OffsetCurve_swigregister = _Geom2d.Handle_Geom2d_OffsetCurve_swigregister
Handle_Geom2d_OffsetCurve_swigregister(Handle_Geom2d_OffsetCurve)

def Handle_Geom2d_OffsetCurve_DownCast(thing):
    return _Geom2d.Handle_Geom2d_OffsetCurve_DownCast(thing)
Handle_Geom2d_OffsetCurve_DownCast = _Geom2d.Handle_Geom2d_OffsetCurve_DownCast

class Geom2d_Hyperbola(Geom2d_Conic):
    """
    Describes a branch of a hyperbola in the plane (2D space).
    A hyperbola is defined by its major and minor radii
    and, as with any conic curve, is positioned in the
    plane with a coordinate system (gp_Ax22d object) where:
    - the origin is the center of the hyperbola,
    - the "X Direction" defines the major axis, and
    - the "Y Direction" defines the minor axis.
    This coordinate system is the local coordinate
    system of the hyperbola.
    The branch of the hyperbola described is the one
    located on the positive side of the major axis.
    The orientation (direct or indirect) of the local
    coordinate system gives an explicit orientation to the
    hyperbola, determining the direction in which the
    parameter increases along the hyperbola.
    The Geom2d_Hyperbola hyperbola is parameterized as follows:
    P(U) = O + MajRad*Cosh(U)*XDir + MinRad*Sinh(U)*YDir
    where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - MajRad and MinRad are the major and minor radii of the hyperbola.
    The "X Axis" of the local coordinate system therefore
    defines the origin of the parameter of the hyperbola.
    The parameter range is ] -infinite,+infinite [.
    The following diagram illustrates the respective
    positions, in the plane of the hyperbola, of the three
    branches of hyperbolas constructed using the
    functions OtherBranch, ConjugateBranch1 and
    ConjugateBranch2:
    ^YAxis
    |
    FirstConjugateBranch
    |
    Other         |          Main
    --------------------- C
    --------------------->XAxis
    Branch       |
    Branch
    |
    SecondConjugateBranch
    |
    Warning
    The value of the major radius (on the major axis) can
    be less than the value of the minor radius (on the minor axis).
    See Also
    GCE2d_MakeHyperbola which provides functions for
    more complex hyperbola constructions
    gp_Ax22d
    gp_Hypr2d for an equivalent, non-parameterized data structure
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Hyperbola
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Hyperbola(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Hyperbola self, gp_Hypr2d H) -> Geom2d_Hyperbola
        __init__(Geom2d_Hyperbola self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> Geom2d_Hyperbola
        __init__(Geom2d_Hyperbola self, gp_Ax22d Axis, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> Geom2d_Hyperbola

        The XDirection of "Axis" is the "XAxis" of the hyperbola and
        the YDirection of "Axis" is the "YAxis".
        The major radius of the hyperbola is on this "XAxis" and
        the minor radius is on the "YAxis" of the hyperbola.
        Raised if MajorRadius < 0.0 or if MinorRadius < 0.0

        :type Axis: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _Geom2d.new_Geom2d_Hyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetHypr2d(self, *args):
        """
        SetHypr2d(Geom2d_Hyperbola self, gp_Hypr2d H)

        Converts the gp_Hypr2d hyperbola H into this hyperbola.

        :type H: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Geom2d_Hyperbola_SetHypr2d(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Geom2d_Hyperbola self, Standard_Real const MajorRadius)

        Assigns a value to the major or minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0,
        - MinorRadius is less than 0.0.

        :type MajorRadius: float

        """
        return _Geom2d.Geom2d_Hyperbola_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Geom2d_Hyperbola self, Standard_Real const MinorRadius)

        Assigns a value to the major or minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0,
        - MinorRadius is less than 0.0.

        :type MinorRadius: float

        """
        return _Geom2d.Geom2d_Hyperbola_SetMinorRadius(self, *args)


    def Hypr2d(self, *args):
        """
        Hypr2d(Geom2d_Hyperbola self) -> gp_Hypr2d

        Converts this hyperbola into a gp_Hypr2d one.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Geom2d_Hyperbola_Hypr2d(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Hyperbola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed hyperbola,
        for the point of parameter U on this hyperbola.
        For a hyperbola, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_Hyperbola self) -> Standard_Real

        Returns RealFirst from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_Hyperbola self) -> Standard_Real

        returns RealLast from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_Hyperbola self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Hyperbola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_Hyperbola self) -> Standard_Boolean

        return False for an hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Hyperbola_IsPeriodic(self, *args)


    def Asymptote1(self, *args):
        """
        Asymptote1(Geom2d_Hyperbola self) -> gp_Ax2d

        In the local coordinate system of the hyperbola the
        equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0
        and the equation of the first asymptote is Y = (B/A)*X
        where A is the major radius of the hyperbola and B is the
        minor radius of the hyperbola.
        Raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Hyperbola_Asymptote1(self, *args)


    def Asymptote2(self, *args):
        """
        Asymptote2(Geom2d_Hyperbola self) -> gp_Ax2d

        In the local coordinate system of the hyperbola the
        equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0
        and the equation of the first asymptote is Y = -(B/A)*X.
        where A is the major radius of the hyperbola and B is the
        minor radius of the hyperbola.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Hyperbola_Asymptote2(self, *args)


    def ConjugateBranch1(self, *args):
        """
        ConjugateBranch1(Geom2d_Hyperbola self) -> gp_Hypr2d

        Computes the first conjugate branch relative to this hyperbola.
        Note: The diagram given under the class purpose
        indicates where these two branches of hyperbola are
        positioned in relation to this branch of hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Geom2d_Hyperbola_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args):
        """
        ConjugateBranch2(Geom2d_Hyperbola self) -> gp_Hypr2d

        Computes the second conjugate branch relative to this hyperbola.
        Note: The diagram given under the class purpose
        indicates where these two branches of hyperbola are
        positioned in relation to this branch of hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Geom2d_Hyperbola_ConjugateBranch2(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Geom2d_Hyperbola self) -> gp_Ax2d

        This directrix is the line normal to the XAxis of the hyperbola
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the hyperbola, where e is the eccentricity of
        the hyperbola.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the location point of the
        directrix1. This point is on the positive side of the "XAxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Hyperbola_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Geom2d_Hyperbola self) -> gp_Ax2d

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_Hyperbola_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom2d_Hyperbola self) -> Standard_Real

        Returns the excentricity of the hyperbola (e > 1).
        If f is the distance between the location of the hyperbola
        and the Focus1 then the eccentricity e = f / MajorRadius.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Geom2d_Hyperbola self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        two focus of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Geom2d_Hyperbola self) -> gp_Pnt2d

        Returns the first focus of the hyperbola. This focus is on the
        positive side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Hyperbola_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Geom2d_Hyperbola self) -> gp_Pnt2d

        Returns the second focus of the hyperbola. This focus is on the
        negative side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Hyperbola_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Geom2d_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The major radius is also the distance between the
        center of the hyperbola and the apex of the main
        branch (located on the "X Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Geom2d_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The minor radius is also the distance between the
        center of the hyperbola and the apex of a conjugate
        branch (located on the "Y Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_MinorRadius(self, *args)


    def OtherBranch(self, *args):
        """
        OtherBranch(Geom2d_Hyperbola self) -> gp_Hypr2d

        Computes the "other" branch of this hyperbola. This
        is a symmetrical branch with respect to the center of this hyperbola.
        Note: The diagram given under the class purpose
        indicates where the "other" branch is positioned in
        relation to this branch of the hyperbola.
        ^ YAxis
        |
        FirstConjugateBranch
        |
        Other   | Main
        ---------------------------- C
        ------------------------------------------&gtXAxis
        Branch |  Branch
        |
        |
        SecondConjugateBranch
        |
        Warning
        The major radius can be less than the minor radius.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Geom2d_Hyperbola_OtherBranch(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom2d_Hyperbola self) -> Standard_Real

        Computes the parameter of this hyperbola.
        The parameter is:
        p = (e*e - 1) * MajorRadius
        where e is the eccentricity of this hyperbola and
        MajorRadius its major radius.
        Exceptions
        Standard_DomainError if the major radius of this
        hyperbola is null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Hyperbola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cosh (U) * XDir +
        MinorRadius * Sinh (U) * YDir
        where C is the center of the hyperbola , XDir the XDirection and
        YDir the YDirection of the hyperbola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Hyperbola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Hyperbola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Hyperbola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Hyperbola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_Hyperbola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this hyperbola,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Hyperbola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Hyperbola self, gp_Trsf2d T)

        Applies the transformation T to this hyperbola.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Hyperbola_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Hyperbola self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this hyperbola.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Hyperbola_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Hyperbola_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Hyperbola_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Hyperbola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Hyperbola
Geom2d_Hyperbola_swigregister = _Geom2d.Geom2d_Hyperbola_swigregister
Geom2d_Hyperbola_swigregister(Geom2d_Hyperbola)

def Geom2d_Hyperbola_get_type_name(*args):
    """
    Geom2d_Hyperbola_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Hyperbola_get_type_name(*args)

def Geom2d_Hyperbola_get_type_descriptor(*args):
    """
    Geom2d_Hyperbola_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Hyperbola_get_type_descriptor(*args)

class Handle_Geom2d_Transformation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Transformation self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Transformation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Transformation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Transformation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Transformation self, Geom2d_Transformation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Transformation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation theHandle) -> Handle_Geom2d_Transformation
        assign(Handle_Geom2d_Transformation self, Geom2d_Transformation thePtr) -> Handle_Geom2d_Transformation
        assign(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation theHandle) -> Handle_Geom2d_Transformation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Transformation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Transformation self) -> Geom2d_Transformation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Transformation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Transformation self) -> Geom2d_Transformation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Transformation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Transformation self) -> Geom2d_Transformation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Transformation___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Transformation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Transformation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Transformation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Transformation_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Transformation

    def SetMirror(self, *args):
        """
        SetMirror(Handle_Geom2d_Transformation self, gp_Pnt2d P)
        SetMirror(Handle_Geom2d_Transformation self, gp_Ax2d A)

        Makes the transformation into a symmetrical transformation
        with respect to an axis A.
        A is the center of the axial symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Transformation_SetMirror(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(Handle_Geom2d_Transformation self, gp_Pnt2d P, Standard_Real const Ang)

        Assigns to this transformation the geometric
        properties of a rotation at angle Ang (in radians) about point P.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Transformation_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Handle_Geom2d_Transformation self, gp_Pnt2d P, Standard_Real const S)

        Makes the transformation into a scale. P is the center of
        the scale and S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Transformation_SetScale(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Handle_Geom2d_Transformation self, gp_Ax2d FromSystem1, gp_Ax2d ToSystem2)
        SetTransformation(Handle_Geom2d_Transformation self, gp_Ax2d ToSystem)

        Makes the transformation allowing passage from the basic
        coordinate system
        {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.)}
        to the local coordinate system defined with the Ax2d ToSystem.

        :type ToSystem: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Transformation_SetTransformation(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(Handle_Geom2d_Transformation self, gp_Vec2d V)
        SetTranslation(Handle_Geom2d_Transformation self, gp_Pnt2d P1, gp_Pnt2d P2)

        Makes the transformation into a translation from the point
        P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Transformation_SetTranslation(self, *args)


    def SetTrsf2d(self, *args):
        """
        SetTrsf2d(Handle_Geom2d_Transformation self, gp_Trsf2d T)

        Makes the transformation into a transformation T from
        package gp.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Transformation_SetTrsf2d(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(Handle_Geom2d_Transformation self) -> Standard_Boolean

        Checks whether this transformation is an indirect
        transformation: returns true if the determinant of the
        matrix of the vectorial part of the transformation is less than 0.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Transformation_IsNegative(self, *args)


    def Form(self, *args):
        """
        Form(Handle_Geom2d_Transformation self) -> gp_TrsfForm

        Returns the nature of this transformation as a value
        of the gp_TrsfForm enumeration.
        Returns the nature of the transformation. It can be
        Identity, Rotation, Translation, PntMirror, Ax1Mirror,
        Scale, CompoundTrsf

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _Geom2d.Handle_Geom2d_Transformation_Form(self, *args)


    def ScaleFactor(self, *args):
        """
        ScaleFactor(Handle_Geom2d_Transformation self) -> Standard_Real

        Returns the scale value of the transformation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Transformation_ScaleFactor(self, *args)


    def Trsf2d(self, *args):
        """
        Trsf2d(Handle_Geom2d_Transformation self) -> gp_Trsf2d

        Converts this transformation into a gp_Trsf2d transformation.
        Returns a non persistent copy of <me>.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Transformation_Trsf2d(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Transformation self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        Returns the coefficients of the global matrix of tranformation.
        It is a 2 rows X 3 columns matrix.

        Raised if  Row < 1 or Row > 2  or  Col < 1 or Col > 2

        Computes the reverse transformation.

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Transformation_Value(self, *args)


    def Invert(self, *args):
        """
        Invert(Handle_Geom2d_Transformation self)

        Computes the inverse of this transformation.
        and  assigns the result to this transformatio

        Raised if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from
        package gp.


        """
        return _Geom2d.Handle_Geom2d_Transformation_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(Handle_Geom2d_Transformation self) -> Handle_Geom2d_Transformation

        Computes the inverse of this transformation and creates a new one.
        Raises ConstructionError  if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from package gp.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation Other) -> Handle_Geom2d_Transformation

        Computes the transformation composed with Other and <me>.
        <me> * Other.
        Returns a new transformation

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation Other) -> Handle_Geom2d_Transformation

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation Other)

        Computes the transformation composed with Other and <me> .
        <me> = <me> * Other.

        Computes the following composition of transformations
        if N > 0  <me> * <me> * .......* <me>.
        if N = 0  Identity
        if N < 0  <me>.Invert() * .........* <me>.Invert()

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation Other)

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation___imul__(self, *args)


    def Power(self, *args):
        """
        Power(Handle_Geom2d_Transformation self, Standard_Integer const N)

        Raised if N < 0 and if the transformation is not inversible

        :type N: int

        """
        return _Geom2d.Handle_Geom2d_Transformation_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(Handle_Geom2d_Transformation self, Standard_Integer const N) -> Handle_Geom2d_Transformation

        Raised if N < 0 and if the transformation is not inversible

        :type N: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation_Powered(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(Handle_Geom2d_Transformation self, Handle_Geom2d_Transformation Other)

        Computes the matrix of the transformation composed with
        <me> and Other.     <me> = Other * <me>

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation_PreMultiply(self, *args)


    def Transforms(self, *args):
        """
        Transforms(Handle_Geom2d_Transformation self)

        Applies the transformation <me> to the triplet {X, Y}.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_Transformation_Transforms(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Transformation self) -> Handle_Geom2d_Transformation

        Creates a new object, which is a copy of this transformation.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        return _Geom2d.Handle_Geom2d_Transformation_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Transformation self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Transformation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Transformation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Transformation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Transformation self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Transformation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Transformation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Transformation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Transformation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Transformation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Transformation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Transformation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Transformation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Transformation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Transformation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Transformation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Transformation self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Transformation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Transformation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Transformation_DecrementRefCounter(self, *args)

Handle_Geom2d_Transformation_swigregister = _Geom2d.Handle_Geom2d_Transformation_swigregister
Handle_Geom2d_Transformation_swigregister(Handle_Geom2d_Transformation)

def Handle_Geom2d_Transformation_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Transformation_DownCast(thing)
Handle_Geom2d_Transformation_DownCast = _Geom2d.Handle_Geom2d_Transformation_DownCast

class Handle_Geom2d_Direction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Direction self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Direction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Direction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Direction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Direction self, Geom2d_Direction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Direction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Direction self, Handle_Geom2d_Direction theHandle) -> Handle_Geom2d_Direction
        assign(Handle_Geom2d_Direction self, Geom2d_Direction thePtr) -> Handle_Geom2d_Direction
        assign(Handle_Geom2d_Direction self, Handle_Geom2d_Direction theHandle) -> Handle_Geom2d_Direction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Direction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Direction self) -> Geom2d_Direction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Direction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Direction self) -> Geom2d_Direction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Direction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Direction self) -> Geom2d_Direction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Direction___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Direction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Direction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Direction_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Direction

    def SetCoord(self, *args):
        """
        SetCoord(Handle_Geom2d_Direction self, Standard_Real const X, Standard_Real const Y)

        Assigns the coordinates X and Y to this unit vector,
        then normalizes it.
        Exceptions
        Standard_ConstructionError if Sqrt(X*X +
        Y*Y) is less than or equal to gp::Resolution().

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_Direction_SetCoord(self, *args)


    def SetDir2d(self, *args):
        """
        SetDir2d(Handle_Geom2d_Direction self, gp_Dir2d V)

        Converts the gp_Dir2d unit vector V into this unit vector.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Handle_Geom2d_Direction_SetDir2d(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_Geom2d_Direction self, Standard_Real const X)

        Assigns a value to the X coordinate of this unit vector, then normalizes it.
        Exceptions
        Standard_ConstructionError if the value assigned
        causes the magnitude of the vector to become less
        than or equal to gp::Resolution().

        :type X: float

        """
        return _Geom2d.Handle_Geom2d_Direction_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_Geom2d_Direction self, Standard_Real const Y)

        Assigns a value to the Y coordinate of this unit vector, then normalizes it.
        Exceptions
        Standard_ConstructionError if the value assigned
        causes the magnitude of the vector to become less
        than or equal to gp::Resolution().

        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_Direction_SetY(self, *args)


    def Dir2d(self, *args):
        """
        Dir2d(Handle_Geom2d_Direction self) -> gp_Dir2d

        Converts this unit vector into a gp_Dir2d unit vector.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Handle_Geom2d_Direction_Dir2d(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Handle_Geom2d_Direction self) -> Standard_Real

        returns 1.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Handle_Geom2d_Direction self) -> Standard_Real

        returns 1.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_SquareMagnitude(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Handle_Geom2d_Direction self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the cross product between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(Handle_Geom2d_Direction self, Handle_Geom2d_Vector Other) -> Standard_Real

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction___xor__(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Direction self, gp_Trsf2d T)

        Applies the transformation T to this unit vector, then normalizes it.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Direction_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Direction self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this unit vector.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Direction_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Direction self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Direction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Direction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Direction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Direction self)

        Reverses the vector <me>.


        """
        return _Geom2d.Handle_Geom2d_Direction_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Direction self) -> Handle_Geom2d_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_Direction_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom2d_Direction self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The orientation is from this
        vector to vector Other.
        Raises VectorWithNullMagnitude if one of the two vectors is a vector with
        null magnitude because the angular value is indefinite.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_Angle(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom2d_Direction self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_Direction_Coord(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom2d_Direction self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom2d_Direction self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_Y(self, *args)


    def Dot(self, *args):
        """
        Dot(Handle_Geom2d_Direction self, Handle_Geom2d_Vector Other) -> Standard_Real

        Returns the scalar product of 2 Vectors.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Direction_Dot(self, *args)


    def Vec2d(self, *args):
        """
        Vec2d(Handle_Geom2d_Direction self) -> gp_Vec2d

        Returns a non persistent copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Direction_Vec2d(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Direction self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Direction self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Direction_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Direction self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Direction_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Direction self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Direction_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Direction self, gp_Vec2d V)
        Translate(Handle_Geom2d_Direction self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Direction_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Direction self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Direction self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Direction_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Direction self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Direction_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Direction self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Direction_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Direction self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Direction_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Direction self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Direction self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Direction_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Direction self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Direction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Direction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Direction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Direction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Direction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Direction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Direction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Direction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Direction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Direction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Direction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Direction self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Direction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Direction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Direction_DecrementRefCounter(self, *args)

Handle_Geom2d_Direction_swigregister = _Geom2d.Handle_Geom2d_Direction_swigregister
Handle_Geom2d_Direction_swigregister(Handle_Geom2d_Direction)

def Handle_Geom2d_Direction_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Direction_DownCast(thing)
Handle_Geom2d_Direction_DownCast = _Geom2d.Handle_Geom2d_Direction_DownCast

class Geom2d_BSplineCurve(Geom2d_BoundedCurve):
    """
    Describes a BSpline curve.
    A BSpline curve can be:
    - uniform or non-uniform,
    - rational or non-rational,
    - periodic or non-periodic.
    A BSpline curve is defined by:
    - its degree; the degree for a
    Geom2d_BSplineCurve is limited to a value (25)
    which is defined and controlled by the system. This
    value is returned by the function MaxDegree;
    - its periodic or non-periodic nature;
    - a table of poles (also called control points), with
    their associated weights if the BSpline curve is
    rational. The poles of the curve are "control points"
    used to deform the curve. If the curve is
    non-periodic, the first pole is the start point of the
    curve, and the last pole is the end point of the
    curve. The segment, which joins the first pole to the
    second pole, is the tangent to the curve at its start
    point, and the segment, which joins the last pole to
    the second-from-last pole, is the tangent to the
    curve at its end point. If the curve is periodic, these
    geometric properties are not verified. It is more
    difficult to give a geometric signification to the
    weights but they are useful for providing exact
    representations of the arcs of a circle or ellipse.
    Moreover, if the weights of all the poles are equal,
    the curve has a polynomial equation; it is
    therefore a non-rational curve.
    - a table of knots with their multiplicities. For a
    Geom2d_BSplineCurve, the table of knots is an
    increasing sequence of reals without repetition; the
    multiplicities define the repetition of the knots. A
    BSpline curve is a piecewise polynomial or rational
    curve. The knots are the parameters of junction
    points between two pieces. The multiplicity
    Mult(i) of the knot Knot(i) of the BSpline
    curve is related to the degree of continuity of the
    curve at the knot Knot(i), which is equal to
    Degree - Mult(i) where Degree is the
    degree of the BSpline curve.
    If the knots are regularly spaced (i.e. the difference
    between two consecutive knots is a constant), three
    specific and frequently used cases of knot distribution
    can be identified:
    - "uniform" if all multiplicities are equal to 1,
    - "quasi-uniform" if all multiplicities are equal to 1,
    except the first and the last knot which have a
    multiplicity of Degree + 1, where Degree is
    the degree of the BSpline curve,
    - "Piecewise Bezier" if all multiplicities are equal to
    Degree except the first and last knot which have
    a multiplicity of Degree + 1, where Degree is
    the degree of the BSpline curve. A curve of this
    type is a concatenation of arcs of Bezier curves.
    If the BSpline curve is not periodic:
    - the bounds of the Poles and Weights tables are 1
    and NbPoles, where NbPoles is the number of
    poles of the BSpline curve,
    - the bounds of the Knots and Multiplicities tables are
    1 and NbKnots, where NbKnots is the number
    of knots of the BSpline curve.
    If the BSpline curve is periodic, and if there are k
    periodic knots and p periodic poles, the period is:
    period = Knot(k + 1) - Knot(1)
    and the poles and knots tables can be considered as
    infinite tables, such that:
    - Knot(i+k) = Knot(i) + period
    - Pole(i+p) = Pole(i)
    Note: data structures of a periodic BSpline curve are
    more complex than those of a non-periodic one.
    Warnings :
    In this class we consider that a weight value is zero if
    Weight <= Resolution from package gp.
    For two parametric values (or two knot values) U1, U2 we
    consider that U1 = U2 if Abs (U2 - U1) <= Epsilon (U1).
    For two weights values W1, W2 we consider that W1 = W2 if
    Abs (W2 - W1) <= Epsilon (W1).  The method Epsilon is
    defined in the class Real from package Standard.

    References :
    . A survey of curve and surface methods in CADG Wolfgang BOHM
    CAGD 1 (1984)
    . On de Boor-like algorithms and blossoming Wolfgang BOEHM
    cagd 5 (1988)
    . Blossoming and knot insertion algorithms for B-spline curves
    Ronald N. GOLDMAN
    . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
    . Curves and Surfaces for Computer Aided Geometric Design,
    a practical guide Gerald Farin
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_BSplineCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_BSplineCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_BSplineCurve self, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Multiplicities, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Geom2d_BSplineCurve
        __init__(Geom2d_BSplineCurve self, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Multiplicities, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Geom2d_BSplineCurve

        Creates  a rational B_spline  curve  on the basis
        <Knots, Multiplicities> of degree <Degree>.
        The following conditions must be verified.
        0 < Degree <= MaxDegree.

        Knots.Length() == Mults.Length() >= 2

        Knots(i) < Knots(i+1) (Knots are increasing)

        1 <= Mults(i) <= Degree

        On a non periodic curve the first and last multiplicities
        may be Degree+1 (this is even recommanded if you want the
        curve to start and finish on the first and last pole).

        On a periodic  curve the first  and  the last multicities
        must be the same.

        on non-periodic curves

        Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2

        on periodic curves

        Poles.Length() == Sum(Mults(i)) except the first or last

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Multiplicities: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type Periodic: bool

        """
        this = _Geom2d.new_Geom2d_BSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Geom2d_BSplineCurve self, Standard_Integer const Degree)

        Increases the degree of this BSpline curve to
        Degree. As a result, the poles, weights and
        multiplicities tables are modified; the knots table is
        not changed. Nothing is done if Degree is less than
        or equal to the current degree.
        Exceptions
        Standard_ConstructionError if Degree is greater than
        Geom2d_BSplineCurve::MaxDegree().

        :type Degree: int

        """
        return _Geom2d.Geom2d_BSplineCurve_IncreaseDegree(self, *args)


    def IncreaseMultiplicity(self, *args):
        """
        IncreaseMultiplicity(Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M)
        IncreaseMultiplicity(Geom2d_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases  the  multiplicities   of  the knots  in
        [I1,I2] to <M>.

        For each knot if  <M>  is  lower  or equal  to  the
        current multiplicity  nothing  is  done. If <M>  is
        higher than the degree the degree is used.
        As a result, the poles and weights tables of this curve are modified.
        Warning
        It is forbidden to modify the multiplicity of the first or
        last knot of a non-periodic curve. Be careful as
        Geom2d does not protect against this.
        Exceptions
        Standard_OutOfRange if either Index, I1 or I2 is
        outside the bounds of the knots table.

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom2d.Geom2d_BSplineCurve_IncreaseMultiplicity(self, *args)


    def IncrementMultiplicity(self, *args):
        """
        IncrementMultiplicity(Geom2d_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases by M the multiplicity of the knots of indexes
        I1 to I2 in the knots table of this BSpline curve. For
        each knot, the resulting multiplicity is limited to the
        degree of this curve. If M is negative, nothing is done.
        As a result, the poles and weights tables of this
        BSpline curve are modified.
        Warning
        It is forbidden to modify the multiplicity of the first or
        last knot of a non-periodic curve. Be careful as
        Geom2d does not protect against this.
        Exceptions
        Standard_OutOfRange if I1 or I2 is outside the
        bounds of the knots table.

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom2d.Geom2d_BSplineCurve_IncrementMultiplicity(self, *args)


    def InsertKnot(self, *args):
        """
        InsertKnot(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const M=1, Standard_Real const ParametricTolerance=0.0)

        Inserts a knot value in the sequence of knots.  If
        <U>  is an  existing knot     the multiplicity  is
        increased by <M>.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.
        Warning
        - If U is less than the first parameter or greater than
        the last parameter of this BSpline curve, nothing is done.
        - If M is negative or null, nothing is done.
        - The multiplicity of a knot is limited to the degree of
        this BSpline curve.

        :type U: float
        :type M: int
        :type ParametricTolerance: float

        """
        return _Geom2d.Geom2d_BSplineCurve_InsertKnot(self, *args)


    def InsertKnots(self, *args):
        """
        InsertKnots(Geom2d_BSplineCurve self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts the values of the array Knots, with the
        respective multiplicities given by the array Mults, into
        the knots table of this BSpline curve.
        If a value of the array Knots is an existing knot, its multiplicity is:
        - increased by M, if Add is true, or
        - increased to M, if Add is false (default value).
        The tolerance criterion used for knot equality is the
        larger of the values ParametricTolerance (defaulted
        to 0.) and Standard_Real::Epsilon(U),
        where U is the current knot value.
        Warning
        - For a value of the array Knots which is less than
        the first parameter or greater than the last
        parameter of this BSpline curve, nothing is done.
        - For a value of the array Mults which is negative or
        null, nothing is done.
        - The multiplicity of a knot is limited to the degree of
        this BSpline curve.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom2d.Geom2d_BSplineCurve_InsertKnots(self, *args)


    def RemoveKnot(self, *args):
        """
        RemoveKnot(Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces the multiplicity of the knot of index Index
        to M. If M is equal to 0, the knot is removed.
        With a modification of this type, the array of poles is also modified.
        Two different algorithms are systematically used to
        compute the new poles of the curve. If, for each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is less than
        Tolerance, this ensures that the curve is not
        modified by more than Tolerance. Under these
        conditions, true is returned; otherwise, false is returned.
        A low tolerance is used to prevent modification of
        the curve. A high tolerance is used to "smooth" the curve.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BSplineCurve_RemoveKnot(self, *args)


    def InsertPoleAfter(self, *args):
        """
        InsertPoleAfter(Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        The new pole is inserted after the pole of range Index.
        If the curve was non rational it can become rational.

        Raised if the B-spline is NonUniform or PiecewiseBezier or if
        Weight <= 0.0
        Raised if Index is not in the range [1, Number of Poles]

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Geom2d_BSplineCurve_InsertPoleAfter(self, *args)


    def InsertPoleBefore(self, *args):
        """
        InsertPoleBefore(Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        The new pole is inserted before the pole of range Index.
        If the curve was non rational it can become rational.

        Raised if the B-spline is NonUniform or PiecewiseBezier or if
        Weight <= 0.0
        Raised if Index is not in the range [1, Number of Poles]

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Geom2d_BSplineCurve_InsertPoleBefore(self, *args)


    def RemovePole(self, *args):
        """
        RemovePole(Geom2d_BSplineCurve self, Standard_Integer const Index)

        Removes the pole of range Index
        If the curve was rational it can become non rational.

        Raised if the B-spline is NonUniform or PiecewiseBezier.
        Raised if the number of poles of the B-spline curve is lower or
        equal to 2 before removing.
        Raised if Index is not in the range [1, Number of Poles]

        :type Index: int

        """
        return _Geom2d.Geom2d_BSplineCurve_RemovePole(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Geom2d_BSplineCurve self)

        Reverses the orientation of this BSpline curve. As a result
        - the knots and poles tables are modified;
        - the start point of the initial curve becomes the end
        point of the reversed curve;
        - the end point of the initial curve becomes the start
        point of the reversed curve.


        """
        return _Geom2d.Geom2d_BSplineCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_BSplineCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this BSpline curve.
        The returned value is: UFirst + ULast - U,
        where UFirst and ULast are the values of the
        first and last parameters of this BSpline curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BSplineCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom2d_BSplineCurve self, Standard_Real const U1, Standard_Real const U2)

        Modifies this BSpline curve by segmenting it
        between U1 and U2. Either of these values can be
        outside the bounds of the curve, but U2 must be greater than U1.
        All data structure tables of this BSpline curve are
        modified, but the knots located between U1 and U2
        are retained. The degree of the curve is not modified.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.
        - The segmentation of a periodic curve over an
        interval corresponding to its period generates a
        non-periodic curve with equivalent geometry.
        Exceptions
        Standard_DomainError if U2 is less than U1.
        raises if U2 < U1.
        Standard_DomainError if U2 - U1 exceeds the period for periodic curves.
        i.e. ((U2 - U1) - Period) > Precision::PConfusion().

        :type U1: float
        :type U2: float

        """
        return _Geom2d.Geom2d_BSplineCurve_Segment(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(Geom2d_BSplineCurve self, NCollection_Array1_Standard_Real K)

        Modifies this BSpline curve by assigning the array
        K to its knots table. The multiplicity of the knots is not modified.
        Exceptions
        Standard_ConstructionError if the values in the
        array K are not in ascending order.
        Standard_OutOfRange if the bounds of the array
        K are not respectively 1 and the number of knots of this BSpline curve.

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2d.Geom2d_BSplineCurve_SetKnots(self, *args)


    def SetKnot(self, *args):
        """
        SetKnot(Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Real const K)
        SetKnot(Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Real const K, Standard_Integer const M)

        Modifies this BSpline curve by assigning the value K
        to the knot of index Index in the knots table. This is a
        relatively local modification because K must be such that:
        Knots(Index - 1) < K < Knots(Index + 1)
        The second syntax allows you also to increase the
        multiplicity of the knot to M (but it is not possible to
        decrease the multiplicity of the knot with this function).
        Exceptions
        Standard_ConstructionError if:
        - K is not such that:
        Knots(Index - 1) < K < Knots(Index + 1)
        - M is greater than the degree of this BSpline curve
        or lower than the previous multiplicity of knot of
        index Index in the knots table.
        Standard_OutOfRange if Index is outside the bounds of the knots table.

        :type Index: int
        :type K: float
        :type M: int

        """
        return _Geom2d.Geom2d_BSplineCurve_SetKnot(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Geom2d_BSplineCurve self)

        Computes the parameter normalized within the
        "first" period of this BSpline curve, if it is periodic:
        the returned value is in the range Param1 and
        Param1 + Period, where:
        - Param1 is the "first parameter", and
        - Period the period of this BSpline curve.
        Note: If this curve is not periodic, U is not modified.

        :type U: float

        """
        return _Geom2d.Geom2d_BSplineCurve_PeriodicNormalization(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(Geom2d_BSplineCurve self)

        Changes this BSpline curve into a periodic curve.
        To become periodic, the curve must first be closed.
        Next, the knot sequence must be periodic. For this,
        FirstUKnotIndex and LastUKnotIndex are used to
        compute I1 and I2, the indexes in the knots array
        of the knots corresponding to the first and last
        parameters of this BSpline curve.
        The period is therefore Knot(I2) - Knot(I1).
        Consequently, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if this BSpline curve is not closed.


        """
        return _Geom2d.Geom2d_BSplineCurve_SetPeriodic(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(Geom2d_BSplineCurve self, Standard_Integer const Index)

        Assigns the knot of index Index in the knots table as
        the origin of this periodic BSpline curve. As a
        consequence, the knots and poles tables are modified.
        Exceptions
        Standard_NoSuchObject if this curve is not periodic.
        Standard_DomainError if Index is outside the
        bounds of the knots table.

        :type Index: int

        """
        return _Geom2d.Geom2d_BSplineCurve_SetOrigin(self, *args)


    def SetNotPeriodic(self, *args):
        """
        SetNotPeriodic(Geom2d_BSplineCurve self)

        Changes this BSpline curve into a non-periodic
        curve. If this curve is already non-periodic, it is not modified.
        Note that the poles and knots tables are modified.
        Warning
        If this curve is periodic, as the multiplicity of the first
        and last knots is not modified, and is not equal to
        Degree + 1, where Degree is the degree of
        this BSpline curve, the start and end points of the
        curve are not its first and last poles.


        """
        return _Geom2d.Geom2d_BSplineCurve_SetNotPeriodic(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P)
        SetPole(Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight)

        Modifies this BSpline curve by assigning P to the
        pole of index Index in the poles table.
        The second syntax also allows you to modify the
        weight of the modified pole, which becomes Weight.
        In this case, if this BSpline curve is non-rational, it
        can become rational and vice versa.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the poles table.
        Standard_ConstructionError if Weight is negative or null.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Geom2d_BSplineCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Assigns the weight Weight to the pole of index Index of the poles table.
        If the curve was non rational it can become rational.
        If the curve was rational it can become non rational.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the poles table.
        Standard_ConstructionError if Weight is negative or null.

        :type Index: int
        :type Weight: float

        """
        return _Geom2d.Geom2d_BSplineCurve_SetWeight(self, *args)


    def MovePoint(self, *args):
        """
        MovePoint(Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, Standard_Integer const Index1, Standard_Integer const Index2)

        Moves the point of parameter U of this BSpline
        curve to P. Index1 and Index2 are the indexes in the
        table of poles of this BSpline curve of the first and
        last poles designated to be moved.
        FirstModifiedPole and LastModifiedPole are the
        indexes of the first and last poles, which are
        effectively modified.
        In the event of incompatibility between Index1,
        Index2 and the value U:
        - no change is made to this BSpline curve, and
        - the FirstModifiedPole and LastModifiedPole are returned null.
        Exceptions
        Standard_OutOfRange if:
        - Index1 is greater than or equal to Index2, or
        - Index1 or Index2 is less than 1 or greater than the
        number of poles of this BSpline curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Index1: int
        :type Index2: int
        :type FirstModifiedPole: int
        :type LastModifiedPole: int

        """
        return _Geom2d.Geom2d_BSplineCurve_MovePoint(self, *args)


    def MovePointAndTangent(self, *args):
        """
        MovePointAndTangent(Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d Tangent, Standard_Real const Tolerance, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition)

        Move a point with parameter U to P.
        and makes it tangent at U be Tangent.
        StartingCondition = -1 means first can move
        EndingCondition   = -1 means last point can move
        StartingCondition = 0 means the first point cannot move
        EndingCondition   = 0 means the last point cannot move
        StartingCondition = 1 means the first point and tangent cannot move
        EndingCondition   = 1 means the last point and tangent cannot move
        and so forth
        ErrorStatus != 0 means that there are not enought degree of freedom
        with the constrain to deform the curve accordingly

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tangent: OCC.wrapper.gp.gp_Vec2d
        :type Tolerance: float
        :type StartingCondition: int
        :type EndingCondition: int
        :type ErrorStatus: int

        """
        return _Geom2d.Geom2d_BSplineCurve_MovePointAndTangent(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_BSplineCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this
        BSpline curve is at least N. A BSpline curve is at least GeomAbs_C0.
        Exceptions Standard_RangeError if N is negative.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BSplineCurve_IsCN(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Geom2d_BSplineCurve self, Standard_Real const theTf, Standard_Real const theTl, Standard_Real const theAngTol) -> Standard_Boolean

        Check if curve has at least G1 continuity in interval [theTf, theTl]
        Returns true if IsCN(1)
        or
        angle betweem "left" and "right" first derivatives at
        knots with C0 continuity is less then theAngTol
        only knots in interval [theTf, theTl] is checked

        :type theTf: float
        :type theTl: float
        :type theAngTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BSplineCurve_IsG1(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_BSplineCurve self) -> Standard_Boolean

        Returns true if the distance between the first point and the
        last point of the curve is lower or equal to Resolution
        from package gp.
        Warnings :
        The first and the last point can be different from the first
        pole and the last pole of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BSplineCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_BSplineCurve self) -> Standard_Boolean

        Returns True if the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BSplineCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Geom2d_BSplineCurve self) -> Standard_Boolean

        Returns True if the weights are not identical.
        The tolerance criterion is Epsilon of the class Real.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_BSplineCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_BSplineCurve self) -> GeomAbs_Shape

        Returns the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.
        For a B-spline curve of degree d if a knot Ui has a
        multiplicity p the B-spline curve is only Cd-p continuous
        at Ui. So the global continuity of the curve can't be greater
        than Cd-p where p is the maximum multiplicity of the interior
        Knots. In the interior of a knot span the curve is infinitely
        continuously differentiable.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_BSplineCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the degree of this BSpline curve.
        In this class the degree of the basis normalized B-spline
        functions cannot be greater than "MaxDegree"
        Computation of value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BSplineCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        For this BSpline curve, computes
        - the point P of parameter U, or
        - the point P and one or more of the following values:
        - V1, the first derivative vector,
        - V2, the second derivative vector,
        - V3, the third derivative vector.
        Warning
        On a point where the continuity of the curve is not the
        one requested, these functions impact the part
        defined by the parameter with a value greater than U,
        i.e. the part of the curve to the "right" of the singularity.
        Raises UndefinedDerivative if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this BSpline curve,
        computes the vector corresponding to the Nth derivative.
        Warning
        On a point where the continuity of the curve is not the
        one requested, this function impacts the part defined
        by the parameter with a value greater than U, i.e. the
        part of the curve to the "right" of the singularity.
        Raises  UndefinedDerivative if the continuity of the curve is not CN.
        RangeError if N < 1.
        The following functions computes the point of parameter U
        and the derivatives at this point on the B-spline curve
        arc defined between the knot FromK1 and the knot ToK2.
        U can be out of bounds [Knot (FromK1),  Knot (ToK2)] but
        for the computation we only use the definition of the curve
        between these two knots. This method is useful to compute
        local derivative, if the order of continuity of the whole
        curve is not greater enough.    Inside the parametric
        domain Knot (FromK1), Knot (ToK2) the evaluations are
        the same as if we consider the whole definition of the
        curve. Of course the evaluations are different outside
        this parametric domain.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_DN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2) -> gp_Pnt2d

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BSplineCurve_LocalValue(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P)

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BSplineCurve_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P, gp_Vec2d V1)

        Raised if the local continuity of the curve is not C1
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the local continuity of the curve is not C2
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Raised if the local continuity of the curve is not C3
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Integer const N) -> gp_Vec2d

        Raised if the local continuity of the curve is not CN
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.
        Raised if N < 1.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_BSplineCurve_LocalDN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Geom2d_BSplineCurve self) -> gp_Pnt2d

        Returns the last point of the curve.
        Warnings :
        The last point of the curve is different from the last
        pole of the curve if the multiplicity of the last knot
        is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BSplineCurve_EndPoint(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Geom2d_BSplineCurve self) -> Standard_Integer

        For a B-spline curve the first parameter (which gives the start
        point of the curve) is a knot value but if the multiplicity of
        the first knot index is lower than Degree + 1 it is not the
        first knot of the curve. This method computes the index of the
        knot corresponding to the first parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_FirstUKnotIndex(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_BSplineCurve self) -> Standard_Real

        Computes the parametric value of the start point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BSplineCurve_FirstParameter(self, *args)


    def Knot(self, *args):
        """
        Knot(Geom2d_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of range Index. When there is a knot
        with a multiplicity greater than 1 the knot is not repeated.
        The method Multiplicity can be used to get the multiplicity
        of the Knot.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BSplineCurve_Knot(self, *args)


    def Knots(self, *args):
        """
        returns the knot values of the B-spline curve;

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom2d.Geom2d_BSplineCurve_Knots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotSequence(self, *args):
        """
        Returns the knots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        K = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom2d.Geom2d_BSplineCurve_KnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotDistribution(self, *args):
        """
        KnotDistribution(Geom2d_BSplineCurve self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier.
        If all the knots differ by a positive constant from the
        preceding knot the BSpline Curve can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1 except for
        the first and last knot which are of multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have multiplicity
        Degree + 1 and if interior knots have multiplicity Degree
        A piecewise Bezier with only two knots is a BezierCurve.
        else the curve is non uniform.
        The tolerance criterion is Epsilon from class Real.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom2d.Geom2d_BSplineCurve_KnotDistribution(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Geom2d_BSplineCurve self) -> Standard_Integer

        For a BSpline curve the last parameter (which gives the
        end point of the curve) is a knot value but if the
        multiplicity of the last knot index is lower than
        Degree + 1 it is not the last knot of the curve. This
        method computes the index of the knot corresponding to
        the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_LastUKnotIndex(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_BSplineCurve self) -> Standard_Real

        Computes the parametric value of the end point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BSplineCurve_LastParameter(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Geom2d_BSplineCurve self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        Knots (I1) <= U <= Knots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance)
        . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom2d.Geom2d_BSplineCurve_LocateU(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Geom2d_BSplineCurve self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knots of range Index.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_Multiplicity(self, *args)


    def Multiplicities(self, *args):
        """
        returns the multiplicity of the knots of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom2d.Geom2d_BSplineCurve_Multiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbKnots(self, *args):
        """
        NbKnots(Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the number of knots. This method returns the number of
        knot without repetition of multiple knots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_NbKnots(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the number of poles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Geom2d.Geom2d_BSplineCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the B-spline curve;

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Geom2d.Geom2d_BSplineCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPoint(self, *args):
        """
        StartPoint(Geom2d_BSplineCurve self) -> gp_Pnt2d

        Returns the start point of the curve.
        Warnings :
        This point is different from the first pole of the curve if the
        multiplicity of the first knot is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_BSplineCurve_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Geom2d_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of range Index .
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_BSplineCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Geom2d_BSplineCurve self, NCollection_Array1_Standard_Real W)
        Weights(Geom2d_BSplineCurve self) -> NCollection_Array1_Standard_Real

        Returns the weights of the B-spline curve;

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2d.Geom2d_BSplineCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_BSplineCurve self, gp_Trsf2d T)

        Applies the transformation T to this BSpline curve.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_BSplineCurve_Transform(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in this package.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Geom2d_BSplineCurve_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def Resolution(self, *args):
        """
        Resolution(Geom2d_BSplineCurve self, Standard_Real const ToleranceUV)

        Computes for this BSpline curve the parametric
        tolerance UTolerance for a given tolerance
        Tolerance3D (relative to dimensions in the plane).
        If f(t) is the equation of this BSpline curve,
        UTolerance ensures that:
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < ToleranceUV

        :type ToleranceUV: float
        :type UTolerance: float

        """
        return _Geom2d.Geom2d_BSplineCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_BSplineCurve self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this BSpline curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_BSplineCurve_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_BSplineCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_BSplineCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_BSplineCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_BSplineCurve
Geom2d_BSplineCurve_swigregister = _Geom2d.Geom2d_BSplineCurve_swigregister
Geom2d_BSplineCurve_swigregister(Geom2d_BSplineCurve)

def Geom2d_BSplineCurve_MaxDegree(*args):
    """
    Geom2d_BSplineCurve_MaxDegree() -> Standard_Integer

    Returns the value of the maximum degree of the normalized
    B-spline basis functions in this package.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom2d.Geom2d_BSplineCurve_MaxDegree(*args)

def Geom2d_BSplineCurve_get_type_name(*args):
    """
    Geom2d_BSplineCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_BSplineCurve_get_type_name(*args)

def Geom2d_BSplineCurve_get_type_descriptor(*args):
    """
    Geom2d_BSplineCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_BSplineCurve_get_type_descriptor(*args)

class Handle_Geom2d_UndefinedDerivative(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_UndefinedDerivative self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_UndefinedDerivative self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_UndefinedDerivative self, Geom2d_UndefinedDerivative thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_UndefinedDerivative self, Handle_Geom2d_UndefinedDerivative theHandle) -> Handle_Geom2d_UndefinedDerivative
        assign(Handle_Geom2d_UndefinedDerivative self, Geom2d_UndefinedDerivative thePtr) -> Handle_Geom2d_UndefinedDerivative
        assign(Handle_Geom2d_UndefinedDerivative self, Handle_Geom2d_UndefinedDerivative theHandle) -> Handle_Geom2d_UndefinedDerivative

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_UndefinedDerivative self) -> Geom2d_UndefinedDerivative

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_UndefinedDerivative self) -> Geom2d_UndefinedDerivative

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_UndefinedDerivative self) -> Geom2d_UndefinedDerivative

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_UndefinedDerivative___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_UndefinedDerivative___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_UndefinedDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_UndefinedDerivative_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_UndefinedDerivative

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Geom2d_UndefinedDerivative self, Standard_CString const theMessage) -> Handle_Geom2d_UndefinedDerivative

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_UndefinedDerivative

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_UndefinedDerivative self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_UndefinedDerivative_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_UndefinedDerivative_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Geom2d_UndefinedDerivative self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Geom2d_UndefinedDerivative self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Geom2d_UndefinedDerivative self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Geom2d_UndefinedDerivative self)
        Reraise(Handle_Geom2d_UndefinedDerivative self, Standard_CString const aMessage)
        Reraise(Handle_Geom2d_UndefinedDerivative self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Geom2d_UndefinedDerivative self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Geom2d_UndefinedDerivative self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_UndefinedDerivative self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_UndefinedDerivative self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_UndefinedDerivative self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_UndefinedDerivative self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_UndefinedDerivative self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_UndefinedDerivative self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_UndefinedDerivative self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_UndefinedDerivative self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_UndefinedDerivative self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_UndefinedDerivative_DecrementRefCounter(self, *args)

Handle_Geom2d_UndefinedDerivative_swigregister = _Geom2d.Handle_Geom2d_UndefinedDerivative_swigregister
Handle_Geom2d_UndefinedDerivative_swigregister(Handle_Geom2d_UndefinedDerivative)

def Handle_Geom2d_UndefinedDerivative_DownCast(thing):
    return _Geom2d.Handle_Geom2d_UndefinedDerivative_DownCast(thing)
Handle_Geom2d_UndefinedDerivative_DownCast = _Geom2d.Handle_Geom2d_UndefinedDerivative_DownCast

class Geom2d_CartesianPoint(Geom2d_Point):
    """
    Describes a point in 2D space. A
    Geom2d_CartesianPoint is defined by a gp_Pnt2d
    point, with its two Cartesian coordinates X and Y.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_CartesianPoint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_CartesianPoint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_CartesianPoint self, gp_Pnt2d P) -> Geom2d_CartesianPoint
        __init__(Geom2d_CartesianPoint self, Standard_Real const X, Standard_Real const Y) -> Geom2d_CartesianPoint

        :type X: float
        :type Y: float

        """
        this = _Geom2d.new_Geom2d_CartesianPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCoord(self, *args):
        """
        SetCoord(Geom2d_CartesianPoint self, Standard_Real const X, Standard_Real const Y)

        Set <me> to X, Y coordinates.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_CartesianPoint_SetCoord(self, *args)


    def SetPnt2d(self, *args):
        """
        SetPnt2d(Geom2d_CartesianPoint self, gp_Pnt2d P)

        Set <me> to P.X(), P.Y() coordinates.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_CartesianPoint_SetPnt2d(self, *args)


    def SetX(self, *args):
        """
        SetX(Geom2d_CartesianPoint self, Standard_Real const X)

        Changes the X coordinate of me.

        :type X: float

        """
        return _Geom2d.Geom2d_CartesianPoint_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Geom2d_CartesianPoint self, Standard_Real const Y)

        Changes the Y coordinate of me.

        :type Y: float

        """
        return _Geom2d.Geom2d_CartesianPoint_SetY(self, *args)


    def Coord(self, *args):
        """
        Coord(Geom2d_CartesianPoint self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Geom2d_CartesianPoint_Coord(self, *args)


    def Pnt2d(self, *args):
        """
        Pnt2d(Geom2d_CartesianPoint self) -> gp_Pnt2d

        Returns a non persistent cartesian point with
        the same coordinates as <me>.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_CartesianPoint_Pnt2d(self, *args)


    def X(self, *args):
        """
        X(Geom2d_CartesianPoint self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_CartesianPoint_X(self, *args)


    def Y(self, *args):
        """
        Y(Geom2d_CartesianPoint self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_CartesianPoint_Y(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_CartesianPoint self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_CartesianPoint_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_CartesianPoint self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_CartesianPoint_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_CartesianPoint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_CartesianPoint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_CartesianPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_CartesianPoint
Geom2d_CartesianPoint_swigregister = _Geom2d.Geom2d_CartesianPoint_swigregister
Geom2d_CartesianPoint_swigregister(Geom2d_CartesianPoint)

def Geom2d_CartesianPoint_get_type_name(*args):
    """
    Geom2d_CartesianPoint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_CartesianPoint_get_type_name(*args)

def Geom2d_CartesianPoint_get_type_descriptor(*args):
    """
    Geom2d_CartesianPoint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_CartesianPoint_get_type_descriptor(*args)

class Handle_Geom2d_CartesianPoint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_CartesianPoint self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_CartesianPoint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_CartesianPoint self, Geom2d_CartesianPoint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_CartesianPoint self, Handle_Geom2d_CartesianPoint theHandle) -> Handle_Geom2d_CartesianPoint
        assign(Handle_Geom2d_CartesianPoint self, Geom2d_CartesianPoint thePtr) -> Handle_Geom2d_CartesianPoint
        assign(Handle_Geom2d_CartesianPoint self, Handle_Geom2d_CartesianPoint theHandle) -> Handle_Geom2d_CartesianPoint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_CartesianPoint self) -> Geom2d_CartesianPoint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_CartesianPoint self) -> Geom2d_CartesianPoint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_CartesianPoint self) -> Geom2d_CartesianPoint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_CartesianPoint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_CartesianPoint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_CartesianPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_CartesianPoint_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_CartesianPoint

    def SetCoord(self, *args):
        """
        SetCoord(Handle_Geom2d_CartesianPoint self, Standard_Real const X, Standard_Real const Y)

        Set <me> to X, Y coordinates.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_SetCoord(self, *args)


    def SetPnt2d(self, *args):
        """
        SetPnt2d(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P)

        Set <me> to P.X(), P.Y() coordinates.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_SetPnt2d(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_Geom2d_CartesianPoint self, Standard_Real const X)

        Changes the X coordinate of me.

        :type X: float

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_Geom2d_CartesianPoint self, Standard_Real const Y)

        Changes the Y coordinate of me.

        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_SetY(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom2d_CartesianPoint self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Coord(self, *args)


    def Pnt2d(self, *args):
        """
        Pnt2d(Handle_Geom2d_CartesianPoint self) -> gp_Pnt2d

        Returns a non persistent cartesian point with
        the same coordinates as <me>.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Pnt2d(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom2d_CartesianPoint self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom2d_CartesianPoint self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Y(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_CartesianPoint self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_CartesianPoint self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_CartesianPoint self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_CartesianPoint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_CartesianPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Distance(self, *args):
        """
        Distance(Handle_Geom2d_CartesianPoint self, Handle_Geom2d_Point Other) -> Standard_Real

        computes the distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Handle_Geom2d_CartesianPoint self, Handle_Geom2d_Point Other) -> Standard_Real

        computes the square distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_SquareDistance(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_CartesianPoint self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_CartesianPoint self, gp_Vec2d V)
        Translate(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_CartesianPoint self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_CartesianPoint self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_CartesianPoint self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_CartesianPoint self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_CartesianPoint self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_CartesianPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_CartesianPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_CartesianPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_CartesianPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_CartesianPoint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_CartesianPoint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_CartesianPoint self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_CartesianPoint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_CartesianPoint_DecrementRefCounter(self, *args)

Handle_Geom2d_CartesianPoint_swigregister = _Geom2d.Handle_Geom2d_CartesianPoint_swigregister
Handle_Geom2d_CartesianPoint_swigregister(Handle_Geom2d_CartesianPoint)

def Handle_Geom2d_CartesianPoint_DownCast(thing):
    return _Geom2d.Handle_Geom2d_CartesianPoint_DownCast(thing)
Handle_Geom2d_CartesianPoint_DownCast = _Geom2d.Handle_Geom2d_CartesianPoint_DownCast

class Handle_Geom2d_UndefinedValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_UndefinedValue self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_UndefinedValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_UndefinedValue self, Geom2d_UndefinedValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_UndefinedValue self, Handle_Geom2d_UndefinedValue theHandle) -> Handle_Geom2d_UndefinedValue
        assign(Handle_Geom2d_UndefinedValue self, Geom2d_UndefinedValue thePtr) -> Handle_Geom2d_UndefinedValue
        assign(Handle_Geom2d_UndefinedValue self, Handle_Geom2d_UndefinedValue theHandle) -> Handle_Geom2d_UndefinedValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_UndefinedValue self) -> Geom2d_UndefinedValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_UndefinedValue self) -> Geom2d_UndefinedValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_UndefinedValue self) -> Geom2d_UndefinedValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_UndefinedValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_UndefinedValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_UndefinedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_UndefinedValue_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_UndefinedValue

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Geom2d_UndefinedValue self, Standard_CString const theMessage) -> Handle_Geom2d_UndefinedValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_UndefinedValue

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_UndefinedValue self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_UndefinedValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_UndefinedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Geom2d_UndefinedValue self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Geom2d_UndefinedValue self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Geom2d_UndefinedValue self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Geom2d_UndefinedValue self)
        Reraise(Handle_Geom2d_UndefinedValue self, Standard_CString const aMessage)
        Reraise(Handle_Geom2d_UndefinedValue self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Geom2d_UndefinedValue self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Geom2d_UndefinedValue self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_UndefinedValue self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_UndefinedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_UndefinedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_UndefinedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_UndefinedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_UndefinedValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_UndefinedValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_UndefinedValue self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_UndefinedValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_UndefinedValue_DecrementRefCounter(self, *args)

Handle_Geom2d_UndefinedValue_swigregister = _Geom2d.Handle_Geom2d_UndefinedValue_swigregister
Handle_Geom2d_UndefinedValue_swigregister(Handle_Geom2d_UndefinedValue)

def Handle_Geom2d_UndefinedValue_DownCast(thing):
    return _Geom2d.Handle_Geom2d_UndefinedValue_DownCast(thing)
Handle_Geom2d_UndefinedValue_DownCast = _Geom2d.Handle_Geom2d_UndefinedValue_DownCast

class Geom2d_AxisPlacement(Geom2d_Geometry):
    """
    Describes an axis in 2D space.
    An axis is defined by:
    - its origin, also termed the "Location point" of the axis,
    - its unit vector, termed the "Direction" of the axis.
    Note: Geom2d_AxisPlacement axes provide the
    same kind of "geometric" services as gp_Ax2d axes
    but have more complex data structures. The
    geometric objects provided by the Geom2d package
    use gp_Ax2d objects to include axes in their data
    structures, or to define an axis of symmetry or axis of rotation.
    Geom2d_AxisPlacement axes are used in a context
    where they can be shared by several objects
    contained inside a common data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_AxisPlacement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_AxisPlacement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_AxisPlacement self, gp_Ax2d A) -> Geom2d_AxisPlacement
        __init__(Geom2d_AxisPlacement self, gp_Pnt2d P, gp_Dir2d V) -> Geom2d_AxisPlacement

        Constructs an axis from a given origin P and unit vector V.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        this = _Geom2d.new_Geom2d_AxisPlacement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """Reverse(Geom2d_AxisPlacement self)"""
        return _Geom2d.Geom2d_AxisPlacement_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Geom2d_AxisPlacement self) -> Handle_Geom2d_AxisPlacement

        Reverses the unit vector of this axis.
        Note:
        - Reverse assigns the result to this axis, while
        - Reversed creates a new one.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_AxisPlacement

        """
        return _Geom2d.Geom2d_AxisPlacement_Reversed(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Geom2d_AxisPlacement self, gp_Ax2d A)

        Changes the complete definition of the axis placement.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_AxisPlacement_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom2d_AxisPlacement self, gp_Dir2d V)

        Changes the "Direction" of the axis placement.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Geom2d_AxisPlacement_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom2d_AxisPlacement self, gp_Pnt2d P)

        Changes the "Location" point (origin) of the axis placement.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_AxisPlacement_SetLocation(self, *args)


    def Angle(self, *args):
        """
        Angle(Geom2d_AxisPlacement self, Handle_Geom2d_AxisPlacement Other) -> Standard_Real

        Computes the angle between the "Direction" of
        two axis placement in radians.
        The result is comprised between -Pi and Pi.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_AxisPlacement
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_AxisPlacement_Angle(self, *args)


    def Ax2d(self, *args):
        """
        Ax2d(Geom2d_AxisPlacement self) -> gp_Ax2d

        Converts this axis into a gp_Ax2d axis.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Geom2d_AxisPlacement_Ax2d(self, *args)


    def Direction(self, *args):
        """
        Direction(Geom2d_AxisPlacement self) -> gp_Dir2d

        Returns the "Direction" of <me>.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Geom2d_AxisPlacement_Direction(self, *args)


    def Location(self, *args):
        """
        Location(Geom2d_AxisPlacement self) -> gp_Pnt2d

        Returns the "Location" point (origin) of the axis placement.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_AxisPlacement_Location(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_AxisPlacement self, gp_Trsf2d T)

        Applies the transformation T to this axis.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_AxisPlacement_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_AxisPlacement self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this axis.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_AxisPlacement_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_AxisPlacement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_AxisPlacement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_AxisPlacement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_AxisPlacement
Geom2d_AxisPlacement_swigregister = _Geom2d.Geom2d_AxisPlacement_swigregister
Geom2d_AxisPlacement_swigregister(Geom2d_AxisPlacement)

def Geom2d_AxisPlacement_get_type_name(*args):
    """
    Geom2d_AxisPlacement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_AxisPlacement_get_type_name(*args)

def Geom2d_AxisPlacement_get_type_descriptor(*args):
    """
    Geom2d_AxisPlacement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_AxisPlacement_get_type_descriptor(*args)

class Handle_Geom2d_BezierCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_BezierCurve self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_BezierCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_BezierCurve self, Geom2d_BezierCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_BezierCurve self, Handle_Geom2d_BezierCurve theHandle) -> Handle_Geom2d_BezierCurve
        assign(Handle_Geom2d_BezierCurve self, Geom2d_BezierCurve thePtr) -> Handle_Geom2d_BezierCurve
        assign(Handle_Geom2d_BezierCurve self, Handle_Geom2d_BezierCurve theHandle) -> Handle_Geom2d_BezierCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_BezierCurve self) -> Geom2d_BezierCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_BezierCurve self) -> Geom2d_BezierCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_BezierCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_BezierCurve self) -> Geom2d_BezierCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_BezierCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_BezierCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_BezierCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_BezierCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_BezierCurve_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_BezierCurve

    def Increase(self, *args):
        """
        Increase(Handle_Geom2d_BezierCurve self, Standard_Integer const Degree)

        Increases the degree of a bezier curve. Degree is the new
        degree of <me>.
        raises ConstructionError if Degree is greater than MaxDegree or lower than 2
        or lower than the initial degree of <me>.

        :type Degree: int

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Increase(self, *args)


    def InsertPoleAfter(self, *args):
        """
        InsertPoleAfter(Handle_Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        Inserts a pole with its weight in the set of poles after the
        pole of range Index. If the curve was non rational it can
        become rational if all the weights are not identical.
        Raised if Index is not in the range [0, NbPoles]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_InsertPoleAfter(self, *args)


    def InsertPoleBefore(self, *args):
        """
        InsertPoleBefore(Handle_Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        Inserts a pole with its weight in the set of poles after
        the pole of range Index. If the curve was non rational it
        can become rational if all the weights are not identical.
        Raised if Index is not in the range [1, NbPoles+1]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_InsertPoleBefore(self, *args)


    def RemovePole(self, *args):
        """
        RemovePole(Handle_Geom2d_BezierCurve self, Standard_Integer const Index)

        Removes the pole of range Index.
        If the curve was rational it can become non rational.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_RemovePole(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_BezierCurve self)

        Reverses the direction of parametrization of <me>
        Value (NewU) =  Value (1 - OldU)


        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_BezierCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns 1-U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Geom2d_BezierCurve self, Standard_Real const U1, Standard_Real const U2)

        Segments the curve between U1 and U2 which can be out
        of the bounds of the curve. The curve is oriented from U1
        to U2.
        The control points are modified, the first and the last point
        are not the same but the parametrization range is [0, 1]
        else it could not be a Bezier curve.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.

        :type U1: float
        :type U2: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Segment(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P)
        SetPole(Handle_Geom2d_BezierCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight)

        Substitutes the pole and the weights of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Geom2d_BezierCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight of the pole of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_SetWeight(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_BezierCurve self) -> Standard_Boolean

        Returns True if the distance between the first point
        and the last point of the curve is lower or equal to
        the Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_BezierCurve self, Standard_Integer const N) -> Standard_Boolean

        Continuity of the curve, returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_BezierCurve self) -> Standard_Boolean

        Returns False. A BezierCurve cannot be periodic in this
        package

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Geom2d_BezierCurve self) -> Standard_Boolean

        Returns false if all the weights are identical. The tolerance
        criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_BezierCurve self) -> GeomAbs_Shape

        Returns GeomAbs_CN, which is the continuity of any Bezier curve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Geom2d_BezierCurve self) -> Standard_Integer

        Returns the polynomial degree of the curve. It is the number
        of poles less one.  In this package the Degree of a Bezier
        curve cannot be greater than "MaxDegree".

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_BezierCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_BezierCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For this Bezier curve, computes
        - the point P of parameter U, or
        - the point P and one or more of the following values:
        - V1, the first derivative vector,
        - V2, the second derivative vector,
        - V3, the third derivative vector.
        Note: the parameter U can be outside the bounds of the curve.
        Raises RangeError if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_DN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom2d_BezierCurve self) -> gp_Pnt2d

        Returns the end point or start point of this Bezier curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_BezierCurve self) -> Standard_Real

        Returns the value of the first  parameter of this
        Bezier curve. This is  0.0, which gives the start point of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_BezierCurve self) -> Standard_Real

        Returns the value of the last  parameter of this
        Bezier curve. This is  1.0, which gives the end point of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_LastParameter(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Geom2d_BezierCurve self) -> Standard_Integer

        Returns the number of poles for this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Geom2d.Handle_Geom2d_BezierCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns all the poles of the curve.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Geom2d.Handle_Geom2d_BezierCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom2d_BezierCurve self) -> gp_Pnt2d

        Returns Value (U=1), it is the first control point
        of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Handle_Geom2d_BezierCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Geom2d_BezierCurve self, NCollection_Array1_Standard_Real W)
        Weights(Handle_Geom2d_BezierCurve self) -> NCollection_Array1_Standard_Real

        Returns all the weights of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_BezierCurve self, gp_Trsf2d T)

        Applies the transformation T to this Bezier curve.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Transform(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Geom2d_BezierCurve self) -> Standard_Integer

        Returns the value of the maximum polynomial degree of a
        BezierCurve. This value is 25.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_MaxDegree(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Geom2d_BezierCurve self, Standard_Real const ToleranceUV)

        Computes for this Bezier curve the parametric
        tolerance UTolerance for a given tolerance
        Tolerance3D (relative to dimensions in the plane).
        If f(t) is the equation of this Bezier curve,
        UTolerance ensures that
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < ToleranceUV

        :type ToleranceUV: float
        :type UTolerance: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_BezierCurve self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this Bezier curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_BezierCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_BezierCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_BezierCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_BezierCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_BezierCurve self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_BezierCurve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_BezierCurve self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_BezierCurve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_BezierCurve self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_BezierCurve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_BezierCurve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_BezierCurve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_BezierCurve self, gp_Vec2d V)
        Translate(Handle_Geom2d_BezierCurve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_BezierCurve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_BezierCurve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_BezierCurve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_BezierCurve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_BezierCurve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_BezierCurve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_BezierCurve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_BezierCurve self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_BezierCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_BezierCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_BezierCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_BezierCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_BezierCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_BezierCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_BezierCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_BezierCurve self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_BezierCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_BezierCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BezierCurve_DecrementRefCounter(self, *args)

Handle_Geom2d_BezierCurve_swigregister = _Geom2d.Handle_Geom2d_BezierCurve_swigregister
Handle_Geom2d_BezierCurve_swigregister(Handle_Geom2d_BezierCurve)

def Handle_Geom2d_BezierCurve_DownCast(thing):
    return _Geom2d.Handle_Geom2d_BezierCurve_DownCast(thing)
Handle_Geom2d_BezierCurve_DownCast = _Geom2d.Handle_Geom2d_BezierCurve_DownCast

class Handle_Geom2d_VectorWithMagnitude(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_VectorWithMagnitude self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_VectorWithMagnitude self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_VectorWithMagnitude self, Geom2d_VectorWithMagnitude thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_VectorWithMagnitude theHandle) -> Handle_Geom2d_VectorWithMagnitude
        assign(Handle_Geom2d_VectorWithMagnitude self, Geom2d_VectorWithMagnitude thePtr) -> Handle_Geom2d_VectorWithMagnitude
        assign(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_VectorWithMagnitude theHandle) -> Handle_Geom2d_VectorWithMagnitude

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_VectorWithMagnitude self) -> Geom2d_VectorWithMagnitude

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_VectorWithMagnitude self) -> Geom2d_VectorWithMagnitude

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_VectorWithMagnitude self) -> Geom2d_VectorWithMagnitude

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_VectorWithMagnitude___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_VectorWithMagnitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_VectorWithMagnitude_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_VectorWithMagnitude

    def SetCoord(self, *args):
        """
        SetCoord(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const X, Standard_Real const Y)

        Set <me> to X, Y coordinates.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_SetCoord(self, *args)


    def SetVec2d(self, *args):
        """
        SetVec2d(Handle_Geom2d_VectorWithMagnitude self, gp_Vec2d V)

        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_SetVec2d(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const X)

        Changes the X coordinate of <me>.

        :type X: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const Y)

        Changes the Y coordinate of <me>

        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_SetY(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Real

        Returns the magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_SquareMagnitude(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        Adds the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        Adds the vector Other to <me>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___add__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the cross product  between <me> and Other
        <me> ^ Other. A new vector is returned.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Standard_Real

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___xor__(self, *args)


    def Divide(self, *args):
        """
        Divide(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const Scalar)

        Divides <me> by a scalar.

        :type Scalar: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Divide(self, *args)


    def __itruediv__(self, *args):
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom2d_VectorWithMagnitude

        Divides <me> by a scalar. A new vector is returned.

        :type Scalar: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Divided(self, *args)


    def __truediv__(self, *args):
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___truediv__(self, *args)
    __div__ = __truediv__



    def Multiplied(self, *args):
        """
        Multiplied(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom2d_VectorWithMagnitude

        Computes the product of the vector <me> by a scalar.
        A new vector is returned.

        -C++: alias operator *
        Collision with same operator defined for the class Vector!

        :type Scalar: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Multiplied(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const Scalar)

        Computes the product of the vector <me> by a scalar.

        :type Scalar: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(Handle_Geom2d_VectorWithMagnitude self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___imul__(self, *args)


    def Normalize(self, *args):
        """
        Normalize(Handle_Geom2d_VectorWithMagnitude self)

        Normalizes <me>.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.


        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(Handle_Geom2d_VectorWithMagnitude self) -> Handle_Geom2d_VectorWithMagnitude

        Returns a copy of <me> Normalized.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Normalized(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        Subtracts the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other)

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        Subtracts the vector Other to <me>. A new vector is returned.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Handle_Geom2d_VectorWithMagnitude

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_VectorWithMagnitude

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude___sub__(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_VectorWithMagnitude self, gp_Trsf2d T)

        Applies the transformation T to this vector.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_VectorWithMagnitude self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this vector.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_VectorWithMagnitude self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_VectorWithMagnitude_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_VectorWithMagnitude_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_VectorWithMagnitude self)

        Reverses the vector <me>.


        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_VectorWithMagnitude self) -> Handle_Geom2d_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The orientation is from this
        vector to vector Other.
        Raises VectorWithNullMagnitude if one of the two vectors is a vector with
        null magnitude because the angular value is indefinite.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Angle(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom2d_VectorWithMagnitude self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Coord(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Y(self, *args)


    def Dot(self, *args):
        """
        Dot(Handle_Geom2d_VectorWithMagnitude self, Handle_Geom2d_Vector Other) -> Standard_Real

        Returns the scalar product of 2 Vectors.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Dot(self, *args)


    def Vec2d(self, *args):
        """
        Vec2d(Handle_Geom2d_VectorWithMagnitude self) -> gp_Vec2d

        Returns a non persistent copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Vec2d(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_VectorWithMagnitude self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_VectorWithMagnitude self, gp_Vec2d V)
        Translate(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_VectorWithMagnitude self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_VectorWithMagnitude self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_VectorWithMagnitude self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_VectorWithMagnitude self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_VectorWithMagnitude self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_VectorWithMagnitude self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_VectorWithMagnitude self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_VectorWithMagnitude self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_VectorWithMagnitude self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_VectorWithMagnitude self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_VectorWithMagnitude self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_VectorWithMagnitude_DecrementRefCounter(self, *args)

Handle_Geom2d_VectorWithMagnitude_swigregister = _Geom2d.Handle_Geom2d_VectorWithMagnitude_swigregister
Handle_Geom2d_VectorWithMagnitude_swigregister(Handle_Geom2d_VectorWithMagnitude)

def Handle_Geom2d_VectorWithMagnitude_DownCast(thing):
    return _Geom2d.Handle_Geom2d_VectorWithMagnitude_DownCast(thing)
Handle_Geom2d_VectorWithMagnitude_DownCast = _Geom2d.Handle_Geom2d_VectorWithMagnitude_DownCast

class Geom2d_Circle(Geom2d_Conic):
    """
    Describes a circle in the plane (2D space).
    A circle is defined by its radius and, as with any conic
    curve, is positioned in the plane with a coordinate
    system (gp_Ax22d object) where the origin is the
    center of the circle.
    The coordinate system is the local coordinate
    system of the circle.
    The orientation (direct or indirect) of the local
    coordinate system gives an explicit orientation to the
    circle, determining the direction in which the
    parameter increases along the circle.
    The Geom2d_Circle circle is parameterized by an angle:
    P(U) = O + R*Cos(U)*XDir + R*Sin(U)*YDir
    where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - R is the radius of the circle.
    The "X Axis" of the local coordinate system therefore
    defines the origin of the parameter of the circle. The
    parameter is the angle with this "X Direction".
    A circle is a closed and periodic curve. The period is
    2.*Pi and the parameter range is [ 0,2.*Pi [.
    See Also
    GCE2d_MakeCircle which provides functions for
    more complex circle constructions
    gp_Ax22d and  gp_Circ2d for an equivalent, non-parameterized data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_Circle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_Circle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_Circle self, gp_Circ2d C) -> Geom2d_Circle
        __init__(Geom2d_Circle self, gp_Ax2d A, Standard_Real const Radius, Standard_Boolean const Sense) -> Geom2d_Circle
        __init__(Geom2d_Circle self, gp_Ax22d A, Standard_Real const Radius) -> Geom2d_Circle

        Constructs a circle
        of radius Radius, where the coordinate system A
        locates the circle and defines its orientation in the plane such that:
        - the center of the circle is the origin of A,
        - the orientation (direct or indirect) of A gives the
        orientation of the circle.

        :type A: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float

        """
        this = _Geom2d.new_Geom2d_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCirc2d(self, *args):
        """
        SetCirc2d(Geom2d_Circle self, gp_Circ2d C)

        Converts the gp_Circ2d circle C into this circle.

        :type C: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2d.Geom2d_Circle_SetCirc2d(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Geom2d_Circle self, Standard_Real const R)

        :type R: float

        """
        return _Geom2d.Geom2d_Circle_SetRadius(self, *args)


    def Circ2d(self, *args):
        """
        Circ2d(Geom2d_Circle self) -> gp_Circ2d

        Returns the non persistent circle from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2d.Geom2d_Circle_Circ2d(self, *args)


    def Radius(self, *args):
        """
        Radius(Geom2d_Circle self) -> Standard_Real

        Returns the radius of this circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Circle_Radius(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_Circle self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed circle for
        the point of parameter U on this circle.
        For a circle, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Circle_ReversedParameter(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom2d_Circle self) -> Standard_Real

        Returns 0., which is the eccentricity of any circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Circle_Eccentricity(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_Circle self) -> Standard_Real

        Returns 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Circle_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_Circle self) -> Standard_Real

        Returns 2*PI.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_Circle_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_Circle self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Circle_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_Circle self) -> Standard_Boolean

        returns True. The period of a circle is 2.*Pi.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_Circle_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P = C + R * Cos (U) * XDir + R * Sin (U) * YDir
        where C is the center of the circle , XDir the XDirection and
        YDir the YDirection of the circle's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_Circle_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Circle_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Circle_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter u, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Circle_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_Circle self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this circle, computes
        the vector corresponding to the Nth derivative.
        Exceptions: Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_Circle_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_Circle self, gp_Trsf2d T)

        Applies the transformation T to this circle.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_Circle_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_Circle self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this circle.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_Circle_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_Circle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_Circle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_Circle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_Circle
Geom2d_Circle_swigregister = _Geom2d.Geom2d_Circle_swigregister
Geom2d_Circle_swigregister(Geom2d_Circle)

def Geom2d_Circle_get_type_name(*args):
    """
    Geom2d_Circle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_Circle_get_type_name(*args)

def Geom2d_Circle_get_type_descriptor(*args):
    """
    Geom2d_Circle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_Circle_get_type_descriptor(*args)

class Handle_Geom2d_Line(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Line self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Line_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Line self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Line_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Line self, Geom2d_Line thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Line_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Line self, Handle_Geom2d_Line theHandle) -> Handle_Geom2d_Line
        assign(Handle_Geom2d_Line self, Geom2d_Line thePtr) -> Handle_Geom2d_Line
        assign(Handle_Geom2d_Line self, Handle_Geom2d_Line theHandle) -> Handle_Geom2d_Line

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Line_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Line self) -> Geom2d_Line

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Line_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Line self) -> Geom2d_Line

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Line___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Line self) -> Geom2d_Line

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Line___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Line___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Line___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Line_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Line

    def SetLin2d(self, *args):
        """
        SetLin2d(Handle_Geom2d_Line self, gp_Lin2d L)

        Set <me> so that <me> has the same geometric properties as L.

        :type L: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2d.Handle_Geom2d_Line_SetLin2d(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom2d_Line self, gp_Dir2d V)

        changes the direction of the line.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Handle_Geom2d_Line_SetDirection(self, *args)


    def Direction(self, *args):
        """
        changes the direction of the line.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _Geom2d.Handle_Geom2d_Line_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_Line self, gp_Pnt2d P)

        Changes the "Location" point (origin) of the line.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Line_SetLocation(self, *args)


    def Location(self, *args):
        """
        Changes the "Location" point (origin) of the line.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Geom2d.Handle_Geom2d_Line_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom2d_Line self, gp_Ax2d A)

        Changes the "Location" and a the "Direction" of <me>.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Line_SetPosition(self, *args)


    def Position(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        res = _Geom2d.Handle_Geom2d_Line_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Lin2d(self, *args):
        """
        Lin2d(Handle_Geom2d_Line self) -> gp_Lin2d

        Returns non persistent line from gp with the same geometric
        properties as <me>

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2d.Handle_Geom2d_Line_Lin2d(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Line self)

        Changes the orientation of this line. As a result, the
        unit vector of the positioning axis of this line is reversed.


        """
        return _Geom2d.Handle_Geom2d_Line_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Line self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed line for the
        point of parameter U on this line.
        For a line, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Line self) -> Standard_Real

        Returns RealFirst  from  Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Line self) -> Standard_Real

        Returns RealLast  from Standard

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Line self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Line_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Line self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Line_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Line self) -> GeomAbs_Shape

        Returns GeomAbs_CN, which is the global continuity of any line.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Line_Continuity(self, *args)


    def Distance(self, *args):
        """
        Distance(Handle_Geom2d_Line self, gp_Pnt2d P) -> Standard_Real

        Computes the distance between <me> and the point P.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_Distance(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Line self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Line_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Line self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P (U) = O + U * Dir where O is the "Location" point of the
        line and Dir the direction of the line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Line_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Line self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter u and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Line_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Line self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2. V2 is a vector with null magnitude
        for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Line_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Line self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        V2 and V3 are vectors with null magnitude for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Line_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Line self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this line, computes
        the vector corresponding to the Nth derivative.
        Note: if N is greater than or equal to 2, the result is a
        vector with null magnitude.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Line_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Line self, gp_Trsf2d T)

        Applies the transformation T to this line.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Line_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Line self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the line transformed by
        T for the point of parameter U on this line.
        For a line, the returned value is equal to U multiplied
        by the scale factor of transformation T.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Line self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this line when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this line
        and the parameter of the transformed point on the
        new line transformed by T.
        For a line, the returned value is the scale factor of the transformation T.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Line self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this line.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Line_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Line self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Line_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Line_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Line self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Line_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Line self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Line_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Line self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Line_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Line self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Line self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Line_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Line self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Line_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Line self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Line_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Line self, gp_Vec2d V)
        Translate(Handle_Geom2d_Line self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Line_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Line self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Line self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Line_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Line self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Line_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Line self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Line_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Line self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Line_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Line self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Line self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Line_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Line self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Line_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Line_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Line_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Line self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Line_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Line self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Line_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Line self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Line_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Line self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Line_DecrementRefCounter(self, *args)

Handle_Geom2d_Line_swigregister = _Geom2d.Handle_Geom2d_Line_swigregister
Handle_Geom2d_Line_swigregister(Handle_Geom2d_Line)

def Handle_Geom2d_Line_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Line_DownCast(thing)
Handle_Geom2d_Line_DownCast = _Geom2d.Handle_Geom2d_Line_DownCast

class Handle_Geom2d_Conic(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Conic self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Conic_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Conic self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Conic_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Conic self, Geom2d_Conic thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Conic_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Conic self, Handle_Geom2d_Conic theHandle) -> Handle_Geom2d_Conic
        assign(Handle_Geom2d_Conic self, Geom2d_Conic thePtr) -> Handle_Geom2d_Conic
        assign(Handle_Geom2d_Conic self, Handle_Geom2d_Conic theHandle) -> Handle_Geom2d_Conic

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Conic_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Conic self) -> Geom2d_Conic

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Conic_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Conic self) -> Geom2d_Conic

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Conic___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Conic self) -> Geom2d_Conic

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Conic___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Conic___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Conic___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Conic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Conic_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Conic

    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom2d_Conic self, gp_Ax22d A)

        Modifies this conic, redefining its local coordinate system
        partially, by assigning P as its origin

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _Geom2d.Handle_Geom2d_Conic_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(Handle_Geom2d_Conic self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Conic_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(Handle_Geom2d_Conic self, gp_Ax2d A)

        Assigns the origin and unit vector of axis A to the
        origin of the local coordinate system of this conic and either:
        - its "X Direction", or
        - its "Y Direction".
        The other unit vector of the local coordinate system
        of this conic is recomputed normal to A, without
        changing the orientation of the local coordinate
        system (right-handed or left-handed).

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Conic_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_Conic self, gp_Pnt2d P)

        Modifies this conic, redefining its local coordinate
        system fully, by assigning A as this coordinate system.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Conic_SetLocation(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Handle_Geom2d_Conic self) -> gp_Ax2d

        Returns the "XAxis" of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis and the "Yaxis" define the local coordinate system
        of the conic.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Conic_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom2d_Conic self) -> gp_Ax2d

        Returns the "YAxis" of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Conic_YAxis(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom2d_Conic self) -> Standard_Real

        returns the eccentricity value of the conic e.
        e = 0 for a circle
        0 < e < 1 for an ellipse  (e = 0 if MajorRadius = MinorRadius)
        e > 1 for a hyperbola
        e = 1 for a parabola

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_Eccentricity(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom2d_Conic self) -> gp_Pnt2d

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Conic_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _Geom2d.Handle_Geom2d_Conic_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Conic self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom2d.Handle_Geom2d_Conic_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Conic self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_ReversedParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Conic self) -> GeomAbs_Shape

        Returns GeomAbs_CN which is the global continuity of any conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Conic_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Conic self, Standard_Integer const N) -> Standard_Boolean

        Returns True, the order of continuity of a conic is infinite.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Conic_IsCN(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Conic self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Conic_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Conic_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Conic_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Conic self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Conic self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Conic self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Conic_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Conic self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Conic self) -> Standard_Real

        Value of the last parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Conic self) -> Standard_Boolean

        Returns true if the curve is closed.
        Examples :
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Conic_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Conic self) -> Standard_Boolean

        Returns true if the parameter of the curve is periodic.
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Conic_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Conic self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Conic_Period(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Conic self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Conic_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Conic self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Conic_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Conic self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Conic_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Conic self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Conic_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Conic self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this curve, computes
        the vector corresponding to the Nth derivative.
        Exceptions
        StdFail_UndefinedDerivative if:
        - the continuity of the curve is not "CN", or
        - the derivative vector cannot be computed easily;
        this is the case with specific types of curve (for
        example, a rational BSpline curve where N is greater than 3).
        Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Conic_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Conic self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Conic_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Conic self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Conic self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Conic_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Conic self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Conic_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Conic self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Conic_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Conic self, gp_Vec2d V)
        Translate(Handle_Geom2d_Conic self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Conic_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Conic self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Conic_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Conic self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Conic self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Conic_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Conic self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Conic_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Conic self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Conic_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Conic self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Conic_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Conic self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Conic self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Conic_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Conic self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Conic_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Conic self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Conic_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Conic self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Conic self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Conic_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Conic self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Conic self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Conic_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Conic self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Conic_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Conic self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Conic_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Conic self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Conic_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Conic self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Conic_DecrementRefCounter(self, *args)

Handle_Geom2d_Conic_swigregister = _Geom2d.Handle_Geom2d_Conic_swigregister
Handle_Geom2d_Conic_swigregister(Handle_Geom2d_Conic)

def Handle_Geom2d_Conic_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Conic_DownCast(thing)
Handle_Geom2d_Conic_DownCast = _Geom2d.Handle_Geom2d_Conic_DownCast

class Handle_Geom2d_Ellipse(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Ellipse self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Ellipse_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Ellipse self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Ellipse_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Ellipse self, Geom2d_Ellipse thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Ellipse_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Ellipse self, Handle_Geom2d_Ellipse theHandle) -> Handle_Geom2d_Ellipse
        assign(Handle_Geom2d_Ellipse self, Geom2d_Ellipse thePtr) -> Handle_Geom2d_Ellipse
        assign(Handle_Geom2d_Ellipse self, Handle_Geom2d_Ellipse theHandle) -> Handle_Geom2d_Ellipse

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Ellipse_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Ellipse self) -> Geom2d_Ellipse

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Ellipse_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Ellipse self) -> Geom2d_Ellipse

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Ellipse___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Ellipse self) -> Geom2d_Ellipse

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Ellipse___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Ellipse___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Ellipse___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Ellipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Ellipse_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Ellipse

    def SetElips2d(self, *args):
        """
        SetElips2d(Handle_Geom2d_Ellipse self, gp_Elips2d E)

        Converts the gp_Elips2d ellipse E into this ellipse.

        :type E: OCC.wrapper.gp.gp_Elips2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetElips2d(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Handle_Geom2d_Ellipse self, Standard_Real const MajorRadius)

        Assigns a value to the major radius of this ellipse.
        Exceptions
        Standard_ConstructionError if:
        - the major radius of this ellipse becomes less than
        the minor radius, or
        - MinorRadius is less than 0.

        :type MajorRadius: float

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Handle_Geom2d_Ellipse self, Standard_Real const MinorRadius)

        Assigns a value to the minor radius of this ellipse.
        Exceptions
        Standard_ConstructionError if:
        - the major radius of this ellipse becomes less than
        the minor radius, or
        - MinorRadius is less than 0.

        :type MinorRadius: float

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetMinorRadius(self, *args)


    def Elips2d(self, *args):
        """
        Elips2d(Handle_Geom2d_Ellipse self) -> gp_Elips2d

        Converts this ellipse into a gp_Elips2d ellipse.

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Elips2d(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Ellipse self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed ellipse for
        the point of parameter U on this ellipse.
        For an ellipse, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_ReversedParameter(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Handle_Geom2d_Ellipse self) -> gp_Ax2d

        Computes the directrices of this ellipse.
        This directrix is the line normal to the XAxis of the ellipse
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the ellipse, where e is the eccentricity of
        the ellipse.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the "Location" point
        of the directrix1. This point is on the positive side of
        the "XAxis".
        Raises ConstructionError if Eccentricity = 0.0. (The ellipse degenerates
        into a circle)

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Handle_Geom2d_Ellipse self) -> gp_Ax2d

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the ellipse.
        Raises ConstructionError if Eccentricity = 0.0. (The ellipse degenerates into a
        circle).

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom2d_Ellipse self) -> Standard_Real

        Returns the eccentricity of the ellipse  between 0.0 and 1.0
        If f is the distance between the center of the ellipse and
        the Focus1 then the eccentricity e = f / MajorRadius.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Handle_Geom2d_Ellipse self) -> Standard_Real

        Computes the focal distance. The focal distance is the distance between the center
        and a focus of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Handle_Geom2d_Ellipse self) -> gp_Pnt2d

        Returns the first focus of the ellipse. This focus is on the
        positive side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Handle_Geom2d_Ellipse self) -> gp_Pnt2d

        Returns the second focus of the ellipse. This focus is on
        the negative side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Handle_Geom2d_Ellipse self) -> Standard_Real

        Returns the major radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Handle_Geom2d_Ellipse self) -> Standard_Real

        Returns the minor radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_MinorRadius(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Geom2d_Ellipse self) -> Standard_Real

        Computes the parameter of this ellipse. This value is
        given by the formula p = (1 - e * e) * MajorRadius where e is the eccentricity
        of the ellipse.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Parameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Ellipse self) -> Standard_Real

        Returns the value of the first parameter of this
        ellipse. This is  0.0, which gives the start point of this ellipse.
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Ellipse self) -> Standard_Real

        Returns the value of the  last parameter of this
        ellipse. This is  2.*Pi, which gives the end point of this ellipse.
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Ellipse_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Ellipse_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cos (U) * XDir + MinorRadius * Sin (U) * YDir
        where C is the center of the ellipse , XDir the direction of
        the "XAxis" and "YDir" the "YAxis" of the ellipse.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U. The vectors V1 and V2
        are the first and second derivatives at this point.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Ellipse self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Ellipse self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this ellipse,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Ellipse self, gp_Trsf2d T)

        Applies the transformation T to this ellipse.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Ellipse self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this ellipse.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Ellipse self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Ellipse_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Ellipse_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Ellipse_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom2d_Ellipse self, gp_Ax22d A)

        Modifies this conic, redefining its local coordinate system
        partially, by assigning P as its origin

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(Handle_Geom2d_Ellipse self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(Handle_Geom2d_Ellipse self, gp_Ax2d A)

        Assigns the origin and unit vector of axis A to the
        origin of the local coordinate system of this conic and either:
        - its "X Direction", or
        - its "Y Direction".
        The other unit vector of the local coordinate system
        of this conic is recomputed normal to A, without
        changing the orientation of the local coordinate
        system (right-handed or left-handed).

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_Ellipse self, gp_Pnt2d P)

        Modifies this conic, redefining its local coordinate
        system fully, by assigning A as this coordinate system.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_SetLocation(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Handle_Geom2d_Ellipse self) -> gp_Ax2d

        Returns the "XAxis" of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis and the "Yaxis" define the local coordinate system
        of the conic.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom2d_Ellipse self) -> gp_Ax2d

        Returns the "YAxis" of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_YAxis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom2d_Ellipse self) -> gp_Pnt2d

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _Geom2d.Handle_Geom2d_Ellipse_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Ellipse self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom2d.Handle_Geom2d_Ellipse_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Ellipse self) -> GeomAbs_Shape

        Returns GeomAbs_CN which is the global continuity of any conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Ellipse self, Standard_Integer const N) -> Standard_Boolean

        Returns True, the order of continuity of a conic is infinite.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Ellipse_IsCN(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Ellipse self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Ellipse self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Ellipse self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Ellipse self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Ellipse self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Ellipse self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Ellipse self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Ellipse self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Ellipse self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Ellipse self, gp_Vec2d V)
        Translate(Handle_Geom2d_Ellipse self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Ellipse self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Ellipse self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Ellipse self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Ellipse self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Ellipse self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Ellipse self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Ellipse self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Ellipse_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Ellipse self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Ellipse_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Ellipse self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Ellipse self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Ellipse_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Ellipse self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Ellipse self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Ellipse_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Ellipse self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Ellipse_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Ellipse self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Ellipse_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Ellipse self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Ellipse_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Ellipse self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Ellipse_DecrementRefCounter(self, *args)

Handle_Geom2d_Ellipse_swigregister = _Geom2d.Handle_Geom2d_Ellipse_swigregister
Handle_Geom2d_Ellipse_swigregister(Handle_Geom2d_Ellipse)

def Handle_Geom2d_Ellipse_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Ellipse_DownCast(thing)
Handle_Geom2d_Ellipse_DownCast = _Geom2d.Handle_Geom2d_Ellipse_DownCast

class Handle_Geom2d_Vector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Vector self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Vector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Vector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Vector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Vector self, Geom2d_Vector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Vector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Vector self, Handle_Geom2d_Vector theHandle) -> Handle_Geom2d_Vector
        assign(Handle_Geom2d_Vector self, Geom2d_Vector thePtr) -> Handle_Geom2d_Vector
        assign(Handle_Geom2d_Vector self, Handle_Geom2d_Vector theHandle) -> Handle_Geom2d_Vector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Vector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Vector self) -> Geom2d_Vector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Vector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Vector self) -> Geom2d_Vector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Vector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Vector self) -> Geom2d_Vector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Vector___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Vector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Vector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Vector_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Vector

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Vector self)

        Reverses the vector <me>.


        """
        return _Geom2d.Handle_Geom2d_Vector_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Vector self) -> Handle_Geom2d_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Vector

        """
        return _Geom2d.Handle_Geom2d_Vector_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom2d_Vector self, Handle_Geom2d_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The orientation is from this
        vector to vector Other.
        Raises VectorWithNullMagnitude if one of the two vectors is a vector with
        null magnitude because the angular value is indefinite.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_Angle(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom2d_Vector self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_Vector_Coord(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Handle_Geom2d_Vector self) -> Standard_Real

        Returns the  Magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Handle_Geom2d_Vector self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_SquareMagnitude(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom2d_Vector self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom2d_Vector self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_Y(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Handle_Geom2d_Vector self, Handle_Geom2d_Vector Other) -> Standard_Real

        Cross product of <me> with the vector <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_Crossed(self, *args)


    def Dot(self, *args):
        """
        Dot(Handle_Geom2d_Vector self, Handle_Geom2d_Vector Other) -> Standard_Real

        Returns the scalar product of 2 Vectors.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Vector_Dot(self, *args)


    def Vec2d(self, *args):
        """
        Vec2d(Handle_Geom2d_Vector self) -> gp_Vec2d

        Returns a non persistent copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Vector_Vec2d(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Vector self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Vector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Vector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Vector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Vector self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Vector self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Vector_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Vector self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Vector_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Vector self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Vector_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Vector self, gp_Vec2d V)
        Translate(Handle_Geom2d_Vector self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Vector_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Vector self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Vector_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Vector self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Vector self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Vector_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Vector self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Vector_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Vector self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Vector_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Vector self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Vector_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Vector self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Vector self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Vector_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Vector self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Vector_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Vector self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Vector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Vector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Vector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Vector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Vector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Vector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Vector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Vector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Vector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Vector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Vector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Vector self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Vector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Vector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Vector_DecrementRefCounter(self, *args)

Handle_Geom2d_Vector_swigregister = _Geom2d.Handle_Geom2d_Vector_swigregister
Handle_Geom2d_Vector_swigregister(Handle_Geom2d_Vector)

def Handle_Geom2d_Vector_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Vector_DownCast(thing)
Handle_Geom2d_Vector_DownCast = _Geom2d.Handle_Geom2d_Vector_DownCast

class Handle_Geom2d_BSplineCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_BSplineCurve self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_BSplineCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_BSplineCurve self, Geom2d_BSplineCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_BSplineCurve self, Handle_Geom2d_BSplineCurve theHandle) -> Handle_Geom2d_BSplineCurve
        assign(Handle_Geom2d_BSplineCurve self, Geom2d_BSplineCurve thePtr) -> Handle_Geom2d_BSplineCurve
        assign(Handle_Geom2d_BSplineCurve self, Handle_Geom2d_BSplineCurve theHandle) -> Handle_Geom2d_BSplineCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_BSplineCurve self) -> Geom2d_BSplineCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_BSplineCurve self) -> Geom2d_BSplineCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_BSplineCurve self) -> Geom2d_BSplineCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_BSplineCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_BSplineCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_BSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_BSplineCurve_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_BSplineCurve

    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Handle_Geom2d_BSplineCurve self, Standard_Integer const Degree)

        Increases the degree of this BSpline curve to
        Degree. As a result, the poles, weights and
        multiplicities tables are modified; the knots table is
        not changed. Nothing is done if Degree is less than
        or equal to the current degree.
        Exceptions
        Standard_ConstructionError if Degree is greater than
        Geom2d_BSplineCurve::MaxDegree().

        :type Degree: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IncreaseDegree(self, *args)


    def IncreaseMultiplicity(self, *args):
        """
        IncreaseMultiplicity(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M)
        IncreaseMultiplicity(Handle_Geom2d_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases  the  multiplicities   of  the knots  in
        [I1,I2] to <M>.

        For each knot if  <M>  is  lower  or equal  to  the
        current multiplicity  nothing  is  done. If <M>  is
        higher than the degree the degree is used.
        As a result, the poles and weights tables of this curve are modified.
        Warning
        It is forbidden to modify the multiplicity of the first or
        last knot of a non-periodic curve. Be careful as
        Geom2d does not protect against this.
        Exceptions
        Standard_OutOfRange if either Index, I1 or I2 is
        outside the bounds of the knots table.

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IncreaseMultiplicity(self, *args)


    def IncrementMultiplicity(self, *args):
        """
        IncrementMultiplicity(Handle_Geom2d_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases by M the multiplicity of the knots of indexes
        I1 to I2 in the knots table of this BSpline curve. For
        each knot, the resulting multiplicity is limited to the
        degree of this curve. If M is negative, nothing is done.
        As a result, the poles and weights tables of this
        BSpline curve are modified.
        Warning
        It is forbidden to modify the multiplicity of the first or
        last knot of a non-periodic curve. Be careful as
        Geom2d does not protect against this.
        Exceptions
        Standard_OutOfRange if I1 or I2 is outside the
        bounds of the knots table.

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IncrementMultiplicity(self, *args)


    def InsertKnot(self, *args):
        """
        InsertKnot(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const M=1, Standard_Real const ParametricTolerance=0.0)

        Inserts a knot value in the sequence of knots.  If
        <U>  is an  existing knot     the multiplicity  is
        increased by <M>.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.
        Warning
        - If U is less than the first parameter or greater than
        the last parameter of this BSpline curve, nothing is done.
        - If M is negative or null, nothing is done.
        - The multiplicity of a knot is limited to the degree of
        this BSpline curve.

        :type U: float
        :type M: int
        :type ParametricTolerance: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_InsertKnot(self, *args)


    def InsertKnots(self, *args):
        """
        InsertKnots(Handle_Geom2d_BSplineCurve self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts the values of the array Knots, with the
        respective multiplicities given by the array Mults, into
        the knots table of this BSpline curve.
        If a value of the array Knots is an existing knot, its multiplicity is:
        - increased by M, if Add is true, or
        - increased to M, if Add is false (default value).
        The tolerance criterion used for knot equality is the
        larger of the values ParametricTolerance (defaulted
        to 0.) and Standard_Real::Epsilon(U),
        where U is the current knot value.
        Warning
        - For a value of the array Knots which is less than
        the first parameter or greater than the last
        parameter of this BSpline curve, nothing is done.
        - For a value of the array Mults which is negative or
        null, nothing is done.
        - The multiplicity of a knot is limited to the degree of
        this BSpline curve.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_InsertKnots(self, *args)


    def RemoveKnot(self, *args):
        """
        RemoveKnot(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces the multiplicity of the knot of index Index
        to M. If M is equal to 0, the knot is removed.
        With a modification of this type, the array of poles is also modified.
        Two different algorithms are systematically used to
        compute the new poles of the curve. If, for each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is less than
        Tolerance, this ensures that the curve is not
        modified by more than Tolerance. Under these
        conditions, true is returned; otherwise, false is returned.
        A low tolerance is used to prevent modification of
        the curve. A high tolerance is used to "smooth" the curve.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_RemoveKnot(self, *args)


    def InsertPoleAfter(self, *args):
        """
        InsertPoleAfter(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        The new pole is inserted after the pole of range Index.
        If the curve was non rational it can become rational.

        Raised if the B-spline is NonUniform or PiecewiseBezier or if
        Weight <= 0.0
        Raised if Index is not in the range [1, Number of Poles]

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_InsertPoleAfter(self, *args)


    def InsertPoleBefore(self, *args):
        """
        InsertPoleBefore(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight=1.0)

        The new pole is inserted before the pole of range Index.
        If the curve was non rational it can become rational.

        Raised if the B-spline is NonUniform or PiecewiseBezier or if
        Weight <= 0.0
        Raised if Index is not in the range [1, Number of Poles]

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_InsertPoleBefore(self, *args)


    def RemovePole(self, *args):
        """
        RemovePole(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index)

        Removes the pole of range Index
        If the curve was rational it can become non rational.

        Raised if the B-spline is NonUniform or PiecewiseBezier.
        Raised if the number of poles of the B-spline curve is lower or
        equal to 2 before removing.
        Raised if Index is not in the range [1, Number of Poles]

        :type Index: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_RemovePole(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_BSplineCurve self)

        Reverses the orientation of this BSpline curve. As a result
        - the knots and poles tables are modified;
        - the start point of the initial curve becomes the end
        point of the reversed curve;
        - the end point of the initial curve becomes the start
        point of the reversed curve.


        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_BSplineCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this BSpline curve.
        The returned value is: UFirst + ULast - U,
        where UFirst and ULast are the values of the
        first and last parameters of this BSpline curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Geom2d_BSplineCurve self, Standard_Real const U1, Standard_Real const U2)

        Modifies this BSpline curve by segmenting it
        between U1 and U2. Either of these values can be
        outside the bounds of the curve, but U2 must be greater than U1.
        All data structure tables of this BSpline curve are
        modified, but the knots located between U1 and U2
        are retained. The degree of the curve is not modified.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.
        - The segmentation of a periodic curve over an
        interval corresponding to its period generates a
        non-periodic curve with equivalent geometry.
        Exceptions
        Standard_DomainError if U2 is less than U1.
        raises if U2 < U1.
        Standard_DomainError if U2 - U1 exceeds the period for periodic curves.
        i.e. ((U2 - U1) - Period) > Precision::PConfusion().

        :type U1: float
        :type U2: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Segment(self, *args)


    def SetKnot(self, *args):
        """
        SetKnot(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Real const K)
        SetKnot(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Real const K, Standard_Integer const M)

        Modifies this BSpline curve by assigning the value K
        to the knot of index Index in the knots table. This is a
        relatively local modification because K must be such that:
        Knots(Index - 1) < K < Knots(Index + 1)
        The second syntax allows you also to increase the
        multiplicity of the knot to M (but it is not possible to
        decrease the multiplicity of the knot with this function).
        Exceptions
        Standard_ConstructionError if:
        - K is not such that:
        Knots(Index - 1) < K < Knots(Index + 1)
        - M is greater than the degree of this BSpline curve
        or lower than the previous multiplicity of knot of
        index Index in the knots table.
        Standard_OutOfRange if Index is outside the bounds of the knots table.

        :type Index: int
        :type K: float
        :type M: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetKnot(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(Handle_Geom2d_BSplineCurve self, NCollection_Array1_Standard_Real K)

        Modifies this BSpline curve by assigning the array
        K to its knots table. The multiplicity of the knots is not modified.
        Exceptions
        Standard_ConstructionError if the values in the
        array K are not in ascending order.
        Standard_OutOfRange if the bounds of the array
        K are not respectively 1 and the number of knots of this BSpline curve.

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetKnots(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Handle_Geom2d_BSplineCurve self)

        Computes the parameter normalized within the
        "first" period of this BSpline curve, if it is periodic:
        the returned value is in the range Param1 and
        Param1 + Period, where:
        - Param1 is the "first parameter", and
        - Period the period of this BSpline curve.
        Note: If this curve is not periodic, U is not modified.

        :type U: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_PeriodicNormalization(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(Handle_Geom2d_BSplineCurve self)

        Changes this BSpline curve into a periodic curve.
        To become periodic, the curve must first be closed.
        Next, the knot sequence must be periodic. For this,
        FirstUKnotIndex and LastUKnotIndex are used to
        compute I1 and I2, the indexes in the knots array
        of the knots corresponding to the first and last
        parameters of this BSpline curve.
        The period is therefore Knot(I2) - Knot(I1).
        Consequently, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if this BSpline curve is not closed.


        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetPeriodic(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index)

        Assigns the knot of index Index in the knots table as
        the origin of this periodic BSpline curve. As a
        consequence, the knots and poles tables are modified.
        Exceptions
        Standard_NoSuchObject if this curve is not periodic.
        Standard_DomainError if Index is outside the
        bounds of the knots table.

        :type Index: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetOrigin(self, *args)


    def SetNotPeriodic(self, *args):
        """
        SetNotPeriodic(Handle_Geom2d_BSplineCurve self)

        Changes this BSpline curve into a non-periodic
        curve. If this curve is already non-periodic, it is not modified.
        Note that the poles and knots tables are modified.
        Warning
        If this curve is periodic, as the multiplicity of the first
        and last knots is not modified, and is not equal to
        Degree + 1, where Degree is the degree of
        this BSpline curve, the start and end points of the
        curve are not its first and last poles.


        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetNotPeriodic(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P)
        SetPole(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, gp_Pnt2d P, Standard_Real const Weight)

        Modifies this BSpline curve by assigning P to the
        pole of index Index in the poles table.
        The second syntax also allows you to modify the
        weight of the modified pole, which becomes Weight.
        In this case, if this BSpline curve is non-rational, it
        can become rational and vice versa.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the poles table.
        Standard_ConstructionError if Weight is negative or null.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Assigns the weight Weight to the pole of index Index of the poles table.
        If the curve was non rational it can become rational.
        If the curve was rational it can become non rational.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the poles table.
        Standard_ConstructionError if Weight is negative or null.

        :type Index: int
        :type Weight: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_SetWeight(self, *args)


    def MovePoint(self, *args):
        """
        MovePoint(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, Standard_Integer const Index1, Standard_Integer const Index2)

        Moves the point of parameter U of this BSpline
        curve to P. Index1 and Index2 are the indexes in the
        table of poles of this BSpline curve of the first and
        last poles designated to be moved.
        FirstModifiedPole and LastModifiedPole are the
        indexes of the first and last poles, which are
        effectively modified.
        In the event of incompatibility between Index1,
        Index2 and the value U:
        - no change is made to this BSpline curve, and
        - the FirstModifiedPole and LastModifiedPole are returned null.
        Exceptions
        Standard_OutOfRange if:
        - Index1 is greater than or equal to Index2, or
        - Index1 or Index2 is less than 1 or greater than the
        number of poles of this BSpline curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Index1: int
        :type Index2: int
        :type FirstModifiedPole: int
        :type LastModifiedPole: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_MovePoint(self, *args)


    def MovePointAndTangent(self, *args):
        """
        MovePointAndTangent(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d Tangent, Standard_Real const Tolerance, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition)

        Move a point with parameter U to P.
        and makes it tangent at U be Tangent.
        StartingCondition = -1 means first can move
        EndingCondition   = -1 means last point can move
        StartingCondition = 0 means the first point cannot move
        EndingCondition   = 0 means the last point cannot move
        StartingCondition = 1 means the first point and tangent cannot move
        EndingCondition   = 1 means the last point and tangent cannot move
        and so forth
        ErrorStatus != 0 means that there are not enought degree of freedom
        with the constrain to deform the curve accordingly

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tangent: OCC.wrapper.gp.gp_Vec2d
        :type Tolerance: float
        :type StartingCondition: int
        :type EndingCondition: int
        :type ErrorStatus: int

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_MovePointAndTangent(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_BSplineCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this
        BSpline curve is at least N. A BSpline curve is at least GeomAbs_C0.
        Exceptions Standard_RangeError if N is negative.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsCN(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_Geom2d_BSplineCurve self, Standard_Real const theTf, Standard_Real const theTl, Standard_Real const theAngTol) -> Standard_Boolean

        Check if curve has at least G1 continuity in interval [theTf, theTl]
        Returns true if IsCN(1)
        or
        angle betweem "left" and "right" first derivatives at
        knots with C0 continuity is less then theAngTol
        only knots in interval [theTf, theTl] is checked

        :type theTf: float
        :type theTl: float
        :type theAngTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsG1(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_BSplineCurve self) -> Standard_Boolean

        Returns true if the distance between the first point and the
        last point of the curve is lower or equal to Resolution
        from package gp.
        Warnings :
        The first and the last point can be different from the first
        pole and the last pole of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_BSplineCurve self) -> Standard_Boolean

        Returns True if the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Geom2d_BSplineCurve self) -> Standard_Boolean

        Returns True if the weights are not identical.
        The tolerance criterion is Epsilon of the class Real.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_BSplineCurve self) -> GeomAbs_Shape

        Returns the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.
        For a B-spline curve of degree d if a knot Ui has a
        multiplicity p the B-spline curve is only Cd-p continuous
        at Ui. So the global continuity of the curve can't be greater
        than Cd-p where p is the maximum multiplicity of the interior
        Knots. In the interior of a knot span the curve is infinitely
        continuously differentiable.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the degree of this BSpline curve.
        In this class the degree of the basis normalized B-spline
        functions cannot be greater than "MaxDegree"
        Computation of value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        For this BSpline curve, computes
        - the point P of parameter U, or
        - the point P and one or more of the following values:
        - V1, the first derivative vector,
        - V2, the second derivative vector,
        - V3, the third derivative vector.
        Warning
        On a point where the continuity of the curve is not the
        one requested, these functions impact the part
        defined by the parameter with a value greater than U,
        i.e. the part of the curve to the "right" of the singularity.
        Raises UndefinedDerivative if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this BSpline curve,
        computes the vector corresponding to the Nth derivative.
        Warning
        On a point where the continuity of the curve is not the
        one requested, this function impacts the part defined
        by the parameter with a value greater than U, i.e. the
        part of the curve to the "right" of the singularity.
        Raises  UndefinedDerivative if the continuity of the curve is not CN.
        RangeError if N < 1.
        The following functions computes the point of parameter U
        and the derivatives at this point on the B-spline curve
        arc defined between the knot FromK1 and the knot ToK2.
        U can be out of bounds [Knot (FromK1),  Knot (ToK2)] but
        for the computation we only use the definition of the curve
        between these two knots. This method is useful to compute
        local derivative, if the order of continuity of the whole
        curve is not greater enough.    Inside the parametric
        domain Knot (FromK1), Knot (ToK2) the evaluations are
        the same as if we consider the whole definition of the
        curve. Of course the evaluations are different outside
        this parametric domain.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_DN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2) -> gp_Pnt2d

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocalValue(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P)

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P, gp_Vec2d V1)

        Raised if the local continuity of the curve is not C1
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the local continuity of the curve is not C2
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Raised if the local continuity of the curve is not C3
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Integer const N) -> gp_Vec2d

        Raised if the local continuity of the curve is not CN
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.
        Raised if N < 1.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocalDN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom2d_BSplineCurve self) -> gp_Pnt2d

        Returns the last point of the curve.
        Warnings :
        The last point of the curve is different from the last
        pole of the curve if the multiplicity of the last knot
        is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_EndPoint(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        For a B-spline curve the first parameter (which gives the start
        point of the curve) is a knot value but if the multiplicity of
        the first knot index is lower than Degree + 1 it is not the
        first knot of the curve. This method computes the index of the
        knot corresponding to the first parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_FirstUKnotIndex(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_BSplineCurve self) -> Standard_Real

        Computes the parametric value of the start point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_FirstParameter(self, *args)


    def Knot(self, *args):
        """
        Knot(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of range Index. When there is a knot
        with a multiplicity greater than 1 the knot is not repeated.
        The method Multiplicity can be used to get the multiplicity
        of the Knot.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Knot(self, *args)


    def Knots(self, *args):
        """
        returns the knot values of the B-spline curve;

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_Knots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotSequence(self, *args):
        """
        Returns the knots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        K = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_KnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotDistribution(self, *args):
        """
        KnotDistribution(Handle_Geom2d_BSplineCurve self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier.
        If all the knots differ by a positive constant from the
        preceding knot the BSpline Curve can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1 except for
        the first and last knot which are of multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have multiplicity
        Degree + 1 and if interior knots have multiplicity Degree
        A piecewise Bezier with only two knots is a BezierCurve.
        else the curve is non uniform.
        The tolerance criterion is Epsilon from class Real.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_KnotDistribution(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        For a BSpline curve the last parameter (which gives the
        end point of the curve) is a knot value but if the
        multiplicity of the last knot index is lower than
        Degree + 1 it is not the last knot of the curve. This
        method computes the index of the knot corresponding to
        the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LastUKnotIndex(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_BSplineCurve self) -> Standard_Real

        Computes the parametric value of the end point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LastParameter(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Handle_Geom2d_BSplineCurve self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        Knots (I1) <= U <= Knots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance)
        . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_LocateU(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knots of range Index.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Multiplicity(self, *args)


    def Multiplicities(self, *args):
        """
        returns the multiplicity of the knots of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_Multiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbKnots(self, *args):
        """
        NbKnots(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the number of knots. This method returns the number of
        knot without repetition of multiple knots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_NbKnots(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the number of poles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the B-spline curve;

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom2d_BSplineCurve self) -> gp_Pnt2d

        Returns the start point of the curve.
        Warnings :
        This point is different from the first pole of the curve if the
        multiplicity of the first knot is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Handle_Geom2d_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of range Index .
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Geom2d_BSplineCurve self, NCollection_Array1_Standard_Real W)
        Weights(Handle_Geom2d_BSplineCurve self) -> NCollection_Array1_Standard_Real

        Returns the weights of the B-spline curve;

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_BSplineCurve self, gp_Trsf2d T)

        Applies the transformation T to this BSpline curve.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Transform(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in this package.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_MaxDegree(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Geom2d_BSplineCurve self, Standard_Real const ToleranceUV)

        Computes for this BSpline curve the parametric
        tolerance UTolerance for a given tolerance
        Tolerance3D (relative to dimensions in the plane).
        If f(t) is the equation of this BSpline curve,
        UTolerance ensures that:
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < ToleranceUV

        :type ToleranceUV: float
        :type UTolerance: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_BSplineCurve self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this BSpline curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_BSplineCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_BSplineCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_BSplineCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_BSplineCurve self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_BSplineCurve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_BSplineCurve self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_BSplineCurve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_BSplineCurve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_BSplineCurve self, gp_Vec2d V)
        Translate(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_BSplineCurve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_BSplineCurve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_BSplineCurve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_BSplineCurve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_BSplineCurve self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_BSplineCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_BSplineCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_BSplineCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_BSplineCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_BSplineCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_BSplineCurve self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_BSplineCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BSplineCurve_DecrementRefCounter(self, *args)

Handle_Geom2d_BSplineCurve_swigregister = _Geom2d.Handle_Geom2d_BSplineCurve_swigregister
Handle_Geom2d_BSplineCurve_swigregister(Handle_Geom2d_BSplineCurve)

def Handle_Geom2d_BSplineCurve_DownCast(thing):
    return _Geom2d.Handle_Geom2d_BSplineCurve_DownCast(thing)
Handle_Geom2d_BSplineCurve_DownCast = _Geom2d.Handle_Geom2d_BSplineCurve_DownCast

class Handle_Geom2d_Geometry(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Geometry self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Geometry_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Geometry self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Geometry_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Geometry self, Geom2d_Geometry thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Geometry_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Geometry self, Handle_Geom2d_Geometry theHandle) -> Handle_Geom2d_Geometry
        assign(Handle_Geom2d_Geometry self, Geom2d_Geometry thePtr) -> Handle_Geom2d_Geometry
        assign(Handle_Geom2d_Geometry self, Handle_Geom2d_Geometry theHandle) -> Handle_Geom2d_Geometry

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Geometry_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Geometry self) -> Geom2d_Geometry

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Geometry_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Geometry self) -> Geom2d_Geometry

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Geometry___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Geometry self) -> Geom2d_Geometry

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Geometry___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Geometry___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Geometry___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Geometry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Geometry_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Geometry

    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Geometry self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Geometry self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Geometry_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Geometry_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Geometry_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Geometry self, gp_Vec2d V)
        Translate(Handle_Geom2d_Geometry self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Geometry_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Geometry self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Geometry_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Geometry self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Geometry self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Geometry_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Geometry_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Geometry self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Geometry_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Geometry self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Geometry_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Geometry self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Geometry self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Geometry_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Geometry self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Geometry_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Geometry self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Geometry_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Geometry_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Geometry_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Geometry self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Geometry_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Geometry self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Geometry self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Geometry_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Geometry self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Geometry self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Geometry_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Geometry self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Geometry_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Geometry self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Geometry_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Geometry self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Geometry_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Geometry self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Geometry_DecrementRefCounter(self, *args)

Handle_Geom2d_Geometry_swigregister = _Geom2d.Handle_Geom2d_Geometry_swigregister
Handle_Geom2d_Geometry_swigregister(Handle_Geom2d_Geometry)

def Handle_Geom2d_Geometry_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Geometry_DownCast(thing)
Handle_Geom2d_Geometry_DownCast = _Geom2d.Handle_Geom2d_Geometry_DownCast

class Handle_Geom2d_Circle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Circle self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Circle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Circle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Circle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Circle self, Geom2d_Circle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Circle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Circle self, Handle_Geom2d_Circle theHandle) -> Handle_Geom2d_Circle
        assign(Handle_Geom2d_Circle self, Geom2d_Circle thePtr) -> Handle_Geom2d_Circle
        assign(Handle_Geom2d_Circle self, Handle_Geom2d_Circle theHandle) -> Handle_Geom2d_Circle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Circle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Circle self) -> Geom2d_Circle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Circle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Circle self) -> Geom2d_Circle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Circle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Circle self) -> Geom2d_Circle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Circle___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Circle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Circle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Circle_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Circle

    def SetCirc2d(self, *args):
        """
        SetCirc2d(Handle_Geom2d_Circle self, gp_Circ2d C)

        Converts the gp_Circ2d circle C into this circle.

        :type C: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2d.Handle_Geom2d_Circle_SetCirc2d(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_Geom2d_Circle self, Standard_Real const R)

        :type R: float

        """
        return _Geom2d.Handle_Geom2d_Circle_SetRadius(self, *args)


    def Circ2d(self, *args):
        """
        Circ2d(Handle_Geom2d_Circle self) -> gp_Circ2d

        Returns the non persistent circle from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2d.Handle_Geom2d_Circle_Circ2d(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_Geom2d_Circle self) -> Standard_Real

        Returns the radius of this circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_Radius(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Circle self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed circle for
        the point of parameter U on this circle.
        For a circle, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_ReversedParameter(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom2d_Circle self) -> Standard_Real

        Returns 0., which is the eccentricity of any circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_Eccentricity(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Circle self) -> Standard_Real

        Returns 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Circle self) -> Standard_Real

        Returns 2*PI.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Circle self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Circle_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Circle self) -> Standard_Boolean

        returns True. The period of a circle is 2.*Pi.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Circle_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P = C + R * Cos (U) * XDir + R * Sin (U) * YDir
        where C is the center of the circle , XDir the XDirection and
        YDir the YDirection of the circle's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Circle_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Circle_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Circle_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Circle self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter u, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Circle_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Circle self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this circle, computes
        the vector corresponding to the Nth derivative.
        Exceptions: Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Circle_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Circle self, gp_Trsf2d T)

        Applies the transformation T to this circle.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Circle_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Circle self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this circle.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Circle_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Circle self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Circle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Circle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Circle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom2d_Circle self, gp_Ax22d A)

        Modifies this conic, redefining its local coordinate system
        partially, by assigning P as its origin

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _Geom2d.Handle_Geom2d_Circle_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(Handle_Geom2d_Circle self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Circle_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(Handle_Geom2d_Circle self, gp_Ax2d A)

        Assigns the origin and unit vector of axis A to the
        origin of the local coordinate system of this conic and either:
        - its "X Direction", or
        - its "Y Direction".
        The other unit vector of the local coordinate system
        of this conic is recomputed normal to A, without
        changing the orientation of the local coordinate
        system (right-handed or left-handed).

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Circle_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_Circle self, gp_Pnt2d P)

        Modifies this conic, redefining its local coordinate
        system fully, by assigning A as this coordinate system.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Circle_SetLocation(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Handle_Geom2d_Circle self) -> gp_Ax2d

        Returns the "XAxis" of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis and the "Yaxis" define the local coordinate system
        of the conic.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Circle_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom2d_Circle self) -> gp_Ax2d

        Returns the "YAxis" of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Circle_YAxis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom2d_Circle self) -> gp_Pnt2d

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Circle_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _Geom2d.Handle_Geom2d_Circle_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Circle self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom2d.Handle_Geom2d_Circle_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Circle self) -> GeomAbs_Shape

        Returns GeomAbs_CN which is the global continuity of any conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Circle_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Circle self, Standard_Integer const N) -> Standard_Boolean

        Returns True, the order of continuity of a conic is infinite.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Circle_IsCN(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Circle self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Circle self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Circle self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Circle_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Circle self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Circle_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Circle self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Circle_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Circle self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Circle self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Circle_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Circle self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Circle_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Circle self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Circle_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Circle self, gp_Vec2d V)
        Translate(Handle_Geom2d_Circle self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Circle_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Circle self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Circle self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Circle_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Circle self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Circle_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Circle self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Circle_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Circle self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Circle_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Circle self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Circle self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Circle_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Circle self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Circle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Circle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Circle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Circle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Circle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Circle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Circle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Circle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Circle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Circle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Circle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Circle self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Circle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Circle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Circle_DecrementRefCounter(self, *args)

Handle_Geom2d_Circle_swigregister = _Geom2d.Handle_Geom2d_Circle_swigregister
Handle_Geom2d_Circle_swigregister(Handle_Geom2d_Circle)

def Handle_Geom2d_Circle_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Circle_DownCast(thing)
Handle_Geom2d_Circle_DownCast = _Geom2d.Handle_Geom2d_Circle_DownCast

class Geom2d_TrimmedCurve(Geom2d_BoundedCurve):
    """
    Defines a portion of a curve limited by two values of
    parameters inside the parametric domain of the curve.
    The trimmed curve is defined by:
    - the basis curve, and
    - the two parameter values which limit it.
    The trimmed curve can either have the same
    orientation as the basis curve or the opposite orientation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2d_TrimmedCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2d_TrimmedCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2d_TrimmedCurve self, Handle_Geom2d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const Sense, Standard_Boolean const theAdjustPeriodic) -> Geom2d_TrimmedCurve

        Creates a trimmed curve from the basis curve C limited between
        U1 and U2.

        . U1 can be greater or lower than U2.
        . The returned curve is oriented from U1 to U2.
        . If the basis curve C is periodic there is an ambiguity
        because two parts are available. In this case by default
        the trimmed curve has the same orientation as the basis
        curve (Sense = True). If Sense = False then the orientation
        of the trimmed curve is opposite to the orientation of the
        basis curve C.
        If the curve is closed but not periodic it is not possible
        to keep the part of the curve including the junction point
        (except if the junction point is at the beginning or
        at the end of the trimmed curve) because you could lose the
        fundamental characteristics of the basis curve which are
        used for example to compute the derivatives of the trimmed
        curve. So for a closed curve the rules are the same as for
        a open curve.
        Warnings :
        In this package the entities are not shared. The TrimmedCurve is
        built with a copy of the curve C. So when C is modified the
        TrimmedCurve is not modified
        Warnings :
        If <C> is periodic and <theAdjustPeriodic> is True, parametrics
        bounds of the TrimmedCurve, can be different to [<U1>;<U2>},
        if <U1> or <U2> are not in the principal period.
        Include :
        For more explanation see the scheme given with this class.
        Raises ConstructionError the C is not periodic and U1 or U2 are out of
        the bounds of C.
        Raised if U1 = U2.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type U1: float
        :type U2: float
        :type Sense: bool
        :type theAdjustPeriodic: bool

        """
        this = _Geom2d.new_Geom2d_TrimmedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """
        Reverse(Geom2d_TrimmedCurve self)

        Changes the direction of parametrization of <me>. The first and
        the last parametric values are modified. The "StartPoint"
        of the initial curve becomes the "EndPoint" of the reversed
        curve and the "EndPoint" of the initial curve becomes the
        "StartPoint" of the reversed curve.
        Example  -   If the trimmed curve is defined by:
        - a basis curve whose parameter range is [ 0.,1. ], and
        - the two trim values U1 (first parameter) and U2 (last parameter),
        the reversed trimmed curve is defined by:
        - the reversed basis curve, whose parameter range is still [ 0.,1. ], and
        - the two trim values 1. - U2 (first parameter)
        and 1. - U1 (last parameter).


        """
        return _Geom2d.Geom2d_TrimmedCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom2d_TrimmedCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns UFirst + ULast - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_TrimmedCurve_ReversedParameter(self, *args)


    def SetTrim(self, *args):
        """
        SetTrim(Geom2d_TrimmedCurve self, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const Sense, Standard_Boolean const theAdjustPeriodic)

        Changes this trimmed curve, by redefining the
        parameter values U1 and U2, which limit its basis curve.
        Note: If the basis curve is periodic, the trimmed curve
        has the same orientation as the basis curve if Sense
        is true (default value) or the opposite orientation if Sense is false.
        Warning
        If the basis curve is periodic and theAdjustPeriodic is True,
        the bounds of the trimmed curve may be different from U1 and U2 if the
        parametric origin of the basis curve is within the arc
        of the trimmed curve. In this case, the modified
        parameter will be equal to U1 or U2 plus or minus the period.
        If theAdjustPeriodic is False, parameters U1 and U2 will stay unchanged.
        Exceptions
        Standard_ConstructionError if:
        - the basis curve is not periodic, and either U1 or U2
        are outside the bounds of the basis curve, or
        - U1 is equal to U2.

        :type U1: float
        :type U2: float
        :type Sense: bool
        :type theAdjustPeriodic: bool

        """
        return _Geom2d.Geom2d_TrimmedCurve_SetTrim(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Geom2d_TrimmedCurve self) -> Handle_Geom2d_Curve

        Returns the basis curve.
        Warning
        This function does not return a constant reference.
        Consequently, any modification of the returned value
        directly modifies the trimmed curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Geom2d_TrimmedCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom2d_TrimmedCurve self) -> GeomAbs_Shape

        Returns the global continuity of the basis curve of this trimmed curve.
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Geom2d_TrimmedCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom2d_TrimmedCurve self, Standard_Integer const N) -> Standard_Boolean

        --- Purpose
        Returns True if the order of continuity of the
        trimmed curve is N. A trimmed curve is at least "C0" continuous.
        Warnings :
        The continuity of the trimmed curve can be greater than
        the continuity of the basis curve because you consider
        only a part of the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_TrimmedCurve_IsCN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Geom2d_TrimmedCurve self) -> gp_Pnt2d

        Returns the end point of <me>. This point is the
        evaluation of the curve for the "LastParameter".

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom2d_TrimmedCurve self) -> Standard_Real

        Returns the value of the first parameter of <me>.
        The first parameter is the parameter of the "StartPoint"
        of the trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_TrimmedCurve_FirstParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom2d_TrimmedCurve self) -> Standard_Boolean

        Returns True if the distance between the StartPoint and
        the EndPoint is lower or equal to Resolution from package
        gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_TrimmedCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom2d_TrimmedCurve self) -> Standard_Boolean

        Always returns FALSE (independently of the type of basis curve).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Geom2d_TrimmedCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Geom2d_TrimmedCurve self) -> Standard_Real

        Returns the period of the basis curve of this trimmed curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_TrimmedCurve_Period(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom2d_TrimmedCurve self) -> Standard_Real

        Returns the value of the last parameter of <me>.
        The last parameter is the parameter of the "EndPoint" of the
        trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_TrimmedCurve_LastParameter(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Geom2d_TrimmedCurve self) -> gp_Pnt2d

        Returns the start point of <me>.
        This point is the evaluation of the curve from the
        "FirstParameter".
        value and derivatives
        Warnings :
        The returned derivatives have the same orientation as the
        derivatives of the basis curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_StartPoint(self, *args)


    def D0(self, *args):
        """
        D0(Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P)

        If the basis curve is an OffsetCurve sometimes it is not
        possible to do the evaluation of the curve at the parameter
        U (see class OffsetCurve).

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom2d_TrimmedCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this trimmed curve,
        computes the vector corresponding to the Nth derivative.
        Warning
        The returned derivative vector has the same
        orientation as the derivative vector of the basis curve,
        even if the trimmed curve does not have the same
        orientation as the basis curve.
        Exceptions
        Standard_RangeError if N is less than 1.
        geometric transformations

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom2d_TrimmedCurve self, gp_Trsf2d T)

        Applies the transformation T to this trimmed curve.
        Warning The basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Geom2d_TrimmedCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom2d_TrimmedCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_TrimmedCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom2d_TrimmedCurve self, gp_Trsf2d T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Geom2d_TrimmedCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom2d_TrimmedCurve self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this trimmed curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Geom2d_TrimmedCurve_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2d.Geom2d_TrimmedCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2d.Geom2d_TrimmedCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Geom2d_TrimmedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2d.delete_Geom2d_TrimmedCurve
Geom2d_TrimmedCurve_swigregister = _Geom2d.Geom2d_TrimmedCurve_swigregister
Geom2d_TrimmedCurve_swigregister(Geom2d_TrimmedCurve)

def Geom2d_TrimmedCurve_get_type_name(*args):
    """
    Geom2d_TrimmedCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2d.Geom2d_TrimmedCurve_get_type_name(*args)

def Geom2d_TrimmedCurve_get_type_descriptor(*args):
    """
    Geom2d_TrimmedCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2d.Geom2d_TrimmedCurve_get_type_descriptor(*args)

class Handle_Geom2d_Curve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Curve self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Curve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Curve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Curve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Curve self, Geom2d_Curve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Curve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Curve self, Handle_Geom2d_Curve theHandle) -> Handle_Geom2d_Curve
        assign(Handle_Geom2d_Curve self, Geom2d_Curve thePtr) -> Handle_Geom2d_Curve
        assign(Handle_Geom2d_Curve self, Handle_Geom2d_Curve theHandle) -> Handle_Geom2d_Curve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Curve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Curve self) -> Geom2d_Curve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Curve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Curve self) -> Geom2d_Curve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Curve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Curve self) -> Geom2d_Curve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Curve___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Curve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Curve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Curve_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Curve

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Curve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Geom2d.Handle_Geom2d_Curve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Curve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this curve.
        Note: The point of parameter U on this curve is
        identical to the point of parameter
        ReversedParameter(U) on the reversed curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Curve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Curve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Curve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Curve self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Curve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Curve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Curve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Curve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Curve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Curve self) -> Standard_Real

        Value of the last parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Curve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Curve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Examples :
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Curve self) -> Standard_Boolean

        Returns true if the parameter of the curve is periodic.
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Curve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Curve self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Curve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Curve self) -> GeomAbs_Shape

        It is the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Curve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Curve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Curve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Curve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Curve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Curve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Curve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Curve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this curve, computes
        the vector corresponding to the Nth derivative.
        Exceptions
        StdFail_UndefinedDerivative if:
        - the continuity of the curve is not "CN", or
        - the derivative vector cannot be computed easily;
        this is the case with specific types of curve (for
        example, a rational BSpline curve where N is greater than 3).
        Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Curve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Curve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Curve_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Curve self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Curve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Curve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Curve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Curve self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Curve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Curve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Curve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Curve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Curve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Curve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Curve self, gp_Vec2d V)
        Translate(Handle_Geom2d_Curve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Curve_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Curve self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Curve_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Curve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Curve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Curve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Curve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Curve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Curve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Curve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Curve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Curve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Curve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Curve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Curve_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Curve self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Curve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Curve self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Curve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Curve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Curve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Curve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Curve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Curve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Curve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Curve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Curve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Curve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Curve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Curve self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Curve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Curve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Curve_DecrementRefCounter(self, *args)

Handle_Geom2d_Curve_swigregister = _Geom2d.Handle_Geom2d_Curve_swigregister
Handle_Geom2d_Curve_swigregister(Handle_Geom2d_Curve)

def Handle_Geom2d_Curve_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Curve_DownCast(thing)
Handle_Geom2d_Curve_DownCast = _Geom2d.Handle_Geom2d_Curve_DownCast

class Handle_Geom2d_Point(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Point self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Point_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Point self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Point_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Point self, Geom2d_Point thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Point_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Point self, Handle_Geom2d_Point theHandle) -> Handle_Geom2d_Point
        assign(Handle_Geom2d_Point self, Geom2d_Point thePtr) -> Handle_Geom2d_Point
        assign(Handle_Geom2d_Point self, Handle_Geom2d_Point theHandle) -> Handle_Geom2d_Point

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Point_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Point self) -> Geom2d_Point

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Point_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Point self) -> Geom2d_Point

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Point___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Point self) -> Geom2d_Point

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Point___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Point___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Point___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Point_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Point

    def Coord(self, *args):
        """
        Coord(Handle_Geom2d_Point self)

        returns the Coordinates of <me>.

        :type X: float
        :type Y: float

        """
        return _Geom2d.Handle_Geom2d_Point_Coord(self, *args)


    def Pnt2d(self, *args):
        """
        Pnt2d(Handle_Geom2d_Point self) -> gp_Pnt2d

        returns a non persistent copy of <me>

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Point_Pnt2d(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom2d_Point self) -> Standard_Real

        returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Point_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom2d_Point self) -> Standard_Real

        returns  the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Point_Y(self, *args)


    def Distance(self, *args):
        """
        Distance(Handle_Geom2d_Point self, Handle_Geom2d_Point Other) -> Standard_Real

        computes the distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Point_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Handle_Geom2d_Point self, Handle_Geom2d_Point Other) -> Standard_Real

        computes the square distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Point_SquareDistance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Point self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Point_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Point_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Point_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Point self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Point self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Point_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Point self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Point_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Point self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Point_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Point self, gp_Vec2d V)
        Translate(Handle_Geom2d_Point self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Point_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Point self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Point_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Point self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Point self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Point_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Point self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Point_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Point self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Point_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Point self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Point_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Point self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Point self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Point_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Point self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Point_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Point self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Point_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Point self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Point self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Point_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Point self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Point self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Point_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Point self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Point_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Point self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Point_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Point self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Point_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Point self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Point_DecrementRefCounter(self, *args)

Handle_Geom2d_Point_swigregister = _Geom2d.Handle_Geom2d_Point_swigregister
Handle_Geom2d_Point_swigregister(Handle_Geom2d_Point)

def Handle_Geom2d_Point_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Point_DownCast(thing)
Handle_Geom2d_Point_DownCast = _Geom2d.Handle_Geom2d_Point_DownCast

class Handle_Geom2d_Parabola(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Parabola self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Parabola_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Parabola self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Parabola_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Parabola self, Geom2d_Parabola thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Parabola_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Parabola self, Handle_Geom2d_Parabola theHandle) -> Handle_Geom2d_Parabola
        assign(Handle_Geom2d_Parabola self, Geom2d_Parabola thePtr) -> Handle_Geom2d_Parabola
        assign(Handle_Geom2d_Parabola self, Handle_Geom2d_Parabola theHandle) -> Handle_Geom2d_Parabola

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Parabola_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Parabola self) -> Geom2d_Parabola

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Parabola_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Parabola self) -> Geom2d_Parabola

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Parabola___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Parabola self) -> Geom2d_Parabola

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Parabola___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Parabola___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Parabola___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Parabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Parabola_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Parabola

    def SetFocal(self, *args):
        """
        SetFocal(Handle_Geom2d_Parabola self, Standard_Real const Focal)

        Assigns the value Focal to the focal length of this parabola.
        Exceptions Standard_ConstructionError if Focal is negative.

        :type Focal: float

        """
        return _Geom2d.Handle_Geom2d_Parabola_SetFocal(self, *args)


    def SetParab2d(self, *args):
        """
        SetParab2d(Handle_Geom2d_Parabola self, gp_Parab2d Prb)

        Converts the gp_Parab2d parabola Prb into this parabola.

        :type Prb: OCC.wrapper.gp.gp_Parab2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_SetParab2d(self, *args)


    def Parab2d(self, *args):
        """
        Parab2d(Handle_Geom2d_Parabola self) -> gp_Parab2d

        Returns the non persistent parabola from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Parab2d(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Parabola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed parabola
        for the point of parameter U on this parabola.
        For a parabola, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Parabola self) -> Standard_Real

        Returns RealFirst from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Parabola self) -> Standard_Real

        Returns  RealLast from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Parabola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Parabola_IsPeriodic(self, *args)


    def Directrix(self, *args):
        """
        Directrix(Handle_Geom2d_Parabola self) -> gp_Ax2d

        The directrix is parallel to the "YAxis" of the parabola.
        The "Location" point of the directrix is the intersection
        point between the directrix and the symmetry axis ("XAxis") of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Directrix(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom2d_Parabola self) -> Standard_Real

        Returns the eccentricity e = 1.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_Eccentricity(self, *args)


    def Focus(self, *args):
        """
        Focus(Handle_Geom2d_Parabola self) -> gp_Pnt2d

        Computes the focus of this parabola The focus is on the
        positive side of the "X Axis" of the local coordinate system of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Focus(self, *args)


    def Focal(self, *args):
        """
        Focal(Handle_Geom2d_Parabola self) -> Standard_Real

        Computes the focal length of this parabola.
        The focal length is the distance between the apex and the focus of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_Focal(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Geom2d_Parabola self) -> Standard_Real

        Computes the parameter of this parabola, which is
        the distance between its focus and its directrix. This
        distance is twice the focal length.
        If P is the parameter of the parabola, the equation of
        the parabola in its local coordinate system is: Y**2 = 2.*P*X.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If U = 0 the returned point is the origin of the XAxis and
        the YAxis of the parabola and it is the vertex of the parabola.
        P = S + F * (U * U * XDir +  * U * YDir)
        where S is the vertex of the parabola, XDir the XDirection and
        YDir the YDirection of the parabola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Parabola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Parabola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this parabola,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Parabola self, gp_Trsf2d T)

        Applies the transformation T to this parabola.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Parabola self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the transformed
        parabola, for the point of parameter U on this parabola.
        For a parabola, the returned value is equal to U
        multiplied by the scale factor of transformation T.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Parabola self, gp_Trsf2d T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Parabola self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this parabola.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Parabola_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Parabola self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Parabola_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Parabola_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Parabola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom2d_Parabola self, gp_Ax22d A)

        Modifies this conic, redefining its local coordinate system
        partially, by assigning P as its origin

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _Geom2d.Handle_Geom2d_Parabola_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(Handle_Geom2d_Parabola self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(Handle_Geom2d_Parabola self, gp_Ax2d A)

        Assigns the origin and unit vector of axis A to the
        origin of the local coordinate system of this conic and either:
        - its "X Direction", or
        - its "Y Direction".
        The other unit vector of the local coordinate system
        of this conic is recomputed normal to A, without
        changing the orientation of the local coordinate
        system (right-handed or left-handed).

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_Parabola self, gp_Pnt2d P)

        Modifies this conic, redefining its local coordinate
        system fully, by assigning A as this coordinate system.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_SetLocation(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Handle_Geom2d_Parabola self) -> gp_Ax2d

        Returns the "XAxis" of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis and the "Yaxis" define the local coordinate system
        of the conic.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom2d_Parabola self) -> gp_Ax2d

        Returns the "YAxis" of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_YAxis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom2d_Parabola self) -> gp_Pnt2d

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _Geom2d.Handle_Geom2d_Parabola_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Parabola self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom2d.Handle_Geom2d_Parabola_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Parabola self) -> GeomAbs_Shape

        Returns GeomAbs_CN which is the global continuity of any conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Parabola_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Parabola self, Standard_Integer const N) -> Standard_Boolean

        Returns True, the order of continuity of a conic is infinite.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Parabola_IsCN(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Parabola self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Parabola_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Parabola self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Parabola_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Parabola self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Parabola self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Parabola self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Parabola self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Parabola_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Parabola self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Parabola_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Parabola self, gp_Vec2d V)
        Translate(Handle_Geom2d_Parabola self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Parabola_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Parabola self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Parabola self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Parabola_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Parabola self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Parabola_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Parabola self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Parabola_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Parabola self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Parabola_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Parabola self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Parabola self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Parabola_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Parabola self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Parabola_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Parabola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Parabola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Parabola_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Parabola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Parabola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Parabola_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Parabola self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Parabola_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Parabola self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Parabola_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Parabola self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Parabola_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Parabola self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Parabola_DecrementRefCounter(self, *args)

Handle_Geom2d_Parabola_swigregister = _Geom2d.Handle_Geom2d_Parabola_swigregister
Handle_Geom2d_Parabola_swigregister(Handle_Geom2d_Parabola)

def Handle_Geom2d_Parabola_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Parabola_DownCast(thing)
Handle_Geom2d_Parabola_DownCast = _Geom2d.Handle_Geom2d_Parabola_DownCast

class Handle_Geom2d_BoundedCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_BoundedCurve self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_BoundedCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_BoundedCurve self, Geom2d_BoundedCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_BoundedCurve self, Handle_Geom2d_BoundedCurve theHandle) -> Handle_Geom2d_BoundedCurve
        assign(Handle_Geom2d_BoundedCurve self, Geom2d_BoundedCurve thePtr) -> Handle_Geom2d_BoundedCurve
        assign(Handle_Geom2d_BoundedCurve self, Handle_Geom2d_BoundedCurve theHandle) -> Handle_Geom2d_BoundedCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_BoundedCurve self) -> Geom2d_BoundedCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_BoundedCurve self) -> Geom2d_BoundedCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_BoundedCurve self) -> Geom2d_BoundedCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_BoundedCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_BoundedCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_BoundedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_BoundedCurve_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_BoundedCurve

    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom2d_BoundedCurve self) -> gp_Pnt2d

        Returns the end point of the curve.
        The end point is the value of the curve for the
        "LastParameter" of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_EndPoint(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom2d_BoundedCurve self) -> gp_Pnt2d

        Returns the start point of the curve.
        The start point is the value of the curve for the
        "FirstParameter" of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_StartPoint(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_BoundedCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_BoundedCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_BoundedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_BoundedCurve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_BoundedCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this curve.
        Note: The point of parameter U on this curve is
        identical to the point of parameter
        ReversedParameter(U) on the reversed curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_BoundedCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_BoundedCurve self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_BoundedCurve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_BoundedCurve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_BoundedCurve self) -> Standard_Real

        Value of the last parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_BoundedCurve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Examples :
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_BoundedCurve self) -> Standard_Boolean

        Returns true if the parameter of the curve is periodic.
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_BoundedCurve self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_BoundedCurve self) -> GeomAbs_Shape

        It is the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_BoundedCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_BoundedCurve self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_BoundedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_BoundedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_BoundedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_BoundedCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this curve, computes
        the vector corresponding to the Nth derivative.
        Exceptions
        StdFail_UndefinedDerivative if:
        - the continuity of the curve is not "CN", or
        - the derivative vector cannot be computed easily;
        this is the case with specific types of curve (for
        example, a rational BSpline curve where N is greater than 3).
        Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_BoundedCurve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_BoundedCurve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_BoundedCurve self, gp_Vec2d V)
        Translate(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_BoundedCurve self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_BoundedCurve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_BoundedCurve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_BoundedCurve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_BoundedCurve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_BoundedCurve self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_BoundedCurve self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_BoundedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_BoundedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_BoundedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_BoundedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_BoundedCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_BoundedCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_BoundedCurve self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_BoundedCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_BoundedCurve_DecrementRefCounter(self, *args)

Handle_Geom2d_BoundedCurve_swigregister = _Geom2d.Handle_Geom2d_BoundedCurve_swigregister
Handle_Geom2d_BoundedCurve_swigregister(Handle_Geom2d_BoundedCurve)

def Handle_Geom2d_BoundedCurve_DownCast(thing):
    return _Geom2d.Handle_Geom2d_BoundedCurve_DownCast(thing)
Handle_Geom2d_BoundedCurve_DownCast = _Geom2d.Handle_Geom2d_BoundedCurve_DownCast

class Handle_Geom2d_Hyperbola(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_Hyperbola self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_Hyperbola self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_Hyperbola self, Geom2d_Hyperbola thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_Hyperbola self, Handle_Geom2d_Hyperbola theHandle) -> Handle_Geom2d_Hyperbola
        assign(Handle_Geom2d_Hyperbola self, Geom2d_Hyperbola thePtr) -> Handle_Geom2d_Hyperbola
        assign(Handle_Geom2d_Hyperbola self, Handle_Geom2d_Hyperbola theHandle) -> Handle_Geom2d_Hyperbola

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_Hyperbola self) -> Geom2d_Hyperbola

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_Hyperbola self) -> Geom2d_Hyperbola

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_Hyperbola___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_Hyperbola self) -> Geom2d_Hyperbola

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_Hyperbola___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_Hyperbola___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_Hyperbola___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_Hyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_Hyperbola_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_Hyperbola

    def SetHypr2d(self, *args):
        """
        SetHypr2d(Handle_Geom2d_Hyperbola self, gp_Hypr2d H)

        Converts the gp_Hypr2d hyperbola H into this hyperbola.

        :type H: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetHypr2d(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Handle_Geom2d_Hyperbola self, Standard_Real const MajorRadius)

        Assigns a value to the major or minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0,
        - MinorRadius is less than 0.0.

        :type MajorRadius: float

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Handle_Geom2d_Hyperbola self, Standard_Real const MinorRadius)

        Assigns a value to the major or minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0,
        - MinorRadius is less than 0.0.

        :type MinorRadius: float

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetMinorRadius(self, *args)


    def Hypr2d(self, *args):
        """
        Hypr2d(Handle_Geom2d_Hyperbola self) -> gp_Hypr2d

        Converts this hyperbola into a gp_Hypr2d one.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Hypr2d(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_Hyperbola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed hyperbola,
        for the point of parameter U on this hyperbola.
        For a hyperbola, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Returns RealFirst from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_Hyperbola self) -> Standard_Real

        returns RealLast from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_Hyperbola self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_Hyperbola self) -> Standard_Boolean

        return False for an hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IsPeriodic(self, *args)


    def Asymptote1(self, *args):
        """
        Asymptote1(Handle_Geom2d_Hyperbola self) -> gp_Ax2d

        In the local coordinate system of the hyperbola the
        equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0
        and the equation of the first asymptote is Y = (B/A)*X
        where A is the major radius of the hyperbola and B is the
        minor radius of the hyperbola.
        Raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Asymptote1(self, *args)


    def Asymptote2(self, *args):
        """
        Asymptote2(Handle_Geom2d_Hyperbola self) -> gp_Ax2d

        In the local coordinate system of the hyperbola the
        equation of the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0
        and the equation of the first asymptote is Y = -(B/A)*X.
        where A is the major radius of the hyperbola and B is the
        minor radius of the hyperbola.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Asymptote2(self, *args)


    def ConjugateBranch1(self, *args):
        """
        ConjugateBranch1(Handle_Geom2d_Hyperbola self) -> gp_Hypr2d

        Computes the first conjugate branch relative to this hyperbola.
        Note: The diagram given under the class purpose
        indicates where these two branches of hyperbola are
        positioned in relation to this branch of hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args):
        """
        ConjugateBranch2(Handle_Geom2d_Hyperbola self) -> gp_Hypr2d

        Computes the second conjugate branch relative to this hyperbola.
        Note: The diagram given under the class purpose
        indicates where these two branches of hyperbola are
        positioned in relation to this branch of hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_ConjugateBranch2(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Handle_Geom2d_Hyperbola self) -> gp_Ax2d

        This directrix is the line normal to the XAxis of the hyperbola
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the hyperbola, where e is the eccentricity of
        the hyperbola.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the location point of the
        directrix1. This point is on the positive side of the "XAxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Handle_Geom2d_Hyperbola self) -> gp_Ax2d

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Returns the excentricity of the hyperbola (e > 1).
        If f is the distance between the location of the hyperbola
        and the Focus1 then the eccentricity e = f / MajorRadius.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        two focus of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Handle_Geom2d_Hyperbola self) -> gp_Pnt2d

        Returns the first focus of the hyperbola. This focus is on the
        positive side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Handle_Geom2d_Hyperbola self) -> gp_Pnt2d

        Returns the second focus of the hyperbola. This focus is on the
        negative side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The major radius is also the distance between the
        center of the hyperbola and the apex of the main
        branch (located on the "X Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The minor radius is also the distance between the
        center of the hyperbola and the apex of a conjugate
        branch (located on the "Y Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_MinorRadius(self, *args)


    def OtherBranch(self, *args):
        """
        OtherBranch(Handle_Geom2d_Hyperbola self) -> gp_Hypr2d

        Computes the "other" branch of this hyperbola. This
        is a symmetrical branch with respect to the center of this hyperbola.
        Note: The diagram given under the class purpose
        indicates where the "other" branch is positioned in
        relation to this branch of the hyperbola.
        ^ YAxis
        |
        FirstConjugateBranch
        |
        Other   | Main
        ---------------------------- C
        ------------------------------------------&gtXAxis
        Branch |  Branch
        |
        |
        SecondConjugateBranch
        |
        Warning
        The major radius can be less than the minor radius.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_OtherBranch(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Computes the parameter of this hyperbola.
        The parameter is:
        p = (e*e - 1) * MajorRadius
        where e is the eccentricity of this hyperbola and
        MajorRadius its major radius.
        Exceptions
        Standard_DomainError if the major radius of this
        hyperbola is null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cosh (U) * XDir +
        MinorRadius * Sinh (U) * YDir
        where C is the center of the hyperbola , XDir the XDirection and
        YDir the YDirection of the hyperbola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_Hyperbola self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_Hyperbola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this hyperbola,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_Hyperbola self, gp_Trsf2d T)

        Applies the transformation T to this hyperbola.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_Hyperbola self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this hyperbola.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_Hyperbola self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Hyperbola_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_Hyperbola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom2d_Hyperbola self, gp_Ax22d A)

        Modifies this conic, redefining its local coordinate system
        partially, by assigning P as its origin

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(Handle_Geom2d_Hyperbola self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(Handle_Geom2d_Hyperbola self, gp_Ax2d A)

        Assigns the origin and unit vector of axis A to the
        origin of the local coordinate system of this conic and either:
        - its "X Direction", or
        - its "Y Direction".
        The other unit vector of the local coordinate system
        of this conic is recomputed normal to A, without
        changing the orientation of the local coordinate
        system (right-handed or left-handed).

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_Hyperbola self, gp_Pnt2d P)

        Modifies this conic, redefining its local coordinate
        system fully, by assigning A as this coordinate system.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_SetLocation(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Handle_Geom2d_Hyperbola self) -> gp_Ax2d

        Returns the "XAxis" of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis and the "Yaxis" define the local coordinate system
        of the conic.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom2d_Hyperbola self) -> gp_Ax2d

        Returns the "YAxis" of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_YAxis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom2d_Hyperbola self) -> gp_Pnt2d

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _Geom2d.Handle_Geom2d_Hyperbola_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_Hyperbola self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_Hyperbola self) -> GeomAbs_Shape

        Returns GeomAbs_CN which is the global continuity of any conic.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_Hyperbola self, Standard_Integer const N) -> Standard_Boolean

        Returns True, the order of continuity of a conic is infinite.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IsCN(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_Hyperbola self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_Hyperbola self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_Hyperbola self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_Hyperbola self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_Hyperbola self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_Hyperbola self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_Hyperbola self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_Hyperbola self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_Hyperbola self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_Hyperbola self, gp_Vec2d V)
        Translate(Handle_Geom2d_Hyperbola self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_Hyperbola self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_Hyperbola self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_Hyperbola self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_Hyperbola self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_Hyperbola self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_Hyperbola self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_Hyperbola self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_Hyperbola self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_Hyperbola_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_Hyperbola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_Hyperbola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_Hyperbola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_Hyperbola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_Hyperbola self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_Hyperbola self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_Hyperbola self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_Hyperbola_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_Hyperbola self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_Hyperbola_DecrementRefCounter(self, *args)

Handle_Geom2d_Hyperbola_swigregister = _Geom2d.Handle_Geom2d_Hyperbola_swigregister
Handle_Geom2d_Hyperbola_swigregister(Handle_Geom2d_Hyperbola)

def Handle_Geom2d_Hyperbola_DownCast(thing):
    return _Geom2d.Handle_Geom2d_Hyperbola_DownCast(thing)
Handle_Geom2d_Hyperbola_DownCast = _Geom2d.Handle_Geom2d_Hyperbola_DownCast

class Handle_Geom2d_AxisPlacement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_AxisPlacement self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_AxisPlacement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_AxisPlacement self, Geom2d_AxisPlacement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_AxisPlacement self, Handle_Geom2d_AxisPlacement theHandle) -> Handle_Geom2d_AxisPlacement
        assign(Handle_Geom2d_AxisPlacement self, Geom2d_AxisPlacement thePtr) -> Handle_Geom2d_AxisPlacement
        assign(Handle_Geom2d_AxisPlacement self, Handle_Geom2d_AxisPlacement theHandle) -> Handle_Geom2d_AxisPlacement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_AxisPlacement self) -> Geom2d_AxisPlacement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_AxisPlacement self) -> Geom2d_AxisPlacement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_AxisPlacement self) -> Geom2d_AxisPlacement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_AxisPlacement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_AxisPlacement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_AxisPlacement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_AxisPlacement_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_AxisPlacement

    def Reverse(self, *args):
        """Reverse(Handle_Geom2d_AxisPlacement self)"""
        return _Geom2d.Handle_Geom2d_AxisPlacement_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_AxisPlacement self) -> Handle_Geom2d_AxisPlacement

        Reverses the unit vector of this axis.
        Note:
        - Reverse assigns the result to this axis, while
        - Reversed creates a new one.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_AxisPlacement

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Reversed(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom2d_AxisPlacement self, gp_Ax2d A)

        Changes the complete definition of the axis placement.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom2d_AxisPlacement self, gp_Dir2d V)

        Changes the "Direction" of the axis placement.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P)

        Changes the "Location" point (origin) of the axis placement.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_SetLocation(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom2d_AxisPlacement self, Handle_Geom2d_AxisPlacement Other) -> Standard_Real

        Computes the angle between the "Direction" of
        two axis placement in radians.
        The result is comprised between -Pi and Pi.

        :type Other: OCC.wrapper.Geom2d.Handle_Geom2d_AxisPlacement
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Angle(self, *args)


    def Ax2d(self, *args):
        """
        Ax2d(Handle_Geom2d_AxisPlacement self) -> gp_Ax2d

        Converts this axis into a gp_Ax2d axis.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Ax2d(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_Geom2d_AxisPlacement self) -> gp_Dir2d

        Returns the "Direction" of <me>.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Direction(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom2d_AxisPlacement self) -> gp_Pnt2d

        Returns the "Location" point (origin) of the axis placement.
        -C++: return const&

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Location(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_AxisPlacement self, gp_Trsf2d T)

        Applies the transformation T to this axis.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_AxisPlacement self) -> Handle_Geom2d_Geometry

        Creates a new object which is a copy of this axis.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_AxisPlacement self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_AxisPlacement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_AxisPlacement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_AxisPlacement self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_AxisPlacement self, gp_Vec2d V)
        Translate(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_AxisPlacement self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_AxisPlacement self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_AxisPlacement self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_AxisPlacement self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_AxisPlacement self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_AxisPlacement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_AxisPlacement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_AxisPlacement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_AxisPlacement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_AxisPlacement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_AxisPlacement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_AxisPlacement self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_AxisPlacement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_AxisPlacement_DecrementRefCounter(self, *args)

Handle_Geom2d_AxisPlacement_swigregister = _Geom2d.Handle_Geom2d_AxisPlacement_swigregister
Handle_Geom2d_AxisPlacement_swigregister(Handle_Geom2d_AxisPlacement)

def Handle_Geom2d_AxisPlacement_DownCast(thing):
    return _Geom2d.Handle_Geom2d_AxisPlacement_DownCast(thing)
Handle_Geom2d_AxisPlacement_DownCast = _Geom2d.Handle_Geom2d_AxisPlacement_DownCast

class Handle_Geom2d_TrimmedCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2d_TrimmedCurve self)

        Nullify the handle


        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2d_TrimmedCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2d_TrimmedCurve self, Geom2d_TrimmedCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2d_TrimmedCurve self, Handle_Geom2d_TrimmedCurve theHandle) -> Handle_Geom2d_TrimmedCurve
        assign(Handle_Geom2d_TrimmedCurve self, Geom2d_TrimmedCurve thePtr) -> Handle_Geom2d_TrimmedCurve
        assign(Handle_Geom2d_TrimmedCurve self, Handle_Geom2d_TrimmedCurve theHandle) -> Handle_Geom2d_TrimmedCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2d_TrimmedCurve self) -> Geom2d_TrimmedCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2d_TrimmedCurve self) -> Geom2d_TrimmedCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2d_TrimmedCurve self) -> Geom2d_TrimmedCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom2d.Handle_Geom2d_TrimmedCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2d.Handle_Geom2d_TrimmedCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2d.new_Handle_Geom2d_TrimmedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2d.Handle_Geom2d_TrimmedCurve_DownCast)
    __swig_destroy__ = _Geom2d.delete_Handle_Geom2d_TrimmedCurve

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom2d_TrimmedCurve self)

        Changes the direction of parametrization of <me>. The first and
        the last parametric values are modified. The "StartPoint"
        of the initial curve becomes the "EndPoint" of the reversed
        curve and the "EndPoint" of the initial curve becomes the
        "StartPoint" of the reversed curve.
        Example  -   If the trimmed curve is defined by:
        - a basis curve whose parameter range is [ 0.,1. ], and
        - the two trim values U1 (first parameter) and U2 (last parameter),
        the reversed trimmed curve is defined by:
        - the reversed basis curve, whose parameter range is still [ 0.,1. ], and
        - the two trim values 1. - U2 (first parameter)
        and 1. - U1 (last parameter).


        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom2d_TrimmedCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns UFirst + ULast - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_ReversedParameter(self, *args)


    def SetTrim(self, *args):
        """
        SetTrim(Handle_Geom2d_TrimmedCurve self, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const Sense, Standard_Boolean const theAdjustPeriodic)

        Changes this trimmed curve, by redefining the
        parameter values U1 and U2, which limit its basis curve.
        Note: If the basis curve is periodic, the trimmed curve
        has the same orientation as the basis curve if Sense
        is true (default value) or the opposite orientation if Sense is false.
        Warning
        If the basis curve is periodic and theAdjustPeriodic is True,
        the bounds of the trimmed curve may be different from U1 and U2 if the
        parametric origin of the basis curve is within the arc
        of the trimmed curve. In this case, the modified
        parameter will be equal to U1 or U2 plus or minus the period.
        If theAdjustPeriodic is False, parameters U1 and U2 will stay unchanged.
        Exceptions
        Standard_ConstructionError if:
        - the basis curve is not periodic, and either U1 or U2
        are outside the bounds of the basis curve, or
        - U1 is equal to U2.

        :type U1: float
        :type U2: float
        :type Sense: bool
        :type theAdjustPeriodic: bool

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_SetTrim(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom2d_TrimmedCurve self) -> Handle_Geom2d_Curve

        Returns the basis curve.
        Warning
        This function does not return a constant reference.
        Consequently, any modification of the returned value
        directly modifies the trimmed curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom2d_TrimmedCurve self) -> GeomAbs_Shape

        Returns the global continuity of the basis curve of this trimmed curve.
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom2d_TrimmedCurve self, Standard_Integer const N) -> Standard_Boolean

        --- Purpose
        Returns True if the order of continuity of the
        trimmed curve is N. A trimmed curve is at least "C0" continuous.
        Warnings :
        The continuity of the trimmed curve can be greater than
        the continuity of the basis curve because you consider
        only a part of the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IsCN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom2d_TrimmedCurve self) -> gp_Pnt2d

        Returns the end point of <me>. This point is the
        evaluation of the curve for the "LastParameter".

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom2d_TrimmedCurve self) -> Standard_Real

        Returns the value of the first parameter of <me>.
        The first parameter is the parameter of the "StartPoint"
        of the trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_FirstParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom2d_TrimmedCurve self) -> Standard_Boolean

        Returns True if the distance between the StartPoint and
        the EndPoint is lower or equal to Resolution from package
        gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom2d_TrimmedCurve self) -> Standard_Boolean

        Always returns FALSE (independently of the type of basis curve).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom2d_TrimmedCurve self) -> Standard_Real

        Returns the period of the basis curve of this trimmed curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Period(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom2d_TrimmedCurve self) -> Standard_Real

        Returns the value of the last parameter of <me>.
        The last parameter is the parameter of the "EndPoint" of the
        trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_LastParameter(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom2d_TrimmedCurve self) -> gp_Pnt2d

        Returns the start point of <me>.
        This point is the evaluation of the curve from the
        "FirstParameter".
        value and derivatives
        Warnings :
        The returned derivatives have the same orientation as the
        derivatives of the basis curve.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_StartPoint(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P)

        If the basis curve is an OffsetCurve sometimes it is not
        possible to do the evaluation of the curve at the parameter
        U (see class OffsetCurve).

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom2d_TrimmedCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom2d_TrimmedCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this trimmed curve,
        computes the vector corresponding to the Nth derivative.
        Warning
        The returned derivative vector has the same
        orientation as the derivative vector of the basis curve,
        even if the trimmed curve does not have the same
        orientation as the basis curve.
        Exceptions
        Standard_RangeError if N is less than 1.
        geometric transformations

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom2d_TrimmedCurve self, gp_Trsf2d T)

        Applies the transformation T to this trimmed curve.
        Warning The basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom2d_TrimmedCurve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom2d_TrimmedCurve self, gp_Trsf2d T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom2d_TrimmedCurve self) -> Handle_Geom2d_Geometry

        Creates a new object, which is a copy of this trimmed curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2d_TrimmedCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_TrimmedCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2d.Handle_Geom2d_TrimmedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reversed(self, *args):
        """
        Reversed(Handle_Geom2d_TrimmedCurve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Reversed(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom2d_TrimmedCurve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P)
        Mirror(Handle_Geom2d_TrimmedCurve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom2d_TrimmedCurve self, gp_Vec2d V)
        Translate(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Geom2d_TrimmedCurve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom2d_TrimmedCurve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom2d_TrimmedCurve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Geom2d_TrimmedCurve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2d_TrimmedCurve self)

        Memory deallocator for transient classes


        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2d_TrimmedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2d_TrimmedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2d_TrimmedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2d_TrimmedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2d_TrimmedCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2d_TrimmedCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2d_TrimmedCurve self)

        Increments the reference counter of this object


        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2d_TrimmedCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2d.Handle_Geom2d_TrimmedCurve_DecrementRefCounter(self, *args)

Handle_Geom2d_TrimmedCurve_swigregister = _Geom2d.Handle_Geom2d_TrimmedCurve_swigregister
Handle_Geom2d_TrimmedCurve_swigregister(Handle_Geom2d_TrimmedCurve)

def Handle_Geom2d_TrimmedCurve_DownCast(thing):
    return _Geom2d.Handle_Geom2d_TrimmedCurve_DownCast(thing)
Handle_Geom2d_TrimmedCurve_DownCast = _Geom2d.Handle_Geom2d_TrimmedCurve_DownCast




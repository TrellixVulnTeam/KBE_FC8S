# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopTools')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopTools')
    _TopTools = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopTools', [dirname(__file__)])
        except ImportError:
            import _TopTools
            return _TopTools
        try:
            _mod = imp.load_module('_TopTools', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopTools = swig_import_helper()
    del swig_import_helper
else:
    import _TopTools
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopTools.delete_SwigPyIterator

    def value(self):
        return _TopTools.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopTools.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopTools.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopTools.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopTools.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopTools.SwigPyIterator_copy(self)

    def next(self):
        return _TopTools.SwigPyIterator_next(self)

    def __next__(self):
        return _TopTools.SwigPyIterator___next__(self)

    def previous(self):
        return _TopTools.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopTools.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopTools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopTools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopTools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopTools.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopTools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopTools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopTools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopTools.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopTools.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopTools.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopTools.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopTools.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopTools.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopTools.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopTools.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopTools.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopTools.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopTools.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopTools.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopTools.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopTools.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopTools.ptr_to_number(item)
ptr_to_number = _TopTools.ptr_to_number

def HashCode(*args):
    return _TopTools.HashCode(*args)
HashCode = _TopTools.HashCode

def ptr_equal(a, b):
    return _TopTools.ptr_equal(a, b)
ptr_equal = _TopTools.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class TopTools_HArray1OfShape(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopTools_HArray1OfShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopTools_HArray1OfShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopTools_HArray1OfShape self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TopTools_HArray1OfShape
        __init__(TopTools_HArray1OfShape self, Standard_Integer const theLower, Standard_Integer const theUpper, TopoDS_Shape theValue) -> TopTools_HArray1OfShape
        __init__(TopTools_HArray1OfShape self, NCollection_Array1_TopoDS_Shape theOther) -> TopTools_HArray1OfShape

        :type theOther: OCC.wrapper.TopTools.TopTools_Array1OfShape

        """
        this = _TopTools.new_TopTools_HArray1OfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfShape

        """
        res = _TopTools.TopTools_HArray1OfShape_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TopTools_HArray1OfShape self) -> NCollection_Array1_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfShape

        """
        return _TopTools.TopTools_HArray1OfShape_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopTools.TopTools_HArray1OfShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopTools.TopTools_HArray1OfShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.TopTools_HArray1OfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopTools.delete_TopTools_HArray1OfShape
TopTools_HArray1OfShape_swigregister = _TopTools.TopTools_HArray1OfShape_swigregister
TopTools_HArray1OfShape_swigregister(TopTools_HArray1OfShape)

def TopTools_HArray1OfShape_get_type_name(*args):
    """
    TopTools_HArray1OfShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopTools.TopTools_HArray1OfShape_get_type_name(*args)

def TopTools_HArray1OfShape_get_type_descriptor(*args):
    """
    TopTools_HArray1OfShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopTools.TopTools_HArray1OfShape_get_type_descriptor(*args)

class TopTools_ShapeMapHasher(object):
    """Hash tool, used for generating maps of shapes in topology."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(TopoDS_Shape S, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  Key <K>  in the
        range 0..Upper.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_ShapeMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

        Returns True  when the two  keys are the same. Two
        same  keys  must   have  the  same  hashcode,  the
        contrary is not necessary.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.TopTools_ShapeMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """Hash tool, used for generating maps of shapes in topology."""
        this = _TopTools.new_TopTools_ShapeMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_TopTools_ShapeMapHasher
TopTools_ShapeMapHasher_swigregister = _TopTools.TopTools_ShapeMapHasher_swigregister
TopTools_ShapeMapHasher_swigregister(TopTools_ShapeMapHasher)

def TopTools_ShapeMapHasher_HashCode(*args):
    """
    TopTools_ShapeMapHasher_HashCode(TopoDS_Shape S, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  Key <K>  in the
    range 0..Upper.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopTools.TopTools_ShapeMapHasher_HashCode(*args)

def TopTools_ShapeMapHasher_IsEqual(*args):
    """
    TopTools_ShapeMapHasher_IsEqual(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

    Returns True  when the two  keys are the same. Two
    same  keys  must   have  the  same  hashcode,  the
    contrary is not necessary.

    :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopTools.TopTools_ShapeMapHasher_IsEqual(*args)

class TopTools_HSequenceOfShape(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopTools_HSequenceOfShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopTools_HSequenceOfShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopTools_HSequenceOfShape self) -> TopTools_HSequenceOfShape
        __init__(TopTools_HSequenceOfShape self, NCollection_Sequence_TopoDS_Shape theOther) -> TopTools_HSequenceOfShape

        :type theOther: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        this = _TopTools.new_TopTools_HSequenceOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _TopTools.TopTools_HSequenceOfShape_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TopTools_HSequenceOfShape self, TopoDS_Shape theItem)
        Append(TopTools_HSequenceOfShape self, NCollection_Sequence_TopoDS_Shape theSequence)

        :type theSequence: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        return _TopTools.TopTools_HSequenceOfShape_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TopTools_HSequenceOfShape self) -> NCollection_Sequence_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        return _TopTools.TopTools_HSequenceOfShape_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopTools.TopTools_HSequenceOfShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopTools.TopTools_HSequenceOfShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.TopTools_HSequenceOfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopTools.delete_TopTools_HSequenceOfShape
TopTools_HSequenceOfShape_swigregister = _TopTools.TopTools_HSequenceOfShape_swigregister
TopTools_HSequenceOfShape_swigregister(TopTools_HSequenceOfShape)

def TopTools_HSequenceOfShape_get_type_name(*args):
    """
    TopTools_HSequenceOfShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopTools.TopTools_HSequenceOfShape_get_type_name(*args)

def TopTools_HSequenceOfShape_get_type_descriptor(*args):
    """
    TopTools_HSequenceOfShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopTools.TopTools_HSequenceOfShape_get_type_descriptor(*args)

class TopTools_OrientedShapeMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(TopoDS_Shape S, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  Key <K>  in the
        range 0..Upper.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_OrientedShapeMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

        Returns True when the two keys are equal. Two same
        keys must have the same hashcode,  the contrary is
        not necessary.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.TopTools_OrientedShapeMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _TopTools.new_TopTools_OrientedShapeMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_TopTools_OrientedShapeMapHasher
TopTools_OrientedShapeMapHasher_swigregister = _TopTools.TopTools_OrientedShapeMapHasher_swigregister
TopTools_OrientedShapeMapHasher_swigregister(TopTools_OrientedShapeMapHasher)

def TopTools_OrientedShapeMapHasher_HashCode(*args):
    """
    TopTools_OrientedShapeMapHasher_HashCode(TopoDS_Shape S, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  Key <K>  in the
    range 0..Upper.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopTools.TopTools_OrientedShapeMapHasher_HashCode(*args)

def TopTools_OrientedShapeMapHasher_IsEqual(*args):
    """
    TopTools_OrientedShapeMapHasher_IsEqual(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

    Returns True when the two keys are equal. Two same
    keys must have the same hashcode,  the contrary is
    not necessary.

    :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopTools.TopTools_OrientedShapeMapHasher_IsEqual(*args)

class TopTools_MutexForShapeProvider(object):
    """
    Class TopTools_MutexForShapeProvider 
    This class is used to create and store mutexes associated with shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopTools_MutexForShapeProvider self) -> TopTools_MutexForShapeProvider

        Constructor


        """
        this = _TopTools.new_TopTools_MutexForShapeProvider(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CreateMutexesForSubShapes(self, *args):
        """
        CreateMutexesForSubShapes(TopTools_MutexForShapeProvider self, TopoDS_Shape theShape, TopAbs_ShapeEnum const theType)

        Creates and associates mutexes with each sub-shape of type theType in theShape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopTools.TopTools_MutexForShapeProvider_CreateMutexesForSubShapes(self, *args)


    def CreateMutexForShape(self, *args):
        """
        CreateMutexForShape(TopTools_MutexForShapeProvider self, TopoDS_Shape theShape)

        Creates and associates mutex with theShape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopTools.TopTools_MutexForShapeProvider_CreateMutexForShape(self, *args)


    def GetMutex(self, *args):
        """
        GetMutex(TopTools_MutexForShapeProvider self, TopoDS_Shape theShape) -> Standard_Mutex

        Returns pointer to mutex associated with theShape.
        In case when mutex not found returns NULL.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Mutex

        """
        return _TopTools.TopTools_MutexForShapeProvider_GetMutex(self, *args)


    def RemoveAllMutexes(self, *args):
        """
        RemoveAllMutexes(TopTools_MutexForShapeProvider self)

        Removes all mutexes


        """
        return _TopTools.TopTools_MutexForShapeProvider_RemoveAllMutexes(self, *args)

    __swig_destroy__ = _TopTools.delete_TopTools_MutexForShapeProvider
TopTools_MutexForShapeProvider_swigregister = _TopTools.TopTools_MutexForShapeProvider_swigregister
TopTools_MutexForShapeProvider_swigregister(TopTools_MutexForShapeProvider)

class NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfInteger,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfInteger,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfInteger,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfInteger,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_Standard_Integer theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_Standard_Integer theItem) -> NCollection_List_Standard_Integer

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_Standard_Integer

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_Standard_Integer

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_Standard_Integer

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeListOfInteger = NCollection_DataMap_TopoDS_Shape_TColStd_ListOfInteger_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopTools_HArray1OfShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopTools_HArray1OfShape self)

        Nullify the handle


        """
        return _TopTools.Handle_TopTools_HArray1OfShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopTools_HArray1OfShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopTools_HArray1OfShape self, TopTools_HArray1OfShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopTools_HArray1OfShape self, Handle_TopTools_HArray1OfShape theHandle) -> Handle_TopTools_HArray1OfShape
        assign(Handle_TopTools_HArray1OfShape self, TopTools_HArray1OfShape thePtr) -> Handle_TopTools_HArray1OfShape
        assign(Handle_TopTools_HArray1OfShape self, Handle_TopTools_HArray1OfShape theHandle) -> Handle_TopTools_HArray1OfShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopTools_HArray1OfShape self) -> TopTools_HArray1OfShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopTools_HArray1OfShape self) -> TopTools_HArray1OfShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HArray1OfShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopTools_HArray1OfShape self) -> TopTools_HArray1OfShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopTools.Handle_TopTools_HArray1OfShape___ref__(self, *args)


    def __hash__(self):
        return _TopTools.Handle_TopTools_HArray1OfShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopTools.Handle_TopTools_HArray1OfShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopTools.new_Handle_TopTools_HArray1OfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopTools.Handle_TopTools_HArray1OfShape_DownCast)
    __swig_destroy__ = _TopTools.delete_Handle_TopTools_HArray1OfShape

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfShape

        """
        res = _TopTools.Handle_TopTools_HArray1OfShape_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TopTools_HArray1OfShape self) -> NCollection_Array1_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfShape

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopTools_HArray1OfShape self) -> char const *

        :rtype: const char *

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HArray1OfShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HArray1OfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopTools_HArray1OfShape self)

        Memory deallocator for transient classes


        """
        return _TopTools.Handle_TopTools_HArray1OfShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopTools_HArray1OfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopTools_HArray1OfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopTools_HArray1OfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopTools_HArray1OfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopTools_HArray1OfShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopTools_HArray1OfShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopTools_HArray1OfShape self)

        Increments the reference counter of this object


        """
        return _TopTools.Handle_TopTools_HArray1OfShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopTools_HArray1OfShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfShape_DecrementRefCounter(self, *args)

Handle_TopTools_HArray1OfShape_swigregister = _TopTools.Handle_TopTools_HArray1OfShape_swigregister
Handle_TopTools_HArray1OfShape_swigregister(Handle_TopTools_HArray1OfShape)

def Handle_TopTools_HArray1OfShape_DownCast(thing):
    return _TopTools.Handle_TopTools_HArray1OfShape_DownCast(thing)
Handle_TopTools_HArray1OfShape_DownCast = _TopTools.Handle_TopTools_HArray1OfShape_DownCast


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeShape = NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_ListOfInteger = TColStd.NCollection_List_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_SequenceOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_SequenceOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_SequenceOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_SequenceOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_TopoDS_Shape theItem) -> NCollection_Sequence_TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeSequenceOfShape = NCollection_DataMap_TopoDS_Shape_TopTools_SequenceOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Bnd_Box theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Bnd_Box theItem) -> Bnd_Box

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Bnd_Box

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Bnd_Box

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Bnd_Box

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeBox = NCollection_DataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, NCollection_List_TopoDS_Shape theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, NCollection_List_TopoDS_Shape theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> NCollection_List_TopoDS_Shape

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_List_TopoDS_Shape

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_List_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_List_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_IndexedDataMapOfShapeListOfShape = NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_swigregister = _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopTools_DataMapOfIntegerShape = NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfOrientedShapeInteger = NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_TopTools_ListOfShape(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TopTools_ListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TopTools_ListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TopTools_ListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TopTools_ListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TopTools.new_NCollection_Array1_TopTools_ListOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TopTools_ListOfShape self, NCollection_List_TopoDS_Shape theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TopTools_ListOfShape self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TopTools_ListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> NCollection_Array1_TopTools_ListOfShape

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TopTools_ListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> NCollection_Array1_TopTools_ListOfShape

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TopTools_ListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> NCollection_Array1_TopTools_ListOfShape
        assign(NCollection_Array1_TopTools_ListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> NCollection_Array1_TopTools_ListOfShape

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopTools_ListOfShape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TopTools_ListOfShape self) -> NCollection_List_TopoDS_Shape

        @return first element

        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopTools_ListOfShape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TopTools_ListOfShape self) -> NCollection_List_TopoDS_Shape

        @return last element

        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopTools_ListOfShape_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TopTools_ListOfShape self, Standard_Integer const theIndex) -> NCollection_List_TopoDS_Shape

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopTools_ListOfShape___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopTools_ListOfShape_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TopTools_ListOfShape self, Standard_Integer const theIndex, NCollection_List_TopoDS_Shape theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TopTools_ListOfShape self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TopTools.NCollection_Array1_TopTools_ListOfShape_Resize(self, *args)

    __swig_destroy__ = _TopTools.delete_NCollection_Array1_TopTools_ListOfShape
NCollection_Array1_TopTools_ListOfShape_swigregister = _TopTools.NCollection_Array1_TopTools_ListOfShape_swigregister
NCollection_Array1_TopTools_ListOfShape_swigregister(NCollection_Array1_TopTools_ListOfShape)


try:
	TopTools_Array1OfListOfShape = NCollection_Array1_TopTools_ListOfShape
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_TopoDS_Shape(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TopoDS_Shape self) -> NCollection_Array1< TopoDS_Shape >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TopoDS_Shape self) -> NCollection_Array1< TopoDS_Shape >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TopoDS_Shape self) -> NCollection_Array1< TopoDS_Shape >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TopoDS_Shape self) -> NCollection_Array1< TopoDS_Shape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TopTools.new_NCollection_Array1_TopoDS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TopoDS_Shape self, TopoDS_Shape theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TopoDS_Shape self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TopoDS_Shape self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TopoDS_Shape self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TopoDS_Shape self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TopoDS_Shape self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TopoDS_Shape self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TopoDS_Shape self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TopoDS_Shape self, NCollection_Array1_TopoDS_Shape theOther) -> NCollection_Array1_TopoDS_Shape

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TopoDS_Shape self, NCollection_Array1_TopoDS_Shape theOther) -> NCollection_Array1_TopoDS_Shape

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TopoDS_Shape self, NCollection_Array1_TopoDS_Shape theOther) -> NCollection_Array1_TopoDS_Shape
        assign(NCollection_Array1_TopoDS_Shape self, NCollection_Array1_TopoDS_Shape theOther) -> NCollection_Array1_TopoDS_Shape

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopoDS_Shape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TopoDS_Shape self) -> TopoDS_Shape

        @return first element

        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopoDS_Shape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TopoDS_Shape self) -> TopoDS_Shape

        @return last element

        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopoDS_Shape_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TopoDS_Shape self, Standard_Integer const theIndex) -> TopoDS_Shape

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopoDS_Shape___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array1_TopoDS_Shape_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TopoDS_Shape self, Standard_Integer const theIndex, TopoDS_Shape theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TopoDS_Shape self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TopTools.NCollection_Array1_TopoDS_Shape_Resize(self, *args)

    __swig_destroy__ = _TopTools.delete_NCollection_Array1_TopoDS_Shape
NCollection_Array1_TopoDS_Shape_swigregister = _TopTools.NCollection_Array1_TopoDS_Shape_swigregister
NCollection_Array1_TopoDS_Shape_swigregister(NCollection_Array1_TopoDS_Shape)


try:
	TopTools_Array1OfShape = NCollection_Array1_TopoDS_Shape
except NameError:
	pass # does not exist, probably ignored

class TopTools_HArray2OfShape(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopTools_HArray2OfShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopTools_HArray2OfShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopTools_HArray2OfShape self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> TopTools_HArray2OfShape
        __init__(TopTools_HArray2OfShape self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, TopoDS_Shape theValue) -> TopTools_HArray2OfShape
        __init__(TopTools_HArray2OfShape self, NCollection_Array2_TopoDS_Shape theOther) -> TopTools_HArray2OfShape

        :type theOther: OCC.wrapper.TopTools.TopTools_Array2OfShape

        """
        this = _TopTools.new_TopTools_HArray2OfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_Array2OfShape

        """
        res = _TopTools.TopTools_HArray2OfShape_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(TopTools_HArray2OfShape self) -> NCollection_Array2_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_Array2OfShape

        """
        return _TopTools.TopTools_HArray2OfShape_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopTools.TopTools_HArray2OfShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopTools.TopTools_HArray2OfShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.TopTools_HArray2OfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopTools.delete_TopTools_HArray2OfShape
TopTools_HArray2OfShape_swigregister = _TopTools.TopTools_HArray2OfShape_swigregister
TopTools_HArray2OfShape_swigregister(TopTools_HArray2OfShape)

def TopTools_HArray2OfShape_get_type_name(*args):
    """
    TopTools_HArray2OfShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopTools.TopTools_HArray2OfShape_get_type_name(*args)

def TopTools_HArray2OfShape_get_type_descriptor(*args):
    """
    TopTools_HArray2OfShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopTools.TopTools_HArray2OfShape_get_type_descriptor(*args)

class NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Integer,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeInteger = NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedMap< TopoDS_Shape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedMap< TopoDS_Shape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopTools.new_NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self)

        RemoveLast


        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher
NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister
NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher)

class NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopTools_IndexedMapOfOrientedShape = NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_Map< TopoDS_Shape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_Map< TopoDS_Shape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TopTools.new_NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape K) -> Standard_Boolean
        Contains(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Differ(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher
NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister = _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister
NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher)

class NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopTools_MapOfOrientedShape = NCollection_Map_TopoDS_Shape_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopTools_HSequenceOfShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopTools_HSequenceOfShape self)

        Nullify the handle


        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopTools_HSequenceOfShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopTools_HSequenceOfShape self, TopTools_HSequenceOfShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopTools_HSequenceOfShape self, Handle_TopTools_HSequenceOfShape theHandle) -> Handle_TopTools_HSequenceOfShape
        assign(Handle_TopTools_HSequenceOfShape self, TopTools_HSequenceOfShape thePtr) -> Handle_TopTools_HSequenceOfShape
        assign(Handle_TopTools_HSequenceOfShape self, Handle_TopTools_HSequenceOfShape theHandle) -> Handle_TopTools_HSequenceOfShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopTools_HSequenceOfShape self) -> TopTools_HSequenceOfShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopTools_HSequenceOfShape self) -> TopTools_HSequenceOfShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopTools_HSequenceOfShape self) -> TopTools_HSequenceOfShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape___ref__(self, *args)


    def __hash__(self):
        return _TopTools.Handle_TopTools_HSequenceOfShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopTools.Handle_TopTools_HSequenceOfShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopTools.new_Handle_TopTools_HSequenceOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopTools.Handle_TopTools_HSequenceOfShape_DownCast)
    __swig_destroy__ = _TopTools.delete_Handle_TopTools_HSequenceOfShape

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _TopTools.Handle_TopTools_HSequenceOfShape_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TopTools_HSequenceOfShape self, TopoDS_Shape theItem)
        Append(Handle_TopTools_HSequenceOfShape self, NCollection_Sequence_TopoDS_Shape theSequence)

        :type theSequence: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TopTools_HSequenceOfShape self) -> NCollection_Sequence_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopTools_HSequenceOfShape self) -> char const *

        :rtype: const char *

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HSequenceOfShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HSequenceOfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopTools_HSequenceOfShape self)

        Memory deallocator for transient classes


        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopTools_HSequenceOfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopTools_HSequenceOfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopTools_HSequenceOfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopTools_HSequenceOfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopTools_HSequenceOfShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopTools_HSequenceOfShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopTools_HSequenceOfShape self)

        Increments the reference counter of this object


        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopTools_HSequenceOfShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HSequenceOfShape_DecrementRefCounter(self, *args)

Handle_TopTools_HSequenceOfShape_swigregister = _TopTools.Handle_TopTools_HSequenceOfShape_swigregister
Handle_TopTools_HSequenceOfShape_swigregister(Handle_TopTools_HSequenceOfShape)

def Handle_TopTools_HSequenceOfShape_DownCast(thing):
    return _TopTools.Handle_TopTools_HSequenceOfShape_DownCast(thing)
Handle_TopTools_HSequenceOfShape_DownCast = _TopTools.Handle_TopTools_HSequenceOfShape_DownCast

class NCollection_Sequence_TopoDS_Shape(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TopoDS_Shape self) -> NCollection_Sequence< TopoDS_Shape >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TopoDS_Shape self) -> NCollection_Sequence< TopoDS_Shape >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TopoDS_Shape self) -> NCollection_Sequence< TopoDS_Shape >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TopoDS_Shape self) -> NCollection_Sequence< TopoDS_Shape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TopTools.new_NCollection_Sequence_TopoDS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TopoDS_Shape self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TopoDS_Shape self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TopoDS_Shape self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TopoDS_Shape self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TopoDS_Shape self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TopoDS_Shape self)

        Reverse sequence


        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TopoDS_Shape self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TopoDS_Shape self, NCollection_Sequence_TopoDS_Shape theOther) -> NCollection_Sequence_TopoDS_Shape

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TopoDS_Shape self, NCollection_Sequence_TopoDS_Shape theOther) -> NCollection_Sequence_TopoDS_Shape

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TopoDS_Shape self, NCollection_Sequence< TopoDS_Shape >::Iterator & thePosition)
        Remove(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TopoDS_Shape self, TopoDS_Shape theItem)
        Append(NCollection_Sequence_TopoDS_Shape self, NCollection_Sequence_TopoDS_Shape theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TopoDS_Shape self, TopoDS_Shape theItem)
        Prepend(NCollection_Sequence_TopoDS_Shape self, NCollection_Sequence_TopoDS_Shape theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex, TopoDS_Shape theItem)
        InsertBefore(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex, NCollection_Sequence_TopoDS_Shape theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TopoDS_Shape self, NCollection_Sequence< TopoDS_Shape >::Iterator & thePosition, TopoDS_Shape theItem)
        InsertAfter(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex, NCollection_Sequence_TopoDS_Shape theSeq)
        InsertAfter(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex, TopoDS_Shape theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex, NCollection_Sequence_TopoDS_Shape theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Sequence_TopoDS_Shape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TopoDS_Shape self) -> TopoDS_Shape

        First item access

        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Sequence_TopoDS_Shape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TopoDS_Shape self) -> TopoDS_Shape

        Last item access

        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Sequence_TopoDS_Shape_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex) -> TopoDS_Shape

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Sequence_TopoDS_Shape___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TopoDS_Shape self, Standard_Integer const theIndex, TopoDS_Shape theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_Sequence_TopoDS_Shape_SetValue(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_Sequence_TopoDS_Shape___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_Sequence_TopoDS_Shape
NCollection_Sequence_TopoDS_Shape_swigregister = _TopTools.NCollection_Sequence_TopoDS_Shape_swigregister
NCollection_Sequence_TopoDS_Shape_swigregister(NCollection_Sequence_TopoDS_Shape)

def NCollection_Sequence_TopoDS_Shape_delNode(*args):
    """
    NCollection_Sequence_TopoDS_Shape_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TopTools.NCollection_Sequence_TopoDS_Shape_delNode(*args)

class NCollection_Sequence_TopoDS_Shape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_Sequence_TopoDS_Shape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_Sequence_TopoDS_Shape_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_Sequence_TopoDS_Shape_IteratorHelper___next__(self)
NCollection_Sequence_TopoDS_Shape_IteratorHelper_swigregister = _TopTools.NCollection_Sequence_TopoDS_Shape_IteratorHelper_swigregister
NCollection_Sequence_TopoDS_Shape_IteratorHelper_swigregister(NCollection_Sequence_TopoDS_Shape_IteratorHelper)


try:
	TopTools_SequenceOfShape = NCollection_Sequence_TopoDS_Shape
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array2_TopoDS_Shape(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TopTools.new_NCollection_Array2_TopoDS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_TopoDS_Shape self, TopoDS_Shape theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_TopoDS_Shape self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_TopoDS_Shape self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_TopoDS_Shape self, NCollection_Array2_TopoDS_Shape theOther) -> NCollection_Array2_TopoDS_Shape

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_TopoDS_Shape self, NCollection_Array2_TopoDS_Shape theOther) -> NCollection_Array2_TopoDS_Shape

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array2_TopoDS_Shape_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_TopoDS_Shape self, Standard_Integer const theRow, Standard_Integer const theCol) -> TopoDS_Shape

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_Array2_TopoDS_Shape___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_TopoDS_Shape self, Standard_Integer const theRow, Standard_Integer const theCol, TopoDS_Shape theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_Array2_TopoDS_Shape_SetValue(self, *args)

    __swig_destroy__ = _TopTools.delete_NCollection_Array2_TopoDS_Shape
NCollection_Array2_TopoDS_Shape_swigregister = _TopTools.NCollection_Array2_TopoDS_Shape_swigregister
NCollection_Array2_TopoDS_Shape_swigregister(NCollection_Array2_TopoDS_Shape)


try:
	TopTools_Array2OfShape = NCollection_Array2_TopoDS_Shape
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopTools_ListOfShape,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopTools_ListOfShape,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopTools_ListOfShape,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopTools_ListOfShape,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_TopoDS_Shape theItem) -> NCollection_List_TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_swigregister = _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopTools_DataMapOfIntegerListOfShape = NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class TopTools_HArray1OfListOfShape(NCollection_Array1_TopTools_ListOfShape, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopTools_HArray1OfListOfShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopTools_HArray1OfListOfShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopTools_HArray1OfListOfShape self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TopTools_HArray1OfListOfShape
        __init__(TopTools_HArray1OfListOfShape self, Standard_Integer const theLower, Standard_Integer const theUpper, NCollection_List_TopoDS_Shape theValue) -> TopTools_HArray1OfListOfShape
        __init__(TopTools_HArray1OfListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> TopTools_HArray1OfListOfShape

        :type theOther: OCC.wrapper.TopTools.TopTools_Array1OfListOfShape

        """
        this = _TopTools.new_TopTools_HArray1OfListOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfListOfShape

        """
        res = _TopTools.TopTools_HArray1OfListOfShape_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TopTools_HArray1OfListOfShape self) -> NCollection_Array1_TopTools_ListOfShape

        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfListOfShape

        """
        return _TopTools.TopTools_HArray1OfListOfShape_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopTools.TopTools_HArray1OfListOfShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopTools.TopTools_HArray1OfListOfShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.TopTools_HArray1OfListOfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopTools.delete_TopTools_HArray1OfListOfShape
TopTools_HArray1OfListOfShape_swigregister = _TopTools.TopTools_HArray1OfListOfShape_swigregister
TopTools_HArray1OfListOfShape_swigregister(TopTools_HArray1OfListOfShape)

def TopTools_HArray1OfListOfShape_get_type_name(*args):
    """
    TopTools_HArray1OfListOfShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopTools.TopTools_HArray1OfListOfShape_get_type_name(*args)

def TopTools_HArray1OfListOfShape_get_type_descriptor(*args):
    """
    TopTools_HArray1OfListOfShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopTools.TopTools_HArray1OfListOfShape_get_type_descriptor(*args)

class NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,void *,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, void *const & theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, void *const & theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> void *&

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> void *&

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> void *const *

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> void **

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_IndexedDataMapOfShapeAddress = NCollection_IndexedDataMap_TopoDS_Shape_Standard_Address_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopTools_ShapeSet(object):
    """
    A ShapeSets    contains  a  Shape    and all   its
    sub-shapes and locations.  It  can be dump,  write
    and read.

    Methods to handle the geometry can be redefined.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopTools_ShapeSet self) -> TopTools_ShapeSet

        Builds an empty ShapeSet.


        """
        this = _TopTools.new_TopTools_ShapeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFormatNb(self, *args):
        """
        SetFormatNb(TopTools_ShapeSet self, Standard_Integer const theFormatNb)

        :type theFormatNb: int

        """
        return _TopTools.TopTools_ShapeSet_SetFormatNb(self, *args)


    def FormatNb(self, *args):
        """
        FormatNb(TopTools_ShapeSet self) -> Standard_Integer

        two formats available for the moment:
        First: does not write CurveOnSurface UV Points into the file
        on reading calls Check() method.
        Second: stores CurveOnSurface UV Points.
        On reading format is recognized from Version string.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_ShapeSet_FormatNb(self, *args)


    def Clear(self, *args):
        """
        Clear(TopTools_ShapeSet self)

        Clears the content of the set.  This method can be
        redefined.


        """
        return _TopTools.TopTools_ShapeSet_Clear(self, *args)


    def Add(self, *args):
        """
        Add(TopTools_ShapeSet self, TopoDS_Shape S) -> Standard_Integer

        Stores <S> and its sub-shape. Returns the index of <S>.
        The method AddGeometry is called on each sub-shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_ShapeSet_Add(self, *args)


    def Shape(self, *args):
        """
        Returns the sub-shape of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopTools.TopTools_ShapeSet_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(TopTools_ShapeSet self, TopoDS_Shape S) -> Standard_Integer

        Returns the index of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_ShapeSet_Index(self, *args)


    def Locations(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_LocationSet

        """
        res = _TopTools.TopTools_ShapeSet_Locations(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLocations(self, *args):
        """
        ChangeLocations(TopTools_ShapeSet self) -> TopTools_LocationSet

        :rtype: OCC.wrapper.TopTools.TopTools_LocationSet

        """
        return _TopTools.TopTools_ShapeSet_ChangeLocations(self, *args)


    def DumpExtent(self, *args):
        """
        DumpExtent(TopTools_ShapeSet self, Standard_OStream & OS) -> Standard_OStream
        DumpExtent(TopTools_ShapeSet self, TCollection_AsciiString S)

        Dumps the number of objects in me in the string S
        (Number of shapes of each type)

        :type S: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopTools.TopTools_ShapeSet_DumpExtent(self, *args)


    def Dump(self, *args):
        """
        Dump(TopTools_ShapeSet self, Standard_OStream & OS)
        Dump(TopTools_ShapeSet self, TopoDS_Shape S, Standard_OStream & OS)

        Dumps   on  <OS>    the  shape  <S>.   Dumps   the
        orientation, the index of the TShape and the index
        of the Location.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools_ShapeSet_Dump(self, *args)


    def Write(self, *args):
        """
        Write(TopTools_ShapeSet self, Standard_OStream & OS)
        Write(TopTools_ShapeSet self, TopoDS_Shape S, Standard_OStream & OS)

        Writes   on  <OS>   the shape   <S>.    Writes the
        orientation, the index of the TShape and the index
        of the Location.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools_ShapeSet_Write(self, *args)


    def Read(self, *args):
        """
        Read(TopTools_ShapeSet self, Standard_IStream & IS)
        Read(TopTools_ShapeSet self, TopoDS_Shape S, Standard_IStream & IS)

        Reads from <IS> a shape and returns it in S.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type IS: OCC.wrapper.Standard.Standard_IStream

        """
        return _TopTools.TopTools_ShapeSet_Read(self, *args)


    def AddGeometry(self, *args):
        """
        AddGeometry(TopTools_ShapeSet self, TopoDS_Shape S)

        Stores the geometry of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopTools.TopTools_ShapeSet_AddGeometry(self, *args)


    def DumpGeometry(self, *args):
        """
        DumpGeometry(TopTools_ShapeSet self, Standard_OStream & OS)
        DumpGeometry(TopTools_ShapeSet self, TopoDS_Shape S, Standard_OStream & OS)

        Dumps the geometry of <S> on the stream <OS>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools_ShapeSet_DumpGeometry(self, *args)


    def WriteGeometry(self, *args):
        """
        WriteGeometry(TopTools_ShapeSet self, Standard_OStream & OS)
        WriteGeometry(TopTools_ShapeSet self, TopoDS_Shape S, Standard_OStream & OS)

        Writes the geometry of <S>  on the stream <OS> in a
        format that can be read back by Read.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools_ShapeSet_WriteGeometry(self, *args)


    def ReadGeometry(self, *args):
        """
        ReadGeometry(TopTools_ShapeSet self, Standard_IStream & IS)
        ReadGeometry(TopTools_ShapeSet self, TopAbs_ShapeEnum const T, Standard_IStream & IS, TopoDS_Shape S)

        Reads the geometry of a shape of type <T> from the
        stream <IS> and returns it in <S>.

        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type IS: OCC.wrapper.Standard.Standard_IStream
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopTools.TopTools_ShapeSet_ReadGeometry(self, *args)


    def AddShapes(self, *args):
        """
        AddShapes(TopTools_ShapeSet self, TopoDS_Shape S1, TopoDS_Shape S2)

        Inserts  the shape <S2> in  the  shape <S1>.  This
        method must be   redefined  to  use   the  correct
        builder.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopTools.TopTools_ShapeSet_AddShapes(self, *args)


    def Check(self, *args):
        """
        Check(TopTools_ShapeSet self, TopAbs_ShapeEnum const T, TopoDS_Shape S)

        This method is   called after  each  new  completed
        shape. <T> is the  type. <S> is  the shape. In this
        class it does nothing, but it gives the opportunity
        in derived  classes to perform  extra  treatment on
        shapes.

        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopTools.TopTools_ShapeSet_Check(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(TopTools_ShapeSet self) -> Standard_Integer

        Returns number of shapes read from file.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_ShapeSet_NbShapes(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(TopTools_ShapeSet self, Handle_Message_ProgressIndicator PR)

        :type PR: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _TopTools.TopTools_ShapeSet_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(TopTools_ShapeSet self) -> Handle_Message_ProgressIndicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _TopTools.TopTools_ShapeSet_GetProgress(self, *args)

    __swig_destroy__ = _TopTools.delete_TopTools_ShapeSet
TopTools_ShapeSet_swigregister = _TopTools.TopTools_ShapeSet_swigregister
TopTools_ShapeSet_swigregister(TopTools_ShapeSet)

class NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, TopoDS_Shape theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, TopoDS_Shape theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> TopoDS_Shape

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopoDS_Shape

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_IndexedDataMapOfShapeShape = NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopTools_LocationSet(object):
    """
    The class LocationSet stores a set of location in
    a relocatable state.

    It can be created from Locations.

    It can create Locations.

    It can be write and read from a stream.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopTools_LocationSet self) -> TopTools_LocationSet

        Returns an empty set of locations.


        """
        this = _TopTools.new_TopTools_LocationSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(TopTools_LocationSet self)

        Clears the content of the set.


        """
        return _TopTools.TopTools_LocationSet_Clear(self, *args)


    def Add(self, *args):
        """
        Add(TopTools_LocationSet self, TopLoc_Location L) -> Standard_Integer

        Incorporate a new Location in the  set and returns
        its index.

        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_LocationSet_Add(self, *args)


    def Location(self, *args):
        """
        Returns the location of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _TopTools.TopTools_LocationSet_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(TopTools_LocationSet self, TopLoc_Location L) -> Standard_Integer

        Returns the index of <L>.

        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.TopTools_LocationSet_Index(self, *args)


    def Dump(self, *args):
        """
        Dump(TopTools_LocationSet self, Standard_OStream & OS)

        Dumps the content of me on the stream <OS>.

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools_LocationSet_Dump(self, *args)


    def Write(self, *args):
        """
        Write(TopTools_LocationSet self, Standard_OStream & OS)

        Writes the content of  me  on the stream <OS> in a
        format that can be read back by Read.

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools_LocationSet_Write(self, *args)


    def Read(self, *args):
        """
        Read(TopTools_LocationSet self, Standard_IStream & IS)

        Reads the content of me from the  stream  <IS>. me
        is first cleared.

        :type IS: OCC.wrapper.Standard.Standard_IStream

        """
        return _TopTools.TopTools_LocationSet_Read(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(TopTools_LocationSet self, Handle_Message_ProgressIndicator PR)

        :type PR: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _TopTools.TopTools_LocationSet_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(TopTools_LocationSet self) -> Handle_Message_ProgressIndicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _TopTools.TopTools_LocationSet_GetProgress(self, *args)

    __swig_destroy__ = _TopTools.delete_TopTools_LocationSet
TopTools_LocationSet_swigregister = _TopTools.TopTools_LocationSet_swigregister
TopTools_LocationSet_swigregister(TopTools_LocationSet)

class NCollection_List_TopTools_ListOfShape(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_TopTools_ListOfShape self) -> NCollection_List< TopTools_ListOfShape >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_TopTools_ListOfShape self) -> NCollection_List< TopTools_ListOfShape >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_TopTools_ListOfShape self) -> NCollection_List< TopTools_ListOfShape >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_TopTools_ListOfShape self) -> NCollection_List< TopTools_ListOfShape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TopTools.new_NCollection_List_TopTools_ListOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_TopTools_ListOfShape self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopTools_ListOfShape theOther) -> NCollection_List_TopTools_ListOfShape

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopTools_ListOfShape theOther) -> NCollection_List_TopTools_ListOfShape

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_TopTools_ListOfShape self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_List_TopTools_ListOfShape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_List_TopTools_ListOfShape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopoDS_Shape theItem) -> NCollection_List_TopoDS_Shape
        Append(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopoDS_Shape theItem, NCollection_List< TopTools_ListOfShape >::Iterator & theIter)
        Append(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopTools_ListOfShape theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopoDS_Shape theItem) -> NCollection_List_TopoDS_Shape
        Prepend(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopTools_ListOfShape theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_TopTools_ListOfShape self)

        RemoveFirst item


        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_TopTools_ListOfShape self, NCollection_List< TopTools_ListOfShape >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopoDS_Shape theItem, NCollection_List< TopTools_ListOfShape >::Iterator & theIter) -> NCollection_List_TopoDS_Shape
        InsertBefore(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopTools_ListOfShape theOther, NCollection_List< TopTools_ListOfShape >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopoDS_Shape theItem, NCollection_List< TopTools_ListOfShape >::Iterator & theIter) -> NCollection_List_TopoDS_Shape
        InsertAfter(NCollection_List_TopTools_ListOfShape self, NCollection_List_TopTools_ListOfShape theOther, NCollection_List< TopTools_ListOfShape >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_TopTools_ListOfShape self)

        Reverse the list


        """
        return _TopTools.NCollection_List_TopTools_ListOfShape_Reverse(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_List_TopTools_ListOfShape___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_List_TopTools_ListOfShape
NCollection_List_TopTools_ListOfShape_swigregister = _TopTools.NCollection_List_TopTools_ListOfShape_swigregister
NCollection_List_TopTools_ListOfShape_swigregister(NCollection_List_TopTools_ListOfShape)

class NCollection_List_TopTools_ListOfShape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_List_TopTools_ListOfShape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_List_TopTools_ListOfShape_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_List_TopTools_ListOfShape_IteratorHelper___next__(self)
NCollection_List_TopTools_ListOfShape_IteratorHelper_swigregister = _TopTools.NCollection_List_TopTools_ListOfShape_IteratorHelper_swigregister
NCollection_List_TopTools_ListOfShape_IteratorHelper_swigregister(NCollection_List_TopTools_ListOfShape_IteratorHelper)


try:
	TopTools_ListOfListOfShape = NCollection_List_TopTools_ListOfShape
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopoDS_Shape,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfOrientedShapeShape = NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TopTools_ListOfShape = TopoDS.NCollection_List_TopoDS_Shape
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_IndexedMap< TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_IndexedMap< TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopTools.new_NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher
NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher)

class NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_IndexedMapOfShape = NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopTools_HArray2OfShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopTools_HArray2OfShape self)

        Nullify the handle


        """
        return _TopTools.Handle_TopTools_HArray2OfShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopTools_HArray2OfShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopTools_HArray2OfShape self, TopTools_HArray2OfShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopTools_HArray2OfShape self, Handle_TopTools_HArray2OfShape theHandle) -> Handle_TopTools_HArray2OfShape
        assign(Handle_TopTools_HArray2OfShape self, TopTools_HArray2OfShape thePtr) -> Handle_TopTools_HArray2OfShape
        assign(Handle_TopTools_HArray2OfShape self, Handle_TopTools_HArray2OfShape theHandle) -> Handle_TopTools_HArray2OfShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopTools_HArray2OfShape self) -> TopTools_HArray2OfShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopTools_HArray2OfShape self) -> TopTools_HArray2OfShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HArray2OfShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopTools_HArray2OfShape self) -> TopTools_HArray2OfShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopTools.Handle_TopTools_HArray2OfShape___ref__(self, *args)


    def __hash__(self):
        return _TopTools.Handle_TopTools_HArray2OfShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopTools.Handle_TopTools_HArray2OfShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopTools.new_Handle_TopTools_HArray2OfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopTools.Handle_TopTools_HArray2OfShape_DownCast)
    __swig_destroy__ = _TopTools.delete_Handle_TopTools_HArray2OfShape

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_Array2OfShape

        """
        res = _TopTools.Handle_TopTools_HArray2OfShape_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_TopTools_HArray2OfShape self) -> NCollection_Array2_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_Array2OfShape

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopTools_HArray2OfShape self) -> char const *

        :rtype: const char *

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HArray2OfShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HArray2OfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopTools_HArray2OfShape self)

        Memory deallocator for transient classes


        """
        return _TopTools.Handle_TopTools_HArray2OfShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopTools_HArray2OfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopTools_HArray2OfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopTools_HArray2OfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopTools_HArray2OfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopTools_HArray2OfShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopTools_HArray2OfShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopTools_HArray2OfShape self)

        Increments the reference counter of this object


        """
        return _TopTools.Handle_TopTools_HArray2OfShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopTools_HArray2OfShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray2OfShape_DecrementRefCounter(self, *args)

Handle_TopTools_HArray2OfShape_swigregister = _TopTools.Handle_TopTools_HArray2OfShape_swigregister
Handle_TopTools_HArray2OfShape_swigregister(Handle_TopTools_HArray2OfShape)

def Handle_TopTools_HArray2OfShape_DownCast(thing):
    return _TopTools.Handle_TopTools_HArray2OfShape_DownCast(thing)
Handle_TopTools_HArray2OfShape_DownCast = _TopTools.Handle_TopTools_HArray2OfShape_DownCast

class NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_Map< TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self) -> NCollection_Map< TopoDS_Shape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TopTools.new_NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, TopoDS_Shape K) -> Standard_Boolean
        Contains(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theLeft, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_Differ(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher
NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister
NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_swigregister(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher)

class NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_MapOfShape = NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, double const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, double const & theItem) -> double *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> double const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> double *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> double &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeReal = NCollection_DataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Standard_Real,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, double const & theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, double const & theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> double &

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> double &

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> double const *

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> double *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_IndexedDataMapOfShapeReal = NCollection_IndexedDataMap_TopoDS_Shape_Standard_Real_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopTools_(object):
    """
    The  TopTools package provides   utilities for the
    topological data structure.

    * ShapeMapHasher. Hash a  Shape base on the TShape
    and the Location. The Orientation is not used.

    * OrientedShapeMapHasher. Hash a Shape base on the
    TShape ,the Location and the Orientation.

    * Instantiations of TCollection for Shapes :
    MapOfShape
    IndexedMapOfShape
    DataMapOfIntegerShape
    DataMapOfShapeInteger
    DataMapOfShapeReal
    Array1OfShape
    HArray1OfShape
    SequenceOfShape
    HSequenceOfShape
    ListOfShape
    Array1OfListShape
    HArray1OfListShape
    DataMapOfIntegerListOfShape
    DataMapOfShapeListOfShape
    DataMapOfShapeListOfInteger
    IndexedDataMapOfShapeShape
    IndexedDataMapOfShapeListOfShape
    DataMapOfShapeShape
    IndexedMapOfOrientedShape
    DataMapOfShapeSequenceOfShape
    IndexedDataMapOfShapeAddress
    DataMapOfOrientedShapeShape

    * LocationSet : to write sets of locations.

    * ShapeSet : to writes sets of TShapes.

    Package Methods :

    Dump : To dump the topology of a Shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(*args):
        """
        Dump(TopoDS_Shape Sh, Standard_OStream & S)

        A set of Shapes. Can be dump, wrote or read.
        Dumps the topological structure  of <Sh>  on the
        stream <S>.

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopTools.TopTools__Dump(*args)

    Dump = staticmethod(Dump)

    def Dummy(*args):
        """
        Dummy(Standard_Integer const I)

        This is to bypass an extraction bug. It will force
        the  inclusion    of  Standard_Integer.hxx  itself
        including Standard_OStream.hxx  at   the   correct
        position.

        :type I: int

        """
        return _TopTools.TopTools__Dummy(*args)

    Dummy = staticmethod(Dummy)

    def __init__(self):
        """
        The  TopTools package provides   utilities for the
        topological data structure.

        * ShapeMapHasher. Hash a  Shape base on the TShape
        and the Location. The Orientation is not used.

        * OrientedShapeMapHasher. Hash a Shape base on the
        TShape ,the Location and the Orientation.

        * Instantiations of TCollection for Shapes :
        MapOfShape
        IndexedMapOfShape
        DataMapOfIntegerShape
        DataMapOfShapeInteger
        DataMapOfShapeReal
        Array1OfShape
        HArray1OfShape
        SequenceOfShape
        HSequenceOfShape
        ListOfShape
        Array1OfListShape
        HArray1OfListShape
        DataMapOfIntegerListOfShape
        DataMapOfShapeListOfShape
        DataMapOfShapeListOfInteger
        IndexedDataMapOfShapeShape
        IndexedDataMapOfShapeListOfShape
        DataMapOfShapeShape
        IndexedMapOfOrientedShape
        DataMapOfShapeSequenceOfShape
        IndexedDataMapOfShapeAddress
        DataMapOfOrientedShapeShape

        * LocationSet : to write sets of locations.

        * ShapeSet : to writes sets of TShapes.

        Package Methods :

        Dump : To dump the topology of a Shape.
        """
        this = _TopTools.new_TopTools_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_TopTools_
TopTools__swigregister = _TopTools.TopTools__swigregister
TopTools__swigregister(TopTools_)

def TopTools__Dump(*args):
    """
    TopTools__Dump(TopoDS_Shape Sh, Standard_OStream & S)

    A set of Shapes. Can be dump, wrote or read.
    Dumps the topological structure  of <Sh>  on the
    stream <S>.

    :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S: OCC.wrapper.Standard.Standard_OStream

    """
    return _TopTools.TopTools__Dump(*args)

def TopTools__Dummy(*args):
    """
    TopTools__Dummy(Standard_Integer const I)

    This is to bypass an extraction bug. It will force
    the  inclusion    of  Standard_Integer.hxx  itself
    including Standard_OStream.hxx  at   the   correct
    position.

    :type I: int

    """
    return _TopTools.TopTools__Dummy(*args)

class NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_ListOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_TopoDS_Shape theItem) -> NCollection_List_TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopTools.new_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTools.delete_NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopTools.NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopTools_DataMapOfShapeListOfShape = NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopTools_HArray1OfListOfShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopTools_HArray1OfListOfShape self)

        Nullify the handle


        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopTools_HArray1OfListOfShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopTools_HArray1OfListOfShape self, TopTools_HArray1OfListOfShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopTools_HArray1OfListOfShape self, Handle_TopTools_HArray1OfListOfShape theHandle) -> Handle_TopTools_HArray1OfListOfShape
        assign(Handle_TopTools_HArray1OfListOfShape self, TopTools_HArray1OfListOfShape thePtr) -> Handle_TopTools_HArray1OfListOfShape
        assign(Handle_TopTools_HArray1OfListOfShape self, Handle_TopTools_HArray1OfListOfShape theHandle) -> Handle_TopTools_HArray1OfListOfShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopTools_HArray1OfListOfShape self) -> TopTools_HArray1OfListOfShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopTools_HArray1OfListOfShape self) -> TopTools_HArray1OfListOfShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopTools_HArray1OfListOfShape self) -> TopTools_HArray1OfListOfShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape___ref__(self, *args)


    def __hash__(self):
        return _TopTools.Handle_TopTools_HArray1OfListOfShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopTools.Handle_TopTools_HArray1OfListOfShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopTools.new_Handle_TopTools_HArray1OfListOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopTools.Handle_TopTools_HArray1OfListOfShape_DownCast)
    __swig_destroy__ = _TopTools.delete_Handle_TopTools_HArray1OfListOfShape

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfListOfShape

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_Array1_TopTools_ListOfShape

        :rtype: OCC.wrapper.TopTools.TopTools_Array1OfListOfShape

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopTools_HArray1OfListOfShape self) -> char const *

        :rtype: const char *

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_Array1< TopTools_ListOfShape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TopTools_HArray1OfListOfShape self, NCollection_List_TopoDS_Shape theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_TopTools_HArray1OfListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> NCollection_Array1_TopTools_ListOfShape

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_TopTools_HArray1OfListOfShape self, NCollection_Array1_TopTools_ListOfShape theOther) -> NCollection_Array1_TopTools_ListOfShape

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_List_TopoDS_Shape

        @return first element

        :rtype: TheItemType &

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_TopTools_HArray1OfListOfShape self) -> NCollection_List_TopoDS_Shape

        @return last element

        :rtype: TheItemType &

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopTools.Handle_TopTools_HArray1OfListOfShape_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_TopTools_HArray1OfListOfShape self, Standard_Integer const theIndex) -> NCollection_List_TopoDS_Shape

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TopTools_HArray1OfListOfShape self, Standard_Integer const theIndex, NCollection_List_TopoDS_Shape theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_TopTools_HArray1OfListOfShape self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopTools_HArray1OfListOfShape self)

        Memory deallocator for transient classes


        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopTools_HArray1OfListOfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopTools_HArray1OfListOfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopTools_HArray1OfListOfShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopTools_HArray1OfListOfShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopTools_HArray1OfListOfShape self)

        Increments the reference counter of this object


        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopTools_HArray1OfListOfShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTools.Handle_TopTools_HArray1OfListOfShape_DecrementRefCounter(self, *args)

Handle_TopTools_HArray1OfListOfShape_swigregister = _TopTools.Handle_TopTools_HArray1OfListOfShape_swigregister
Handle_TopTools_HArray1OfListOfShape_swigregister(Handle_TopTools_HArray1OfListOfShape)

def Handle_TopTools_HArray1OfListOfShape_DownCast(thing):
    return _TopTools.Handle_TopTools_HArray1OfListOfShape_DownCast(thing)
Handle_TopTools_HArray1OfListOfShape_DownCast = _TopTools.Handle_TopTools_HArray1OfListOfShape_DownCast




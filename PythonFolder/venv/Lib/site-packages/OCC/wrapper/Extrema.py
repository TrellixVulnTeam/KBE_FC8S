# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Extrema')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Extrema')
    _Extrema = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Extrema', [dirname(__file__)])
        except ImportError:
            import _Extrema
            return _Extrema
        try:
            _mod = imp.load_module('_Extrema', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Extrema = swig_import_helper()
    del swig_import_helper
else:
    import _Extrema
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Extrema.delete_SwigPyIterator

    def value(self):
        return _Extrema.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Extrema.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Extrema.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Extrema.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Extrema.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Extrema.SwigPyIterator_copy(self)

    def next(self):
        return _Extrema.SwigPyIterator_next(self)

    def __next__(self):
        return _Extrema.SwigPyIterator___next__(self)

    def previous(self):
        return _Extrema.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Extrema.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Extrema.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Extrema.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Extrema.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Extrema.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Extrema.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Extrema.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Extrema.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Extrema.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Extrema.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Extrema.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Extrema.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Extrema.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Extrema.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Extrema.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Extrema.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Extrema.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Extrema.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Extrema.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Extrema.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Extrema.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Extrema.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Extrema.ptr_to_number(item)
ptr_to_number = _Extrema.ptr_to_number

def HashCode(*args):
    return _Extrema.HashCode(*args)
HashCode = _Extrema.HashCode

def ptr_equal(a, b):
    return _Extrema.ptr_equal(a, b)
ptr_equal = _Extrema.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
Extrema_Node = _Extrema.Extrema_Node
Extrema_UIsoEdge = _Extrema.Extrema_UIsoEdge
Extrema_VIsoEdge = _Extrema.Extrema_VIsoEdge
Extrema_Face = _Extrema.Extrema_Face
Extrema_ExtAlgo_Grad = _Extrema.Extrema_ExtAlgo_Grad
Extrema_ExtAlgo_Tree = _Extrema.Extrema_ExtAlgo_Tree
Extrema_ExtFlag_MIN = _Extrema.Extrema_ExtFlag_MIN
Extrema_ExtFlag_MAX = _Extrema.Extrema_ExtFlag_MAX
Extrema_ExtFlag_MINMAX = _Extrema.Extrema_ExtFlag_MINMAX
class Extrema_POnSurf(object):
    """Definition of a point on surface."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_POnSurf self) -> Extrema_POnSurf
        __init__(Extrema_POnSurf self, Standard_Real const U, Standard_Real const V, gp_Pnt P) -> Extrema_POnSurf

        Creation of a point on surface with parameter
        values on the surface and a Pnt from gp.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        this = _Extrema.new_Extrema_POnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the 3d point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Extrema.Extrema_POnSurf_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetParameters(self, *args):
        """
        SetParameters(Extrema_POnSurf self, Standard_Real const theU, Standard_Real const theV, gp_Pnt thePnt)

        Sets the params of current POnSurf instance.
        (e.g. to the point to be projected).

        :type theU: float
        :type theV: float
        :type thePnt: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_POnSurf_SetParameters(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Extrema_POnSurf self)

        Returns the parameter values on the surface.

        :type U: float
        :type V: float

        """
        return _Extrema.Extrema_POnSurf_Parameter(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_POnSurf
Extrema_POnSurf_swigregister = _Extrema.Extrema_POnSurf_swigregister
Extrema_POnSurf_swigregister(Extrema_POnSurf)

class Extrema_ExtPExtS(Standard.Standard_Transient):
    """
    It calculates all the extremum (minimum and
    maximum) distances between a point and a linear
    extrusion surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_ExtPExtS
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_ExtPExtS(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_ExtPExtS self) -> Extrema_ExtPExtS
        __init__(Extrema_ExtPExtS self, gp_Pnt P, Handle_GeomAdaptor_HSurfaceOfLinearExtrusion S, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV) -> Extrema_ExtPExtS
        __init__(Extrema_ExtPExtS self, gp_Pnt P, Handle_GeomAdaptor_HSurfaceOfLinearExtrusion S, Standard_Real const TolU, Standard_Real const TolV) -> Extrema_ExtPExtS

        It calculates all the distances between a point
        from gp and a Surface.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurfaceOfLinearExtrusion
        :type TolU: float
        :type TolV: float

        """
        this = _Extrema.new_Extrema_ExtPExtS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtPExtS self, Handle_GeomAdaptor_HSurfaceOfLinearExtrusion S, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV)

        Initializes the fields of the algorithm.

        :type S: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurfaceOfLinearExtrusion
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float

        """
        return _Extrema.Extrema_ExtPExtS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtPExtS self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtPExtS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPExtS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPExtS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPExtS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPExtS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPExtS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPExtS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_ExtPExtS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_ExtPExtS_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_ExtPExtS_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_ExtPExtS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_ExtPExtS
Extrema_ExtPExtS_swigregister = _Extrema.Extrema_ExtPExtS_swigregister
Extrema_ExtPExtS_swigregister(Extrema_ExtPExtS)

def Extrema_ExtPExtS_get_type_name(*args):
    """
    Extrema_ExtPExtS_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_ExtPExtS_get_type_name(*args)

def Extrema_ExtPExtS_get_type_descriptor(*args):
    """
    Extrema_ExtPExtS_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_ExtPExtS_get_type_descriptor(*args)

class Extrema_POnSurfParams(Extrema_POnSurf):
    """
    Data container for point on surface parameters. These parameters
    are required to compute an initial approximation for extrema
    computation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_POnSurfParams self) -> Extrema_POnSurfParams
        __init__(Extrema_POnSurfParams self, Standard_Real const theU, Standard_Real const theV, gp_Pnt thePnt) -> Extrema_POnSurfParams

        Creation of a point on surface with parameter
        values on the surface and a Pnt from gp.

        :type theU: float
        :type theV: float
        :type thePnt: OCC.wrapper.gp.gp_Pnt

        """
        this = _Extrema.new_Extrema_POnSurfParams(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetSqrDistance(self, *args):
        """
        SetSqrDistance(Extrema_POnSurfParams self, Standard_Real const theSqrDistance)

        Sets the square distance from this point to another one
        (e.g. to the point to be projected).

        :type theSqrDistance: float

        """
        return _Extrema.Extrema_POnSurfParams_SetSqrDistance(self, *args)


    def GetSqrDistance(self, *args):
        """
        GetSqrDistance(Extrema_POnSurfParams self) -> Standard_Real

        Query the square distance from this point to another one.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_POnSurfParams_GetSqrDistance(self, *args)


    def SetElementType(self, *args):
        """
        SetElementType(Extrema_POnSurfParams self, Extrema_ElementType const theElementType)

        Sets the element type on which this point is situated.

        :type theElementType: OCC.wrapper.Extrema.Extrema_ElementType

        """
        return _Extrema.Extrema_POnSurfParams_SetElementType(self, *args)


    def GetElementType(self, *args):
        """
        GetElementType(Extrema_POnSurfParams self) -> Extrema_ElementType

        Query the element type on which this point is situated.

        :rtype: OCC.wrapper.Extrema.Extrema_ElementType

        """
        return _Extrema.Extrema_POnSurfParams_GetElementType(self, *args)


    def SetIndices(self, *args):
        """
        SetIndices(Extrema_POnSurfParams self, Standard_Integer const theIndexU, Standard_Integer const theIndexV)

        Sets the U and V indices of an element that contains
        this point.

        :type theIndexU: int
        :type theIndexV: int

        """
        return _Extrema.Extrema_POnSurfParams_SetIndices(self, *args)


    def GetIndices(self, *args):
        """
        GetIndices(Extrema_POnSurfParams self)

        Query the U and V indices of an element that contains
        this point.

        :type theIndexU: int
        :type theIndexV: int

        """
        return _Extrema.Extrema_POnSurfParams_GetIndices(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_POnSurfParams
Extrema_POnSurfParams_swigregister = _Extrema.Extrema_POnSurfParams_swigregister
Extrema_POnSurfParams_swigregister(Extrema_POnSurfParams)

class Extrema_HArray2OfPOnSurf(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray2OfPOnSurf
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray2OfPOnSurf(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray2OfPOnSurf self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> Extrema_HArray2OfPOnSurf
        __init__(Extrema_HArray2OfPOnSurf self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, Extrema_POnSurf theValue) -> Extrema_HArray2OfPOnSurf
        __init__(Extrema_HArray2OfPOnSurf self, NCollection_Array2_Extrema_POnSurf theOther) -> Extrema_HArray2OfPOnSurf

        :type theOther: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurf

        """
        this = _Extrema.new_Extrema_HArray2OfPOnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurf

        """
        res = _Extrema.Extrema_HArray2OfPOnSurf_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Extrema_HArray2OfPOnSurf self) -> NCollection_Array2_Extrema_POnSurf

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurf

        """
        return _Extrema.Extrema_HArray2OfPOnSurf_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray2OfPOnSurf_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray2OfPOnSurf_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray2OfPOnSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray2OfPOnSurf
Extrema_HArray2OfPOnSurf_swigregister = _Extrema.Extrema_HArray2OfPOnSurf_swigregister
Extrema_HArray2OfPOnSurf_swigregister(Extrema_HArray2OfPOnSurf)

def Extrema_HArray2OfPOnSurf_get_type_name(*args):
    """
    Extrema_HArray2OfPOnSurf_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray2OfPOnSurf_get_type_name(*args)

def Extrema_HArray2OfPOnSurf_get_type_descriptor(*args):
    """
    Extrema_HArray2OfPOnSurf_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray2OfPOnSurf_get_type_descriptor(*args)

class Extrema_HArray2OfPOnSurfParams(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray2OfPOnSurfParams
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray2OfPOnSurfParams(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray2OfPOnSurfParams self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> Extrema_HArray2OfPOnSurfParams
        __init__(Extrema_HArray2OfPOnSurfParams self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, Extrema_POnSurfParams theValue) -> Extrema_HArray2OfPOnSurfParams
        __init__(Extrema_HArray2OfPOnSurfParams self, NCollection_Array2_Extrema_POnSurfParams theOther) -> Extrema_HArray2OfPOnSurfParams

        :type theOther: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurfParams

        """
        this = _Extrema.new_Extrema_HArray2OfPOnSurfParams(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurfParams

        """
        res = _Extrema.Extrema_HArray2OfPOnSurfParams_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Extrema_HArray2OfPOnSurfParams self) -> NCollection_Array2_Extrema_POnSurfParams

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurfParams

        """
        return _Extrema.Extrema_HArray2OfPOnSurfParams_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray2OfPOnSurfParams_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray2OfPOnSurfParams_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray2OfPOnSurfParams_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray2OfPOnSurfParams
Extrema_HArray2OfPOnSurfParams_swigregister = _Extrema.Extrema_HArray2OfPOnSurfParams_swigregister
Extrema_HArray2OfPOnSurfParams_swigregister(Extrema_HArray2OfPOnSurfParams)

def Extrema_HArray2OfPOnSurfParams_get_type_name(*args):
    """
    Extrema_HArray2OfPOnSurfParams_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray2OfPOnSurfParams_get_type_name(*args)

def Extrema_HArray2OfPOnSurfParams_get_type_descriptor(*args):
    """
    Extrema_HArray2OfPOnSurfParams_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray2OfPOnSurfParams_get_type_descriptor(*args)

class Extrema_Curve2dTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Adaptor2d_Curve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_Curve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Adaptor2d_Curve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_Curve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Adaptor2d_Curve2d C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Extrema.Extrema_Curve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Adaptor2d_Curve2d C, GeomAbs_Shape const S) -> Standard_Integer

        If necessary,   breaks the curve  in  intervals of
        continuity <S>.     And   returns  the  number  of
        intervals.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_Curve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Adaptor2d_Curve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Extrema.Extrema_Curve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def DeflCurvIntervals(*args):
        """
        DeflCurvIntervals(Adaptor2d_Curve2d C) -> Handle_TColStd_HArray1OfReal

        Returns the parameters bounding the intervals of subdivision of curve
        according to Curvature deflection. Value of deflection is defined in method.


        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Extrema.Extrema_Curve2dTool_DeflCurvIntervals(*args)

    DeflCurvIntervals = staticmethod(DeflCurvIntervals)

    def IsClosed(*args):
        """
        IsClosed(Adaptor2d_Curve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_Curve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Adaptor2d_Curve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_Curve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Adaptor2d_Curve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_Curve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Adaptor2d_Curve2d C, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_Curve2dTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_Curve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point of parameter U on the curve with its
        first derivative.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Extrema.Extrema_Curve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Extrema.Extrema_Curve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Extrema.Extrema_Curve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Adaptor2d_Curve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Extrema.Extrema_Curve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Adaptor2d_Curve2d C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_Curve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Adaptor2d_Curve2d C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Extrema.Extrema_Curve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Adaptor2d_Curve2d C) -> gp_Lin2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Extrema.Extrema_Curve2dTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Adaptor2d_Curve2d C) -> gp_Circ2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Extrema.Extrema_Curve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Adaptor2d_Curve2d C) -> gp_Elips2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Extrema.Extrema_Curve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Adaptor2d_Curve2d C) -> gp_Hypr2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Extrema.Extrema_Curve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Adaptor2d_Curve2d C) -> gp_Parab2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Extrema.Extrema_Curve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Degree(*args):
        """
        Degree(Adaptor2d_Curve2d C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_Curve2dTool_Degree(*args)

    Degree = staticmethod(Degree)

    def IsRational(*args):
        """
        IsRational(Adaptor2d_Curve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_Curve2dTool_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def NbPoles(*args):
        """
        NbPoles(Adaptor2d_Curve2d C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_Curve2dTool_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def NbKnots(*args):
        """
        NbKnots(Adaptor2d_Curve2d C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_Curve2dTool_NbKnots(*args)

    NbKnots = staticmethod(NbKnots)

    def Bezier(*args):
        """
        Bezier(Adaptor2d_Curve2d C) -> Handle_Geom2d_BezierCurve

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Extrema.Extrema_Curve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Adaptor2d_Curve2d C) -> Handle_Geom2d_BSplineCurve

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Extrema.Extrema_Curve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def __init__(self):
        this = _Extrema.new_Extrema_Curve2dTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_Extrema_Curve2dTool
Extrema_Curve2dTool_swigregister = _Extrema.Extrema_Curve2dTool_swigregister
Extrema_Curve2dTool_swigregister(Extrema_Curve2dTool)

def Extrema_Curve2dTool_FirstParameter(*args):
    """
    Extrema_Curve2dTool_FirstParameter(Adaptor2d_Curve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_Curve2dTool_FirstParameter(*args)

def Extrema_Curve2dTool_LastParameter(*args):
    """
    Extrema_Curve2dTool_LastParameter(Adaptor2d_Curve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_Curve2dTool_LastParameter(*args)

def Extrema_Curve2dTool_Continuity(*args):
    """
    Extrema_Curve2dTool_Continuity(Adaptor2d_Curve2d C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _Extrema.Extrema_Curve2dTool_Continuity(*args)

def Extrema_Curve2dTool_NbIntervals(*args):
    """
    Extrema_Curve2dTool_NbIntervals(Adaptor2d_Curve2d C, GeomAbs_Shape const S) -> Standard_Integer

    If necessary,   breaks the curve  in  intervals of
    continuity <S>.     And   returns  the  number  of
    intervals.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_Curve2dTool_NbIntervals(*args)

def Extrema_Curve2dTool_Intervals(*args):
    """
    Extrema_Curve2dTool_Intervals(Adaptor2d_Curve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _Extrema.Extrema_Curve2dTool_Intervals(*args)

def Extrema_Curve2dTool_DeflCurvIntervals(*args):
    """
    Extrema_Curve2dTool_DeflCurvIntervals(Adaptor2d_Curve2d C) -> Handle_TColStd_HArray1OfReal

    Returns the parameters bounding the intervals of subdivision of curve
    according to Curvature deflection. Value of deflection is defined in method.


    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _Extrema.Extrema_Curve2dTool_DeflCurvIntervals(*args)

def Extrema_Curve2dTool_IsClosed(*args):
    """
    Extrema_Curve2dTool_IsClosed(Adaptor2d_Curve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Extrema.Extrema_Curve2dTool_IsClosed(*args)

def Extrema_Curve2dTool_IsPeriodic(*args):
    """
    Extrema_Curve2dTool_IsPeriodic(Adaptor2d_Curve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Extrema.Extrema_Curve2dTool_IsPeriodic(*args)

def Extrema_Curve2dTool_Period(*args):
    """
    Extrema_Curve2dTool_Period(Adaptor2d_Curve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_Curve2dTool_Period(*args)

def Extrema_Curve2dTool_Value(*args):
    """
    Extrema_Curve2dTool_Value(Adaptor2d_Curve2d C, Standard_Real const U) -> gp_Pnt2d

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Extrema.Extrema_Curve2dTool_Value(*args)

def Extrema_Curve2dTool_D0(*args):
    """
    Extrema_Curve2dTool_D0(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Extrema.Extrema_Curve2dTool_D0(*args)

def Extrema_Curve2dTool_D1(*args):
    """
    Extrema_Curve2dTool_D1(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

    Computes the point of parameter U on the curve with its
    first derivative.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _Extrema.Extrema_Curve2dTool_D1(*args)

def Extrema_Curve2dTool_D2(*args):
    """
    Extrema_Curve2dTool_D2(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _Extrema.Extrema_Curve2dTool_D2(*args)

def Extrema_Curve2dTool_D3(*args):
    """
    Extrema_Curve2dTool_D3(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _Extrema.Extrema_Curve2dTool_D3(*args)

def Extrema_Curve2dTool_DN(*args):
    """
    Extrema_Curve2dTool_DN(Adaptor2d_Curve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

    The returned vector gives the value of the derivative for the
    order of derivation N.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _Extrema.Extrema_Curve2dTool_DN(*args)

def Extrema_Curve2dTool_Resolution(*args):
    """
    Extrema_Curve2dTool_Resolution(Adaptor2d_Curve2d C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_Curve2dTool_Resolution(*args)

def Extrema_Curve2dTool_GetType(*args):
    """
    Extrema_Curve2dTool_GetType(Adaptor2d_Curve2d C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _Extrema.Extrema_Curve2dTool_GetType(*args)

def Extrema_Curve2dTool_Line(*args):
    """
    Extrema_Curve2dTool_Line(Adaptor2d_Curve2d C) -> gp_Lin2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Lin2d

    """
    return _Extrema.Extrema_Curve2dTool_Line(*args)

def Extrema_Curve2dTool_Circle(*args):
    """
    Extrema_Curve2dTool_Circle(Adaptor2d_Curve2d C) -> gp_Circ2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Circ2d

    """
    return _Extrema.Extrema_Curve2dTool_Circle(*args)

def Extrema_Curve2dTool_Ellipse(*args):
    """
    Extrema_Curve2dTool_Ellipse(Adaptor2d_Curve2d C) -> gp_Elips2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Elips2d

    """
    return _Extrema.Extrema_Curve2dTool_Ellipse(*args)

def Extrema_Curve2dTool_Hyperbola(*args):
    """
    Extrema_Curve2dTool_Hyperbola(Adaptor2d_Curve2d C) -> gp_Hypr2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Hypr2d

    """
    return _Extrema.Extrema_Curve2dTool_Hyperbola(*args)

def Extrema_Curve2dTool_Parabola(*args):
    """
    Extrema_Curve2dTool_Parabola(Adaptor2d_Curve2d C) -> gp_Parab2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Parab2d

    """
    return _Extrema.Extrema_Curve2dTool_Parabola(*args)

def Extrema_Curve2dTool_Degree(*args):
    """
    Extrema_Curve2dTool_Degree(Adaptor2d_Curve2d C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_Curve2dTool_Degree(*args)

def Extrema_Curve2dTool_IsRational(*args):
    """
    Extrema_Curve2dTool_IsRational(Adaptor2d_Curve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Extrema.Extrema_Curve2dTool_IsRational(*args)

def Extrema_Curve2dTool_NbPoles(*args):
    """
    Extrema_Curve2dTool_NbPoles(Adaptor2d_Curve2d C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_Curve2dTool_NbPoles(*args)

def Extrema_Curve2dTool_NbKnots(*args):
    """
    Extrema_Curve2dTool_NbKnots(Adaptor2d_Curve2d C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_Curve2dTool_NbKnots(*args)

def Extrema_Curve2dTool_Bezier(*args):
    """
    Extrema_Curve2dTool_Bezier(Adaptor2d_Curve2d C) -> Handle_Geom2d_BezierCurve

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

    """
    return _Extrema.Extrema_Curve2dTool_Bezier(*args)

def Extrema_Curve2dTool_BSpline(*args):
    """
    Extrema_Curve2dTool_BSpline(Adaptor2d_Curve2d C) -> Handle_Geom2d_BSplineCurve

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _Extrema.Extrema_Curve2dTool_BSpline(*args)

class Extrema_PCFOfEPCOfELPCOfLocateExtPC2d(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self) -> Extrema_PCFOfEPCOfELPCOfLocateExtPC2d
        __init__(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C) -> Extrema_PCFOfEPCOfELPCOfLocateExtPC2d

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Extrema.new_Extrema_PCFOfEPCOfELPCOfLocateExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Adaptor2d_Curve2d C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, gp_Pnt2d P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_PCFOfEPCOfELPCOfLocateExtPC2d
Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_swigregister = _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_swigregister
Extrema_PCFOfEPCOfELPCOfLocateExtPC2d_swigregister(Extrema_PCFOfEPCOfELPCOfLocateExtPC2d)

class Extrema_FuncExtCS(math.math_FunctionSetWithDerivatives):
    """
    Function to find extrema of the
    distance between a curve and a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_FuncExtCS self) -> Extrema_FuncExtCS
        __init__(Extrema_FuncExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S) -> Extrema_FuncExtCS

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        this = _Extrema.new_Extrema_FuncExtCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_FuncExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S)

        sets the field mysurf of the function.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        return _Extrema.Extrema_FuncExtCS_Initialize(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Extrema_FuncExtCS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtCS_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Extrema_FuncExtCS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtCS_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_FuncExtCS self, math_Vector UV, math_Vector F) -> Standard_Boolean

        Calculation of Fi(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncExtCS_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Extrema_FuncExtCS self, math_Vector UV, math_Matrix DF) -> Standard_Boolean

        Calculation of Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncExtCS_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_FuncExtCS self, math_Vector UV, math_Vector F, math_Matrix DF) -> Standard_Boolean

        Calculation of Fi(U,V) and Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncExtCS_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_FuncExtCS self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtCS_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_FuncExtCS self) -> Standard_Integer

        Return the number of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtCS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_FuncExtCS self, Standard_Integer const N) -> Standard_Real

        Return the value of the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_FuncExtCS_SquareDistance(self, *args)


    def PointOnCurve(self, *args):
        """
        Returns the Nth extremum on C.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_FuncExtCS_PointOnCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnSurface(self, *args):
        """
        Return the Nth extremum on S.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_FuncExtCS_PointOnSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_FuncExtCS
Extrema_FuncExtCS_swigregister = _Extrema.Extrema_FuncExtCS_swigregister
Extrema_FuncExtCS_swigregister(Extrema_FuncExtCS)

class Extrema_POnCurv2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_POnCurv2d self) -> Extrema_POnCurv2d
        __init__(Extrema_POnCurv2d self, Standard_Real const U, gp_Pnt2d P) -> Extrema_POnCurv2d

        Creation of a point on curve with a parameter
        value on the curve and a Pnt from gp.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _Extrema.new_Extrema_POnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(Extrema_POnCurv2d self, Standard_Real const U, gp_Pnt2d P)

        sets the point and parameter values.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_POnCurv2d_SetValues(self, *args)


    def Value(self, *args):
        """
        Returns the point.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Extrema.Extrema_POnCurv2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Extrema_POnCurv2d self) -> Standard_Real

        Returns the parameter on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_POnCurv2d_Parameter(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_POnCurv2d
Extrema_POnCurv2d_swigregister = _Extrema.Extrema_POnCurv2d_swigregister
Extrema_POnCurv2d_swigregister(Extrema_POnCurv2d)

class Handle_Extrema_ExtPExtS(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_ExtPExtS self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_ExtPExtS_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_ExtPExtS self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_ExtPExtS_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_ExtPExtS self, Extrema_ExtPExtS thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_ExtPExtS_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_ExtPExtS self, Handle_Extrema_ExtPExtS theHandle) -> Handle_Extrema_ExtPExtS
        assign(Handle_Extrema_ExtPExtS self, Extrema_ExtPExtS thePtr) -> Handle_Extrema_ExtPExtS
        assign(Handle_Extrema_ExtPExtS self, Handle_Extrema_ExtPExtS theHandle) -> Handle_Extrema_ExtPExtS

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_ExtPExtS_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_ExtPExtS self) -> Extrema_ExtPExtS

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_ExtPExtS_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_ExtPExtS self) -> Extrema_ExtPExtS

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_ExtPExtS___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_ExtPExtS self) -> Extrema_ExtPExtS

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_ExtPExtS___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_ExtPExtS___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_ExtPExtS___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_ExtPExtS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_ExtPExtS_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_ExtPExtS

    def Initialize(self, *args):
        """
        Initialize(Handle_Extrema_ExtPExtS self, Handle_GeomAdaptor_HSurfaceOfLinearExtrusion S, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV)

        Initializes the fields of the algorithm.

        :type S: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurfaceOfLinearExtrusion
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float

        """
        return _Extrema.Handle_Extrema_ExtPExtS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_Extrema_ExtPExtS self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Handle_Extrema_ExtPExtS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_Extrema_ExtPExtS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_ExtPExtS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Handle_Extrema_ExtPExtS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_ExtPExtS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Handle_Extrema_ExtPExtS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Handle_Extrema_ExtPExtS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Handle_Extrema_ExtPExtS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_ExtPExtS self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_ExtPExtS_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_ExtPExtS_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_ExtPExtS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_ExtPExtS self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_ExtPExtS_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_ExtPExtS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_ExtPExtS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_ExtPExtS_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_ExtPExtS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_ExtPExtS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_ExtPExtS_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_ExtPExtS self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_ExtPExtS_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_ExtPExtS self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_ExtPExtS_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_ExtPExtS self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_ExtPExtS_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_ExtPExtS self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_ExtPExtS_DecrementRefCounter(self, *args)

Handle_Extrema_ExtPExtS_swigregister = _Extrema.Handle_Extrema_ExtPExtS_swigregister
Handle_Extrema_ExtPExtS_swigregister(Handle_Extrema_ExtPExtS)

def Handle_Extrema_ExtPExtS_DownCast(thing):
    return _Extrema.Handle_Extrema_ExtPExtS_DownCast(thing)
Handle_Extrema_ExtPExtS_DownCast = _Extrema.Handle_Extrema_ExtPExtS_DownCast

class Extrema_LocECC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocECC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const U0, Standard_Real const V0, Standard_Real const TolU, Standard_Real const TolV) -> Extrema_LocECC

        Calculates the distance with a close point. The
        close point is defined by a parameter value on each
        curve.
        The function F(u,v)=distance(C1(u),C2(v)) has an
        extremun when gradient(f)=0. The algorithm searchs
        the zero near the close point.

        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type C2: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U0: float
        :type V0: float
        :type TolU: float
        :type TolV: float

        """
        this = _Extrema.new_Extrema_LocECC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Extrema_LocECC self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocECC_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocECC self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocECC_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Point(Extrema_LocECC self, Extrema_POnCurv P1, Extrema_POnCurv P2)

        Returns the points of the extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        return _Extrema.Extrema_LocECC_Point(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_LocECC
Extrema_LocECC_swigregister = _Extrema.Extrema_LocECC_swigregister
Extrema_LocECC_swigregister(Extrema_LocECC)

class Extrema_GenExtPS(object):
    """
    It calculates all the extremum distances
    between a point and a surface.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GenExtPS self) -> Extrema_GenExtPS
        __init__(Extrema_GenExtPS self, gp_Pnt P, Adaptor3d_Surface S, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const TolU, Standard_Real const TolV, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> Extrema_GenExtPS
        __init__(Extrema_GenExtPS self, gp_Pnt P, Adaptor3d_Surface S, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> Extrema_GenExtPS

        It calculates all the distances.
        The function F(u,v)=distance(P,S(u,v)) has an
        extremum when gradient(F)=0. The algorithm searchs
        all the zeros inside the definition ranges of the
        surface.
        NbU and NbV are used to locate the close points
        to find the zeros. They must be great enough
        such that if there is N extrema, there will
        be N extrema between P and the grid.
        TolU et TolV are used to determine the conditions
        to stop the iterations; at the iteration number n:
        (Un - Un-1) < TolU and (Vn - Vn-1) < TolV .

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type NbU: int
        :type NbV: int
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float
        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag
        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        this = _Extrema.new_Extrema_GenExtPS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_GenExtPS self, Adaptor3d_Surface S, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const TolU, Standard_Real const TolV)
        Initialize(Extrema_GenExtPS self, Adaptor3d_Surface S, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV)

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type NbU: int
        :type NbV: int
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float

        """
        return _Extrema.Extrema_GenExtPS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_GenExtPS self, gp_Pnt P)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_GenExtPS_Perform(self, *args)


    def SetFlag(self, *args):
        """
        SetFlag(Extrema_GenExtPS self, Extrema_ExtFlag const F)

        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag

        """
        return _Extrema.Extrema_GenExtPS_SetFlag(self, *args)


    def SetAlgo(self, *args):
        """
        SetAlgo(Extrema_GenExtPS self, Extrema_ExtAlgo const A)

        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _Extrema.Extrema_GenExtPS_SetAlgo(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_GenExtPS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GenExtPS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_GenExtPS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GenExtPS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_GenExtPS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_GenExtPS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenExtPS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_GenExtPS
Extrema_GenExtPS_swigregister = _Extrema.Extrema_GenExtPS_swigregister
Extrema_GenExtPS_swigregister(Extrema_GenExtPS)

class Extrema_GlobOptFuncCCC2(math.math_MultipleVarFunctionWithHessian):
    """
    This class implements function which calculate Eucluidean distance
    between point on curve and point on other curve in case of C1 and C2 continuity is C2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GlobOptFuncCCC2 self, Adaptor3d_Curve C1, Adaptor3d_Curve C2) -> Extrema_GlobOptFuncCCC2
        __init__(Extrema_GlobOptFuncCCC2 self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2) -> Extrema_GlobOptFuncCCC2

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Extrema.new_Extrema_GlobOptFuncCCC2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(Extrema_GlobOptFuncCCC2 self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GlobOptFuncCCC2_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_GlobOptFuncCCC2 self, math_Vector X) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC2_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(Extrema_GlobOptFuncCCC2 self, math_Vector X, math_Vector G) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC2_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_GlobOptFuncCCC2 self, math_Vector X, math_Vector G) -> Standard_Boolean
        Values(Extrema_GlobOptFuncCCC2 self, math_Vector X, math_Vector G, math_Matrix H) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :type H: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC2_Values(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_GlobOptFuncCCC2
Extrema_GlobOptFuncCCC2_swigregister = _Extrema.Extrema_GlobOptFuncCCC2_swigregister
Extrema_GlobOptFuncCCC2_swigregister(Extrema_GlobOptFuncCCC2)

class Handle_Extrema_HArray2OfPOnSurfParams(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray2OfPOnSurfParams self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray2OfPOnSurfParams self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray2OfPOnSurfParams self, Extrema_HArray2OfPOnSurfParams thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray2OfPOnSurfParams self, Handle_Extrema_HArray2OfPOnSurfParams theHandle) -> Handle_Extrema_HArray2OfPOnSurfParams
        assign(Handle_Extrema_HArray2OfPOnSurfParams self, Extrema_HArray2OfPOnSurfParams thePtr) -> Handle_Extrema_HArray2OfPOnSurfParams
        assign(Handle_Extrema_HArray2OfPOnSurfParams self, Handle_Extrema_HArray2OfPOnSurfParams theHandle) -> Handle_Extrema_HArray2OfPOnSurfParams

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray2OfPOnSurfParams self) -> Extrema_HArray2OfPOnSurfParams

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray2OfPOnSurfParams self) -> Extrema_HArray2OfPOnSurfParams

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray2OfPOnSurfParams self) -> Extrema_HArray2OfPOnSurfParams

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray2OfPOnSurfParams(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray2OfPOnSurfParams_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray2OfPOnSurfParams

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurfParams

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_Extrema_HArray2OfPOnSurfParams self) -> NCollection_Array2_Extrema_POnSurfParams

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurfParams

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray2OfPOnSurfParams self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray2OfPOnSurfParams self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray2OfPOnSurfParams self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray2OfPOnSurfParams self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray2OfPOnSurfParams self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray2OfPOnSurfParams self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray2OfPOnSurfParams self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray2OfPOnSurfParams self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray2OfPOnSurfParams self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray2OfPOnSurfParams self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_DecrementRefCounter(self, *args)

Handle_Extrema_HArray2OfPOnSurfParams_swigregister = _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_swigregister
Handle_Extrema_HArray2OfPOnSurfParams_swigregister(Handle_Extrema_HArray2OfPOnSurfParams)

def Handle_Extrema_HArray2OfPOnSurfParams_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_DownCast(thing)
Handle_Extrema_HArray2OfPOnSurfParams_DownCast = _Extrema.Handle_Extrema_HArray2OfPOnSurfParams_DownCast

class NCollection_UBTree_Standard_Integer_Bnd_Sphere(object):
    """
    The algorithm of unbalanced binary tree of overlapped bounding boxes.

    Once the tree of boxes  of geometric objects is constructed, the algorithm
    is capable of fast geometric selection of objects.  The tree can be easily
    updated by adding to it a new object with bounding box.

    The time of adding to the tree  of one object is O(log(N)), where N is the
    total number of  objects, so the time  of building a tree of  N objects is
    O(N(log(N)). The search time of one object is O(log(N)).

    Defining  various classes  inheriting NCollection_UBTree::Selector  we can
    perform various kinds of selection over the same b-tree object

    The object  may be of any  type allowing copying. Among  the best suitable
    solutions there can  be a pointer to an object,  handled object or integer
    index of object inside some  collection.  The bounding object may have any
    dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
    public empty and copy constructor and operator =) used in UBTree algorithm
    is as the following:
    @code
    class MyBndType
    {
    public:
    inline void                   Add (const MyBndType& other);
    // Updates me with other bounding

    inline Standard_Boolean       IsOut (const MyBndType& other) const;
    // Classifies other bounding relatively me

    inline Standard_Real          SquareExtent() const;
    // Computes the squared maximal linear extent of me.
    // (For box it is the squared diagonal of box)
    };
    @endcode
    To select objects you need to define a class derived from UBTree::Selector
    that  should  redefine  the  necessary  virtual methods  to  maintain  the
    selection condition.  The object  of this class  is also used  to retrieve
    selected objects after search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The algorithm of unbalanced binary tree of overlapped bounding boxes.

        Once the tree of boxes  of geometric objects is constructed, the algorithm
        is capable of fast geometric selection of objects.  The tree can be easily
        updated by adding to it a new object with bounding box.

        The time of adding to the tree  of one object is O(log(N)), where N is the
        total number of  objects, so the time  of building a tree of  N objects is
        O(N(log(N)). The search time of one object is O(log(N)).

        Defining  various classes  inheriting NCollection_UBTree::Selector  we can
        perform various kinds of selection over the same b-tree object

        The object  may be of any  type allowing copying. Among  the best suitable
        solutions there can  be a pointer to an object,  handled object or integer
        index of object inside some  collection.  The bounding object may have any
        dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
        public empty and copy constructor and operator =) used in UBTree algorithm
        is as the following:
        @code
        class MyBndType
        {
        public:
        inline void                   Add (const MyBndType& other);
        // Updates me with other bounding

        inline Standard_Boolean       IsOut (const MyBndType& other) const;
        // Classifies other bounding relatively me

        inline Standard_Real          SquareExtent() const;
        // Computes the squared maximal linear extent of me.
        // (For box it is the squared diagonal of box)
        };
        @endcode
        To select objects you need to define a class derived from UBTree::Selector
        that  should  redefine  the  necessary  virtual methods  to  maintain  the
        selection condition.  The object  of this class  is also used  to retrieve
        selected objects after search.
        """
        this = _Extrema.new_NCollection_UBTree_Standard_Integer_Bnd_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(NCollection_UBTree_Standard_Integer_Bnd_Sphere self, int const & theObj, Bnd_Sphere theBnd) -> Standard_Boolean

        Update the tree with a new object and its bounding box.
        @param theObj
        added object
        @param theBnd
        bounding box of the object.
        @return
        always True

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_Add(self, *args)


    def Select(self, *args):
        """
        Select(NCollection_UBTree_Standard_Integer_Bnd_Sphere self, NCollection_UBTree< Standard_Integer,Bnd_Sphere >::Selector & theSelector) -> Standard_Integer

        Searches in the branch all objects conforming to the given selector.
        @return
        the number of objects accepted

        :type theBranch: OCC.wrapper.NCollection.TreeNode
        :type theSelector: OCC.wrapper.NCollection.Selector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_Select(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UBTree_Standard_Integer_Bnd_Sphere self, Handle_NCollection_BaseAllocator aNewAlloc=0)

        Clears the contents of the tree.
        @param aNewAlloc
        Optional:   a new allocator that will be used when the tree is rebuilt
        anew. This makes sense if the memory allocator needs re-initialisation
        (like NCollection_IncAllocator).  By default the previous allocator is
        kept.

        :type aNewAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UBTree_Standard_Integer_Bnd_Sphere self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_IsEmpty(self, *args)


    def Root(self, *args):
        """
        @return
        the root node of the tree

        :rtype: OCC.wrapper.NCollection.TreeNode

        """
        res = _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Allocator(self, *args):
        """
        Recommended to be used only in sub-classes.
        @return
        Allocator object used in this instance of UBTree.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_NCollection_UBTree_Standard_Integer_Bnd_Sphere
NCollection_UBTree_Standard_Integer_Bnd_Sphere_swigregister = _Extrema.NCollection_UBTree_Standard_Integer_Bnd_Sphere_swigregister
NCollection_UBTree_Standard_Integer_Bnd_Sphere_swigregister(NCollection_UBTree_Standard_Integer_Bnd_Sphere)


try:
	Extrema_UBTreeOfSphere = NCollection_UBTree_Standard_Integer_Bnd_Sphere
except NameError:
	pass # does not exist, probably ignored

class Extrema_ExtPElS(object):
    """
    It calculates all the extremum distances
    between a point and a surface.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtPElS self) -> Extrema_ExtPElS
        __init__(Extrema_ExtPElS self, gp_Pnt P, gp_Cylinder S, Standard_Real const Tol) -> Extrema_ExtPElS
        __init__(Extrema_ExtPElS self, gp_Pnt P, gp_Pln S, Standard_Real const Tol) -> Extrema_ExtPElS
        __init__(Extrema_ExtPElS self, gp_Pnt P, gp_Cone S, Standard_Real const Tol) -> Extrema_ExtPElS
        __init__(Extrema_ExtPElS self, gp_Pnt P, gp_Torus S, Standard_Real const Tol) -> Extrema_ExtPElS
        __init__(Extrema_ExtPElS self, gp_Pnt P, gp_Sphere S, Standard_Real const Tol) -> Extrema_ExtPElS

        It calculates all the distances between a point
        and a sphere from gp.
        Tol is used to test if the point is at the center.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.gp.gp_Sphere
        :type Tol: float

        """
        this = _Extrema.new_Extrema_ExtPElS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_ExtPElS self, gp_Pnt P, gp_Cylinder S, Standard_Real const Tol)
        Perform(Extrema_ExtPElS self, gp_Pnt P, gp_Pln S, Standard_Real const Tol)
        Perform(Extrema_ExtPElS self, gp_Pnt P, gp_Cone S, Standard_Real const Tol)
        Perform(Extrema_ExtPElS self, gp_Pnt P, gp_Torus S, Standard_Real const Tol)
        Perform(Extrema_ExtPElS self, gp_Pnt P, gp_Sphere S, Standard_Real const Tol)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.gp.gp_Sphere
        :type Tol: float

        """
        return _Extrema.Extrema_ExtPElS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPElS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPElS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPElS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPElS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPElS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPElS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_ExtPElS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_ExtPElS
Extrema_ExtPElS_swigregister = _Extrema.Extrema_ExtPElS_swigregister
Extrema_ExtPElS_swigregister(Extrema_ExtPElS)

class Extrema_HArray2OfPOnCurv(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray2OfPOnCurv
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray2OfPOnCurv(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray2OfPOnCurv self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> Extrema_HArray2OfPOnCurv
        __init__(Extrema_HArray2OfPOnCurv self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, Extrema_POnCurv theValue) -> Extrema_HArray2OfPOnCurv
        __init__(Extrema_HArray2OfPOnCurv self, NCollection_Array2_Extrema_POnCurv theOther) -> Extrema_HArray2OfPOnCurv

        :type theOther: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv

        """
        this = _Extrema.new_Extrema_HArray2OfPOnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv

        """
        res = _Extrema.Extrema_HArray2OfPOnCurv_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Extrema_HArray2OfPOnCurv self) -> NCollection_Array2_Extrema_POnCurv

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv

        """
        return _Extrema.Extrema_HArray2OfPOnCurv_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray2OfPOnCurv_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray2OfPOnCurv_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray2OfPOnCurv_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray2OfPOnCurv
Extrema_HArray2OfPOnCurv_swigregister = _Extrema.Extrema_HArray2OfPOnCurv_swigregister
Extrema_HArray2OfPOnCurv_swigregister(Extrema_HArray2OfPOnCurv)

def Extrema_HArray2OfPOnCurv_get_type_name(*args):
    """
    Extrema_HArray2OfPOnCurv_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray2OfPOnCurv_get_type_name(*args)

def Extrema_HArray2OfPOnCurv_get_type_descriptor(*args):
    """
    Extrema_HArray2OfPOnCurv_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray2OfPOnCurv_get_type_descriptor(*args)

class Extrema_HArray2OfPOnCurv2d(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray2OfPOnCurv2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray2OfPOnCurv2d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray2OfPOnCurv2d self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> Extrema_HArray2OfPOnCurv2d
        __init__(Extrema_HArray2OfPOnCurv2d self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, Extrema_POnCurv2d theValue) -> Extrema_HArray2OfPOnCurv2d
        __init__(Extrema_HArray2OfPOnCurv2d self, NCollection_Array2_Extrema_POnCurv2d theOther) -> Extrema_HArray2OfPOnCurv2d

        :type theOther: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv2d

        """
        this = _Extrema.new_Extrema_HArray2OfPOnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv2d

        """
        res = _Extrema.Extrema_HArray2OfPOnCurv2d_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Extrema_HArray2OfPOnCurv2d self) -> NCollection_Array2_Extrema_POnCurv2d

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv2d

        """
        return _Extrema.Extrema_HArray2OfPOnCurv2d_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray2OfPOnCurv2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray2OfPOnCurv2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray2OfPOnCurv2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray2OfPOnCurv2d
Extrema_HArray2OfPOnCurv2d_swigregister = _Extrema.Extrema_HArray2OfPOnCurv2d_swigregister
Extrema_HArray2OfPOnCurv2d_swigregister(Extrema_HArray2OfPOnCurv2d)

def Extrema_HArray2OfPOnCurv2d_get_type_name(*args):
    """
    Extrema_HArray2OfPOnCurv2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray2OfPOnCurv2d_get_type_name(*args)

def Extrema_HArray2OfPOnCurv2d_get_type_descriptor(*args):
    """
    Extrema_HArray2OfPOnCurv2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray2OfPOnCurv2d_get_type_descriptor(*args)

class Extrema_ExtPC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtPC2d self) -> Extrema_ExtPC2d
        __init__(Extrema_ExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10) -> Extrema_ExtPC2d
        __init__(Extrema_ExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const TolF=1.0e-10) -> Extrema_ExtPC2d

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        Tol is used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        the algorithm stops when abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type TolF: float

        """
        this = _Extrema.new_Extrema_ExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtPC2d self, Adaptor2d_Curve2d C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10)

        initializes the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Uinf: float
        :type Usup: float
        :type TolF: float

        """
        return _Extrema.Extrema_ExtPC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtPC2d self, gp_Pnt2d P)

        An exception is raised if the fields have not been
        initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_ExtPC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPC2d self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPC2d_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPC2d_SquareDistance(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPC2d_NbExt(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_ExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the <N>th extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the <N>th extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_ExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ExtPC2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        if the curve is a trimmed curve,
        dist1 is a square distance between <P> and the point
        of parameter FirstParameter <P1> and
        dist2 is a square distance between <P> and the point
        of parameter LastParameter <P2>.

        :type dist1: float
        :type dist2: float
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_ExtPC2d_TrimmedSquareDistances(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtPC2d
Extrema_ExtPC2d_swigregister = _Extrema.Extrema_ExtPC2d_swigregister
Extrema_ExtPC2d_swigregister(Extrema_ExtPC2d)

class Extrema_EPCOfELPCOfLocateExtPC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_EPCOfELPCOfLocateExtPC2d self) -> Extrema_EPCOfELPCOfLocateExtPC2d
        __init__(Extrema_EPCOfELPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfELPCOfLocateExtPC2d
        __init__(Extrema_EPCOfELPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfELPCOfLocateExtPC2d

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        NbU is used to locate the close points to
        find the zeros.
        Zeros are searched between umin and usup.
        Tol and TolU are used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        abs(Un-Un-1) < TolU and abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        this = _Extrema.new_Extrema_EPCOfELPCOfLocateExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_EPCOfELPCOfLocateExtPC2d self, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfELPCOfLocateExtPC2d self, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfELPCOfLocateExtPC2d self, Adaptor2d_Curve2d C)
        Initialize(Extrema_EPCOfELPCOfLocateExtPC2d self, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)

        sets the fields of the algorithm.

        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_EPCOfELPCOfLocateExtPC2d self, gp_Pnt2d P)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_EPCOfELPCOfLocateExtPC2d self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_EPCOfELPCOfLocateExtPC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_EPCOfELPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_EPCOfELPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the Nth extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_EPCOfELPCOfLocateExtPC2d
Extrema_EPCOfELPCOfLocateExtPC2d_swigregister = _Extrema.Extrema_EPCOfELPCOfLocateExtPC2d_swigregister
Extrema_EPCOfELPCOfLocateExtPC2d_swigregister(Extrema_EPCOfELPCOfLocateExtPC2d)

class Extrema_HArray1OfPOnCurv(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray1OfPOnCurv
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray1OfPOnCurv(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray1OfPOnCurv self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Extrema_HArray1OfPOnCurv
        __init__(Extrema_HArray1OfPOnCurv self, Standard_Integer const theLower, Standard_Integer const theUpper, Extrema_POnCurv theValue) -> Extrema_HArray1OfPOnCurv
        __init__(Extrema_HArray1OfPOnCurv self, NCollection_Array1_Extrema_POnCurv theOther) -> Extrema_HArray1OfPOnCurv

        :type theOther: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv

        """
        this = _Extrema.new_Extrema_HArray1OfPOnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv

        """
        res = _Extrema.Extrema_HArray1OfPOnCurv_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Extrema_HArray1OfPOnCurv self) -> NCollection_Array1_Extrema_POnCurv

        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv

        """
        return _Extrema.Extrema_HArray1OfPOnCurv_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray1OfPOnCurv_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray1OfPOnCurv_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray1OfPOnCurv_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray1OfPOnCurv
Extrema_HArray1OfPOnCurv_swigregister = _Extrema.Extrema_HArray1OfPOnCurv_swigregister
Extrema_HArray1OfPOnCurv_swigregister(Extrema_HArray1OfPOnCurv)

def Extrema_HArray1OfPOnCurv_get_type_name(*args):
    """
    Extrema_HArray1OfPOnCurv_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray1OfPOnCurv_get_type_name(*args)

def Extrema_HArray1OfPOnCurv_get_type_descriptor(*args):
    """
    Extrema_HArray1OfPOnCurv_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray1OfPOnCurv_get_type_descriptor(*args)

class NCollection_Array2_Extrema_POnSurf(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _Extrema.new_NCollection_Array2_Extrema_POnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Extrema_POnSurf self, Extrema_POnSurf theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Extrema_POnSurf self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Extrema_POnSurf self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Extrema_POnSurf self, NCollection_Array2_Extrema_POnSurf theOther) -> NCollection_Array2_Extrema_POnSurf

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Extrema_POnSurf self, NCollection_Array2_Extrema_POnSurf theOther) -> NCollection_Array2_Extrema_POnSurf

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnSurf_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Extrema_POnSurf self, Standard_Integer const theRow, Standard_Integer const theCol) -> Extrema_POnSurf

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnSurf___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Extrema_POnSurf self, Standard_Integer const theRow, Standard_Integer const theCol, Extrema_POnSurf theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurf_SetValue(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array2_Extrema_POnSurf
NCollection_Array2_Extrema_POnSurf_swigregister = _Extrema.NCollection_Array2_Extrema_POnSurf_swigregister
NCollection_Array2_Extrema_POnSurf_swigregister(NCollection_Array2_Extrema_POnSurf)


try:
	Extrema_Array2OfPOnSurf = NCollection_Array2_Extrema_POnSurf
except NameError:
	pass # does not exist, probably ignored

class Extrema_LocateExtCC(object):
    """
    It calculates the distance between two curves with
    a close point; these distances can be maximum or
    minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocateExtCC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const U0, Standard_Real const V0) -> Extrema_LocateExtCC

        Calculates the distance with a close point. The
        close point is defined by a parameter value on each
        curve.
        The function F(u,v)=distance(C1(u),C2(v)) has an
        extremun when gradient(f)=0. The algorithm searchs
        the zero near the close point.

        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type C2: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U0: float
        :type V0: float

        """
        this = _Extrema.new_Extrema_LocateExtCC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Extrema_LocateExtCC self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocateExtCC_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocateExtCC self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocateExtCC_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Point(Extrema_LocateExtCC self, Extrema_POnCurv P1, Extrema_POnCurv P2)

        Returns the points of the extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        return _Extrema.Extrema_LocateExtCC_Point(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_LocateExtCC
Extrema_LocateExtCC_swigregister = _Extrema.Extrema_LocateExtCC_swigregister
Extrema_LocateExtCC_swigregister(Extrema_LocateExtCC)

class NCollection_Sequence_Extrema_POnSurf(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Extrema_POnSurf self) -> NCollection_Sequence< Extrema_POnSurf >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Extrema_POnSurf self) -> NCollection_Sequence< Extrema_POnSurf >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Extrema_POnSurf self) -> NCollection_Sequence< Extrema_POnSurf >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Extrema_POnSurf self) -> NCollection_Sequence< Extrema_POnSurf >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Extrema.new_NCollection_Sequence_Extrema_POnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Extrema_POnSurf self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Extrema_POnSurf self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Extrema_POnSurf self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Extrema_POnSurf self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Extrema_POnSurf self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Extrema_POnSurf self)

        Reverse sequence


        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Extrema_POnSurf self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Extrema_POnSurf self, NCollection_Sequence_Extrema_POnSurf theOther) -> NCollection_Sequence_Extrema_POnSurf

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Extrema_POnSurf self, NCollection_Sequence_Extrema_POnSurf theOther) -> NCollection_Sequence_Extrema_POnSurf

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Extrema_POnSurf self, NCollection_Sequence< Extrema_POnSurf >::Iterator & thePosition)
        Remove(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Extrema_POnSurf self, Extrema_POnSurf theItem)
        Append(NCollection_Sequence_Extrema_POnSurf self, NCollection_Sequence_Extrema_POnSurf theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Extrema_POnSurf self, Extrema_POnSurf theItem)
        Prepend(NCollection_Sequence_Extrema_POnSurf self, NCollection_Sequence_Extrema_POnSurf theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex, Extrema_POnSurf theItem)
        InsertBefore(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnSurf theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Extrema_POnSurf self, NCollection_Sequence< Extrema_POnSurf >::Iterator & thePosition, Extrema_POnSurf theItem)
        InsertAfter(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnSurf theSeq)
        InsertAfter(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex, Extrema_POnSurf theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnSurf theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnSurf_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Extrema_POnSurf self) -> Extrema_POnSurf

        First item access

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnSurf_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Extrema_POnSurf self) -> Extrema_POnSurf

        Last item access

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnSurf_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex) -> Extrema_POnSurf

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnSurf___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Extrema_POnSurf self, Standard_Integer const theIndex, Extrema_POnSurf theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_SetValue(self, *args)


    def __iter__(self):
        return _Extrema.NCollection_Sequence_Extrema_POnSurf___iter__(self)
    __swig_destroy__ = _Extrema.delete_NCollection_Sequence_Extrema_POnSurf
NCollection_Sequence_Extrema_POnSurf_swigregister = _Extrema.NCollection_Sequence_Extrema_POnSurf_swigregister
NCollection_Sequence_Extrema_POnSurf_swigregister(NCollection_Sequence_Extrema_POnSurf)

def NCollection_Sequence_Extrema_POnSurf_delNode(*args):
    """
    NCollection_Sequence_Extrema_POnSurf_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Extrema.NCollection_Sequence_Extrema_POnSurf_delNode(*args)

class NCollection_Sequence_Extrema_POnSurf_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Extrema.new_NCollection_Sequence_Extrema_POnSurf_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_NCollection_Sequence_Extrema_POnSurf_IteratorHelper

    def __next__(self):
        return _Extrema.NCollection_Sequence_Extrema_POnSurf_IteratorHelper___next__(self)
NCollection_Sequence_Extrema_POnSurf_IteratorHelper_swigregister = _Extrema.NCollection_Sequence_Extrema_POnSurf_IteratorHelper_swigregister
NCollection_Sequence_Extrema_POnSurf_IteratorHelper_swigregister(NCollection_Sequence_Extrema_POnSurf_IteratorHelper)


try:
	Extrema_SequenceOfPOnSurf = NCollection_Sequence_Extrema_POnSurf
except NameError:
	pass # does not exist, probably ignored

class Extrema_ExtElSS(object):
    """
    It calculates all the distances between 2 elementary
    surfaces.
    These distances can be maximum or minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtElSS self) -> Extrema_ExtElSS
        __init__(Extrema_ExtElSS self, gp_Pln S1, gp_Pln S2) -> Extrema_ExtElSS
        __init__(Extrema_ExtElSS self, gp_Pln S1, gp_Sphere S2) -> Extrema_ExtElSS
        __init__(Extrema_ExtElSS self, gp_Sphere S1, gp_Sphere S2) -> Extrema_ExtElSS
        __init__(Extrema_ExtElSS self, gp_Sphere S1, gp_Cylinder S2) -> Extrema_ExtElSS
        __init__(Extrema_ExtElSS self, gp_Sphere S1, gp_Cone S2) -> Extrema_ExtElSS
        __init__(Extrema_ExtElSS self, gp_Sphere S1, gp_Torus S2) -> Extrema_ExtElSS

        Calculates the distances between a sphere
        and a torus.

        :type S1: OCC.wrapper.gp.gp_Sphere
        :type S2: OCC.wrapper.gp.gp_Torus

        """
        this = _Extrema.new_Extrema_ExtElSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_ExtElSS self, gp_Pln S1, gp_Pln S2)
        Perform(Extrema_ExtElSS self, gp_Pln S1, gp_Sphere S2)
        Perform(Extrema_ExtElSS self, gp_Sphere S1, gp_Sphere S2)
        Perform(Extrema_ExtElSS self, gp_Sphere S1, gp_Cylinder S2)
        Perform(Extrema_ExtElSS self, gp_Sphere S1, gp_Cone S2)
        Perform(Extrema_ExtElSS self, gp_Sphere S1, gp_Torus S2)

        :type S1: OCC.wrapper.gp.gp_Sphere
        :type S2: OCC.wrapper.gp.gp_Torus

        """
        return _Extrema.Extrema_ExtElSS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtElSS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElSS_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtElSS self) -> Standard_Boolean

        Returns True if the two surfaces are parallel.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElSS_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtElSS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtElSS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtElSS self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtElSS_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtElSS self, Standard_Integer const N, Extrema_POnSurf P1, Extrema_POnSurf P2)

        Returns the points for the Nth resulting distance.
        P1 is on the first surface, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnSurf
        :type P2: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        return _Extrema.Extrema_ExtElSS_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtElSS
Extrema_ExtElSS_swigregister = _Extrema.Extrema_ExtElSS_swigregister
Extrema_ExtElSS_swigregister(Extrema_ExtElSS)

class Extrema_GenLocateExtCS(object):
    """
    With two close points it calculates the distance
    between two surfaces.
    This distance can be a minimum or a maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GenLocateExtCS self) -> Extrema_GenLocateExtCS
        __init__(Extrema_GenLocateExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S, Standard_Real const T, Standard_Real const U, Standard_Real const V, Standard_Real const Tol1, Standard_Real const Tol2) -> Extrema_GenLocateExtCS

        Calculates the distance with two close points.
        The close points are defined by the parameter values
        T for C and (U,V) for S.
        The function F(t,u,v)=distance(C(t),S(u,v))
        has an extremun when gradient(F)=0. The algorithm searchs
        a zero near the close points.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type T: float
        :type U: float
        :type V: float
        :type Tol1: float
        :type Tol2: float

        """
        this = _Extrema.new_Extrema_GenLocateExtCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_GenLocateExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S, Standard_Real const T, Standard_Real const U, Standard_Real const V, Standard_Real const Tol1, Standard_Real const Tol2)

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type T: float
        :type U: float
        :type V: float
        :type Tol1: float
        :type Tol2: float

        """
        return _Extrema.Extrema_GenLocateExtCS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_GenLocateExtCS self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GenLocateExtCS_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_GenLocateExtCS self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_GenLocateExtCS_SquareDistance(self, *args)


    def PointOnCurve(self, *args):
        """
        Returns the point of the extremum distance on C.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_GenLocateExtCS_PointOnCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnSurface(self, *args):
        """
        Returns the point of the extremum distance on S.

        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenLocateExtCS_PointOnSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_GenLocateExtCS
Extrema_GenLocateExtCS_swigregister = _Extrema.Extrema_GenLocateExtCS_swigregister
Extrema_GenLocateExtCS_swigregister(Extrema_GenLocateExtCS)

class Extrema_ExtPElC2d(object):
    """
    It calculates all the distances between a point
    and an elementary curve.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtPElC2d self) -> Extrema_ExtPElC2d
        __init__(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Lin2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC2d
        __init__(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Circ2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC2d
        __init__(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Elips2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC2d
        __init__(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Hypr2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC2d
        __init__(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Parab2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC2d

        Calculates the 4 extremum distances between the
        point P and the segment [Uinf,Usup] of the parabola
        C.
        Tol is used to determine if two solutions u and v
        are identical; the condition is:
        dist(C(u),C(v)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.gp.gp_Parab2d
        :type Tol: float
        :type Uinf: float
        :type Usup: float

        """
        this = _Extrema.new_Extrema_ExtPElC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Lin2d L, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Circ2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Elips2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Hypr2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC2d self, gp_Pnt2d P, gp_Parab2d C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.gp.gp_Parab2d
        :type Tol: float
        :type Uinf: float
        :type Usup: float

        """
        return _Extrema.Extrema_ExtPElC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPElC2d self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPElC2d_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPElC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPElC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPElC2d self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPElC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_ExtPElC2d self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the Nth extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPElC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_ExtPElC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_ExtPElC2d
Extrema_ExtPElC2d_swigregister = _Extrema.Extrema_ExtPElC2d_swigregister
Extrema_ExtPElC2d_swigregister(Extrema_ExtPElC2d)

class Extrema_PCLocFOfLocEPCOfLocateExtPC2d(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self) -> Extrema_PCLocFOfLocEPCOfLocateExtPC2d
        __init__(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C) -> Extrema_PCLocFOfLocEPCOfLocateExtPC2d

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Extrema.new_Extrema_PCLocFOfLocEPCOfLocateExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Adaptor2d_Curve2d C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, gp_Pnt2d P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_PCLocFOfLocEPCOfLocateExtPC2d self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_PCLocFOfLocEPCOfLocateExtPC2d
Extrema_PCLocFOfLocEPCOfLocateExtPC2d_swigregister = _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC2d_swigregister
Extrema_PCLocFOfLocEPCOfLocateExtPC2d_swigregister(Extrema_PCLocFOfLocEPCOfLocateExtPC2d)

class Extrema_ExtPElC(object):
    """
    It calculates all the distances between a point
    and an elementary curve.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtPElC self) -> Extrema_ExtPElC
        __init__(Extrema_ExtPElC self, gp_Pnt P, gp_Lin C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC
        __init__(Extrema_ExtPElC self, gp_Pnt P, gp_Circ C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC
        __init__(Extrema_ExtPElC self, gp_Pnt P, gp_Elips C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC
        __init__(Extrema_ExtPElC self, gp_Pnt P, gp_Hypr C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC
        __init__(Extrema_ExtPElC self, gp_Pnt P, gp_Parab C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup) -> Extrema_ExtPElC

        Calculates the 4 extremum distances between the
        point P and the segment [Uinf,Usup] of the parabola
        C.
        Tol is used to determine if two solutions u and v
        are identical; the condition is:
        dist(C(u),C(v)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.gp.gp_Parab
        :type Tol: float
        :type Uinf: float
        :type Usup: float

        """
        this = _Extrema.new_Extrema_ExtPElC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_ExtPElC self, gp_Pnt P, gp_Lin C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC self, gp_Pnt P, gp_Circ C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC self, gp_Pnt P, gp_Elips C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC self, gp_Pnt P, gp_Hypr C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)
        Perform(Extrema_ExtPElC self, gp_Pnt P, gp_Parab C, Standard_Real const Tol, Standard_Real const Uinf, Standard_Real const Usup)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.gp.gp_Parab
        :type Tol: float
        :type Uinf: float
        :type Usup: float

        """
        return _Extrema.Extrema_ExtPElC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPElC self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPElC_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPElC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPElC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPElC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPElC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_ExtPElC self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the Nth extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPElC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_ExtPElC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_ExtPElC
Extrema_ExtPElC_swigregister = _Extrema.Extrema_ExtPElC_swigregister
Extrema_ExtPElC_swigregister(Extrema_ExtPElC)

class Handle_Extrema_HArray2OfPOnSurf(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray2OfPOnSurf self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray2OfPOnSurf self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray2OfPOnSurf self, Extrema_HArray2OfPOnSurf thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray2OfPOnSurf self, Handle_Extrema_HArray2OfPOnSurf theHandle) -> Handle_Extrema_HArray2OfPOnSurf
        assign(Handle_Extrema_HArray2OfPOnSurf self, Extrema_HArray2OfPOnSurf thePtr) -> Handle_Extrema_HArray2OfPOnSurf
        assign(Handle_Extrema_HArray2OfPOnSurf self, Handle_Extrema_HArray2OfPOnSurf theHandle) -> Handle_Extrema_HArray2OfPOnSurf

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray2OfPOnSurf self) -> Extrema_HArray2OfPOnSurf

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray2OfPOnSurf self) -> Extrema_HArray2OfPOnSurf

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray2OfPOnSurf self) -> Extrema_HArray2OfPOnSurf

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray2OfPOnSurf___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray2OfPOnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray2OfPOnSurf_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray2OfPOnSurf

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurf

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnSurf_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_Extrema_HArray2OfPOnSurf self) -> NCollection_Array2_Extrema_POnSurf

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnSurf

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray2OfPOnSurf self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnSurf_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray2OfPOnSurf self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray2OfPOnSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray2OfPOnSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray2OfPOnSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray2OfPOnSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray2OfPOnSurf self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray2OfPOnSurf self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray2OfPOnSurf self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray2OfPOnSurf self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnSurf_DecrementRefCounter(self, *args)

Handle_Extrema_HArray2OfPOnSurf_swigregister = _Extrema.Handle_Extrema_HArray2OfPOnSurf_swigregister
Handle_Extrema_HArray2OfPOnSurf_swigregister(Handle_Extrema_HArray2OfPOnSurf)

def Handle_Extrema_HArray2OfPOnSurf_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray2OfPOnSurf_DownCast(thing)
Handle_Extrema_HArray2OfPOnSurf_DownCast = _Extrema.Handle_Extrema_HArray2OfPOnSurf_DownCast

class Extrema_EPCOfELPCOfLocateExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_EPCOfELPCOfLocateExtPC self) -> Extrema_EPCOfELPCOfLocateExtPC
        __init__(Extrema_EPCOfELPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfELPCOfLocateExtPC
        __init__(Extrema_EPCOfELPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfELPCOfLocateExtPC

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        NbU is used to locate the close points to
        find the zeros.
        Zeros are searched between umin and usup.
        Tol and TolU are used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        abs(Un-Un-1) < TolU and abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        this = _Extrema.new_Extrema_EPCOfELPCOfLocateExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_EPCOfELPCOfLocateExtPC self, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfELPCOfLocateExtPC self, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfELPCOfLocateExtPC self, Adaptor3d_Curve C)
        Initialize(Extrema_EPCOfELPCOfLocateExtPC self, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)

        sets the fields of the algorithm.

        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_EPCOfELPCOfLocateExtPC self, gp_Pnt P)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_EPCOfELPCOfLocateExtPC self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_EPCOfELPCOfLocateExtPC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_EPCOfELPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_EPCOfELPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the Nth extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfELPCOfLocateExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_EPCOfELPCOfLocateExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_EPCOfELPCOfLocateExtPC
Extrema_EPCOfELPCOfLocateExtPC_swigregister = _Extrema.Extrema_EPCOfELPCOfLocateExtPC_swigregister
Extrema_EPCOfELPCOfLocateExtPC_swigregister(Extrema_EPCOfELPCOfLocateExtPC)

class Extrema_ExtElCS(object):
    """
    It calculates all the distances between a curve and
    a surface.
    These distances can be maximum or minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtElCS self) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Lin C, gp_Pln S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Lin C, gp_Cylinder S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Lin C, gp_Cone S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Lin C, gp_Sphere S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Lin C, gp_Torus S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Circ C, gp_Pln S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Circ C, gp_Cylinder S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Circ C, gp_Cone S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Circ C, gp_Sphere S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Circ C, gp_Torus S) -> Extrema_ExtElCS
        __init__(Extrema_ExtElCS self, gp_Hypr C, gp_Pln S) -> Extrema_ExtElCS

        Calculates the distances between a hyperbola and a
        plane.

        :type C: OCC.wrapper.gp.gp_Hypr
        :type S: OCC.wrapper.gp.gp_Pln

        """
        this = _Extrema.new_Extrema_ExtElCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_ExtElCS self, gp_Lin C, gp_Pln S)
        Perform(Extrema_ExtElCS self, gp_Lin C, gp_Cylinder S)
        Perform(Extrema_ExtElCS self, gp_Lin C, gp_Cone S)
        Perform(Extrema_ExtElCS self, gp_Lin C, gp_Sphere S)
        Perform(Extrema_ExtElCS self, gp_Lin C, gp_Torus S)
        Perform(Extrema_ExtElCS self, gp_Circ C, gp_Pln S)
        Perform(Extrema_ExtElCS self, gp_Circ C, gp_Cylinder S)
        Perform(Extrema_ExtElCS self, gp_Circ C, gp_Cone S)
        Perform(Extrema_ExtElCS self, gp_Circ C, gp_Sphere S)
        Perform(Extrema_ExtElCS self, gp_Circ C, gp_Torus S)
        Perform(Extrema_ExtElCS self, gp_Hypr C, gp_Pln S)

        :type C: OCC.wrapper.gp.gp_Hypr
        :type S: OCC.wrapper.gp.gp_Pln

        """
        return _Extrema.Extrema_ExtElCS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtElCS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElCS_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtElCS self) -> Standard_Boolean

        Returns True if the curve is on a parallel surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElCS_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtElCS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtElCS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtElCS self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtElCS_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtElCS self, Standard_Integer const N, Extrema_POnCurv P1, Extrema_POnSurf P2)

        Returns the points of the Nth extremum distance.
        P1 is on the curve, P2 on the surface.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        return _Extrema.Extrema_ExtElCS_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtElCS
Extrema_ExtElCS_swigregister = _Extrema.Extrema_ExtElCS_swigregister
Extrema_ExtElCS_swigregister(Extrema_ExtElCS)

class Extrema_ExtElC2d(object):
    """
    It calculates all the distance between two elementary
    curves.
    These distances can be maximum or minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtElC2d self) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Lin2d C1, gp_Lin2d C2, Standard_Real const AngTol) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Lin2d C1, gp_Circ2d C2, Standard_Real const Tol) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Lin2d C1, gp_Elips2d C2) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Lin2d C1, gp_Hypr2d C2) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Lin2d C1, gp_Parab2d C2) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Circ2d C1, gp_Circ2d C2) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Circ2d C1, gp_Elips2d C2) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Circ2d C1, gp_Hypr2d C2) -> Extrema_ExtElC2d
        __init__(Extrema_ExtElC2d self, gp_Circ2d C1, gp_Parab2d C2) -> Extrema_ExtElC2d

        Calculates the distance between a circle and a
        parabola.

        :type C1: OCC.wrapper.gp.gp_Circ2d
        :type C2: OCC.wrapper.gp.gp_Parab2d

        """
        this = _Extrema.new_Extrema_ExtElC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtElC2d self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElC2d_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtElC2d self) -> Standard_Boolean

        Returns True if the two curves are parallel.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElC2d_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtElC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtElC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtElC2d self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtElC2d_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtElC2d self, Standard_Integer const N, Extrema_POnCurv2d P1, Extrema_POnCurv2d P2)

        Returns the points of the Nth extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv2d
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Extrema.Extrema_ExtElC2d_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtElC2d
Extrema_ExtElC2d_swigregister = _Extrema.Extrema_ExtElC2d_swigregister
Extrema_ExtElC2d_swigregister(Extrema_ExtElC2d)

class NCollection_Array2_Extrema_POnSurfParams(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _Extrema.new_NCollection_Array2_Extrema_POnSurfParams(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Extrema_POnSurfParams self, Extrema_POnSurfParams theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Extrema_POnSurfParams self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Extrema_POnSurfParams self, NCollection_Array2_Extrema_POnSurfParams theOther) -> NCollection_Array2_Extrema_POnSurfParams

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Extrema_POnSurfParams self, NCollection_Array2_Extrema_POnSurfParams theOther) -> NCollection_Array2_Extrema_POnSurfParams

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnSurfParams_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Extrema_POnSurfParams self, Standard_Integer const theRow, Standard_Integer const theCol) -> Extrema_POnSurfParams

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnSurfParams___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Extrema_POnSurfParams self, Standard_Integer const theRow, Standard_Integer const theCol, Extrema_POnSurfParams theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnSurfParams_SetValue(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array2_Extrema_POnSurfParams
NCollection_Array2_Extrema_POnSurfParams_swigregister = _Extrema.NCollection_Array2_Extrema_POnSurfParams_swigregister
NCollection_Array2_Extrema_POnSurfParams_swigregister(NCollection_Array2_Extrema_POnSurfParams)


try:
	Extrema_Array2OfPOnSurfParams = NCollection_Array2_Extrema_POnSurfParams
except NameError:
	pass # does not exist, probably ignored

class Extrema_LocateExtPC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocateExtPC2d self) -> Extrema_LocateExtPC2d
        __init__(Extrema_LocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const TolF) -> Extrema_LocateExtPC2d
        __init__(Extrema_LocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolF) -> Extrema_LocateExtPC2d

        Calculates the distance with a close point.
        The close point is defined by the parameter value
        U0.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs a zero
        near the close point.
        Zeros are searched between Umin et Usup.
        TolF is used to decide to stop the iterations.
        At the nth iteration, the criteria is:
        abs(Un - Un-1) < TolF.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U0: float
        :type Umin: float
        :type Usup: float
        :type TolF: float

        """
        this = _Extrema.new_Extrema_LocateExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_LocateExtPC2d self, Adaptor2d_Curve2d C, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolF)

        sets the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Umin: float
        :type Usup: float
        :type TolF: float

        """
        return _Extrema.Extrema_LocateExtPC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_LocateExtPC2d self, gp_Pnt2d P, Standard_Real const U0)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type U0: float

        """
        return _Extrema.Extrema_LocateExtPC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_LocateExtPC2d self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocateExtPC2d_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocateExtPC2d self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocateExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_LocateExtPC2d self) -> Standard_Boolean

        Returns True if the extremum distance is a minimum.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocateExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_LocateExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_LocateExtPC2d
Extrema_LocateExtPC2d_swigregister = _Extrema.Extrema_LocateExtPC2d_swigregister
Extrema_LocateExtPC2d_swigregister(Extrema_LocateExtPC2d)

class Extrema_ExtPRevS(Standard.Standard_Transient):
    """
    It calculates all the extremum (minimum and
    maximum) distances between a point and a surface
    of revolution.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_ExtPRevS
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_ExtPRevS(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_ExtPRevS self) -> Extrema_ExtPRevS
        __init__(Extrema_ExtPRevS self, gp_Pnt P, Handle_GeomAdaptor_HSurfaceOfRevolution S, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV) -> Extrema_ExtPRevS
        __init__(Extrema_ExtPRevS self, gp_Pnt P, Handle_GeomAdaptor_HSurfaceOfRevolution S, Standard_Real const TolU, Standard_Real const TolV) -> Extrema_ExtPRevS

        It calculates all the distances between a point
        from gp and a SurfacePtr from Adaptor3d.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurfaceOfRevolution
        :type TolU: float
        :type TolV: float

        """
        this = _Extrema.new_Extrema_ExtPRevS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtPRevS self, Handle_GeomAdaptor_HSurfaceOfRevolution S, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV)

        :type S: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurfaceOfRevolution
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float

        """
        return _Extrema.Extrema_ExtPRevS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtPRevS self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtPRevS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPRevS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPRevS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPRevS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPRevS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPRevS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPRevS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_ExtPRevS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_ExtPRevS_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_ExtPRevS_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_ExtPRevS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_ExtPRevS
Extrema_ExtPRevS_swigregister = _Extrema.Extrema_ExtPRevS_swigregister
Extrema_ExtPRevS_swigregister(Extrema_ExtPRevS)

def Extrema_ExtPRevS_get_type_name(*args):
    """
    Extrema_ExtPRevS_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_ExtPRevS_get_type_name(*args)

def Extrema_ExtPRevS_get_type_descriptor(*args):
    """
    Extrema_ExtPRevS_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_ExtPRevS_get_type_descriptor(*args)

class Extrema_POnCurv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_POnCurv self) -> Extrema_POnCurv
        __init__(Extrema_POnCurv self, Standard_Real const U, gp_Pnt P) -> Extrema_POnCurv

        Creation of a point on curve with a parameter
        value on the curve and a Pnt from gp.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        this = _Extrema.new_Extrema_POnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(Extrema_POnCurv self, Standard_Real const U, gp_Pnt P)

        sets the point and parameter values.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_POnCurv_SetValues(self, *args)


    def Value(self, *args):
        """
        Returns the point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Extrema.Extrema_POnCurv_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Extrema_POnCurv self) -> Standard_Real

        Returns the parameter on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_POnCurv_Parameter(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_POnCurv
Extrema_POnCurv_swigregister = _Extrema.Extrema_POnCurv_swigregister
Extrema_POnCurv_swigregister(Extrema_POnCurv)

class NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere(object):
    """
    This class is used to fill an UBTree in a random order.
    The quality of a tree is much better (from the point of view of
    the search time) if objects are added to it in a random order to
    avoid adding a chain of neerby objects one following each other.

    This class collects objects to be added, and then add them to the tree
    in a random order.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        This class is used to fill an UBTree in a random order.
        The quality of a tree is much better (from the point of view of
        the search time) if objects are added to it in a random order to
        avoid adding a chain of neerby objects one following each other.

        This class collects objects to be added, and then add them to the tree
        in a random order.
        """
        this = _Extrema.new_NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere self, int const & theObj, Bnd_Sphere theBnd)

        Adds a pair (theObj, theBnd) to my sequence

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &

        """
        return _Extrema.NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_Add(self, *args)


    def Fill(self, *args):
        """
        Fill(NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere self) -> Standard_Integer

        Fills the tree with the objects from my sequence. This method clears
        the internal buffer of added items making sure that no item would be added
        twice.
        @return
        the number of objects added to the tree.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_Fill(self, *args)


    def Reset(self, *args):
        """
        Reset(NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere self)

        Remove all data from Filler, partculary if the Tree no more needed
        so the destructor of this Filler should not populate the useless Tree.


        """
        return _Extrema.NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_Reset(self, *args)


    def CheckTree(self, *args):
        """
        CheckTree(NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere self, Standard_OStream & theStream) -> Standard_Integer

        Check the filled tree for the total number of items and the balance
        outputting these results to ostream.
        @return
        the tree size (the same value is returned by method Fill()).

        :type theStream: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_CheckTree(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere
NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_swigregister = _Extrema.NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_swigregister
NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere_swigregister(NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere)


try:
	Extrema_UBTreeFillerOfSphere = NCollection_UBTreeFiller_Standard_Integer_Bnd_Sphere
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array2_Extrema_POnCurv2d(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _Extrema.new_NCollection_Array2_Extrema_POnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Extrema_POnCurv2d self, Extrema_POnCurv2d theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Extrema_POnCurv2d self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Extrema_POnCurv2d self, NCollection_Array2_Extrema_POnCurv2d theOther) -> NCollection_Array2_Extrema_POnCurv2d

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Extrema_POnCurv2d self, NCollection_Array2_Extrema_POnCurv2d theOther) -> NCollection_Array2_Extrema_POnCurv2d

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnCurv2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Extrema_POnCurv2d self, Standard_Integer const theRow, Standard_Integer const theCol) -> Extrema_POnCurv2d

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnCurv2d___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Extrema_POnCurv2d self, Standard_Integer const theRow, Standard_Integer const theCol, Extrema_POnCurv2d theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv2d_SetValue(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array2_Extrema_POnCurv2d
NCollection_Array2_Extrema_POnCurv2d_swigregister = _Extrema.NCollection_Array2_Extrema_POnCurv2d_swigregister
NCollection_Array2_Extrema_POnCurv2d_swigregister(NCollection_Array2_Extrema_POnCurv2d)


try:
	Extrema_Array2OfPOnCurv2d = NCollection_Array2_Extrema_POnCurv2d
except NameError:
	pass # does not exist, probably ignored

class Extrema_ELPCOfLocateExtPC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ELPCOfLocateExtPC2d self) -> Extrema_ELPCOfLocateExtPC2d
        __init__(Extrema_ELPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10) -> Extrema_ELPCOfLocateExtPC2d
        __init__(Extrema_ELPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const TolF=1.0e-10) -> Extrema_ELPCOfLocateExtPC2d

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        Tol is used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        the algorithm stops when abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type TolF: float

        """
        this = _Extrema.new_Extrema_ELPCOfLocateExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ELPCOfLocateExtPC2d self, Adaptor2d_Curve2d C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10)

        initializes the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Uinf: float
        :type Usup: float
        :type TolF: float

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ELPCOfLocateExtPC2d self, gp_Pnt2d P)

        An exception is raised if the fields have not been
        initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ELPCOfLocateExtPC2d self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ELPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_SquareDistance(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ELPCOfLocateExtPC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_NbExt(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_ELPCOfLocateExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the <N>th extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the <N>th extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_ELPCOfLocateExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ELPCOfLocateExtPC2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        if the curve is a trimmed curve,
        dist1 is a square distance between <P> and the point
        of parameter FirstParameter <P1> and
        dist2 is a square distance between <P> and the point
        of parameter LastParameter <P2>.

        :type dist1: float
        :type dist2: float
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC2d_TrimmedSquareDistances(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ELPCOfLocateExtPC2d
Extrema_ELPCOfLocateExtPC2d_swigregister = _Extrema.Extrema_ELPCOfLocateExtPC2d_swigregister
Extrema_ELPCOfLocateExtPC2d_swigregister(Extrema_ELPCOfLocateExtPC2d)

class Extrema_HArray1OfPOnSurf(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray1OfPOnSurf
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray1OfPOnSurf(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray1OfPOnSurf self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Extrema_HArray1OfPOnSurf
        __init__(Extrema_HArray1OfPOnSurf self, Standard_Integer const theLower, Standard_Integer const theUpper, Extrema_POnSurf theValue) -> Extrema_HArray1OfPOnSurf
        __init__(Extrema_HArray1OfPOnSurf self, NCollection_Array1_Extrema_POnSurf theOther) -> Extrema_HArray1OfPOnSurf

        :type theOther: OCC.wrapper.Extrema.Extrema_Array1OfPOnSurf

        """
        this = _Extrema.new_Extrema_HArray1OfPOnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnSurf

        """
        res = _Extrema.Extrema_HArray1OfPOnSurf_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Extrema_HArray1OfPOnSurf self) -> NCollection_Array1_Extrema_POnSurf

        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnSurf

        """
        return _Extrema.Extrema_HArray1OfPOnSurf_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray1OfPOnSurf_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray1OfPOnSurf_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray1OfPOnSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray1OfPOnSurf
Extrema_HArray1OfPOnSurf_swigregister = _Extrema.Extrema_HArray1OfPOnSurf_swigregister
Extrema_HArray1OfPOnSurf_swigregister(Extrema_HArray1OfPOnSurf)

def Extrema_HArray1OfPOnSurf_get_type_name(*args):
    """
    Extrema_HArray1OfPOnSurf_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray1OfPOnSurf_get_type_name(*args)

def Extrema_HArray1OfPOnSurf_get_type_descriptor(*args):
    """
    Extrema_HArray1OfPOnSurf_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray1OfPOnSurf_get_type_descriptor(*args)

class Extrema_FuncExtSS(math.math_FunctionSetWithDerivatives):
    """
    Function to find extrema of the
    distance between two surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_FuncExtSS self) -> Extrema_FuncExtSS
        __init__(Extrema_FuncExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2) -> Extrema_FuncExtSS

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        this = _Extrema.new_Extrema_FuncExtSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_FuncExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2)

        sets the field mysurf of the function.

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        return _Extrema.Extrema_FuncExtSS_Initialize(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Extrema_FuncExtSS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtSS_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Extrema_FuncExtSS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtSS_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_FuncExtSS self, math_Vector UV, math_Vector F) -> Standard_Boolean

        Calculate Fi(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncExtSS_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Extrema_FuncExtSS self, math_Vector UV, math_Matrix DF) -> Standard_Boolean

        Calculate Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncExtSS_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_FuncExtSS self, math_Vector UV, math_Vector F, math_Matrix DF) -> Standard_Boolean

        Calculate Fi(U,V) and Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncExtSS_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_FuncExtSS self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtSS_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_FuncExtSS self) -> Standard_Integer

        Return the number of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncExtSS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_FuncExtSS self, Standard_Integer const N) -> Standard_Real

        Return the value of the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_FuncExtSS_SquareDistance(self, *args)


    def PointOnS1(self, *args):
        """
        Return the Nth extremum on S1.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_FuncExtSS_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        Renvoie le Nieme extremum sur S2.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_FuncExtSS_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_FuncExtSS
Extrema_FuncExtSS_swigregister = _Extrema.Extrema_FuncExtSS_swigregister
Extrema_FuncExtSS_swigregister(Extrema_FuncExtSS)

class Extrema_HArray1OfPOnCurv2d(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Extrema_HArray1OfPOnCurv2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Extrema_HArray1OfPOnCurv2d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Extrema_HArray1OfPOnCurv2d self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Extrema_HArray1OfPOnCurv2d
        __init__(Extrema_HArray1OfPOnCurv2d self, Standard_Integer const theLower, Standard_Integer const theUpper, Extrema_POnCurv2d theValue) -> Extrema_HArray1OfPOnCurv2d
        __init__(Extrema_HArray1OfPOnCurv2d self, NCollection_Array1_Extrema_POnCurv2d theOther) -> Extrema_HArray1OfPOnCurv2d

        :type theOther: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv2d

        """
        this = _Extrema.new_Extrema_HArray1OfPOnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv2d

        """
        res = _Extrema.Extrema_HArray1OfPOnCurv2d_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Extrema_HArray1OfPOnCurv2d self) -> NCollection_Array1_Extrema_POnCurv2d

        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv2d

        """
        return _Extrema.Extrema_HArray1OfPOnCurv2d_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Extrema.Extrema_HArray1OfPOnCurv2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Extrema.Extrema_HArray1OfPOnCurv2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Extrema_HArray1OfPOnCurv2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_HArray1OfPOnCurv2d
Extrema_HArray1OfPOnCurv2d_swigregister = _Extrema.Extrema_HArray1OfPOnCurv2d_swigregister
Extrema_HArray1OfPOnCurv2d_swigregister(Extrema_HArray1OfPOnCurv2d)

def Extrema_HArray1OfPOnCurv2d_get_type_name(*args):
    """
    Extrema_HArray1OfPOnCurv2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Extrema.Extrema_HArray1OfPOnCurv2d_get_type_name(*args)

def Extrema_HArray1OfPOnCurv2d_get_type_descriptor(*args):
    """
    Extrema_HArray1OfPOnCurv2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Extrema.Extrema_HArray1OfPOnCurv2d_get_type_descriptor(*args)

class NCollection_Array1_Extrema_POnCurv2d(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Extrema_POnCurv2d self) -> NCollection_Array1< Extrema_POnCurv2d >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Extrema_POnCurv2d self) -> NCollection_Array1< Extrema_POnCurv2d >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Extrema_POnCurv2d self) -> NCollection_Array1< Extrema_POnCurv2d >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Extrema_POnCurv2d self) -> NCollection_Array1< Extrema_POnCurv2d >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Extrema.new_NCollection_Array1_Extrema_POnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Extrema_POnCurv2d self, Extrema_POnCurv2d theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Extrema_POnCurv2d self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Extrema_POnCurv2d self, NCollection_Array1_Extrema_POnCurv2d theOther) -> NCollection_Array1_Extrema_POnCurv2d

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Extrema_POnCurv2d self, NCollection_Array1_Extrema_POnCurv2d theOther) -> NCollection_Array1_Extrema_POnCurv2d

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Extrema_POnCurv2d self, NCollection_Array1_Extrema_POnCurv2d theOther) -> NCollection_Array1_Extrema_POnCurv2d
        assign(NCollection_Array1_Extrema_POnCurv2d self, NCollection_Array1_Extrema_POnCurv2d theOther) -> NCollection_Array1_Extrema_POnCurv2d

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv2d_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Extrema_POnCurv2d self) -> Extrema_POnCurv2d

        @return first element

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv2d_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Extrema_POnCurv2d self) -> Extrema_POnCurv2d

        @return last element

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Extrema_POnCurv2d self, Standard_Integer const theIndex) -> Extrema_POnCurv2d

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv2d___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv2d_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Extrema_POnCurv2d self, Standard_Integer const theIndex, Extrema_POnCurv2d theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Extrema_POnCurv2d self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv2d_Resize(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array1_Extrema_POnCurv2d
NCollection_Array1_Extrema_POnCurv2d_swigregister = _Extrema.NCollection_Array1_Extrema_POnCurv2d_swigregister
NCollection_Array1_Extrema_POnCurv2d_swigregister(NCollection_Array1_Extrema_POnCurv2d)


try:
	Extrema_Array1OfPOnCurv2d = NCollection_Array1_Extrema_POnCurv2d
except NameError:
	pass # does not exist, probably ignored

class Extrema_EPCOfExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_EPCOfExtPC self) -> Extrema_EPCOfExtPC
        __init__(Extrema_EPCOfExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfExtPC
        __init__(Extrema_EPCOfExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfExtPC

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        NbU is used to locate the close points to
        find the zeros.
        Zeros are searched between umin and usup.
        Tol and TolU are used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        abs(Un-Un-1) < TolU and abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        this = _Extrema.new_Extrema_EPCOfExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_EPCOfExtPC self, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfExtPC self, Adaptor3d_Curve C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfExtPC self, Adaptor3d_Curve C)
        Initialize(Extrema_EPCOfExtPC self, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)

        sets the fields of the algorithm.

        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        return _Extrema.Extrema_EPCOfExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_EPCOfExtPC self, gp_Pnt P)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_EPCOfExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_EPCOfExtPC self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfExtPC_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_EPCOfExtPC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_EPCOfExtPC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_EPCOfExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_EPCOfExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_EPCOfExtPC self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the Nth extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_EPCOfExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_EPCOfExtPC
Extrema_EPCOfExtPC_swigregister = _Extrema.Extrema_EPCOfExtPC_swigregister
Extrema_EPCOfExtPC_swigregister(Extrema_EPCOfExtPC)

class Extrema_ECC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ECC2d self) -> Extrema_ECC2d
        __init__(Extrema_ECC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2) -> Extrema_ECC2d
        __init__(Extrema_ECC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup) -> Extrema_ECC2d

        Calculates all the distances as above
        between Uinf and Usup for C1 and  between Vinf and Vsup
        for C2.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float

        """
        this = _Extrema.new_Extrema_ECC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParams(self, *args):
        """
        SetParams(Extrema_ECC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup)

        Set params in case of empty constructor is usage.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float

        """
        return _Extrema.Extrema_ECC2d_SetParams(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Extrema_ECC2d self, Standard_Real const Tol)

        :type Tol: float

        """
        return _Extrema.Extrema_ECC2d_SetTolerance(self, *args)


    def SetSingleSolutionFlag(self, *args):
        """
        SetSingleSolutionFlag(Extrema_ECC2d self, Standard_Boolean const theSingleSolutionFlag)

        Set flag for single extrema computation. Works on parametric solver only.

        :type theSingleSolutionFlag: bool

        """
        return _Extrema.Extrema_ECC2d_SetSingleSolutionFlag(self, *args)


    def GetSingleSolutionFlag(self, *args):
        """
        GetSingleSolutionFlag(Extrema_ECC2d self) -> Standard_Boolean

        Get flag for single extrema computation. Works on parametric solver only.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ECC2d_GetSingleSolutionFlag(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ECC2d self)

        Performs calculations.


        """
        return _Extrema.Extrema_ECC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ECC2d self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ECC2d_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ECC2d self) -> Standard_Boolean

        Returns state of myParallel flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ECC2d_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ECC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ECC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ECC2d self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth square extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ECC2d_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ECC2d self, Standard_Integer const N, Extrema_POnCurv2d P1, Extrema_POnCurv2d P2)

        Returns the points of the Nth extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv2d
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Extrema.Extrema_ECC2d_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ECC2d
Extrema_ECC2d_swigregister = _Extrema.Extrema_ECC2d_swigregister
Extrema_ECC2d_swigregister(Extrema_ECC2d)

class Extrema_ECC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ECC self) -> Extrema_ECC
        __init__(Extrema_ECC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2) -> Extrema_ECC
        __init__(Extrema_ECC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup) -> Extrema_ECC

        Calculates all the distances as above
        between Uinf and Usup for C1 and  between Vinf and Vsup
        for C2.

        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type C2: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float

        """
        this = _Extrema.new_Extrema_ECC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParams(self, *args):
        """
        SetParams(Extrema_ECC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup)

        Set params in case of empty constructor is usage.

        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type C2: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float

        """
        return _Extrema.Extrema_ECC_SetParams(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Extrema_ECC self, Standard_Real const Tol)

        :type Tol: float

        """
        return _Extrema.Extrema_ECC_SetTolerance(self, *args)


    def SetSingleSolutionFlag(self, *args):
        """
        SetSingleSolutionFlag(Extrema_ECC self, Standard_Boolean const theSingleSolutionFlag)

        Set flag for single extrema computation. Works on parametric solver only.

        :type theSingleSolutionFlag: bool

        """
        return _Extrema.Extrema_ECC_SetSingleSolutionFlag(self, *args)


    def GetSingleSolutionFlag(self, *args):
        """
        GetSingleSolutionFlag(Extrema_ECC self) -> Standard_Boolean

        Get flag for single extrema computation. Works on parametric solver only.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ECC_GetSingleSolutionFlag(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ECC self)

        Performs calculations.


        """
        return _Extrema.Extrema_ECC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ECC self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ECC_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ECC self) -> Standard_Boolean

        Returns state of myParallel flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ECC_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ECC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ECC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ECC self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth square extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ECC_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ECC self, Standard_Integer const N, Extrema_POnCurv P1, Extrema_POnCurv P2)

        Returns the points of the Nth extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        return _Extrema.Extrema_ECC_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ECC
Extrema_ECC_swigregister = _Extrema.Extrema_ECC_swigregister
Extrema_ECC_swigregister(Extrema_ECC)

class NCollection_Array2_Extrema_POnCurv(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _Extrema.new_NCollection_Array2_Extrema_POnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Extrema_POnCurv self, Extrema_POnCurv theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Extrema_POnCurv self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Extrema_POnCurv self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Extrema_POnCurv self, NCollection_Array2_Extrema_POnCurv theOther) -> NCollection_Array2_Extrema_POnCurv

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Extrema_POnCurv self, NCollection_Array2_Extrema_POnCurv theOther) -> NCollection_Array2_Extrema_POnCurv

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnCurv_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Extrema_POnCurv self, Standard_Integer const theRow, Standard_Integer const theCol) -> Extrema_POnCurv

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array2_Extrema_POnCurv___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Extrema_POnCurv self, Standard_Integer const theRow, Standard_Integer const theCol, Extrema_POnCurv theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array2_Extrema_POnCurv_SetValue(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array2_Extrema_POnCurv
NCollection_Array2_Extrema_POnCurv_swigregister = _Extrema.NCollection_Array2_Extrema_POnCurv_swigregister
NCollection_Array2_Extrema_POnCurv_swigregister(NCollection_Array2_Extrema_POnCurv)


try:
	Extrema_Array2OfPOnCurv = NCollection_Array2_Extrema_POnCurv
except NameError:
	pass # does not exist, probably ignored

class Handle_Extrema_HArray2OfPOnCurv2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray2OfPOnCurv2d self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray2OfPOnCurv2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray2OfPOnCurv2d self, Extrema_HArray2OfPOnCurv2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray2OfPOnCurv2d self, Handle_Extrema_HArray2OfPOnCurv2d theHandle) -> Handle_Extrema_HArray2OfPOnCurv2d
        assign(Handle_Extrema_HArray2OfPOnCurv2d self, Extrema_HArray2OfPOnCurv2d thePtr) -> Handle_Extrema_HArray2OfPOnCurv2d
        assign(Handle_Extrema_HArray2OfPOnCurv2d self, Handle_Extrema_HArray2OfPOnCurv2d theHandle) -> Handle_Extrema_HArray2OfPOnCurv2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray2OfPOnCurv2d self) -> Extrema_HArray2OfPOnCurv2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray2OfPOnCurv2d self) -> Extrema_HArray2OfPOnCurv2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray2OfPOnCurv2d self) -> Extrema_HArray2OfPOnCurv2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray2OfPOnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray2OfPOnCurv2d_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray2OfPOnCurv2d

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv2d

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_Extrema_HArray2OfPOnCurv2d self) -> NCollection_Array2_Extrema_POnCurv2d

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv2d

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray2OfPOnCurv2d self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray2OfPOnCurv2d self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray2OfPOnCurv2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray2OfPOnCurv2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray2OfPOnCurv2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray2OfPOnCurv2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray2OfPOnCurv2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray2OfPOnCurv2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray2OfPOnCurv2d self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray2OfPOnCurv2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_DecrementRefCounter(self, *args)

Handle_Extrema_HArray2OfPOnCurv2d_swigregister = _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_swigregister
Handle_Extrema_HArray2OfPOnCurv2d_swigregister(Handle_Extrema_HArray2OfPOnCurv2d)

def Handle_Extrema_HArray2OfPOnCurv2d_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_DownCast(thing)
Handle_Extrema_HArray2OfPOnCurv2d_DownCast = _Extrema.Handle_Extrema_HArray2OfPOnCurv2d_DownCast

class Extrema_FuncPSNorm(math.math_FunctionSetWithDerivatives):
    """
    Functional for search of extremum of the distance between point P and
    surface S, starting from approximate solution (u0, v0).

    The class inherits math_FunctionSetWithDerivatives and thus is intended
    for use in math_FunctionSetRoot algorithm .

    Denoting derivatives of the surface S(u,v) by u and v, respectively, as
    Su and Sv, the two functions to be nullified are:

    F1(u,v) = (S - P) * Su
    F2(u,v) = (S - P) * Sv

    The derivatives of the functional are:

    Duf1(u,v) = Su^2    + (S-P) * Suu;
    Dvf1(u,v) = Su * Sv + (S-P) * Suv
    Duf2(u,v) = Sv * Su + (S-P) * Suv = Dvf1
    Dvf2(u,v) = Sv^2    + (S-P) * Svv

    Here * denotes scalar product, and ^2 is square power.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_FuncPSNorm self) -> Extrema_FuncPSNorm
        __init__(Extrema_FuncPSNorm self, gp_Pnt P, Adaptor3d_Surface S) -> Extrema_FuncPSNorm

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        this = _Extrema.new_Extrema_FuncPSNorm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_FuncPSNorm self, Adaptor3d_Surface S)

        sets the field mysurf of the function.

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        return _Extrema.Extrema_FuncPSNorm_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_FuncPSNorm self, gp_Pnt P)

        sets the field mysurf of the function.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_FuncPSNorm_SetPoint(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Extrema_FuncPSNorm self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncPSNorm_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Extrema_FuncPSNorm self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncPSNorm_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_FuncPSNorm self, math_Vector UV, math_Vector F) -> Standard_Boolean

        Calculate Fi(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncPSNorm_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Extrema_FuncPSNorm self, math_Vector UV, math_Matrix DF) -> Standard_Boolean

        Calculate Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncPSNorm_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_FuncPSNorm self, math_Vector UV, math_Vector F, math_Matrix DF) -> Standard_Boolean

        Calculate Fi(U,V) and Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncPSNorm_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_FuncPSNorm self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncPSNorm_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_FuncPSNorm self) -> Standard_Integer

        Return the number of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncPSNorm_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_FuncPSNorm self, Standard_Integer const N) -> Standard_Real

        Return the value of the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_FuncPSNorm_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_FuncPSNorm_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_FuncPSNorm
Extrema_FuncPSNorm_swigregister = _Extrema.Extrema_FuncPSNorm_swigregister
Extrema_FuncPSNorm_swigregister(Extrema_FuncPSNorm)

class Extrema_ExtCC2d(object):
    """
    It calculates all the distance between two curves.
    These distances can be maximum or minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtCC2d self) -> Extrema_ExtCC2d
        __init__(Extrema_ExtCC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const TolC1=1.0e-10, Standard_Real const TolC2=1.0e-10) -> Extrema_ExtCC2d
        __init__(Extrema_ExtCC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2, Standard_Real const TolC1=1.0e-10, Standard_Real const TolC2=1.0e-10) -> Extrema_ExtCC2d

        It calculates all the distances.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float
        :type TolC1: float
        :type TolC2: float

        """
        this = _Extrema.new_Extrema_ExtCC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtCC2d self, Adaptor2d_Curve2d C2, Standard_Real const V1, Standard_Real const V2, Standard_Real const TolC1=1.0e-10, Standard_Real const TolC2=1.0e-10)

        initializes the fields.

        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type V1: float
        :type V2: float
        :type TolC1: float
        :type TolC2: float

        """
        return _Extrema.Extrema_ExtCC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtCC2d self, Adaptor2d_Curve2d C1, Standard_Real const U1, Standard_Real const U2)

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U1: float
        :type U2: float

        """
        return _Extrema.Extrema_ExtCC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtCC2d self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCC2d_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtCC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtCC2d_NbExt(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtCC2d self) -> Standard_Boolean

        Returns True if the two curves are parallel.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCC2d_IsParallel(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtCC2d self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtCC2d_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtCC2d self, Standard_Integer const N, Extrema_POnCurv2d P1, Extrema_POnCurv2d P2)

        Returns the points of the Nth extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv2d
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Extrema.Extrema_ExtCC2d_Points(self, *args)


    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ExtCC2d self, gp_Pnt2d P11, gp_Pnt2d P12, gp_Pnt2d P21, gp_Pnt2d P22)

        if the curve is a trimmed curve,
        dist11 is a square distance between the point on C1
        of parameter FirstParameter and the point of
        parameter FirstParameter on C2.

        :type dist11: float
        :type distP12: float
        :type distP21: float
        :type distP22: float
        :type P11: OCC.wrapper.gp.gp_Pnt2d
        :type P12: OCC.wrapper.gp.gp_Pnt2d
        :type P21: OCC.wrapper.gp.gp_Pnt2d
        :type P22: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_ExtCC2d_TrimmedSquareDistances(self, *args)


    def SetSingleSolutionFlag(self, *args):
        """
        SetSingleSolutionFlag(Extrema_ExtCC2d self, Standard_Boolean const theSingleSolutionFlag)

        Set flag for single extrema computation. Works on parametric solver only.

        :type theSingleSolutionFlag: bool

        """
        return _Extrema.Extrema_ExtCC2d_SetSingleSolutionFlag(self, *args)


    def GetSingleSolutionFlag(self, *args):
        """
        GetSingleSolutionFlag(Extrema_ExtCC2d self) -> Standard_Boolean

        Get flag for single extrema computation. Works on parametric solver only.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCC2d_GetSingleSolutionFlag(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtCC2d
Extrema_ExtCC2d_swigregister = _Extrema.Extrema_ExtCC2d_swigregister
Extrema_ExtCC2d_swigregister(Extrema_ExtCC2d)

class Extrema_ExtCC(object):
    """
    It calculates all the distance between two curves.
    These distances can be maximum or minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtCC self, Standard_Real const TolC1=1.0e-10, Standard_Real const TolC2=1.0e-10) -> Extrema_ExtCC
        __init__(Extrema_ExtCC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const TolC1=1.0e-10, Standard_Real const TolC2=1.0e-10) -> Extrema_ExtCC
        __init__(Extrema_ExtCC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2, Standard_Real const TolC1=1.0e-10, Standard_Real const TolC2=1.0e-10) -> Extrema_ExtCC

        It calculates all the distances.

        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type C2: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float
        :type TolC1: float
        :type TolC2: float

        """
        this = _Extrema.new_Extrema_ExtCC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurve(self, *args):
        """
        SetCurve(Extrema_ExtCC self, Standard_Integer const theRank, Adaptor3d_Curve C)
        SetCurve(Extrema_ExtCC self, Standard_Integer const theRank, Adaptor3d_Curve C, Standard_Real const Uinf, Standard_Real const Usup)

        :type theRank: int
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Uinf: float
        :type Usup: float

        """
        return _Extrema.Extrema_ExtCC_SetCurve(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Extrema_ExtCC self, Standard_Integer const theRank, Standard_Real const Uinf, Standard_Real const Usup)

        :type theRank: int
        :type Uinf: float
        :type Usup: float

        """
        return _Extrema.Extrema_ExtCC_SetRange(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Extrema_ExtCC self, Standard_Integer const theRank, Standard_Real const Tol)

        :type theRank: int
        :type Tol: float

        """
        return _Extrema.Extrema_ExtCC_SetTolerance(self, *args)


    def Perform(self, *args):
        """Perform(Extrema_ExtCC self)"""
        return _Extrema.Extrema_ExtCC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtCC self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCC_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtCC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtCC_NbExt(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtCC self) -> Standard_Boolean

        Returns True if the two curves are parallel.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCC_IsParallel(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtCC self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtCC_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtCC self, Standard_Integer const N, Extrema_POnCurv P1, Extrema_POnCurv P2)

        Returns the points of the Nth extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        return _Extrema.Extrema_ExtCC_Points(self, *args)


    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ExtCC self, gp_Pnt P11, gp_Pnt P12, gp_Pnt P21, gp_Pnt P22)

        if the curve is a trimmed curve,
        dist11 is a square distance between the point on C1
        of parameter FirstParameter and the point of
        parameter FirstParameter on C2.

        :type dist11: float
        :type distP12: float
        :type distP21: float
        :type distP22: float
        :type P11: OCC.wrapper.gp.gp_Pnt
        :type P12: OCC.wrapper.gp.gp_Pnt
        :type P21: OCC.wrapper.gp.gp_Pnt
        :type P22: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtCC_TrimmedSquareDistances(self, *args)


    def SetSingleSolutionFlag(self, *args):
        """
        SetSingleSolutionFlag(Extrema_ExtCC self, Standard_Boolean const theSingleSolutionFlag)

        Set flag for single extrema computation. Works on parametric solver only.

        :type theSingleSolutionFlag: bool

        """
        return _Extrema.Extrema_ExtCC_SetSingleSolutionFlag(self, *args)


    def GetSingleSolutionFlag(self, *args):
        """
        GetSingleSolutionFlag(Extrema_ExtCC self) -> Standard_Boolean

        Get flag for single extrema computation. Works on parametric solver only.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCC_GetSingleSolutionFlag(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtCC
Extrema_ExtCC_swigregister = _Extrema.Extrema_ExtCC_swigregister
Extrema_ExtCC_swigregister(Extrema_ExtCC)

class Extrema_PCLocFOfLocEPCOfLocateExtPC(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_PCLocFOfLocEPCOfLocateExtPC self) -> Extrema_PCLocFOfLocEPCOfLocateExtPC
        __init__(Extrema_PCLocFOfLocEPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C) -> Extrema_PCLocFOfLocEPCOfLocateExtPC

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        this = _Extrema.new_Extrema_PCLocFOfLocEPCOfLocateExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Adaptor3d_Curve C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_PCLocFOfLocEPCOfLocateExtPC self, gp_Pnt P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_PCLocFOfLocEPCOfLocateExtPC self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_PCLocFOfLocEPCOfLocateExtPC self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_PCLocFOfLocEPCOfLocateExtPC self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_PCLocFOfLocEPCOfLocateExtPC self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_PCLocFOfLocEPCOfLocateExtPC
Extrema_PCLocFOfLocEPCOfLocateExtPC_swigregister = _Extrema.Extrema_PCLocFOfLocEPCOfLocateExtPC_swigregister
Extrema_PCLocFOfLocEPCOfLocateExtPC_swigregister(Extrema_PCLocFOfLocEPCOfLocateExtPC)

class Extrema_PCFOfEPCOfExtPC(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_PCFOfEPCOfExtPC self) -> Extrema_PCFOfEPCOfExtPC
        __init__(Extrema_PCFOfEPCOfExtPC self, gp_Pnt P, Adaptor3d_Curve C) -> Extrema_PCFOfEPCOfExtPC

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        this = _Extrema.new_Extrema_PCFOfEPCOfExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_PCFOfEPCOfExtPC self, Adaptor3d_Curve C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_PCFOfEPCOfExtPC self, gp_Pnt P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_PCFOfEPCOfExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Extrema_PCFOfEPCOfExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_PCFOfEPCOfExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_PCFOfEPCOfExtPC self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_PCFOfEPCOfExtPC self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_PCFOfEPCOfExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_PCFOfEPCOfExtPC self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_PCFOfEPCOfExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_PCFOfEPCOfExtPC self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_PCFOfEPCOfExtPC self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_PCFOfEPCOfExtPC
Extrema_PCFOfEPCOfExtPC_swigregister = _Extrema.Extrema_PCFOfEPCOfExtPC_swigregister
Extrema_PCFOfEPCOfExtPC_swigregister(Extrema_PCFOfEPCOfExtPC)

class NCollection_Array1_Extrema_POnSurf(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Extrema_POnSurf self) -> NCollection_Array1< Extrema_POnSurf >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Extrema_POnSurf self) -> NCollection_Array1< Extrema_POnSurf >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Extrema_POnSurf self) -> NCollection_Array1< Extrema_POnSurf >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Extrema_POnSurf self) -> NCollection_Array1< Extrema_POnSurf >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Extrema.new_NCollection_Array1_Extrema_POnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Extrema_POnSurf self, Extrema_POnSurf theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Extrema_POnSurf self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Extrema_POnSurf self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Extrema_POnSurf self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Extrema_POnSurf self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Extrema_POnSurf self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Extrema_POnSurf self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Extrema_POnSurf self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Extrema_POnSurf self, NCollection_Array1_Extrema_POnSurf theOther) -> NCollection_Array1_Extrema_POnSurf

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Extrema_POnSurf self, NCollection_Array1_Extrema_POnSurf theOther) -> NCollection_Array1_Extrema_POnSurf

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Extrema_POnSurf self, NCollection_Array1_Extrema_POnSurf theOther) -> NCollection_Array1_Extrema_POnSurf
        assign(NCollection_Array1_Extrema_POnSurf self, NCollection_Array1_Extrema_POnSurf theOther) -> NCollection_Array1_Extrema_POnSurf

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnSurf_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Extrema_POnSurf self) -> Extrema_POnSurf

        @return first element

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnSurf_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Extrema_POnSurf self) -> Extrema_POnSurf

        @return last element

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnSurf_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Extrema_POnSurf self, Standard_Integer const theIndex) -> Extrema_POnSurf

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnSurf___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnSurf_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Extrema_POnSurf self, Standard_Integer const theIndex, Extrema_POnSurf theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Extrema_POnSurf self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Extrema.NCollection_Array1_Extrema_POnSurf_Resize(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array1_Extrema_POnSurf
NCollection_Array1_Extrema_POnSurf_swigregister = _Extrema.NCollection_Array1_Extrema_POnSurf_swigregister
NCollection_Array1_Extrema_POnSurf_swigregister(NCollection_Array1_Extrema_POnSurf)


try:
	Extrema_Array1OfPOnSurf = NCollection_Array1_Extrema_POnSurf
except NameError:
	pass # does not exist, probably ignored

class Extrema_ExtCS(object):
    """
    It calculates all the extremum distances
    between a curve and a surface.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtCS self) -> Extrema_ExtCS
        __init__(Extrema_ExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S, Standard_Real const TolC, Standard_Real const TolS) -> Extrema_ExtCS
        __init__(Extrema_ExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S, Standard_Real const UCinf, Standard_Real const UCsup, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup, Standard_Real const TolC, Standard_Real const TolS) -> Extrema_ExtCS

        It calculates all the distances between C and S.
        UCinf and UCmax are the start and end parameters
        of the curve.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type UCinf: float
        :type UCsup: float
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float
        :type TolC: float
        :type TolS: float

        """
        this = _Extrema.new_Extrema_ExtCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtCS self, Adaptor3d_Surface S, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup, Standard_Real const TolC, Standard_Real const TolS)

        Initializes the fields of the algorithm.

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float
        :type TolC: float
        :type TolS: float

        """
        return _Extrema.Extrema_ExtCS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtCS self, Adaptor3d_Curve C, Standard_Real const Uinf, Standard_Real const Usup)

        Computes the distances.
        An exception is raised if the fieds have not been
        initialized.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Uinf: float
        :type Usup: float

        """
        return _Extrema.Extrema_ExtCS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtCS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCS_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtCS self) -> Standard_Boolean

        Returns True if the curve is on a parallel surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtCS_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtCS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtCS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtCS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtCS_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtCS self, Standard_Integer const N, Extrema_POnCurv P1, Extrema_POnSurf P2)

        Returns the point of the Nth resulting distance.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        return _Extrema.Extrema_ExtCS_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtCS
Extrema_ExtCS_swigregister = _Extrema.Extrema_ExtCS_swigregister
Extrema_ExtCS_swigregister(Extrema_ExtCS)

class Extrema_LocEPCOfLocateExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocEPCOfLocateExtPC self) -> Extrema_LocEPCOfLocateExtPC
        __init__(Extrema_LocEPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const U0, Standard_Real const TolU) -> Extrema_LocEPCOfLocateExtPC
        __init__(Extrema_LocEPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const U0, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU) -> Extrema_LocEPCOfLocateExtPC

        Calculates the distance with a close point.
        The close point is defined by the parameter value
        U0.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs a zero
        near the close point.
        Zeros are searched between Umin et Usup.
        TolU is used to decide to stop the iterations.
        At the nth iteration, the criteria is:
        abs(Un - Un-1) < TolU.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U0: float
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        this = _Extrema.new_Extrema_LocEPCOfLocateExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_LocEPCOfLocateExtPC self, Adaptor3d_Curve C, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU)

        sets the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_LocEPCOfLocateExtPC self, gp_Pnt P, Standard_Real const U0)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U0: float

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_LocEPCOfLocateExtPC self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocEPCOfLocateExtPC self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_LocEPCOfLocateExtPC self) -> Standard_Boolean

        Returns True if the extremum distance is a minimum.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_LocEPCOfLocateExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_LocEPCOfLocateExtPC
Extrema_LocEPCOfLocateExtPC_swigregister = _Extrema.Extrema_LocEPCOfLocateExtPC_swigregister
Extrema_LocEPCOfLocateExtPC_swigregister(Extrema_LocEPCOfLocateExtPC)

class Extrema_FuncPSDist(math.math_MultipleVarFunctionWithGradient):
    """
    Functional for search of extremum of the square Euclidean distance between point P and
    surface S, starting from approximate solution (u0, v0).

    The class inherits math_MultipleVarFunctionWithGradient and thus is intended
    for use in math_BFGS algorithm.

    The criteria is:
    F = SquareDist(P, S(u, v)) - > min

    The first derivative are:
    F1(u,v) = (S(u,v) - P) * Su
    F2(u,v) = (S(u,v) - P) * Sv

    Su and Sv are first derivatives of the surface, * symbol means dot product.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_FuncPSDist self, Adaptor3d_Surface theS, gp_Pnt theP) -> Extrema_FuncPSDist

        Constructor.

        :type theS: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type theP: OCC.wrapper.gp.gp_Pnt

        """
        this = _Extrema.new_Extrema_FuncPSDist(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(Extrema_FuncPSDist self) -> Standard_Integer

        Number of variables.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_FuncPSDist_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_FuncPSDist self, math_Vector X) -> Standard_Boolean

        Value.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncPSDist_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(Extrema_FuncPSDist self, math_Vector X, math_Vector G) -> Standard_Boolean

        Gradient.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncPSDist_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_FuncPSDist self, math_Vector X, math_Vector G) -> Standard_Boolean

        Value and gradient.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_FuncPSDist_Values(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_FuncPSDist
Extrema_FuncPSDist_swigregister = _Extrema.Extrema_FuncPSDist_swigregister
Extrema_FuncPSDist_swigregister(Extrema_FuncPSDist)

class Extrema_LocEPCOfLocateExtPC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocEPCOfLocateExtPC2d self) -> Extrema_LocEPCOfLocateExtPC2d
        __init__(Extrema_LocEPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const TolU) -> Extrema_LocEPCOfLocateExtPC2d
        __init__(Extrema_LocEPCOfLocateExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU) -> Extrema_LocEPCOfLocateExtPC2d

        Calculates the distance with a close point.
        The close point is defined by the parameter value
        U0.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs a zero
        near the close point.
        Zeros are searched between Umin et Usup.
        TolU is used to decide to stop the iterations.
        At the nth iteration, the criteria is:
        abs(Un - Un-1) < TolU.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U0: float
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        this = _Extrema.new_Extrema_LocEPCOfLocateExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_LocEPCOfLocateExtPC2d self, Adaptor2d_Curve2d C, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU)

        sets the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_LocEPCOfLocateExtPC2d self, gp_Pnt2d P, Standard_Real const U0)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type U0: float

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_LocEPCOfLocateExtPC2d self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC2d_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocEPCOfLocateExtPC2d self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_LocEPCOfLocateExtPC2d self) -> Standard_Boolean

        Returns True if the extremum distance is a minimum.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocEPCOfLocateExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_LocEPCOfLocateExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_LocEPCOfLocateExtPC2d
Extrema_LocEPCOfLocateExtPC2d_swigregister = _Extrema.Extrema_LocEPCOfLocateExtPC2d_swigregister
Extrema_LocEPCOfLocateExtPC2d_swigregister(Extrema_LocEPCOfLocateExtPC2d)

class Handle_Extrema_HArray1OfPOnCurv(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray1OfPOnCurv self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray1OfPOnCurv self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray1OfPOnCurv self, Extrema_HArray1OfPOnCurv thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray1OfPOnCurv self, Handle_Extrema_HArray1OfPOnCurv theHandle) -> Handle_Extrema_HArray1OfPOnCurv
        assign(Handle_Extrema_HArray1OfPOnCurv self, Extrema_HArray1OfPOnCurv thePtr) -> Handle_Extrema_HArray1OfPOnCurv
        assign(Handle_Extrema_HArray1OfPOnCurv self, Handle_Extrema_HArray1OfPOnCurv theHandle) -> Handle_Extrema_HArray1OfPOnCurv

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray1OfPOnCurv self) -> Extrema_HArray1OfPOnCurv

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray1OfPOnCurv self) -> Extrema_HArray1OfPOnCurv

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray1OfPOnCurv self) -> Extrema_HArray1OfPOnCurv

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray1OfPOnCurv___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray1OfPOnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray1OfPOnCurv_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray1OfPOnCurv

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnCurv_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Extrema_HArray1OfPOnCurv self) -> NCollection_Array1_Extrema_POnCurv

        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray1OfPOnCurv self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnCurv_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnCurv_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray1OfPOnCurv self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray1OfPOnCurv self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray1OfPOnCurv self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray1OfPOnCurv self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray1OfPOnCurv self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray1OfPOnCurv self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray1OfPOnCurv self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray1OfPOnCurv self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray1OfPOnCurv self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv_DecrementRefCounter(self, *args)

Handle_Extrema_HArray1OfPOnCurv_swigregister = _Extrema.Handle_Extrema_HArray1OfPOnCurv_swigregister
Handle_Extrema_HArray1OfPOnCurv_swigregister(Handle_Extrema_HArray1OfPOnCurv)

def Handle_Extrema_HArray1OfPOnCurv_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray1OfPOnCurv_DownCast(thing)
Handle_Extrema_HArray1OfPOnCurv_DownCast = _Extrema.Handle_Extrema_HArray1OfPOnCurv_DownCast

class Extrema_GenLocateExtSS(object):
    """
    With two close points it calculates the distance
    between two surfaces.
    This distance can be a minimum or a maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GenLocateExtSS self) -> Extrema_GenLocateExtSS
        __init__(Extrema_GenLocateExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const Tol1, Standard_Real const Tol2) -> Extrema_GenLocateExtSS

        Calculates the distance with two close points.
        The close points are defined by the parameter values
        (U1,V1) for S1 and (U2,V2) for S2.
        The function F(u1,v1,u2,v2)=distance(S1(u1,v1),S2(u2,v2))
        has an extremun when gradient(F)=0. The algorithm searchs
        a zero near the close points.

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type Tol1: float
        :type Tol2: float

        """
        this = _Extrema.new_Extrema_GenLocateExtSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_GenLocateExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Real const Tol1, Standard_Real const Tol2)

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type Tol1: float
        :type Tol2: float

        """
        return _Extrema.Extrema_GenLocateExtSS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_GenLocateExtSS self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GenLocateExtSS_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_GenLocateExtSS self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_GenLocateExtSS_SquareDistance(self, *args)


    def PointOnS1(self, *args):
        """
        Returns the point of the extremum distance on S1.

        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenLocateExtSS_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        Returns the point of the extremum distance on S2.

        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenLocateExtSS_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_GenLocateExtSS
Extrema_GenLocateExtSS_swigregister = _Extrema.Extrema_GenLocateExtSS_swigregister
Extrema_GenLocateExtSS_swigregister(Extrema_GenLocateExtSS)

class Extrema_CCLocFOfLocECC2d(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_CCLocFOfLocECC2d self, Standard_Real const thetol=1.0e-10) -> Extrema_CCLocFOfLocECC2d
        __init__(Extrema_CCLocFOfLocECC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const thetol=1.0e-10) -> Extrema_CCLocFOfLocECC2d

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type thetol: float

        """
        this = _Extrema.new_Extrema_CCLocFOfLocECC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurve(self, *args):
        """
        SetCurve(Extrema_CCLocFOfLocECC2d self, Standard_Integer const theRank, Adaptor2d_Curve2d C1)

        :type theRank: int
        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_SetCurve(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Extrema_CCLocFOfLocECC2d self, Standard_Real const theTol)

        :type theTol: float

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_SetTolerance(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Extrema_CCLocFOfLocECC2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Extrema_CCLocFOfLocECC2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_CCLocFOfLocECC2d self, math_Vector UV, math_Vector F) -> Standard_Boolean

        Calculate Fi(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Extrema_CCLocFOfLocECC2d self, math_Vector UV, math_Matrix DF) -> Standard_Boolean

        Calculate Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_CCLocFOfLocECC2d self, math_Vector UV, math_Vector F, math_Matrix DF) -> Standard_Boolean

        Calculate Fi(U,V) and Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_CCLocFOfLocECC2d self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_CCLocFOfLocECC2d self) -> Standard_Integer

        Return the number of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_CCLocFOfLocECC2d self, Standard_Integer const N) -> Standard_Real

        Return the value of the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_CCLocFOfLocECC2d self, Standard_Integer const N, Extrema_POnCurv2d P1, Extrema_POnCurv2d P2)

        Return the points of the Nth extreme distance.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv2d
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_Points(self, *args)


    def CurvePtr(self, *args):
        """
        CurvePtr(Extrema_CCLocFOfLocECC2d self, Standard_Integer const theRank) -> Standard_Address

        Returns a pointer to the curve specified in the constructor
        or in SetCurve() method.

        :type theRank: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_CurvePtr(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Extrema_CCLocFOfLocECC2d self) -> Standard_Real

        Returns a tolerance specified in the constructor
        or in SetTolerance() method.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_Tolerance(self, *args)


    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_CCLocFOfLocECC2d self, math_Vector theUfirst, math_Vector theUlast)

        Determines of boundaries of subinterval for find of root.

        :type theUfirst: OCC.wrapper.math.math_Vector
        :type theUlast: OCC.wrapper.math.math_Vector

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_CCLocFOfLocECC2d self, Standard_Address const C) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CCLocFOfLocECC2d_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_CCLocFOfLocECC2d
Extrema_CCLocFOfLocECC2d_swigregister = _Extrema.Extrema_CCLocFOfLocECC2d_swigregister
Extrema_CCLocFOfLocECC2d_swigregister(Extrema_CCLocFOfLocECC2d)

class Handle_Extrema_HArray1OfPOnCurv2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray1OfPOnCurv2d self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray1OfPOnCurv2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray1OfPOnCurv2d self, Extrema_HArray1OfPOnCurv2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray1OfPOnCurv2d self, Handle_Extrema_HArray1OfPOnCurv2d theHandle) -> Handle_Extrema_HArray1OfPOnCurv2d
        assign(Handle_Extrema_HArray1OfPOnCurv2d self, Extrema_HArray1OfPOnCurv2d thePtr) -> Handle_Extrema_HArray1OfPOnCurv2d
        assign(Handle_Extrema_HArray1OfPOnCurv2d self, Handle_Extrema_HArray1OfPOnCurv2d theHandle) -> Handle_Extrema_HArray1OfPOnCurv2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray1OfPOnCurv2d self) -> Extrema_HArray1OfPOnCurv2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray1OfPOnCurv2d self) -> Extrema_HArray1OfPOnCurv2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray1OfPOnCurv2d self) -> Extrema_HArray1OfPOnCurv2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray1OfPOnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray1OfPOnCurv2d_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray1OfPOnCurv2d

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv2d

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Extrema_HArray1OfPOnCurv2d self) -> NCollection_Array1_Extrema_POnCurv2d

        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnCurv2d

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray1OfPOnCurv2d self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray1OfPOnCurv2d self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray1OfPOnCurv2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray1OfPOnCurv2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray1OfPOnCurv2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray1OfPOnCurv2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray1OfPOnCurv2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray1OfPOnCurv2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray1OfPOnCurv2d self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray1OfPOnCurv2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_DecrementRefCounter(self, *args)

Handle_Extrema_HArray1OfPOnCurv2d_swigregister = _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_swigregister
Handle_Extrema_HArray1OfPOnCurv2d_swigregister(Handle_Extrema_HArray1OfPOnCurv2d)

def Handle_Extrema_HArray1OfPOnCurv2d_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_DownCast(thing)
Handle_Extrema_HArray1OfPOnCurv2d_DownCast = _Extrema.Handle_Extrema_HArray1OfPOnCurv2d_DownCast

class Extrema_GlobOptFuncCS(math.math_MultipleVarFunctionWithHessian):
    """
    This class implements function which calculate square Eucluidean distance
    between point on curve and point on surface in case of continuity is C2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GlobOptFuncCS self, Adaptor3d_Curve C, Adaptor3d_Surface S) -> Extrema_GlobOptFuncCS

        Curve and surface should exist during all the lifetime of Extrema_GlobOptFuncCS.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface

        """
        this = _Extrema.new_Extrema_GlobOptFuncCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(Extrema_GlobOptFuncCS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GlobOptFuncCS_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_GlobOptFuncCS self, math_Vector theX) -> Standard_Boolean

        :type theX: OCC.wrapper.math.math_Vector
        :type theF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCS_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(Extrema_GlobOptFuncCS self, math_Vector theX, math_Vector theG) -> Standard_Boolean

        :type theX: OCC.wrapper.math.math_Vector
        :type theG: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCS_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_GlobOptFuncCS self, math_Vector theX, math_Vector theG) -> Standard_Boolean
        Values(Extrema_GlobOptFuncCS self, math_Vector theX, math_Vector theG, math_Matrix theH) -> Standard_Boolean

        :type theX: OCC.wrapper.math.math_Vector
        :type theF: float
        :type theG: OCC.wrapper.math.math_Vector
        :type theH: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCS_Values(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_GlobOptFuncCS
Extrema_GlobOptFuncCS_swigregister = _Extrema.Extrema_GlobOptFuncCS_swigregister
Extrema_GlobOptFuncCS_swigregister(Extrema_GlobOptFuncCS)

class Extrema_EPCOfExtPC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_EPCOfExtPC2d self) -> Extrema_EPCOfExtPC2d
        __init__(Extrema_EPCOfExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfExtPC2d
        __init__(Extrema_EPCOfExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF) -> Extrema_EPCOfExtPC2d

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        NbU is used to locate the close points to
        find the zeros.
        Zeros are searched between umin and usup.
        Tol and TolU are used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        abs(Un-Un-1) < TolU and abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        this = _Extrema.new_Extrema_EPCOfExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_EPCOfExtPC2d self, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfExtPC2d self, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)
        Initialize(Extrema_EPCOfExtPC2d self, Adaptor2d_Curve2d C)
        Initialize(Extrema_EPCOfExtPC2d self, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU, Standard_Real const TolF)

        sets the fields of the algorithm.

        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type TolU: float
        :type TolF: float

        """
        return _Extrema.Extrema_EPCOfExtPC2d_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_EPCOfExtPC2d self, gp_Pnt2d P)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_EPCOfExtPC2d_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_EPCOfExtPC2d self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfExtPC2d_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_EPCOfExtPC2d self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_EPCOfExtPC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_EPCOfExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_EPCOfExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_EPCOfExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the Nth extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_EPCOfExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_EPCOfExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_EPCOfExtPC2d
Extrema_EPCOfExtPC2d_swigregister = _Extrema.Extrema_EPCOfExtPC2d_swigregister
Extrema_EPCOfExtPC2d_swigregister(Extrema_EPCOfExtPC2d)

class Extrema_LocateExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocateExtPC self) -> Extrema_LocateExtPC
        __init__(Extrema_LocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const U0, Standard_Real const TolF) -> Extrema_LocateExtPC
        __init__(Extrema_LocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const U0, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolF) -> Extrema_LocateExtPC

        Calculates the distance with a close point.
        The close point is defined by the parameter value
        U0.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs a zero
        near the close point.
        Zeros are searched between Umin et Usup.
        TolF is used to decide to stop the iterations.
        At the nth iteration, the criteria is:
        abs(Un - Un-1) < TolF.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U0: float
        :type Umin: float
        :type Usup: float
        :type TolF: float

        """
        this = _Extrema.new_Extrema_LocateExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_LocateExtPC self, Adaptor3d_Curve C, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolF)

        sets the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Umin: float
        :type Usup: float
        :type TolF: float

        """
        return _Extrema.Extrema_LocateExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_LocateExtPC self, gp_Pnt P, Standard_Real const U0)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U0: float

        """
        return _Extrema.Extrema_LocateExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_LocateExtPC self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocateExtPC_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocateExtPC self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocateExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_LocateExtPC self) -> Standard_Boolean

        Returns True if the extremum distance is a minimum.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocateExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_LocateExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_LocateExtPC
Extrema_LocateExtPC_swigregister = _Extrema.Extrema_LocateExtPC_swigregister
Extrema_LocateExtPC_swigregister(Extrema_LocateExtPC)

class Handle_Extrema_HArray2OfPOnCurv(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray2OfPOnCurv self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray2OfPOnCurv self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray2OfPOnCurv self, Extrema_HArray2OfPOnCurv thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray2OfPOnCurv self, Handle_Extrema_HArray2OfPOnCurv theHandle) -> Handle_Extrema_HArray2OfPOnCurv
        assign(Handle_Extrema_HArray2OfPOnCurv self, Extrema_HArray2OfPOnCurv thePtr) -> Handle_Extrema_HArray2OfPOnCurv
        assign(Handle_Extrema_HArray2OfPOnCurv self, Handle_Extrema_HArray2OfPOnCurv theHandle) -> Handle_Extrema_HArray2OfPOnCurv

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray2OfPOnCurv self) -> Extrema_HArray2OfPOnCurv

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray2OfPOnCurv self) -> Extrema_HArray2OfPOnCurv

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray2OfPOnCurv self) -> Extrema_HArray2OfPOnCurv

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray2OfPOnCurv___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray2OfPOnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray2OfPOnCurv_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray2OfPOnCurv

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnCurv_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_Extrema_HArray2OfPOnCurv self) -> NCollection_Array2_Extrema_POnCurv

        :rtype: OCC.wrapper.Extrema.Extrema_Array2OfPOnCurv

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray2OfPOnCurv self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnCurv_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray2OfPOnCurv_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray2OfPOnCurv self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray2OfPOnCurv self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray2OfPOnCurv self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray2OfPOnCurv self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray2OfPOnCurv self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray2OfPOnCurv self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray2OfPOnCurv self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray2OfPOnCurv self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray2OfPOnCurv self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray2OfPOnCurv_DecrementRefCounter(self, *args)

Handle_Extrema_HArray2OfPOnCurv_swigregister = _Extrema.Handle_Extrema_HArray2OfPOnCurv_swigregister
Handle_Extrema_HArray2OfPOnCurv_swigregister(Handle_Extrema_HArray2OfPOnCurv)

def Handle_Extrema_HArray2OfPOnCurv_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray2OfPOnCurv_DownCast(thing)
Handle_Extrema_HArray2OfPOnCurv_DownCast = _Extrema.Handle_Extrema_HArray2OfPOnCurv_DownCast

class NCollection_Array1_Extrema_POnCurv(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Extrema_POnCurv self) -> NCollection_Array1< Extrema_POnCurv >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Extrema_POnCurv self) -> NCollection_Array1< Extrema_POnCurv >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Extrema_POnCurv self) -> NCollection_Array1< Extrema_POnCurv >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Extrema_POnCurv self) -> NCollection_Array1< Extrema_POnCurv >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Extrema.new_NCollection_Array1_Extrema_POnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Extrema_POnCurv self, Extrema_POnCurv theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Extrema_POnCurv self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Extrema_POnCurv self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Extrema_POnCurv self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Extrema_POnCurv self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Extrema_POnCurv self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Extrema_POnCurv self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Extrema_POnCurv self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Extrema_POnCurv self, NCollection_Array1_Extrema_POnCurv theOther) -> NCollection_Array1_Extrema_POnCurv

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Extrema_POnCurv self, NCollection_Array1_Extrema_POnCurv theOther) -> NCollection_Array1_Extrema_POnCurv

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Extrema_POnCurv self, NCollection_Array1_Extrema_POnCurv theOther) -> NCollection_Array1_Extrema_POnCurv
        assign(NCollection_Array1_Extrema_POnCurv self, NCollection_Array1_Extrema_POnCurv theOther) -> NCollection_Array1_Extrema_POnCurv

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Extrema_POnCurv self) -> Extrema_POnCurv

        @return first element

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Extrema_POnCurv self) -> Extrema_POnCurv

        @return last element

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Extrema_POnCurv self, Standard_Integer const theIndex) -> Extrema_POnCurv

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Array1_Extrema_POnCurv_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Extrema_POnCurv self, Standard_Integer const theIndex, Extrema_POnCurv theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Extrema_POnCurv self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Extrema.NCollection_Array1_Extrema_POnCurv_Resize(self, *args)

    __swig_destroy__ = _Extrema.delete_NCollection_Array1_Extrema_POnCurv
NCollection_Array1_Extrema_POnCurv_swigregister = _Extrema.NCollection_Array1_Extrema_POnCurv_swigregister
NCollection_Array1_Extrema_POnCurv_swigregister(NCollection_Array1_Extrema_POnCurv)


try:
	Extrema_Array1OfPOnCurv = NCollection_Array1_Extrema_POnCurv
except NameError:
	pass # does not exist, probably ignored

class Extrema_ExtElC(object):
    """
    It calculates all the distance between two elementary
    curves.
    These distances can be maximum or minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtElC self) -> Extrema_ExtElC
        __init__(Extrema_ExtElC self, gp_Lin C1, gp_Lin C2, Standard_Real const AngTol) -> Extrema_ExtElC
        __init__(Extrema_ExtElC self, gp_Lin C1, gp_Circ C2, Standard_Real const Tol) -> Extrema_ExtElC
        __init__(Extrema_ExtElC self, gp_Lin C1, gp_Elips C2) -> Extrema_ExtElC
        __init__(Extrema_ExtElC self, gp_Lin C1, gp_Hypr C2) -> Extrema_ExtElC
        __init__(Extrema_ExtElC self, gp_Lin C1, gp_Parab C2) -> Extrema_ExtElC
        __init__(Extrema_ExtElC self, gp_Circ C1, gp_Circ C2) -> Extrema_ExtElC

        Calculates the distance between two circles.
        The circles can be parallel or identical.

        :type C1: OCC.wrapper.gp.gp_Circ
        :type C2: OCC.wrapper.gp.gp_Circ

        """
        this = _Extrema.new_Extrema_ExtElC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtElC self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElC_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtElC self) -> Standard_Boolean

        Returns True if the two curves are parallel.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtElC_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtElC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtElC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtElC self, Standard_Integer const N=1) -> Standard_Real

        Returns the value of the Nth extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtElC_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtElC self, Standard_Integer const N, Extrema_POnCurv P1, Extrema_POnCurv P2)

        Returns the points of the Nth extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        return _Extrema.Extrema_ExtElC_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtElC
Extrema_ExtElC_swigregister = _Extrema.Extrema_ExtElC_swigregister
Extrema_ExtElC_swigregister(Extrema_ExtElC)

class Extrema_GlobOptFuncCCC1(math.math_MultipleVarFunctionWithGradient):
    """
    This class implements function which calculate Eucluidean distance
    between point on curve and point on other curve in case of C1 and C2 continuity is C1.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GlobOptFuncCCC1 self, Adaptor3d_Curve C1, Adaptor3d_Curve C2) -> Extrema_GlobOptFuncCCC1
        __init__(Extrema_GlobOptFuncCCC1 self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2) -> Extrema_GlobOptFuncCCC1

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Extrema.new_Extrema_GlobOptFuncCCC1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(Extrema_GlobOptFuncCCC1 self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GlobOptFuncCCC1_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_GlobOptFuncCCC1 self, math_Vector X) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC1_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(Extrema_GlobOptFuncCCC1 self, math_Vector X, math_Vector G) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC1_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_GlobOptFuncCCC1 self, math_Vector X, math_Vector G) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC1_Values(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_GlobOptFuncCCC1
Extrema_GlobOptFuncCCC1_swigregister = _Extrema.Extrema_GlobOptFuncCCC1_swigregister
Extrema_GlobOptFuncCCC1_swigregister(Extrema_GlobOptFuncCCC1)

class Extrema_PCFOfEPCOfExtPC2d(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_PCFOfEPCOfExtPC2d self) -> Extrema_PCFOfEPCOfExtPC2d
        __init__(Extrema_PCFOfEPCOfExtPC2d self, gp_Pnt2d P, Adaptor2d_Curve2d C) -> Extrema_PCFOfEPCOfExtPC2d

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Extrema.new_Extrema_PCFOfEPCOfExtPC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_PCFOfEPCOfExtPC2d self, Adaptor2d_Curve2d C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_PCFOfEPCOfExtPC2d self, gp_Pnt2d P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_PCFOfEPCOfExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Extrema_PCFOfEPCOfExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_PCFOfEPCOfExtPC2d self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_PCFOfEPCOfExtPC2d self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_PCFOfEPCOfExtPC2d self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_PCFOfEPCOfExtPC2d self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_PCFOfEPCOfExtPC2d self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Extrema.Extrema_PCFOfEPCOfExtPC2d_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_PCFOfEPCOfExtPC2d self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_PCFOfEPCOfExtPC2d self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfExtPC2d_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_PCFOfEPCOfExtPC2d
Extrema_PCFOfEPCOfExtPC2d_swigregister = _Extrema.Extrema_PCFOfEPCOfExtPC2d_swigregister
Extrema_PCFOfEPCOfExtPC2d_swigregister(Extrema_PCFOfEPCOfExtPC2d)

class Extrema_ExtPS(object):
    """
    It calculates all the extremum distances
    between a point and a surface.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtPS self) -> Extrema_ExtPS
        __init__(Extrema_ExtPS self, gp_Pnt P, Adaptor3d_Surface S, Standard_Real const TolU, Standard_Real const TolV, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> Extrema_ExtPS
        __init__(Extrema_ExtPS self, gp_Pnt P, Adaptor3d_Surface S, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> Extrema_ExtPS

        It calculates all the distances.
        NbU and NbV are used to locate the close points
        to find the zeros. They must be great enough
        such that if there is N extrema, there will
        be N extrema between P and the grid.
        TolU et TolV are used to determine the conditions
        to stop the iterations; at the iteration number n:
        (Un - Un-1) < TolU and (Vn - Vn-1) < TolV .

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float
        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag
        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        this = _Extrema.new_Extrema_ExtPS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtPS self, Adaptor3d_Surface S, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const Vinf, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV)

        Initializes the fields of the algorithm.

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type Uinf: float
        :type Usup: float
        :type Vinf: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float

        """
        return _Extrema.Extrema_ExtPS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtPS self, gp_Pnt P)

        Computes the distances.
        An exception is raised if the fieds have not been
        initialized.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtPS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_ExtPS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ExtPS self, gp_Pnt PUfVf, gp_Pnt PUfVl, gp_Pnt PUlVf, gp_Pnt PUlVl)

        if the surface is a trimmed surface,
        dUfVf is a square distance between <P> and the point
        of parameter FirstUParameter and FirstVParameter <PUfVf>.
        dUfVl is a square distance between <P> and the point
        of parameter FirstUParameter and LastVParameter <PUfVl>.
        dUlVf is a square distance between <P> and the point
        of parameter LastUParameter and FirstVParameter <PUlVf>.
        dUlVl is a square distance between <P> and the point
        of parameter LastUParameter and LastVParameter <PUlVl>.

        :type dUfVf: float
        :type dUfVl: float
        :type dUlVf: float
        :type dUlVl: float
        :type PUfVf: OCC.wrapper.gp.gp_Pnt
        :type PUfVl: OCC.wrapper.gp.gp_Pnt
        :type PUlVf: OCC.wrapper.gp.gp_Pnt
        :type PUlVl: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtPS_TrimmedSquareDistances(self, *args)


    def SetFlag(self, *args):
        """
        SetFlag(Extrema_ExtPS self, Extrema_ExtFlag const F)

        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag

        """
        return _Extrema.Extrema_ExtPS_SetFlag(self, *args)


    def SetAlgo(self, *args):
        """
        SetAlgo(Extrema_ExtPS self, Extrema_ExtAlgo const A)

        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _Extrema.Extrema_ExtPS_SetAlgo(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtPS
Extrema_ExtPS_swigregister = _Extrema.Extrema_ExtPS_swigregister
Extrema_ExtPS_swigregister(Extrema_ExtPS)

class Extrema_ExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtPC self) -> Extrema_ExtPC
        __init__(Extrema_ExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10) -> Extrema_ExtPC
        __init__(Extrema_ExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const TolF=1.0e-10) -> Extrema_ExtPC

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        Tol is used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        the algorithm stops when abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type TolF: float

        """
        this = _Extrema.new_Extrema_ExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtPC self, Adaptor3d_Curve C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10)

        initializes the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Uinf: float
        :type Usup: float
        :type TolF: float

        """
        return _Extrema.Extrema_ExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtPC self, gp_Pnt P)

        An exception is raised if the fields have not been
        initialized.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtPC self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPC_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtPC_SquareDistance(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtPC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtPC_NbExt(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_ExtPC self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the <N>th extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the <N>th extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_ExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ExtPC self, gp_Pnt P1, gp_Pnt P2)

        if the curve is a trimmed curve,
        dist1 is a square distance between <P> and the point
        of parameter FirstParameter <P1> and
        dist2 is a square distance between <P> and the point
        of parameter LastParameter <P2>.

        :type dist1: float
        :type dist2: float
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ExtPC_TrimmedSquareDistances(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtPC
Extrema_ExtPC_swigregister = _Extrema.Extrema_ExtPC_swigregister
Extrema_ExtPC_swigregister(Extrema_ExtPC)

class Extrema_ELPCOfLocateExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ELPCOfLocateExtPC self) -> Extrema_ELPCOfLocateExtPC
        __init__(Extrema_ELPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10) -> Extrema_ELPCOfLocateExtPC
        __init__(Extrema_ELPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C, Standard_Real const TolF=1.0e-10) -> Extrema_ELPCOfLocateExtPC

        It calculates all the distances.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs all the
        zeros inside the definition range of the curve.
        Tol is used to decide to stop the
        iterations according to the following condition:
        if n is the number of iterations,
        the algorithm stops when abs(F(Un)-F(Un-1)) < Tol.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type TolF: float

        """
        this = _Extrema.new_Extrema_ELPCOfLocateExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ELPCOfLocateExtPC self, Adaptor3d_Curve C, Standard_Real const Uinf, Standard_Real const Usup, Standard_Real const TolF=1.0e-10)

        initializes the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Uinf: float
        :type Usup: float
        :type TolF: float

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ELPCOfLocateExtPC self, gp_Pnt P)

        An exception is raised if the fields have not been
        initialized.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ELPCOfLocateExtPC self) -> Standard_Boolean

        True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ELPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_SquareDistance(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ELPCOfLocateExtPC self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_NbExt(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_ELPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the <N>th extremum distance is a
        minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the <N>th extremum distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_ELPCOfLocateExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(Extrema_ELPCOfLocateExtPC self, gp_Pnt P1, gp_Pnt P2)

        if the curve is a trimmed curve,
        dist1 is a square distance between <P> and the point
        of parameter FirstParameter <P1> and
        dist2 is a square distance between <P> and the point
        of parameter LastParameter <P2>.

        :type dist1: float
        :type dist2: float
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_ELPCOfLocateExtPC_TrimmedSquareDistances(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ELPCOfLocateExtPC
Extrema_ELPCOfLocateExtPC_swigregister = _Extrema.Extrema_ELPCOfLocateExtPC_swigregister
Extrema_ELPCOfLocateExtPC_swigregister(Extrema_ELPCOfLocateExtPC)

class Extrema_GenExtSS(object):
    """
    It calculates all the extremum distances
    between two surfaces.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GenExtSS self) -> Extrema_GenExtSS
        __init__(Extrema_GenExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Tol1, Standard_Real const Tol2) -> Extrema_GenExtSS
        __init__(Extrema_GenExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const U1min, Standard_Real const U1sup, Standard_Real const V1min, Standard_Real const V1sup, Standard_Real const U2min, Standard_Real const U2sup, Standard_Real const V2min, Standard_Real const V2sup, Standard_Real const Tol1, Standard_Real const Tol2) -> Extrema_GenExtSS

        It calculates all the distances.
        The function F(u,v)=distance(P,S(u,v)) has an
        extremum when gradient(F)=0. The algorithm searchs
        all the zeros inside the definition ranges of the
        surface.
        NbU and NbV are used to locate the close points
        to find the zeros.

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type NbU: int
        :type NbV: int
        :type U1min: float
        :type U1sup: float
        :type V1min: float
        :type V1sup: float
        :type U2min: float
        :type U2sup: float
        :type V2min: float
        :type V2sup: float
        :type Tol1: float
        :type Tol2: float

        """
        this = _Extrema.new_Extrema_GenExtSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_GenExtSS self, Adaptor3d_Surface S2, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Tol2)
        Initialize(Extrema_GenExtSS self, Adaptor3d_Surface S2, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const U2min, Standard_Real const U2sup, Standard_Real const V2min, Standard_Real const V2sup, Standard_Real const Tol2)

        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type NbU: int
        :type NbV: int
        :type U2min: float
        :type U2sup: float
        :type V2min: float
        :type V2sup: float
        :type Tol2: float

        """
        return _Extrema.Extrema_GenExtSS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_GenExtSS self, Adaptor3d_Surface S1, Standard_Real const Tol1)
        Perform(Extrema_GenExtSS self, Adaptor3d_Surface S1, Standard_Real const U1min, Standard_Real const U1sup, Standard_Real const V1min, Standard_Real const V1sup, Standard_Real const Tol1)

        the algorithm is done withS1
        An exception is raised if the fields have not
        been initialized.

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type U1min: float
        :type U1sup: float
        :type V1min: float
        :type V1sup: float
        :type Tol1: float

        """
        return _Extrema.Extrema_GenExtSS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_GenExtSS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GenExtSS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_GenExtSS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GenExtSS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_GenExtSS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_GenExtSS_SquareDistance(self, *args)


    def PointOnS1(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenExtSS_PointOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnS2(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenExtSS_PointOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_GenExtSS
Extrema_GenExtSS_swigregister = _Extrema.Extrema_GenExtSS_swigregister
Extrema_GenExtSS_swigregister(Extrema_GenExtSS)

class Extrema_GenExtCS(object):
    """
    It calculates all the extremum distances
    between acurve and a surface.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GenExtCS self) -> Extrema_GenExtCS
        __init__(Extrema_GenExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S, Standard_Integer const NbT, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Tol1, Standard_Real const Tol2) -> Extrema_GenExtCS
        __init__(Extrema_GenExtCS self, Adaptor3d_Curve C, Adaptor3d_Surface S, Standard_Integer const NbT, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const tmin, Standard_Real const tsup, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const Tol1, Standard_Real const Tol2) -> Extrema_GenExtCS

        It calculates all the distances.
        The function F(u,v)=distance(P,S(u,v)) has an
        extremum when gradient(F)=0. The algorithm searchs
        all the zeros inside the definition ranges of the
        surface.
        NbT,NbU and NbV are used to locate the close points
        to find the zeros.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type NbT: int
        :type NbU: int
        :type NbV: int
        :type tmin: float
        :type tsup: float
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type Tol1: float
        :type Tol2: float

        """
        this = _Extrema.new_Extrema_GenExtCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_GenExtCS self, Adaptor3d_Surface S, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Tol2)
        Initialize(Extrema_GenExtCS self, Adaptor3d_Surface S, Standard_Integer const NbU, Standard_Integer const NbV, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const Tol2)

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type NbU: int
        :type NbV: int
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type Tol2: float

        """
        return _Extrema.Extrema_GenExtCS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_GenExtCS self, Adaptor3d_Curve C, Standard_Integer const NbT, Standard_Real const Tol1)
        Perform(Extrema_GenExtCS self, Adaptor3d_Curve C, Standard_Integer const NbT, Standard_Real const tmin, Standard_Real const tsup, Standard_Real const Tol1)

        the algorithm is done with C
        An exception is raised if the fields have not
        been initialized.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type NbT: int
        :type tmin: float
        :type tsup: float
        :type Tol1: float

        """
        return _Extrema.Extrema_GenExtCS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_GenExtCS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GenExtCS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_GenExtCS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GenExtCS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_GenExtCS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_GenExtCS_SquareDistance(self, *args)


    def PointOnCurve(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_GenExtCS_PointOnCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnSurface(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenExtCS_PointOnSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_GenExtCS
Extrema_GenExtCS_swigregister = _Extrema.Extrema_GenExtCS_swigregister
Extrema_GenExtCS_swigregister(Extrema_GenExtCS)

class Extrema_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Adaptor3d_Curve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Adaptor3d_Curve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Adaptor3d_Curve C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Extrema.Extrema_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Adaptor3d_Curve C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Adaptor3d_Curve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Extrema.Extrema_CurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def DeflCurvIntervals(*args):
        """
        DeflCurvIntervals(Adaptor3d_Curve C) -> Handle_TColStd_HArray1OfReal

        Returns the parameters bounding the intervals of subdivision of curve
        according to Curvature deflection. Value of deflection is defined in method.


        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Extrema.Extrema_CurveTool_DeflCurvIntervals(*args)

    DeflCurvIntervals = staticmethod(DeflCurvIntervals)

    def IsPeriodic(*args):
        """
        IsPeriodic(Adaptor3d_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Adaptor3d_Curve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CurveTool_Period(*args)

    Period = staticmethod(Period)

    def Resolution(*args):
        """
        Resolution(Adaptor3d_Curve C, Standard_Real const R3d) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Adaptor3d_Curve C) -> GeomAbs_CurveType

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Extrema.Extrema_CurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Value(*args):
        """
        Value(Adaptor3d_Curve C, Standard_Real const U) -> gp_Pnt

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_CurveTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P)

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_CurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _Extrema.Extrema_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Extrema.Extrema_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Extrema.Extrema_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Adaptor3d_Curve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Extrema.Extrema_CurveTool_DN(*args)

    DN = staticmethod(DN)

    def Line(*args):
        """
        Line(Adaptor3d_Curve C) -> gp_Lin

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _Extrema.Extrema_CurveTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Adaptor3d_Curve C) -> gp_Circ

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _Extrema.Extrema_CurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Adaptor3d_Curve C) -> gp_Elips

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _Extrema.Extrema_CurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Adaptor3d_Curve C) -> gp_Hypr

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Extrema.Extrema_CurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Adaptor3d_Curve C) -> gp_Parab

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _Extrema.Extrema_CurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Degree(*args):
        """
        Degree(Adaptor3d_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CurveTool_Degree(*args)

    Degree = staticmethod(Degree)

    def IsRational(*args):
        """
        IsRational(Adaptor3d_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CurveTool_IsRational(*args)

    IsRational = staticmethod(IsRational)

    def NbPoles(*args):
        """
        NbPoles(Adaptor3d_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CurveTool_NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def NbKnots(*args):
        """
        NbKnots(Adaptor3d_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CurveTool_NbKnots(*args)

    NbKnots = staticmethod(NbKnots)

    def Bezier(*args):
        """
        Bezier(Adaptor3d_Curve C) -> Handle_Geom_BezierCurve

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _Extrema.Extrema_CurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Adaptor3d_Curve C) -> Handle_Geom_BSplineCurve

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _Extrema.Extrema_CurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def __init__(self):
        this = _Extrema.new_Extrema_CurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_Extrema_CurveTool
Extrema_CurveTool_swigregister = _Extrema.Extrema_CurveTool_swigregister
Extrema_CurveTool_swigregister(Extrema_CurveTool)

def Extrema_CurveTool_FirstParameter(*args):
    """
    Extrema_CurveTool_FirstParameter(Adaptor3d_Curve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_CurveTool_FirstParameter(*args)

def Extrema_CurveTool_LastParameter(*args):
    """
    Extrema_CurveTool_LastParameter(Adaptor3d_Curve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_CurveTool_LastParameter(*args)

def Extrema_CurveTool_Continuity(*args):
    """
    Extrema_CurveTool_Continuity(Adaptor3d_Curve C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _Extrema.Extrema_CurveTool_Continuity(*args)

def Extrema_CurveTool_NbIntervals(*args):
    """
    Extrema_CurveTool_NbIntervals(Adaptor3d_Curve C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(me) >= <S>

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_CurveTool_NbIntervals(*args)

def Extrema_CurveTool_Intervals(*args):
    """
    Extrema_CurveTool_Intervals(Adaptor3d_Curve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _Extrema.Extrema_CurveTool_Intervals(*args)

def Extrema_CurveTool_DeflCurvIntervals(*args):
    """
    Extrema_CurveTool_DeflCurvIntervals(Adaptor3d_Curve C) -> Handle_TColStd_HArray1OfReal

    Returns the parameters bounding the intervals of subdivision of curve
    according to Curvature deflection. Value of deflection is defined in method.


    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _Extrema.Extrema_CurveTool_DeflCurvIntervals(*args)

def Extrema_CurveTool_IsPeriodic(*args):
    """
    Extrema_CurveTool_IsPeriodic(Adaptor3d_Curve C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Extrema.Extrema_CurveTool_IsPeriodic(*args)

def Extrema_CurveTool_Period(*args):
    """
    Extrema_CurveTool_Period(Adaptor3d_Curve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_CurveTool_Period(*args)

def Extrema_CurveTool_Resolution(*args):
    """
    Extrema_CurveTool_Resolution(Adaptor3d_Curve C, Standard_Real const R3d) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Extrema.Extrema_CurveTool_Resolution(*args)

def Extrema_CurveTool_GetType(*args):
    """
    Extrema_CurveTool_GetType(Adaptor3d_Curve C) -> GeomAbs_CurveType

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _Extrema.Extrema_CurveTool_GetType(*args)

def Extrema_CurveTool_Value(*args):
    """
    Extrema_CurveTool_Value(Adaptor3d_Curve C, Standard_Real const U) -> gp_Pnt

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _Extrema.Extrema_CurveTool_Value(*args)

def Extrema_CurveTool_D0(*args):
    """
    Extrema_CurveTool_D0(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P)

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _Extrema.Extrema_CurveTool_D0(*args)

def Extrema_CurveTool_D1(*args):
    """
    Extrema_CurveTool_D1(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V: OCC.wrapper.gp.gp_Vec

    """
    return _Extrema.Extrema_CurveTool_D1(*args)

def Extrema_CurveTool_D2(*args):
    """
    Extrema_CurveTool_D2(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec

    """
    return _Extrema.Extrema_CurveTool_D2(*args)

def Extrema_CurveTool_D3(*args):
    """
    Extrema_CurveTool_D3(Adaptor3d_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec
    :type V3: OCC.wrapper.gp.gp_Vec

    """
    return _Extrema.Extrema_CurveTool_D3(*args)

def Extrema_CurveTool_DN(*args):
    """
    Extrema_CurveTool_DN(Adaptor3d_Curve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _Extrema.Extrema_CurveTool_DN(*args)

def Extrema_CurveTool_Line(*args):
    """
    Extrema_CurveTool_Line(Adaptor3d_Curve C) -> gp_Lin

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _Extrema.Extrema_CurveTool_Line(*args)

def Extrema_CurveTool_Circle(*args):
    """
    Extrema_CurveTool_Circle(Adaptor3d_Curve C) -> gp_Circ

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _Extrema.Extrema_CurveTool_Circle(*args)

def Extrema_CurveTool_Ellipse(*args):
    """
    Extrema_CurveTool_Ellipse(Adaptor3d_Curve C) -> gp_Elips

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.gp.gp_Elips

    """
    return _Extrema.Extrema_CurveTool_Ellipse(*args)

def Extrema_CurveTool_Hyperbola(*args):
    """
    Extrema_CurveTool_Hyperbola(Adaptor3d_Curve C) -> gp_Hypr

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.gp.gp_Hypr

    """
    return _Extrema.Extrema_CurveTool_Hyperbola(*args)

def Extrema_CurveTool_Parabola(*args):
    """
    Extrema_CurveTool_Parabola(Adaptor3d_Curve C) -> gp_Parab

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.gp.gp_Parab

    """
    return _Extrema.Extrema_CurveTool_Parabola(*args)

def Extrema_CurveTool_Degree(*args):
    """
    Extrema_CurveTool_Degree(Adaptor3d_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_CurveTool_Degree(*args)

def Extrema_CurveTool_IsRational(*args):
    """
    Extrema_CurveTool_IsRational(Adaptor3d_Curve C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Extrema.Extrema_CurveTool_IsRational(*args)

def Extrema_CurveTool_NbPoles(*args):
    """
    Extrema_CurveTool_NbPoles(Adaptor3d_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_CurveTool_NbPoles(*args)

def Extrema_CurveTool_NbKnots(*args):
    """
    Extrema_CurveTool_NbKnots(Adaptor3d_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Extrema.Extrema_CurveTool_NbKnots(*args)

def Extrema_CurveTool_Bezier(*args):
    """
    Extrema_CurveTool_Bezier(Adaptor3d_Curve C) -> Handle_Geom_BezierCurve

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

    """
    return _Extrema.Extrema_CurveTool_Bezier(*args)

def Extrema_CurveTool_BSpline(*args):
    """
    Extrema_CurveTool_BSpline(Adaptor3d_Curve C) -> Handle_Geom_BSplineCurve

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _Extrema.Extrema_CurveTool_BSpline(*args)

class Extrema_LocateExtCC2d(object):
    """
    It calculates the distance between two curves with
    a close point; these distances can be maximum or
    minimum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocateExtCC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const U0, Standard_Real const V0) -> Extrema_LocateExtCC2d

        Calculates the distance with a close point. The
        close point is defined by a parameter value on each
        curve.
        The function F(u,v)=distance(C1(u),C2(v)) has an
        extremun when gradient(f)=0. The algorithm searchs
        the zero near the close point.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U0: float
        :type V0: float

        """
        this = _Extrema.new_Extrema_LocateExtCC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Extrema_LocateExtCC2d self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocateExtCC2d_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocateExtCC2d self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocateExtCC2d_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Point(Extrema_LocateExtCC2d self, Extrema_POnCurv2d P1, Extrema_POnCurv2d P2)

        Returns the points of the extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv2d
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Extrema.Extrema_LocateExtCC2d_Point(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_LocateExtCC2d
Extrema_LocateExtCC2d_swigregister = _Extrema.Extrema_LocateExtCC2d_swigregister
Extrema_LocateExtCC2d_swigregister(Extrema_LocateExtCC2d)

class NCollection_Sequence_Extrema_POnCurv(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Extrema_POnCurv self) -> NCollection_Sequence< Extrema_POnCurv >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Extrema_POnCurv self) -> NCollection_Sequence< Extrema_POnCurv >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Extrema_POnCurv self) -> NCollection_Sequence< Extrema_POnCurv >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Extrema_POnCurv self) -> NCollection_Sequence< Extrema_POnCurv >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Extrema.new_NCollection_Sequence_Extrema_POnCurv(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Extrema_POnCurv self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Extrema_POnCurv self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Extrema_POnCurv self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Extrema_POnCurv self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Extrema_POnCurv self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Extrema_POnCurv self)

        Reverse sequence


        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Extrema_POnCurv self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Extrema_POnCurv self, NCollection_Sequence_Extrema_POnCurv theOther) -> NCollection_Sequence_Extrema_POnCurv

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Extrema_POnCurv self, NCollection_Sequence_Extrema_POnCurv theOther) -> NCollection_Sequence_Extrema_POnCurv

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Extrema_POnCurv self, NCollection_Sequence< Extrema_POnCurv >::Iterator & thePosition)
        Remove(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Extrema_POnCurv self, Extrema_POnCurv theItem)
        Append(NCollection_Sequence_Extrema_POnCurv self, NCollection_Sequence_Extrema_POnCurv theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Extrema_POnCurv self, Extrema_POnCurv theItem)
        Prepend(NCollection_Sequence_Extrema_POnCurv self, NCollection_Sequence_Extrema_POnCurv theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex, Extrema_POnCurv theItem)
        InsertBefore(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnCurv theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Extrema_POnCurv self, NCollection_Sequence< Extrema_POnCurv >::Iterator & thePosition, Extrema_POnCurv theItem)
        InsertAfter(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnCurv theSeq)
        InsertAfter(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex, Extrema_POnCurv theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnCurv theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Extrema_POnCurv self) -> Extrema_POnCurv

        First item access

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Extrema_POnCurv self) -> Extrema_POnCurv

        Last item access

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex) -> Extrema_POnCurv

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Extrema_POnCurv self, Standard_Integer const theIndex, Extrema_POnCurv theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_SetValue(self, *args)


    def __iter__(self):
        return _Extrema.NCollection_Sequence_Extrema_POnCurv___iter__(self)
    __swig_destroy__ = _Extrema.delete_NCollection_Sequence_Extrema_POnCurv
NCollection_Sequence_Extrema_POnCurv_swigregister = _Extrema.NCollection_Sequence_Extrema_POnCurv_swigregister
NCollection_Sequence_Extrema_POnCurv_swigregister(NCollection_Sequence_Extrema_POnCurv)

def NCollection_Sequence_Extrema_POnCurv_delNode(*args):
    """
    NCollection_Sequence_Extrema_POnCurv_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Extrema.NCollection_Sequence_Extrema_POnCurv_delNode(*args)

class NCollection_Sequence_Extrema_POnCurv_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Extrema.new_NCollection_Sequence_Extrema_POnCurv_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_NCollection_Sequence_Extrema_POnCurv_IteratorHelper

    def __next__(self):
        return _Extrema.NCollection_Sequence_Extrema_POnCurv_IteratorHelper___next__(self)
NCollection_Sequence_Extrema_POnCurv_IteratorHelper_swigregister = _Extrema.NCollection_Sequence_Extrema_POnCurv_IteratorHelper_swigregister
NCollection_Sequence_Extrema_POnCurv_IteratorHelper_swigregister(NCollection_Sequence_Extrema_POnCurv_IteratorHelper)


try:
	Extrema_SequenceOfPOnCurv = NCollection_Sequence_Extrema_POnCurv
except NameError:
	pass # does not exist, probably ignored

class Handle_Extrema_ExtPRevS(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_ExtPRevS self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_ExtPRevS_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_ExtPRevS self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_ExtPRevS_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_ExtPRevS self, Extrema_ExtPRevS thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_ExtPRevS_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_ExtPRevS self, Handle_Extrema_ExtPRevS theHandle) -> Handle_Extrema_ExtPRevS
        assign(Handle_Extrema_ExtPRevS self, Extrema_ExtPRevS thePtr) -> Handle_Extrema_ExtPRevS
        assign(Handle_Extrema_ExtPRevS self, Handle_Extrema_ExtPRevS theHandle) -> Handle_Extrema_ExtPRevS

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_ExtPRevS_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_ExtPRevS self) -> Extrema_ExtPRevS

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_ExtPRevS_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_ExtPRevS self) -> Extrema_ExtPRevS

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_ExtPRevS___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_ExtPRevS self) -> Extrema_ExtPRevS

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_ExtPRevS___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_ExtPRevS___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_ExtPRevS___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_ExtPRevS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_ExtPRevS_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_ExtPRevS

    def Initialize(self, *args):
        """
        Initialize(Handle_Extrema_ExtPRevS self, Handle_GeomAdaptor_HSurfaceOfRevolution S, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const TolU, Standard_Real const TolV)

        :type S: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurfaceOfRevolution
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type TolU: float
        :type TolV: float

        """
        return _Extrema.Handle_Extrema_ExtPRevS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_Extrema_ExtPRevS self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Handle_Extrema_ExtPRevS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_Extrema_ExtPRevS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_ExtPRevS_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Handle_Extrema_ExtPRevS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_ExtPRevS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Handle_Extrema_ExtPRevS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Handle_Extrema_ExtPRevS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the Nth resulting distance.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Handle_Extrema_ExtPRevS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_ExtPRevS self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_ExtPRevS_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_ExtPRevS_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_ExtPRevS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_ExtPRevS self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_ExtPRevS_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_ExtPRevS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_ExtPRevS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_ExtPRevS_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_ExtPRevS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_ExtPRevS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_ExtPRevS_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_ExtPRevS self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_ExtPRevS_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_ExtPRevS self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_ExtPRevS_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_ExtPRevS self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_ExtPRevS_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_ExtPRevS self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_ExtPRevS_DecrementRefCounter(self, *args)

Handle_Extrema_ExtPRevS_swigregister = _Extrema.Handle_Extrema_ExtPRevS_swigregister
Handle_Extrema_ExtPRevS_swigregister(Handle_Extrema_ExtPRevS)

def Handle_Extrema_ExtPRevS_DownCast(thing):
    return _Extrema.Handle_Extrema_ExtPRevS_DownCast(thing)
Handle_Extrema_ExtPRevS_DownCast = _Extrema.Handle_Extrema_ExtPRevS_DownCast

class NCollection_Handle_Extrema_UBTreeOfSphere(Standard.Handle_Standard_Transient):
    """
    Purpose: This template class is used to define Handle adaptor
    for allocated dynamically objects of arbitrary type.

    The advantage is that this handle will automatically destroy 
    the object when last referred Handle is destroyed (i.e. it is a 
    typical smart pointer), and that it can be handled as 
    Handle(Standard_Transient) in OCCT components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose: This template class is used to define Handle adaptor
        for allocated dynamically objects of arbitrary type.

        The advantage is that this handle will automatically destroy 
        the object when last referred Handle is destroyed (i.e. it is a 
        typical smart pointer), and that it can be handled as 
        Handle(Standard_Transient) in OCCT components.
        """
        this = _Extrema.new_NCollection_Handle_Extrema_UBTreeOfSphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get(self, *args):
        """
        get(NCollection_Handle_Extrema_UBTreeOfSphere self) -> NCollection_UBTree_Standard_Integer_Bnd_Sphere
        get(NCollection_Handle_Extrema_UBTreeOfSphere self) -> NCollection_UBTree_Standard_Integer_Bnd_Sphere

        Cast handle to contained type

        :rtype: const T *

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(NCollection_Handle_Extrema_UBTreeOfSphere self) -> NCollection_UBTree_Standard_Integer_Bnd_Sphere
        __deref__(NCollection_Handle_Extrema_UBTreeOfSphere self) -> NCollection_UBTree_Standard_Integer_Bnd_Sphere

        Cast handle to contained type

        :rtype: const T *

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere___deref__(self, *args)


    def __ref__(self, *args):
        """
        Cast handle to contained type

        :rtype: const T &

        """
        res = _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere___ref__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DownCast(*args):
        """
        DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_Extrema_UBTreeOfSphere

        Downcast arbitrary Handle to the argument type if contained
        object is Handle for this type; returns null otherwise

        :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_DownCast(*args)

    DownCast = staticmethod(DownCast)
    __swig_destroy__ = _Extrema.delete_NCollection_Handle_Extrema_UBTreeOfSphere

    def Add(self, *args):
        """
        Add(NCollection_Handle_Extrema_UBTreeOfSphere self, int const & theObj, Bnd_Sphere theBnd) -> Standard_Boolean

        Update the tree with a new object and its bounding box.
        @param theObj
        added object
        @param theBnd
        bounding box of the object.
        @return
        always True

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_Add(self, *args)


    def Select(self, *args):
        """
        Select(NCollection_Handle_Extrema_UBTreeOfSphere self, NCollection_UBTree< Standard_Integer,Bnd_Sphere >::Selector & theSelector) -> Standard_Integer

        Searches in the branch all objects conforming to the given selector.
        @return
        the number of objects accepted

        :type theBranch: OCC.wrapper.NCollection.TreeNode
        :type theSelector: OCC.wrapper.NCollection.Selector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_Select(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Handle_Extrema_UBTreeOfSphere self, Handle_NCollection_BaseAllocator aNewAlloc=0)

        Clears the contents of the tree.
        @param aNewAlloc
        Optional:   a new allocator that will be used when the tree is rebuilt
        anew. This makes sense if the memory allocator needs re-initialisation
        (like NCollection_IncAllocator).  By default the previous allocator is
        kept.

        :type aNewAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Handle_Extrema_UBTreeOfSphere self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_IsEmpty(self, *args)


    def Root(self, *args):
        """
        @return
        the root node of the tree

        :rtype: OCC.wrapper.NCollection.TreeNode

        """
        res = _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Allocator(self, *args):
        """
        Recommended to be used only in sub-classes.
        @return
        Allocator object used in this instance of UBTree.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


NCollection_Handle_Extrema_UBTreeOfSphere_swigregister = _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_swigregister
NCollection_Handle_Extrema_UBTreeOfSphere_swigregister(NCollection_Handle_Extrema_UBTreeOfSphere)

def NCollection_Handle_Extrema_UBTreeOfSphere_DownCast(*args):
    """
    NCollection_Handle_Extrema_UBTreeOfSphere_DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_Extrema_UBTreeOfSphere

    Downcast arbitrary Handle to the argument type if contained
    object is Handle for this type; returns null otherwise

    :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

    """
    return _Extrema.NCollection_Handle_Extrema_UBTreeOfSphere_DownCast(*args)


try:
	Extrema_HUBTreeOfSphere = NCollection_Handle_Extrema_UBTreeOfSphere
except NameError:
	pass # does not exist, probably ignored

class Extrema_ExtSS(object):
    """
    It calculates all the extremum distances
    between two surfaces.
    These distances can be minimum or maximum.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_ExtSS self) -> Extrema_ExtSS
        __init__(Extrema_ExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2, Standard_Real const TolS1, Standard_Real const TolS2) -> Extrema_ExtSS
        __init__(Extrema_ExtSS self, Adaptor3d_Surface S1, Adaptor3d_Surface S2, Standard_Real const Uinf1, Standard_Real const Usup1, Standard_Real const Vinf1, Standard_Real const Vsup1, Standard_Real const Uinf2, Standard_Real const Usup2, Standard_Real const Vinf2, Standard_Real const Vsup2, Standard_Real const TolS1, Standard_Real const TolS2) -> Extrema_ExtSS

        It calculates all the distances between S1 and S2.

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type Uinf1: float
        :type Usup1: float
        :type Vinf1: float
        :type Vsup1: float
        :type Uinf2: float
        :type Usup2: float
        :type Vinf2: float
        :type Vsup2: float
        :type TolS1: float
        :type TolS2: float

        """
        this = _Extrema.new_Extrema_ExtSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_ExtSS self, Adaptor3d_Surface S2, Standard_Real const Uinf2, Standard_Real const Usup2, Standard_Real const Vinf2, Standard_Real const Vsup2, Standard_Real const TolS1)

        Initializes the fields of the algorithm.

        :type S2: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type Uinf2: float
        :type Usup2: float
        :type Vinf2: float
        :type Vsup2: float
        :type TolS1: float

        """
        return _Extrema.Extrema_ExtSS_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Extrema_ExtSS self, Adaptor3d_Surface S1, Standard_Real const Uinf1, Standard_Real const Usup1, Standard_Real const Vinf1, Standard_Real const Vsup1, Standard_Real const TolS1)

        Computes the distances.
        An exception is raised if the fieds have not been
        initialized.

        :type S1: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type Uinf1: float
        :type Usup1: float
        :type Vinf1: float
        :type Vsup1: float
        :type TolS1: float

        """
        return _Extrema.Extrema_ExtSS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_ExtSS self) -> Standard_Boolean

        Returns True if the distances are found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtSS_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(Extrema_ExtSS self) -> Standard_Boolean

        Returns True if the curve is on a parallel surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_ExtSS_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_ExtSS self) -> Standard_Integer

        Returns the number of extremum distances.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_ExtSS_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_ExtSS self, Standard_Integer const N) -> Standard_Real

        Returns the value of the Nth resulting square distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_ExtSS_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_ExtSS self, Standard_Integer const N, Extrema_POnSurf P1, Extrema_POnSurf P2)

        Returns the point of the Nth resulting distance.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnSurf
        :type P2: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        return _Extrema.Extrema_ExtSS_Points(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_ExtSS
Extrema_ExtSS_swigregister = _Extrema.Extrema_ExtSS_swigregister
Extrema_ExtSS_swigregister(Extrema_ExtSS)

class Handle_Extrema_HArray1OfPOnSurf(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Extrema_HArray1OfPOnSurf self)

        Nullify the handle


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Extrema_HArray1OfPOnSurf self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Extrema_HArray1OfPOnSurf self, Extrema_HArray1OfPOnSurf thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Extrema_HArray1OfPOnSurf self, Handle_Extrema_HArray1OfPOnSurf theHandle) -> Handle_Extrema_HArray1OfPOnSurf
        assign(Handle_Extrema_HArray1OfPOnSurf self, Extrema_HArray1OfPOnSurf thePtr) -> Handle_Extrema_HArray1OfPOnSurf
        assign(Handle_Extrema_HArray1OfPOnSurf self, Handle_Extrema_HArray1OfPOnSurf theHandle) -> Handle_Extrema_HArray1OfPOnSurf

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Extrema_HArray1OfPOnSurf self) -> Extrema_HArray1OfPOnSurf

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Extrema_HArray1OfPOnSurf self) -> Extrema_HArray1OfPOnSurf

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Extrema_HArray1OfPOnSurf self) -> Extrema_HArray1OfPOnSurf

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf___ref__(self, *args)


    def __hash__(self):
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Extrema.Handle_Extrema_HArray1OfPOnSurf___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Extrema.new_Handle_Extrema_HArray1OfPOnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Extrema.Handle_Extrema_HArray1OfPOnSurf_DownCast)
    __swig_destroy__ = _Extrema.delete_Handle_Extrema_HArray1OfPOnSurf

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnSurf

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnSurf_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Extrema_HArray1OfPOnSurf self) -> NCollection_Array1_Extrema_POnSurf

        :rtype: OCC.wrapper.Extrema.Extrema_Array1OfPOnSurf

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Extrema_HArray1OfPOnSurf self) -> char const *

        :rtype: const char *

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnSurf_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Extrema.Handle_Extrema_HArray1OfPOnSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Extrema_HArray1OfPOnSurf self)

        Memory deallocator for transient classes


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Extrema_HArray1OfPOnSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Extrema_HArray1OfPOnSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Extrema_HArray1OfPOnSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Extrema_HArray1OfPOnSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Extrema_HArray1OfPOnSurf self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Extrema_HArray1OfPOnSurf self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Extrema_HArray1OfPOnSurf self)

        Increments the reference counter of this object


        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Extrema_HArray1OfPOnSurf self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Handle_Extrema_HArray1OfPOnSurf_DecrementRefCounter(self, *args)

Handle_Extrema_HArray1OfPOnSurf_swigregister = _Extrema.Handle_Extrema_HArray1OfPOnSurf_swigregister
Handle_Extrema_HArray1OfPOnSurf_swigregister(Handle_Extrema_HArray1OfPOnSurf)

def Handle_Extrema_HArray1OfPOnSurf_DownCast(thing):
    return _Extrema.Handle_Extrema_HArray1OfPOnSurf_DownCast(thing)
Handle_Extrema_HArray1OfPOnSurf_DownCast = _Extrema.Handle_Extrema_HArray1OfPOnSurf_DownCast

class Extrema_GlobOptFuncCCC0(math.math_MultipleVarFunction):
    """
    This class implements function which calculate Eucluidean distance
    between point on curve and point on other curve in case of C1 and C2 continuity is C0.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GlobOptFuncCCC0 self, Adaptor3d_Curve C1, Adaptor3d_Curve C2) -> Extrema_GlobOptFuncCCC0
        __init__(Extrema_GlobOptFuncCCC0 self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2) -> Extrema_GlobOptFuncCCC0

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Extrema.new_Extrema_GlobOptFuncCCC0(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(Extrema_GlobOptFuncCCC0 self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_GlobOptFuncCCC0_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_GlobOptFuncCCC0 self, math_Vector X) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GlobOptFuncCCC0_Value(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_GlobOptFuncCCC0
Extrema_GlobOptFuncCCC0_swigregister = _Extrema.Extrema_GlobOptFuncCCC0_swigregister
Extrema_GlobOptFuncCCC0_swigregister(Extrema_GlobOptFuncCCC0)

class Extrema_PCFOfEPCOfELPCOfLocateExtPC(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_PCFOfEPCOfELPCOfLocateExtPC self) -> Extrema_PCFOfEPCOfELPCOfLocateExtPC
        __init__(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, gp_Pnt P, Adaptor3d_Curve C) -> Extrema_PCFOfEPCOfELPCOfLocateExtPC

        :type P: OCC.wrapper.gp.gp_Pnt
        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        this = _Extrema.new_Extrema_PCFOfEPCOfELPCOfLocateExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Adaptor3d_Curve C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, gp_Pnt P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_PCFOfEPCOfELPCOfLocateExtPC self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_PCFOfEPCOfELPCOfLocateExtPC self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        res = _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_PCFOfEPCOfELPCOfLocateExtPC self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_PCFOfEPCOfELPCOfLocateExtPC self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_PCFOfEPCOfELPCOfLocateExtPC
Extrema_PCFOfEPCOfELPCOfLocateExtPC_swigregister = _Extrema.Extrema_PCFOfEPCOfELPCOfLocateExtPC_swigregister
Extrema_PCFOfEPCOfELPCOfLocateExtPC_swigregister(Extrema_PCFOfEPCOfELPCOfLocateExtPC)

class NCollection_Sequence_Extrema_POnCurv2d(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Extrema_POnCurv2d self) -> NCollection_Sequence< Extrema_POnCurv2d >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Extrema_POnCurv2d self) -> NCollection_Sequence< Extrema_POnCurv2d >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Extrema_POnCurv2d self) -> NCollection_Sequence< Extrema_POnCurv2d >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Extrema_POnCurv2d self) -> NCollection_Sequence< Extrema_POnCurv2d >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Extrema.new_NCollection_Sequence_Extrema_POnCurv2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Extrema_POnCurv2d self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Extrema_POnCurv2d self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Extrema_POnCurv2d self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Extrema_POnCurv2d self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Extrema_POnCurv2d self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Extrema_POnCurv2d self)

        Reverse sequence


        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Extrema_POnCurv2d self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Extrema_POnCurv2d self, NCollection_Sequence_Extrema_POnCurv2d theOther) -> NCollection_Sequence_Extrema_POnCurv2d

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Extrema_POnCurv2d self, NCollection_Sequence_Extrema_POnCurv2d theOther) -> NCollection_Sequence_Extrema_POnCurv2d

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Extrema_POnCurv2d self, NCollection_Sequence< Extrema_POnCurv2d >::Iterator & thePosition)
        Remove(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Extrema_POnCurv2d self, Extrema_POnCurv2d theItem)
        Append(NCollection_Sequence_Extrema_POnCurv2d self, NCollection_Sequence_Extrema_POnCurv2d theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Extrema_POnCurv2d self, Extrema_POnCurv2d theItem)
        Prepend(NCollection_Sequence_Extrema_POnCurv2d self, NCollection_Sequence_Extrema_POnCurv2d theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex, Extrema_POnCurv2d theItem)
        InsertBefore(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnCurv2d theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Extrema_POnCurv2d self, NCollection_Sequence< Extrema_POnCurv2d >::Iterator & thePosition, Extrema_POnCurv2d theItem)
        InsertAfter(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnCurv2d theSeq)
        InsertAfter(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex, Extrema_POnCurv2d theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex, NCollection_Sequence_Extrema_POnCurv2d theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv2d_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Extrema_POnCurv2d self) -> Extrema_POnCurv2d

        First item access

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Extrema_POnCurv2d self) -> Extrema_POnCurv2d

        Last item access

        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex) -> Extrema_POnCurv2d

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Extrema.NCollection_Sequence_Extrema_POnCurv2d___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Extrema_POnCurv2d self, Standard_Integer const theIndex, Extrema_POnCurv2d theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_SetValue(self, *args)


    def __iter__(self):
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d___iter__(self)
    __swig_destroy__ = _Extrema.delete_NCollection_Sequence_Extrema_POnCurv2d
NCollection_Sequence_Extrema_POnCurv2d_swigregister = _Extrema.NCollection_Sequence_Extrema_POnCurv2d_swigregister
NCollection_Sequence_Extrema_POnCurv2d_swigregister(NCollection_Sequence_Extrema_POnCurv2d)

def NCollection_Sequence_Extrema_POnCurv2d_delNode(*args):
    """
    NCollection_Sequence_Extrema_POnCurv2d_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_delNode(*args)

class NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Extrema.new_NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Extrema.delete_NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper

    def __next__(self):
        return _Extrema.NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper___next__(self)
NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper_swigregister = _Extrema.NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper_swigregister
NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper_swigregister(NCollection_Sequence_Extrema_POnCurv2d_IteratorHelper)


try:
	Extrema_SequenceOfPOnCurv2d = NCollection_Sequence_Extrema_POnCurv2d
except NameError:
	pass # does not exist, probably ignored

class Extrema_LocECC2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_LocECC2d self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const U0, Standard_Real const V0, Standard_Real const TolU, Standard_Real const TolV) -> Extrema_LocECC2d

        Calculates the distance with a close point. The
        close point is defined by a parameter value on each
        curve.
        The function F(u,v)=distance(C1(u),C2(v)) has an
        extremun when gradient(f)=0. The algorithm searchs
        the zero near the close point.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U0: float
        :type V0: float
        :type TolU: float
        :type TolV: float

        """
        this = _Extrema.new_Extrema_LocECC2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Extrema_LocECC2d self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_LocECC2d_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_LocECC2d self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_LocECC2d_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Point(Extrema_LocECC2d self, Extrema_POnCurv2d P1, Extrema_POnCurv2d P2)

        Returns the points of the extremum distance.
        P1 is on the first curve, P2 on the second one.

        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv2d
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Extrema.Extrema_LocECC2d_Point(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_LocECC2d
Extrema_LocECC2d_swigregister = _Extrema.Extrema_LocECC2d_swigregister
Extrema_LocECC2d_swigregister(Extrema_LocECC2d)

class Extrema_GenLocateExtPS(object):
    """
    With a close point, it calculates the distance
    between a point and a surface.
    Criteria type is defined in "Perform" method.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_GenLocateExtPS self, Adaptor3d_Surface theS, Standard_Real const theTolU, Standard_Real const theTolV) -> Extrema_GenLocateExtPS

        Constructor.

        :type theS: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type theTolU: float
        :type theTolV: float

        """
        this = _Extrema.new_Extrema_GenLocateExtPS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Extrema_GenLocateExtPS self, gp_Pnt theP, Standard_Real const theU0, Standard_Real const theV0, Standard_Boolean const isDistanceCriteria)

        Calculates the extrema between the point and the surface using a close point.
        The close point is defined by the parameter values theU0 and theV0.
        Type of the algorithm depends on the isDistanceCriteria flag.
        If flag value is false - normal projection criteria will be used.
        If flag value is true - distance criteria will be used.

        :type theP: OCC.wrapper.gp.gp_Pnt
        :type theU0: float
        :type theV0: float
        :type isDistanceCriteria: bool

        """
        return _Extrema.Extrema_GenLocateExtPS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Extrema_GenLocateExtPS self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_GenLocateExtPS_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_GenLocateExtPS self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_GenLocateExtPS_SquareDistance(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnSurf

        """
        res = _Extrema.Extrema_GenLocateExtPS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Extrema.delete_Extrema_GenLocateExtPS
Extrema_GenLocateExtPS_swigregister = _Extrema.Extrema_GenLocateExtPS_swigregister
Extrema_GenLocateExtPS_swigregister(Extrema_GenLocateExtPS)

class Extrema_CCLocFOfLocECC(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Extrema_CCLocFOfLocECC self, Standard_Real const thetol=1.0e-10) -> Extrema_CCLocFOfLocECC
        __init__(Extrema_CCLocFOfLocECC self, Adaptor3d_Curve C1, Adaptor3d_Curve C2, Standard_Real const thetol=1.0e-10) -> Extrema_CCLocFOfLocECC

        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type C2: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type thetol: float

        """
        this = _Extrema.new_Extrema_CCLocFOfLocECC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurve(self, *args):
        """
        SetCurve(Extrema_CCLocFOfLocECC self, Standard_Integer const theRank, Adaptor3d_Curve C1)

        :type theRank: int
        :type C1: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        return _Extrema.Extrema_CCLocFOfLocECC_SetCurve(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Extrema_CCLocFOfLocECC self, Standard_Real const theTol)

        :type theTol: float

        """
        return _Extrema.Extrema_CCLocFOfLocECC_SetTolerance(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Extrema_CCLocFOfLocECC self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Extrema_CCLocFOfLocECC self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Extrema_CCLocFOfLocECC self, math_Vector UV, math_Vector F) -> Standard_Boolean

        Calculate Fi(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CCLocFOfLocECC_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Extrema_CCLocFOfLocECC self, math_Vector UV, math_Matrix DF) -> Standard_Boolean

        Calculate Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CCLocFOfLocECC_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Extrema_CCLocFOfLocECC self, math_Vector UV, math_Vector F, math_Matrix DF) -> Standard_Boolean

        Calculate Fi(U,V) and Fi'(U,V).

        :type UV: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type DF: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Extrema.Extrema_CCLocFOfLocECC_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Extrema_CCLocFOfLocECC self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Extrema_CCLocFOfLocECC self) -> Standard_Integer

        Return the number of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Extrema.Extrema_CCLocFOfLocECC_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Extrema_CCLocFOfLocECC self, Standard_Integer const N) -> Standard_Real

        Return the value of the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CCLocFOfLocECC_SquareDistance(self, *args)


    def Points(self, *args):
        """
        Points(Extrema_CCLocFOfLocECC self, Standard_Integer const N, Extrema_POnCurv P1, Extrema_POnCurv P2)

        Return the points of the Nth extreme distance.

        :type N: int
        :type P1: OCC.wrapper.Extrema.Extrema_POnCurv
        :type P2: OCC.wrapper.Extrema.Extrema_POnCurv

        """
        return _Extrema.Extrema_CCLocFOfLocECC_Points(self, *args)


    def CurvePtr(self, *args):
        """
        CurvePtr(Extrema_CCLocFOfLocECC self, Standard_Integer const theRank) -> Standard_Address

        Returns a pointer to the curve specified in the constructor
        or in SetCurve() method.

        :type theRank: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Extrema.Extrema_CCLocFOfLocECC_CurvePtr(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Extrema_CCLocFOfLocECC self) -> Standard_Real

        Returns a tolerance specified in the constructor
        or in SetTolerance() method.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CCLocFOfLocECC_Tolerance(self, *args)


    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Extrema_CCLocFOfLocECC self, math_Vector theUfirst, math_Vector theUlast)

        Determines of boundaries of subinterval for find of root.

        :type theUfirst: OCC.wrapper.math.math_Vector
        :type theUlast: OCC.wrapper.math.math_Vector

        """
        return _Extrema.Extrema_CCLocFOfLocECC_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Extrema_CCLocFOfLocECC self, Standard_Address const C) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :type C: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Extrema.Extrema_CCLocFOfLocECC_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Extrema.delete_Extrema_CCLocFOfLocECC
Extrema_CCLocFOfLocECC_swigregister = _Extrema.Extrema_CCLocFOfLocECC_swigregister
Extrema_CCLocFOfLocECC_swigregister(Extrema_CCLocFOfLocECC)




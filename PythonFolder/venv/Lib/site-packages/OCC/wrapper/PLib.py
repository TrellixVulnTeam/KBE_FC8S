# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_PLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_PLib')
    _PLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_PLib', [dirname(__file__)])
        except ImportError:
            import _PLib
            return _PLib
        try:
            _mod = imp.load_module('_PLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _PLib = swig_import_helper()
    del swig_import_helper
else:
    import _PLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _PLib.delete_SwigPyIterator

    def value(self):
        return _PLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _PLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _PLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _PLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _PLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _PLib.SwigPyIterator_copy(self)

    def next(self):
        return _PLib.SwigPyIterator_next(self)

    def __next__(self):
        return _PLib.SwigPyIterator___next__(self)

    def previous(self):
        return _PLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _PLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _PLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _PLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _PLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _PLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _PLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _PLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _PLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _PLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_PLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _PLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _PLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _PLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _PLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _PLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _PLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _PLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_PLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _PLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _PLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _PLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _PLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _PLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _PLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _PLib.ptr_to_number(item)
ptr_to_number = _PLib.ptr_to_number

def HashCode(*args):
    return _PLib.HashCode(*args)
HashCode = _PLib.HashCode

def ptr_equal(a, b):
    return _PLib.ptr_equal(a, b)
ptr_equal = _PLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class PLib_Base(Standard.Standard_Transient):
    """To work with different polynomial's Bases"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_PLib_Base
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_PLib_Base(self) 
            return h


    def ToCoefficients(self, *args):
        """
        ToCoefficients(PLib_Base self, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real CoeffinBase, NCollection_Array1_Standard_Real Coefficients)

        Convert the polynomial P(t) in the canonical base.

        :type Dimension: int
        :type Degree: int
        :type CoeffinBase: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_Base_ToCoefficients(self, *args)


    def D0(self, *args):
        """
        D0(PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue)

        Compute the values of the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_Base_D0(self, *args)


    def D1(self, *args):
        """
        D1(PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_Base_D1(self, *args)


    def D2(self, *args):
        """
        D2(PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_Base_D2(self, *args)


    def D3(self, *args):
        """
        D3(PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2, NCollection_Array1_Standard_Real BasisD3)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD3: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_Base_D3(self, *args)


    def WorkDegree(self, *args):
        """
        WorkDegree(PLib_Base self) -> Standard_Integer

        returns WorkDegree

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib_Base_WorkDegree(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(PLib_Base self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Real const Tol)

        Compute NewDegree <= MaxDegree so that MaxError is lower
        than Tol.
        MaxError can be greater than Tol if it is not possible
        to find a NewDegree <= MaxDegree.
        In this case NewDegree = MaxDegree

        :type Dimension: int
        :type MaxDegree: int
        :type Tol: float
        :type BaseCoeff: float
        :type NewDegree: int
        :type MaxError: float

        """
        return _PLib.PLib_Base_ReduceDegree(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _PLib.PLib_Base_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _PLib.PLib_Base_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.PLib_Base_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _PLib.delete_PLib_Base
PLib_Base_swigregister = _PLib.PLib_Base_swigregister
PLib_Base_swigregister(PLib_Base)

def PLib_Base_get_type_name(*args):
    """
    PLib_Base_get_type_name() -> char const *

    :rtype: const char *

    """
    return _PLib.PLib_Base_get_type_name(*args)

def PLib_Base_get_type_descriptor(*args):
    """
    PLib_Base_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _PLib.PLib_Base_get_type_descriptor(*args)

class PLib_JacobiPolynomial(PLib_Base):
    """
    This class provides method  to work with Jacobi  Polynomials
    relativly to   an order of constraint
    q  = myWorkDegree-2*(myNivConstr+1)
    Jk(t)  for k=0,q compose  the   Jacobi Polynomial  base relativly  to  the weigth W(t)
    iorder is the integer  value for the constraints:
    iorder = 0 <=> ConstraintOrder  = GeomAbs_C0
    iorder = 1 <=>  ConstraintOrder = GeomAbs_C1
    iorder = 2 <=> ConstraintOrder = GeomAbs_C2
    P(t) = R(t) + W(t) * Q(t) Where W(t) = (1-t**2)**(2*iordre+2)
    the coefficients JacCoeff represents P(t) JacCoeff are stored as follow:

    c0(1)      c0(2) ....       c0(Dimension)
    c1(1)      c1(2) ....       c1(Dimension)

    cDegree(1) cDegree(2) ....  cDegree(Dimension)

    The coefficients
    c0(1)                  c0(2) ....            c0(Dimension)
    c2*ordre+1(1)                ...          c2*ordre+1(dimension)

    represents the  part  of the polynomial in  the
    canonical base: R(t)
    R(t) = c0 + c1   t + ...+ c2*iordre+1 t**2*iordre+1
    The following coefficients represents the part of the
    polynomial in the Jacobi base ie Q(t)
    Q(t) = c2*iordre+2  J0(t) + ...+ cDegree JDegree-2*iordre-2
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_PLib_JacobiPolynomial
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_PLib_JacobiPolynomial(self) 
            return h


    def __init__(self, *args):
        """
        __init__(PLib_JacobiPolynomial self, Standard_Integer const WorkDegree, GeomAbs_Shape const ConstraintOrder) -> PLib_JacobiPolynomial

        Initialize the polynomial class
        Degree has to be <= 30
        ConstraintOrder has to be GeomAbs_C0
        GeomAbs_C1
        GeomAbs_C2

        :type WorkDegree: int
        :type ConstraintOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _PLib.new_PLib_JacobiPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Points(self, *args):
        """
        Points(PLib_JacobiPolynomial self, Standard_Integer const NbGaussPoints, NCollection_Array1_Standard_Real TabPoints)

        returns  the  Jacobi  Points   for  Gauss  integration ie
        the positive values of the Legendre roots by increasing values
        NbGaussPoints is the number of   points choosen for the  integral
        computation.
        TabPoints (0,NbGaussPoints/2)
        TabPoints (0) is loaded only for the odd values of NbGaussPoints
        The possible values for NbGaussPoints are : 8, 10,
        15, 20, 25, 30, 35, 40, 50, 61
        NbGaussPoints must be greater than Degree

        :type NbGaussPoints: int
        :type TabPoints: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_Points(self, *args)


    def Weights(self, *args):
        """
        Weights(PLib_JacobiPolynomial self, Standard_Integer const NbGaussPoints, NCollection_Array2_Standard_Real TabWeights)

        returns the Jacobi weigths for Gauss integration only for
        the positive    values of the  Legendre roots   in the order they
        are given by the method Points
        NbGaussPoints   is the number of points choosen   for  the integral
        computation.
        TabWeights  (0,NbGaussPoints/2,0,Degree)
        TabWeights (0,.) are only loaded for the odd values of NbGaussPoints
        The possible values for NbGaussPoints are : 8 , 10 , 15 ,20 ,25 , 30,
        35 , 40 , 50 , 61 NbGaussPoints must be greater than Degree

        :type NbGaussPoints: int
        :type TabWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _PLib.PLib_JacobiPolynomial_Weights(self, *args)


    def MaxValue(self, *args):
        """
        MaxValue(PLib_JacobiPolynomial self, NCollection_Array1_Standard_Real TabMax)

        this method loads for k=0,q the maximum value of
        abs ( W(t)*Jk(t) )for t bellonging to [-1,1]
        This values are loaded is the array TabMax(0,myWorkDegree-2*(myNivConst+1))
        MaxValue ( me ; TabMaxPointer : in  out  Real );

        :type TabMax: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_MaxValue(self, *args)


    def MaxError(self, *args):
        """
        MaxError(PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        This  method computes the  maximum  error on the polynomial
        W(t) Q(t)  obtained  by   missing  the   coefficients of  JacCoeff   from
        NewDegree +1 to Degree

        :type Dimension: int
        :type JacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_JacobiPolynomial_MaxError(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Real const Tol)

        Compute NewDegree <= MaxDegree  so that MaxError is lower
        than Tol.
        MaxError can be greater than Tol  if it is not possible
        to find a NewDegree <= MaxDegree.
        In this case NewDegree = MaxDegree

        :type Dimension: int
        :type MaxDegree: int
        :type Tol: float
        :type JacCoeff: float
        :type NewDegree: int
        :type MaxError: float

        """
        return _PLib.PLib_JacobiPolynomial_ReduceDegree(self, *args)


    def AverageError(self, *args):
        """
        AverageError(PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        :type Dimension: int
        :type JacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_JacobiPolynomial_AverageError(self, *args)


    def ToCoefficients(self, *args):
        """
        ToCoefficients(PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real JacCoeff, NCollection_Array1_Standard_Real Coefficients)

        Convert the polynomial P(t) = R(t) + W(t) Q(t) in the canonical base.

        :type Dimension: int
        :type Degree: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_ToCoefficients(self, *args)


    def D0(self, *args):
        """
        D0(PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue)

        Compute the values of the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_D0(self, *args)


    def D1(self, *args):
        """
        D1(PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_D1(self, *args)


    def D2(self, *args):
        """
        D2(PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_D2(self, *args)


    def D3(self, *args):
        """
        D3(PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2, NCollection_Array1_Standard_Real BasisD3)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD3: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_JacobiPolynomial_D3(self, *args)


    def WorkDegree(self, *args):
        """
        WorkDegree(PLib_JacobiPolynomial self) -> Standard_Integer

        returns WorkDegree

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib_JacobiPolynomial_WorkDegree(self, *args)


    def NivConstr(self, *args):
        """
        NivConstr(PLib_JacobiPolynomial self) -> Standard_Integer

        returns NivConstr

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib_JacobiPolynomial_NivConstr(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _PLib.PLib_JacobiPolynomial_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _PLib.PLib_JacobiPolynomial_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.PLib_JacobiPolynomial_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _PLib.delete_PLib_JacobiPolynomial
PLib_JacobiPolynomial_swigregister = _PLib.PLib_JacobiPolynomial_swigregister
PLib_JacobiPolynomial_swigregister(PLib_JacobiPolynomial)

def PLib_JacobiPolynomial_get_type_name(*args):
    """
    PLib_JacobiPolynomial_get_type_name() -> char const *

    :rtype: const char *

    """
    return _PLib.PLib_JacobiPolynomial_get_type_name(*args)

def PLib_JacobiPolynomial_get_type_descriptor(*args):
    """
    PLib_JacobiPolynomial_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _PLib.PLib_JacobiPolynomial_get_type_descriptor(*args)

class PLib_(object):
    """
    PLib means Polynomial  functions library.  This pk
    provides  basic       computation    functions for
    polynomial functions.
    Note: weight arrays can be passed by pointer for
    some functions so that NULL pointer is valid.
    That means no weights passed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NoWeights(*args):
        """
        NoWeights() -> NCollection_Array1_Standard_Real

        Used as argument for a non rational functions

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib__NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def NoWeights2(*args):
        """
        NoWeights2() -> NCollection_Array2_Standard_Real

        Used as argument for a non rational functions

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _PLib.PLib__NoWeights2(*args)

    NoWeights2 = staticmethod(NoWeights2)

    def SetPoles(*args):
        """
        SetPoles(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real FP)
        SetPoles(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FP)
        SetPoles(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real FP)
        SetPoles(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FP)

        Copy in FP the coordinates of the poles.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib__SetPoles(*args)

    SetPoles = staticmethod(SetPoles)

    def GetPoles(*args):
        """
        GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt Poles)
        GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
        GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt2d Poles)
        GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights)

        Get from FP the coordinates of the poles.

        :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib__GetPoles(*args)

    GetPoles = staticmethod(GetPoles)

    def Bin(*args):
        """
        Bin(Standard_Integer const N, Standard_Integer const P) -> Standard_Real

        Returns the Binomial Cnp. N should be <= BSplCLib::MaxDegree().

        :type N: int
        :type P: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib__Bin(*args)

    Bin = staticmethod(Bin)

    def RationalDerivative(*args):
        """
        RationalDerivative(Standard_Integer const Degree, Standard_Integer const N, Standard_Integer const Dimension, Standard_Boolean const All)

        Computes the derivatives of a ratio at order
        <N> in dimension <Dimension>.

        <Ders> is an  array containing the  values  of the
        input   derivatives from  0 to  Min(<N>,<Degree>).
        For   orders   higher  than <Degree>    the  inputcd /s2d1/BMDL/
        derivatives   are assumed to be  0.

        Content of <Ders> :

        x(1),x(2),...,x(Dimension),w
        x'(1),x'(2),...,x'(Dimension),w'
        x''(1),x''(2),...,x''(Dimension),w''

        If  <All> is false, only the   derivative at order
        <N> is computed.  <RDers>  is an array   of length
        Dimension which will contain the result :

        x(1)/w , x(2)/w ,  ... derivated <N> times

        If <All> is  true all the  derivatives up to order
        <N> are computed.   <RDers> is an array of  length
        Dimension * (N+1) which will contains :

        x(1)/w , x(2)/w ,  ...
        x(1)/w , x(2)/w ,  ... derivated <1> times
        x(1)/w , x(2)/w ,  ... derivated <2> times
        ...
        x(1)/w , x(2)/w ,  ... derivated <N> times

        Warning: <RDers> must be dimensionned properly.

        :type Degree: int
        :type N: int
        :type Dimension: int
        :type Ders: float
        :type RDers: float
        :type All: bool

        """
        return _PLib.PLib__RationalDerivative(*args)

    RationalDerivative = staticmethod(RationalDerivative)

    def RationalDerivatives(*args):
        """
        RationalDerivatives(Standard_Integer const DerivativesRequest, Standard_Integer const Dimension)

        Computes DerivativesRequest derivatives of a ratio at
        of a BSpline function of degree <Degree>
        dimension <Dimension>.

        <PolesDerivatives> is an  array containing the  values
        of the input   derivatives from  0 to  <DerivativeRequest>
        For   orders   higher  than <Degree>    the  input
        derivatives   are assumed to be  0.

        Content of <PoleasDerivatives> :

        x(1),x(2),...,x(Dimension)
        x'(1),x'(2),...,x'(Dimension)
        x''(1),x''(2),...,x''(Dimension)

        WeightsDerivatives is an array that contains derivatives
        from 0 to  <DerivativeRequest>
        After returning from the routine the array
        RationalDerivatives contains the following
        x(1)/w , x(2)/w ,  ...
        x(1)/w , x(2)/w ,  ...   derivated once
        x(1)/w , x(2)/w ,  ...   twice
        x(1)/w , x(2)/w ,  ... derivated <DerivativeRequest> times

        The array RationalDerivatives and PolesDerivatives
        can be same since the overwrite is non destructive within
        the algorithm

        Warning: <RationalDerivates> must be dimensionned properly.

        :type DerivativesRequest: int
        :type Dimension: int
        :type PolesDerivatives: float
        :type WeightsDerivatives: float
        :type RationalDerivates: float

        """
        return _PLib.PLib__RationalDerivatives(*args)

    RationalDerivatives = staticmethod(RationalDerivatives)

    def EvalPolynomial(*args):
        """
        EvalPolynomial(Standard_Real const U, Standard_Integer const DerivativeOrder, Standard_Integer const Degree, Standard_Integer const Dimension)

        Performs Horner method with synthethic division
        for derivatives
        parameter <U>, with <Degree> and <Dimension>.
        PolynomialCoeff are stored in the following fashion
        c0(1)      c0(2) ....       c0(Dimension)
        c1(1)      c1(2) ....       c1(Dimension)

        cDegree(1) cDegree(2) ....  cDegree(Dimension)
        where the polynomial is defined as :

        2                     Degree
        c0 + c1 X + c2 X  +  ....   cDegree X

        Results stores the result in the following format

        f(1)             f(2)  ....     f(Dimension)
        (1)           (1)              (1)
        f  (1)        f   (2) ....     f   (Dimension)

        (DerivativeRequest)            (DerivativeRequest)
        f  (1)                         f   (Dimension)

        this just evaluates the point at parameter U

        Warning: <Results> and <PolynomialCoeff> must be dimensioned properly

        :type U: float
        :type DerivativeOrder: int
        :type Degree: int
        :type Dimension: int
        :type PolynomialCoeff: float
        :type Results: float

        """
        return _PLib.PLib__EvalPolynomial(*args)

    EvalPolynomial = staticmethod(EvalPolynomial)

    def NoDerivativeEvalPolynomial(*args):
        """
        NoDerivativeEvalPolynomial(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const DegreeDimension)

        Same as above with DerivativeOrder = 0;

        :type U: float
        :type Degree: int
        :type Dimension: int
        :type DegreeDimension: int
        :type PolynomialCoeff: float
        :type Results: float

        """
        return _PLib.PLib__NoDerivativeEvalPolynomial(*args)

    NoDerivativeEvalPolynomial = staticmethod(NoDerivativeEvalPolynomial)

    def EvalPoly2Var(*args):
        """
        EvalPoly2Var(Standard_Real const U, Standard_Real const V, Standard_Integer const UDerivativeOrder, Standard_Integer const VDerivativeOrder, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Integer const Dimension)

        Applies EvalPolynomial twice to evaluate the derivative
        of orders UDerivativeOrder in U, VDerivativeOrder in V
        at parameters U,V

        PolynomialCoeff are stored in the following fashion
        c00(1)  ....       c00(Dimension)
        c10(1)  ....       c10(Dimension)
        ....
        cm0(1)  ....       cm0(Dimension)
        ....
        c01(1)  ....       c01(Dimension)
        c11(1)  ....       c11(Dimension)
        ....
        cm1(1)  ....       cm1(Dimension)
        ....
        c0n(1)  ....       c0n(Dimension)
        c1n(1)  ....       c1n(Dimension)
        ....
        cmn(1)  ....       cmn(Dimension)

        where the polynomial is defined as :
        2                 m
        c00 + c10 U + c20 U  +  ....  + cm0 U
        2                   m
        + c01 V + c11 UV + c21 U V  +  ....  + cm1 U  V
        n               m n
        + .... + c0n V +  ....  + cmn U V

        with m = UDegree and n = VDegree

        Results stores the result in the following format

        f(1)             f(2)  ....     f(Dimension)

        Warning: <Results> and <PolynomialCoeff> must be dimensioned properly

        :type U: float
        :type V: float
        :type UDerivativeOrder: int
        :type VDerivativeOrder: int
        :type UDegree: int
        :type VDegree: int
        :type Dimension: int
        :type PolynomialCoeff: float
        :type Results: float

        """
        return _PLib.PLib__EvalPoly2Var(*args)

    EvalPoly2Var = staticmethod(EvalPoly2Var)

    def EvalLagrange(*args):
        """
        EvalLagrange(Standard_Real const U, Standard_Integer const DerivativeOrder, Standard_Integer const Degree, Standard_Integer const Dimension) -> Standard_Integer

        Performs the Lagrange Interpolation of
        given series of points with given parameters
        with the requested derivative order
        Results will store things in the following format
        with d = DerivativeOrder

        [0],             [Dimension-1]              : value
        [Dimension],     [Dimension  + Dimension-1] : first derivative

        [d *Dimension],  [d*Dimension + Dimension-1]: dth   derivative

        :type U: float
        :type DerivativeOrder: int
        :type Degree: int
        :type Dimension: int
        :type ValueArray: float
        :type ParameterArray: float
        :type Results: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib__EvalLagrange(*args)

    EvalLagrange = staticmethod(EvalLagrange)

    def EvalCubicHermite(*args):
        """
        EvalCubicHermite(Standard_Real const U, Standard_Integer const DerivativeOrder, Standard_Integer const Dimension) -> Standard_Integer

        Performs the Cubic Hermite Interpolation of
        given series of points with given parameters
        with the requested derivative order.
        ValueArray stores the value at the first and
        last parameter. It has the following format :
        [0],             [Dimension-1]              : value at first param
        [Dimension],     [Dimension  + Dimension-1] : value at last param
        Derivative array stores the value of the derivatives
        at the first parameter and at the last parameter
        in the following format
        [0],             [Dimension-1]              : derivative at
        first param
        [Dimension],     [Dimension  + Dimension-1] : derivative at
        last param

        ParameterArray  stores the first and last parameter
        in the following format :
        [0] : first parameter
        [1] : last  parameter

        Results will store things in the following format
        with d = DerivativeOrder

        [0],             [Dimension-1]              : value
        [Dimension],     [Dimension  + Dimension-1] : first derivative

        [d *Dimension],  [d*Dimension + Dimension-1]: dth   derivative

        :type U: float
        :type DerivativeOrder: int
        :type Dimension: int
        :type ValueArray: float
        :type DerivativeArray: float
        :type ParameterArray: float
        :type Results: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib__EvalCubicHermite(*args)

    EvalCubicHermite = staticmethod(EvalCubicHermite)

    def HermiteCoefficients(*args):
        """
        HermiteCoefficients(Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Integer const FirstOrder, Standard_Integer const LastOrder, math_Matrix MatrixCoefs) -> Standard_Boolean

        This build the coefficient of Hermite's polynomes on
        [FirstParameter, LastParameter]

        if j <= FirstOrder+1 then

        MatrixCoefs[i, j] = ith coefficient of the polynome H0,j-1

        else

        MatrixCoefs[i, j] = ith coefficient of the polynome H1,k
        with k = j - FirstOrder - 2

        return false if
        - |FirstParameter| > 100
        - |LastParameter| > 100
        - |FirstParameter| +|LastParameter| < 1/100
        -   |LastParameter - FirstParameter|
        / (|FirstParameter| +|LastParameter|)  < 1/100

        :type FirstParameter: float
        :type LastParameter: float
        :type FirstOrder: int
        :type LastOrder: int
        :type MatrixCoefs: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.PLib__HermiteCoefficients(*args)

    HermiteCoefficients = staticmethod(HermiteCoefficients)

    def Trimming(*args):
        """
        Trimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_gp_Pnt Coeffs, NCollection_Array1_Standard_Real WCoeffs)
        Trimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_gp_Pnt2d Coeffs, NCollection_Array1_Standard_Real WCoeffs)
        Trimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real Coeffs, NCollection_Array1_Standard_Real WCoeffs)
        Trimming(Standard_Real const U1, Standard_Real const U2, Standard_Integer const dim, NCollection_Array1_Standard_Real Coeffs, NCollection_Array1_Standard_Real WCoeffs)

        :type U1: float
        :type U2: float
        :type dim: int
        :type Coeffs: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type WCoeffs: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib__Trimming(*args)

    Trimming = staticmethod(Trimming)

    def CoefficientsPoles(*args):
        """
        CoefficientsPoles(NCollection_Array1_gp_Pnt Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real WPoles)
        CoefficientsPoles(NCollection_Array1_gp_Pnt2d Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real WPoles)
        CoefficientsPoles(NCollection_Array1_Standard_Real Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real WPoles)
        CoefficientsPoles(Standard_Integer const dim, NCollection_Array1_Standard_Real Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real WPoles)
        CoefficientsPoles(NCollection_Array2_gp_Pnt Coefs, NCollection_Array2_Standard_Real WCoefs, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real WPoles)

        :type Coefs: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type WCoefs: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type WPoles: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _PLib.PLib__CoefficientsPoles(*args)

    CoefficientsPoles = staticmethod(CoefficientsPoles)

    def UTrimming(*args):
        """
        UTrimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array2_gp_Pnt Coeffs, NCollection_Array2_Standard_Real WCoeffs)

        :type U1: float
        :type U2: float
        :type Coeffs: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type WCoeffs: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _PLib.PLib__UTrimming(*args)

    UTrimming = staticmethod(UTrimming)

    def VTrimming(*args):
        """
        VTrimming(Standard_Real const V1, Standard_Real const V2, NCollection_Array2_gp_Pnt Coeffs, NCollection_Array2_Standard_Real WCoeffs)

        :type V1: float
        :type V2: float
        :type Coeffs: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type WCoeffs: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _PLib.PLib__VTrimming(*args)

    VTrimming = staticmethod(VTrimming)

    def HermiteInterpolate(*args):
        """
        HermiteInterpolate(Standard_Integer const Dimension, Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Integer const FirstOrder, Standard_Integer const LastOrder, NCollection_Array2_Standard_Real FirstConstr, NCollection_Array2_Standard_Real LastConstr, NCollection_Array1_Standard_Real Coefficients) -> Standard_Boolean

        Compute the coefficients in the canonical base of the
        polynomial satisfying the given constraints
        at the given parameters
        The array FirstContr(i,j) i=1,Dimension j=0,FirstOrder
        contains the values of the constraint at parameter FirstParameter
        idem for LastConstr

        :type Dimension: int
        :type FirstParameter: float
        :type LastParameter: float
        :type FirstOrder: int
        :type LastOrder: int
        :type FirstConstr: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type LastConstr: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.PLib__HermiteInterpolate(*args)

    HermiteInterpolate = staticmethod(HermiteInterpolate)

    def JacobiParameters(*args):
        """
        JacobiParameters(GeomAbs_Shape const ConstraintOrder, Standard_Integer const MaxDegree, Standard_Integer const Code)

        Compute the number of points used for integral
        computations (NbGaussPoints) and the degree of Jacobi
        Polynomial (WorkDegree).
        ConstraintOrder has to be GeomAbs_C0, GeomAbs_C1 or GeomAbs_C2
        Code: Code d' init. des parametres de discretisation.
        = -5
        = -4
        = -3
        = -2
        = -1
        =  1 calcul rapide avec precision moyenne.
        =  2 calcul rapide avec meilleure precision.
        =  3 calcul un peu plus lent avec bonne precision.
        =  4 calcul lent avec la meilleure precision possible.

        :type ConstraintOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type Code: int
        :type NbGaussPoints: int
        :type WorkDegree: int

        """
        return _PLib.PLib__JacobiParameters(*args)

    JacobiParameters = staticmethod(JacobiParameters)

    def NivConstr(*args):
        """
        NivConstr(GeomAbs_Shape const ConstraintOrder) -> Standard_Integer

        translates from GeomAbs_Shape to Integer

        :type ConstraintOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib__NivConstr(*args)

    NivConstr = staticmethod(NivConstr)

    def ConstraintOrder(*args):
        """
        ConstraintOrder(Standard_Integer const NivConstr) -> GeomAbs_Shape

        translates from Integer to GeomAbs_Shape

        :type NivConstr: int
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _PLib.PLib__ConstraintOrder(*args)

    ConstraintOrder = staticmethod(ConstraintOrder)

    def EvalLength(*args):
        """
        EvalLength(Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Real const U1, Standard_Real const U2)
        EvalLength(Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol)

        :type Degree: int
        :type Dimension: int
        :type PolynomialCoeff: float
        :type U1: float
        :type U2: float
        :type Tol: float
        :type Length: float
        :type Error: float

        """
        return _PLib.PLib__EvalLength(*args)

    EvalLength = staticmethod(EvalLength)

    def __init__(self):
        """
        PLib means Polynomial  functions library.  This pk
        provides  basic       computation    functions for
        polynomial functions.
        Note: weight arrays can be passed by pointer for
        some functions so that NULL pointer is valid.
        That means no weights passed.
        """
        this = _PLib.new_PLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _PLib.delete_PLib_
PLib__swigregister = _PLib.PLib__swigregister
PLib__swigregister(PLib_)

def PLib__NoWeights(*args):
    """
    PLib__NoWeights() -> NCollection_Array1_Standard_Real

    Used as argument for a non rational functions

    :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _PLib.PLib__NoWeights(*args)

def PLib__NoWeights2(*args):
    """
    PLib__NoWeights2() -> NCollection_Array2_Standard_Real

    Used as argument for a non rational functions

    :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _PLib.PLib__NoWeights2(*args)

def PLib__SetPoles(*args):
    """
    SetPoles(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real FP)
    SetPoles(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FP)
    SetPoles(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real FP)
    PLib__SetPoles(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FP)

    Copy in FP the coordinates of the poles.

    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _PLib.PLib__SetPoles(*args)

def PLib__GetPoles(*args):
    """
    GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt Poles)
    GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
    GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt2d Poles)
    PLib__GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights)

    Get from FP the coordinates of the poles.

    :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _PLib.PLib__GetPoles(*args)

def PLib__Bin(*args):
    """
    PLib__Bin(Standard_Integer const N, Standard_Integer const P) -> Standard_Real

    Returns the Binomial Cnp. N should be <= BSplCLib::MaxDegree().

    :type N: int
    :type P: int
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _PLib.PLib__Bin(*args)

def PLib__RationalDerivative(*args):
    """
    PLib__RationalDerivative(Standard_Integer const Degree, Standard_Integer const N, Standard_Integer const Dimension, Standard_Boolean const All)

    Computes the derivatives of a ratio at order
    <N> in dimension <Dimension>.

    <Ders> is an  array containing the  values  of the
    input   derivatives from  0 to  Min(<N>,<Degree>).
    For   orders   higher  than <Degree>    the  inputcd /s2d1/BMDL/
    derivatives   are assumed to be  0.

    Content of <Ders> :

    x(1),x(2),...,x(Dimension),w
    x'(1),x'(2),...,x'(Dimension),w'
    x''(1),x''(2),...,x''(Dimension),w''

    If  <All> is false, only the   derivative at order
    <N> is computed.  <RDers>  is an array   of length
    Dimension which will contain the result :

    x(1)/w , x(2)/w ,  ... derivated <N> times

    If <All> is  true all the  derivatives up to order
    <N> are computed.   <RDers> is an array of  length
    Dimension * (N+1) which will contains :

    x(1)/w , x(2)/w ,  ...
    x(1)/w , x(2)/w ,  ... derivated <1> times
    x(1)/w , x(2)/w ,  ... derivated <2> times
    ...
    x(1)/w , x(2)/w ,  ... derivated <N> times

    Warning: <RDers> must be dimensionned properly.

    :type Degree: int
    :type N: int
    :type Dimension: int
    :type Ders: float
    :type RDers: float
    :type All: bool

    """
    return _PLib.PLib__RationalDerivative(*args)

def PLib__RationalDerivatives(*args):
    """
    PLib__RationalDerivatives(Standard_Integer const DerivativesRequest, Standard_Integer const Dimension)

    Computes DerivativesRequest derivatives of a ratio at
    of a BSpline function of degree <Degree>
    dimension <Dimension>.

    <PolesDerivatives> is an  array containing the  values
    of the input   derivatives from  0 to  <DerivativeRequest>
    For   orders   higher  than <Degree>    the  input
    derivatives   are assumed to be  0.

    Content of <PoleasDerivatives> :

    x(1),x(2),...,x(Dimension)
    x'(1),x'(2),...,x'(Dimension)
    x''(1),x''(2),...,x''(Dimension)

    WeightsDerivatives is an array that contains derivatives
    from 0 to  <DerivativeRequest>
    After returning from the routine the array
    RationalDerivatives contains the following
    x(1)/w , x(2)/w ,  ...
    x(1)/w , x(2)/w ,  ...   derivated once
    x(1)/w , x(2)/w ,  ...   twice
    x(1)/w , x(2)/w ,  ... derivated <DerivativeRequest> times

    The array RationalDerivatives and PolesDerivatives
    can be same since the overwrite is non destructive within
    the algorithm

    Warning: <RationalDerivates> must be dimensionned properly.

    :type DerivativesRequest: int
    :type Dimension: int
    :type PolesDerivatives: float
    :type WeightsDerivatives: float
    :type RationalDerivates: float

    """
    return _PLib.PLib__RationalDerivatives(*args)

def PLib__EvalPolynomial(*args):
    """
    PLib__EvalPolynomial(Standard_Real const U, Standard_Integer const DerivativeOrder, Standard_Integer const Degree, Standard_Integer const Dimension)

    Performs Horner method with synthethic division
    for derivatives
    parameter <U>, with <Degree> and <Dimension>.
    PolynomialCoeff are stored in the following fashion
    c0(1)      c0(2) ....       c0(Dimension)
    c1(1)      c1(2) ....       c1(Dimension)

    cDegree(1) cDegree(2) ....  cDegree(Dimension)
    where the polynomial is defined as :

    2                     Degree
    c0 + c1 X + c2 X  +  ....   cDegree X

    Results stores the result in the following format

    f(1)             f(2)  ....     f(Dimension)
    (1)           (1)              (1)
    f  (1)        f   (2) ....     f   (Dimension)

    (DerivativeRequest)            (DerivativeRequest)
    f  (1)                         f   (Dimension)

    this just evaluates the point at parameter U

    Warning: <Results> and <PolynomialCoeff> must be dimensioned properly

    :type U: float
    :type DerivativeOrder: int
    :type Degree: int
    :type Dimension: int
    :type PolynomialCoeff: float
    :type Results: float

    """
    return _PLib.PLib__EvalPolynomial(*args)

def PLib__NoDerivativeEvalPolynomial(*args):
    """
    PLib__NoDerivativeEvalPolynomial(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const DegreeDimension)

    Same as above with DerivativeOrder = 0;

    :type U: float
    :type Degree: int
    :type Dimension: int
    :type DegreeDimension: int
    :type PolynomialCoeff: float
    :type Results: float

    """
    return _PLib.PLib__NoDerivativeEvalPolynomial(*args)

def PLib__EvalPoly2Var(*args):
    """
    PLib__EvalPoly2Var(Standard_Real const U, Standard_Real const V, Standard_Integer const UDerivativeOrder, Standard_Integer const VDerivativeOrder, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Integer const Dimension)

    Applies EvalPolynomial twice to evaluate the derivative
    of orders UDerivativeOrder in U, VDerivativeOrder in V
    at parameters U,V

    PolynomialCoeff are stored in the following fashion
    c00(1)  ....       c00(Dimension)
    c10(1)  ....       c10(Dimension)
    ....
    cm0(1)  ....       cm0(Dimension)
    ....
    c01(1)  ....       c01(Dimension)
    c11(1)  ....       c11(Dimension)
    ....
    cm1(1)  ....       cm1(Dimension)
    ....
    c0n(1)  ....       c0n(Dimension)
    c1n(1)  ....       c1n(Dimension)
    ....
    cmn(1)  ....       cmn(Dimension)

    where the polynomial is defined as :
    2                 m
    c00 + c10 U + c20 U  +  ....  + cm0 U
    2                   m
    + c01 V + c11 UV + c21 U V  +  ....  + cm1 U  V
    n               m n
    + .... + c0n V +  ....  + cmn U V

    with m = UDegree and n = VDegree

    Results stores the result in the following format

    f(1)             f(2)  ....     f(Dimension)

    Warning: <Results> and <PolynomialCoeff> must be dimensioned properly

    :type U: float
    :type V: float
    :type UDerivativeOrder: int
    :type VDerivativeOrder: int
    :type UDegree: int
    :type VDegree: int
    :type Dimension: int
    :type PolynomialCoeff: float
    :type Results: float

    """
    return _PLib.PLib__EvalPoly2Var(*args)

def PLib__EvalLagrange(*args):
    """
    PLib__EvalLagrange(Standard_Real const U, Standard_Integer const DerivativeOrder, Standard_Integer const Degree, Standard_Integer const Dimension) -> Standard_Integer

    Performs the Lagrange Interpolation of
    given series of points with given parameters
    with the requested derivative order
    Results will store things in the following format
    with d = DerivativeOrder

    [0],             [Dimension-1]              : value
    [Dimension],     [Dimension  + Dimension-1] : first derivative

    [d *Dimension],  [d*Dimension + Dimension-1]: dth   derivative

    :type U: float
    :type DerivativeOrder: int
    :type Degree: int
    :type Dimension: int
    :type ValueArray: float
    :type ParameterArray: float
    :type Results: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _PLib.PLib__EvalLagrange(*args)

def PLib__EvalCubicHermite(*args):
    """
    PLib__EvalCubicHermite(Standard_Real const U, Standard_Integer const DerivativeOrder, Standard_Integer const Dimension) -> Standard_Integer

    Performs the Cubic Hermite Interpolation of
    given series of points with given parameters
    with the requested derivative order.
    ValueArray stores the value at the first and
    last parameter. It has the following format :
    [0],             [Dimension-1]              : value at first param
    [Dimension],     [Dimension  + Dimension-1] : value at last param
    Derivative array stores the value of the derivatives
    at the first parameter and at the last parameter
    in the following format
    [0],             [Dimension-1]              : derivative at
    first param
    [Dimension],     [Dimension  + Dimension-1] : derivative at
    last param

    ParameterArray  stores the first and last parameter
    in the following format :
    [0] : first parameter
    [1] : last  parameter

    Results will store things in the following format
    with d = DerivativeOrder

    [0],             [Dimension-1]              : value
    [Dimension],     [Dimension  + Dimension-1] : first derivative

    [d *Dimension],  [d*Dimension + Dimension-1]: dth   derivative

    :type U: float
    :type DerivativeOrder: int
    :type Dimension: int
    :type ValueArray: float
    :type DerivativeArray: float
    :type ParameterArray: float
    :type Results: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _PLib.PLib__EvalCubicHermite(*args)

def PLib__HermiteCoefficients(*args):
    """
    PLib__HermiteCoefficients(Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Integer const FirstOrder, Standard_Integer const LastOrder, math_Matrix MatrixCoefs) -> Standard_Boolean

    This build the coefficient of Hermite's polynomes on
    [FirstParameter, LastParameter]

    if j <= FirstOrder+1 then

    MatrixCoefs[i, j] = ith coefficient of the polynome H0,j-1

    else

    MatrixCoefs[i, j] = ith coefficient of the polynome H1,k
    with k = j - FirstOrder - 2

    return false if
    - |FirstParameter| > 100
    - |LastParameter| > 100
    - |FirstParameter| +|LastParameter| < 1/100
    -   |LastParameter - FirstParameter|
    / (|FirstParameter| +|LastParameter|)  < 1/100

    :type FirstParameter: float
    :type LastParameter: float
    :type FirstOrder: int
    :type LastOrder: int
    :type MatrixCoefs: OCC.wrapper.math.math_Matrix
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _PLib.PLib__HermiteCoefficients(*args)

def PLib__Trimming(*args):
    """
    Trimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_gp_Pnt Coeffs, NCollection_Array1_Standard_Real WCoeffs)
    Trimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_gp_Pnt2d Coeffs, NCollection_Array1_Standard_Real WCoeffs)
    Trimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real Coeffs, NCollection_Array1_Standard_Real WCoeffs)
    PLib__Trimming(Standard_Real const U1, Standard_Real const U2, Standard_Integer const dim, NCollection_Array1_Standard_Real Coeffs, NCollection_Array1_Standard_Real WCoeffs)

    :type U1: float
    :type U2: float
    :type dim: int
    :type Coeffs: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type WCoeffs: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _PLib.PLib__Trimming(*args)

def PLib__CoefficientsPoles(*args):
    """
    CoefficientsPoles(NCollection_Array1_gp_Pnt Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real WPoles)
    CoefficientsPoles(NCollection_Array1_gp_Pnt2d Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real WPoles)
    CoefficientsPoles(NCollection_Array1_Standard_Real Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real WPoles)
    CoefficientsPoles(Standard_Integer const dim, NCollection_Array1_Standard_Real Coefs, NCollection_Array1_Standard_Real WCoefs, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real WPoles)
    PLib__CoefficientsPoles(NCollection_Array2_gp_Pnt Coefs, NCollection_Array2_Standard_Real WCoefs, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real WPoles)

    :type Coefs: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type WCoefs: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type WPoles: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _PLib.PLib__CoefficientsPoles(*args)

def PLib__UTrimming(*args):
    """
    PLib__UTrimming(Standard_Real const U1, Standard_Real const U2, NCollection_Array2_gp_Pnt Coeffs, NCollection_Array2_Standard_Real WCoeffs)

    :type U1: float
    :type U2: float
    :type Coeffs: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type WCoeffs: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _PLib.PLib__UTrimming(*args)

def PLib__VTrimming(*args):
    """
    PLib__VTrimming(Standard_Real const V1, Standard_Real const V2, NCollection_Array2_gp_Pnt Coeffs, NCollection_Array2_Standard_Real WCoeffs)

    :type V1: float
    :type V2: float
    :type Coeffs: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type WCoeffs: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _PLib.PLib__VTrimming(*args)

def PLib__HermiteInterpolate(*args):
    """
    PLib__HermiteInterpolate(Standard_Integer const Dimension, Standard_Real const FirstParameter, Standard_Real const LastParameter, Standard_Integer const FirstOrder, Standard_Integer const LastOrder, NCollection_Array2_Standard_Real FirstConstr, NCollection_Array2_Standard_Real LastConstr, NCollection_Array1_Standard_Real Coefficients) -> Standard_Boolean

    Compute the coefficients in the canonical base of the
    polynomial satisfying the given constraints
    at the given parameters
    The array FirstContr(i,j) i=1,Dimension j=0,FirstOrder
    contains the values of the constraint at parameter FirstParameter
    idem for LastConstr

    :type Dimension: int
    :type FirstParameter: float
    :type LastParameter: float
    :type FirstOrder: int
    :type LastOrder: int
    :type FirstConstr: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type LastConstr: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _PLib.PLib__HermiteInterpolate(*args)

def PLib__JacobiParameters(*args):
    """
    PLib__JacobiParameters(GeomAbs_Shape const ConstraintOrder, Standard_Integer const MaxDegree, Standard_Integer const Code)

    Compute the number of points used for integral
    computations (NbGaussPoints) and the degree of Jacobi
    Polynomial (WorkDegree).
    ConstraintOrder has to be GeomAbs_C0, GeomAbs_C1 or GeomAbs_C2
    Code: Code d' init. des parametres de discretisation.
    = -5
    = -4
    = -3
    = -2
    = -1
    =  1 calcul rapide avec precision moyenne.
    =  2 calcul rapide avec meilleure precision.
    =  3 calcul un peu plus lent avec bonne precision.
    =  4 calcul lent avec la meilleure precision possible.

    :type ConstraintOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type MaxDegree: int
    :type Code: int
    :type NbGaussPoints: int
    :type WorkDegree: int

    """
    return _PLib.PLib__JacobiParameters(*args)

def PLib__NivConstr(*args):
    """
    PLib__NivConstr(GeomAbs_Shape const ConstraintOrder) -> Standard_Integer

    translates from GeomAbs_Shape to Integer

    :type ConstraintOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _PLib.PLib__NivConstr(*args)

def PLib__ConstraintOrder(*args):
    """
    PLib__ConstraintOrder(Standard_Integer const NivConstr) -> GeomAbs_Shape

    translates from Integer to GeomAbs_Shape

    :type NivConstr: int
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _PLib.PLib__ConstraintOrder(*args)

def PLib__EvalLength(*args):
    """
    EvalLength(Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Real const U1, Standard_Real const U2)
    PLib__EvalLength(Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol)

    :type Degree: int
    :type Dimension: int
    :type PolynomialCoeff: float
    :type U1: float
    :type U2: float
    :type Tol: float
    :type Length: float
    :type Error: float

    """
    return _PLib.PLib__EvalLength(*args)

class PLib_HermitJacobi(PLib_Base):
    """
    This class provides method  to work with Jacobi Polynomials
    relativly to an order of constraint
    q = myWorkDegree-2*(myNivConstr+1)
    Jk(t) for k=0,q compose the Jacobi Polynomial base relativly to the weigth W(t)
    iorder is the integer  value for the constraints:
    iorder = 0 <=> ConstraintOrder = GeomAbs_C0
    iorder = 1 <=> ConstraintOrder = GeomAbs_C1
    iorder = 2 <=> ConstraintOrder = GeomAbs_C2
    P(t) = H(t) + W(t) * Q(t) Where W(t) = (1-t**2)**(2*iordre+2)
    the coefficients JacCoeff represents P(t) JacCoeff are stored as follow:

    c0(1)      c0(2) ....       c0(Dimension)
    c1(1)      c1(2) ....       c1(Dimension)

    cDegree(1) cDegree(2) ....  cDegree(Dimension)

    The coefficients
    c0(1)                  c0(2) ....            c0(Dimension)
    c2*ordre+1(1)                ...          c2*ordre+1(dimension)

    represents the  part  of the polynomial in  the
    Hermit's base: H(t)
    H(t) = c0H00(t) + c1H01(t) + ...c(iordre)H(0 ;iorder)+ c(iordre+1)H10(t)+...
    The following coefficients represents the part of the
    polynomial in the Jacobi base ie Q(t)
    Q(t) = c2*iordre+2  J0(t) + ...+ cDegree JDegree-2*iordre-2
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_PLib_HermitJacobi
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_PLib_HermitJacobi(self) 
            return h


    def __init__(self, *args):
        """
        __init__(PLib_HermitJacobi self, Standard_Integer const WorkDegree, GeomAbs_Shape const ConstraintOrder) -> PLib_HermitJacobi

        Initialize the polynomial class
        Degree has to be <= 30
        ConstraintOrder has to be GeomAbs_C0
        GeomAbs_C1
        GeomAbs_C2

        :type WorkDegree: int
        :type ConstraintOrder: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _PLib.new_PLib_HermitJacobi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def MaxError(self, *args):
        """
        MaxError(PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        This  method computes the  maximum  error on the polynomial
        W(t) Q(t) obtained by missing the coefficients of JacCoeff from
        NewDegree +1 to Degree

        :type Dimension: int
        :type HermJacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_HermitJacobi_MaxError(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Real const Tol)

        Compute NewDegree <= MaxDegree so that MaxError is lower
        than Tol.
        MaxError can be greater than Tol if it is not possible
        to find a NewDegree <= MaxDegree.
        In this case NewDegree = MaxDegree

        :type Dimension: int
        :type MaxDegree: int
        :type Tol: float
        :type HermJacCoeff: float
        :type NewDegree: int
        :type MaxError: float

        """
        return _PLib.PLib_HermitJacobi_ReduceDegree(self, *args)


    def AverageError(self, *args):
        """
        AverageError(PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        :type Dimension: int
        :type HermJacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_HermitJacobi_AverageError(self, *args)


    def ToCoefficients(self, *args):
        """
        ToCoefficients(PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real HermJacCoeff, NCollection_Array1_Standard_Real Coefficients)

        Convert the polynomial P(t) = H(t) + W(t) Q(t) in the canonical base.

        :type Dimension: int
        :type Degree: int
        :type HermJacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_HermitJacobi_ToCoefficients(self, *args)


    def D0(self, *args):
        """
        D0(PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue)

        Compute the values of the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_HermitJacobi_D0(self, *args)


    def D1(self, *args):
        """
        D1(PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_HermitJacobi_D1(self, *args)


    def D2(self, *args):
        """
        D2(PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_HermitJacobi_D2(self, *args)


    def D3(self, *args):
        """
        D3(PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2, NCollection_Array1_Standard_Real BasisD3)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD3: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_HermitJacobi_D3(self, *args)


    def WorkDegree(self, *args):
        """
        WorkDegree(PLib_HermitJacobi self) -> Standard_Integer

        returns WorkDegree

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib_HermitJacobi_WorkDegree(self, *args)


    def NivConstr(self, *args):
        """
        NivConstr(PLib_HermitJacobi self) -> Standard_Integer

        returns NivConstr

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.PLib_HermitJacobi_NivConstr(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _PLib.PLib_HermitJacobi_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _PLib.PLib_HermitJacobi_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.PLib_HermitJacobi_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _PLib.delete_PLib_HermitJacobi
PLib_HermitJacobi_swigregister = _PLib.PLib_HermitJacobi_swigregister
PLib_HermitJacobi_swigregister(PLib_HermitJacobi)

def PLib_HermitJacobi_get_type_name(*args):
    """
    PLib_HermitJacobi_get_type_name() -> char const *

    :rtype: const char *

    """
    return _PLib.PLib_HermitJacobi_get_type_name(*args)

def PLib_HermitJacobi_get_type_descriptor(*args):
    """
    PLib_HermitJacobi_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _PLib.PLib_HermitJacobi_get_type_descriptor(*args)

class Handle_PLib_JacobiPolynomial(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_PLib_JacobiPolynomial self)

        Nullify the handle


        """
        return _PLib.Handle_PLib_JacobiPolynomial_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_PLib_JacobiPolynomial self) -> bool

        Check for being null

        :rtype: bool

        """
        return _PLib.Handle_PLib_JacobiPolynomial_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_PLib_JacobiPolynomial self, PLib_JacobiPolynomial thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _PLib.Handle_PLib_JacobiPolynomial_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_PLib_JacobiPolynomial self, Handle_PLib_JacobiPolynomial theHandle) -> Handle_PLib_JacobiPolynomial
        assign(Handle_PLib_JacobiPolynomial self, PLib_JacobiPolynomial thePtr) -> Handle_PLib_JacobiPolynomial
        assign(Handle_PLib_JacobiPolynomial self, Handle_PLib_JacobiPolynomial theHandle) -> Handle_PLib_JacobiPolynomial

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _PLib.Handle_PLib_JacobiPolynomial_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_PLib_JacobiPolynomial self) -> PLib_JacobiPolynomial

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _PLib.Handle_PLib_JacobiPolynomial_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_PLib_JacobiPolynomial self) -> PLib_JacobiPolynomial

        Member access operator (note non-const)

        :rtype: T *

        """
        return _PLib.Handle_PLib_JacobiPolynomial___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_PLib_JacobiPolynomial self) -> PLib_JacobiPolynomial

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _PLib.Handle_PLib_JacobiPolynomial___ref__(self, *args)


    def __hash__(self):
        return _PLib.Handle_PLib_JacobiPolynomial___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _PLib.Handle_PLib_JacobiPolynomial___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _PLib.new_Handle_PLib_JacobiPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_PLib.Handle_PLib_JacobiPolynomial_DownCast)
    __swig_destroy__ = _PLib.delete_Handle_PLib_JacobiPolynomial

    def Points(self, *args):
        """
        Points(Handle_PLib_JacobiPolynomial self, Standard_Integer const NbGaussPoints, NCollection_Array1_Standard_Real TabPoints)

        returns  the  Jacobi  Points   for  Gauss  integration ie
        the positive values of the Legendre roots by increasing values
        NbGaussPoints is the number of   points choosen for the  integral
        computation.
        TabPoints (0,NbGaussPoints/2)
        TabPoints (0) is loaded only for the odd values of NbGaussPoints
        The possible values for NbGaussPoints are : 8, 10,
        15, 20, 25, 30, 35, 40, 50, 61
        NbGaussPoints must be greater than Degree

        :type NbGaussPoints: int
        :type TabPoints: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_Points(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_PLib_JacobiPolynomial self, Standard_Integer const NbGaussPoints, NCollection_Array2_Standard_Real TabWeights)

        returns the Jacobi weigths for Gauss integration only for
        the positive    values of the  Legendre roots   in the order they
        are given by the method Points
        NbGaussPoints   is the number of points choosen   for  the integral
        computation.
        TabWeights  (0,NbGaussPoints/2,0,Degree)
        TabWeights (0,.) are only loaded for the odd values of NbGaussPoints
        The possible values for NbGaussPoints are : 8 , 10 , 15 ,20 ,25 , 30,
        35 , 40 , 50 , 61 NbGaussPoints must be greater than Degree

        :type NbGaussPoints: int
        :type TabWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_Weights(self, *args)


    def MaxValue(self, *args):
        """
        MaxValue(Handle_PLib_JacobiPolynomial self, NCollection_Array1_Standard_Real TabMax)

        this method loads for k=0,q the maximum value of
        abs ( W(t)*Jk(t) )for t bellonging to [-1,1]
        This values are loaded is the array TabMax(0,myWorkDegree-2*(myNivConst+1))
        MaxValue ( me ; TabMaxPointer : in  out  Real );

        :type TabMax: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_MaxValue(self, *args)


    def MaxError(self, *args):
        """
        MaxError(Handle_PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        This  method computes the  maximum  error on the polynomial
        W(t) Q(t)  obtained  by   missing  the   coefficients of  JacCoeff   from
        NewDegree +1 to Degree

        :type Dimension: int
        :type JacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.Handle_PLib_JacobiPolynomial_MaxError(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(Handle_PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Real const Tol)

        Compute NewDegree <= MaxDegree  so that MaxError is lower
        than Tol.
        MaxError can be greater than Tol  if it is not possible
        to find a NewDegree <= MaxDegree.
        In this case NewDegree = MaxDegree

        :type Dimension: int
        :type MaxDegree: int
        :type Tol: float
        :type JacCoeff: float
        :type NewDegree: int
        :type MaxError: float

        """
        return _PLib.Handle_PLib_JacobiPolynomial_ReduceDegree(self, *args)


    def AverageError(self, *args):
        """
        AverageError(Handle_PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        :type Dimension: int
        :type JacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.Handle_PLib_JacobiPolynomial_AverageError(self, *args)


    def ToCoefficients(self, *args):
        """
        ToCoefficients(Handle_PLib_JacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real JacCoeff, NCollection_Array1_Standard_Real Coefficients)

        Convert the polynomial P(t) = R(t) + W(t) Q(t) in the canonical base.

        :type Dimension: int
        :type Degree: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_ToCoefficients(self, *args)


    def D0(self, *args):
        """
        D0(Handle_PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue)

        Compute the values of the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_PLib_JacobiPolynomial self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2, NCollection_Array1_Standard_Real BasisD3)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD3: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_JacobiPolynomial_D3(self, *args)


    def WorkDegree(self, *args):
        """
        WorkDegree(Handle_PLib_JacobiPolynomial self) -> Standard_Integer

        returns WorkDegree

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_JacobiPolynomial_WorkDegree(self, *args)


    def NivConstr(self, *args):
        """
        NivConstr(Handle_PLib_JacobiPolynomial self) -> Standard_Integer

        returns NivConstr

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_JacobiPolynomial_NivConstr(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_PLib_JacobiPolynomial self) -> char const *

        :rtype: const char *

        """
        return _PLib.Handle_PLib_JacobiPolynomial_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.Handle_PLib_JacobiPolynomial_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.Handle_PLib_JacobiPolynomial_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_PLib_JacobiPolynomial self)

        Memory deallocator for transient classes


        """
        return _PLib.Handle_PLib_JacobiPolynomial_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_PLib_JacobiPolynomial self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_PLib_JacobiPolynomial self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.Handle_PLib_JacobiPolynomial_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_PLib_JacobiPolynomial self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_PLib_JacobiPolynomial self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.Handle_PLib_JacobiPolynomial_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_PLib_JacobiPolynomial self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _PLib.Handle_PLib_JacobiPolynomial_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_PLib_JacobiPolynomial self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_JacobiPolynomial_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_PLib_JacobiPolynomial self)

        Increments the reference counter of this object


        """
        return _PLib.Handle_PLib_JacobiPolynomial_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_PLib_JacobiPolynomial self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_JacobiPolynomial_DecrementRefCounter(self, *args)

Handle_PLib_JacobiPolynomial_swigregister = _PLib.Handle_PLib_JacobiPolynomial_swigregister
Handle_PLib_JacobiPolynomial_swigregister(Handle_PLib_JacobiPolynomial)

def Handle_PLib_JacobiPolynomial_DownCast(thing):
    return _PLib.Handle_PLib_JacobiPolynomial_DownCast(thing)
Handle_PLib_JacobiPolynomial_DownCast = _PLib.Handle_PLib_JacobiPolynomial_DownCast

class Handle_PLib_HermitJacobi(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_PLib_HermitJacobi self)

        Nullify the handle


        """
        return _PLib.Handle_PLib_HermitJacobi_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_PLib_HermitJacobi self) -> bool

        Check for being null

        :rtype: bool

        """
        return _PLib.Handle_PLib_HermitJacobi_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_PLib_HermitJacobi self, PLib_HermitJacobi thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _PLib.Handle_PLib_HermitJacobi_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_PLib_HermitJacobi self, Handle_PLib_HermitJacobi theHandle) -> Handle_PLib_HermitJacobi
        assign(Handle_PLib_HermitJacobi self, PLib_HermitJacobi thePtr) -> Handle_PLib_HermitJacobi
        assign(Handle_PLib_HermitJacobi self, Handle_PLib_HermitJacobi theHandle) -> Handle_PLib_HermitJacobi

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _PLib.Handle_PLib_HermitJacobi_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_PLib_HermitJacobi self) -> PLib_HermitJacobi

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _PLib.Handle_PLib_HermitJacobi_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_PLib_HermitJacobi self) -> PLib_HermitJacobi

        Member access operator (note non-const)

        :rtype: T *

        """
        return _PLib.Handle_PLib_HermitJacobi___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_PLib_HermitJacobi self) -> PLib_HermitJacobi

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _PLib.Handle_PLib_HermitJacobi___ref__(self, *args)


    def __hash__(self):
        return _PLib.Handle_PLib_HermitJacobi___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _PLib.Handle_PLib_HermitJacobi___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _PLib.new_Handle_PLib_HermitJacobi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_PLib.Handle_PLib_HermitJacobi_DownCast)
    __swig_destroy__ = _PLib.delete_Handle_PLib_HermitJacobi

    def MaxError(self, *args):
        """
        MaxError(Handle_PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        This  method computes the  maximum  error on the polynomial
        W(t) Q(t) obtained by missing the coefficients of JacCoeff from
        NewDegree +1 to Degree

        :type Dimension: int
        :type HermJacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.Handle_PLib_HermitJacobi_MaxError(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(Handle_PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Real const Tol)

        Compute NewDegree <= MaxDegree so that MaxError is lower
        than Tol.
        MaxError can be greater than Tol if it is not possible
        to find a NewDegree <= MaxDegree.
        In this case NewDegree = MaxDegree

        :type Dimension: int
        :type MaxDegree: int
        :type Tol: float
        :type HermJacCoeff: float
        :type NewDegree: int
        :type MaxError: float

        """
        return _PLib.Handle_PLib_HermitJacobi_ReduceDegree(self, *args)


    def AverageError(self, *args):
        """
        AverageError(Handle_PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const NewDegree) -> Standard_Real

        :type Dimension: int
        :type HermJacCoeff: float
        :type NewDegree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.Handle_PLib_HermitJacobi_AverageError(self, *args)


    def ToCoefficients(self, *args):
        """
        ToCoefficients(Handle_PLib_HermitJacobi self, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real HermJacCoeff, NCollection_Array1_Standard_Real Coefficients)

        Convert the polynomial P(t) = H(t) + W(t) Q(t) in the canonical base.

        :type Dimension: int
        :type Degree: int
        :type HermJacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_HermitJacobi_ToCoefficients(self, *args)


    def D0(self, *args):
        """
        D0(Handle_PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue)

        Compute the values of the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_HermitJacobi_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_HermitJacobi_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_HermitJacobi_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_PLib_HermitJacobi self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2, NCollection_Array1_Standard_Real BasisD3)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD3: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_HermitJacobi_D3(self, *args)


    def WorkDegree(self, *args):
        """
        WorkDegree(Handle_PLib_HermitJacobi self) -> Standard_Integer

        returns WorkDegree

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_HermitJacobi_WorkDegree(self, *args)


    def NivConstr(self, *args):
        """
        NivConstr(Handle_PLib_HermitJacobi self) -> Standard_Integer

        returns NivConstr

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_HermitJacobi_NivConstr(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_PLib_HermitJacobi self) -> char const *

        :rtype: const char *

        """
        return _PLib.Handle_PLib_HermitJacobi_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.Handle_PLib_HermitJacobi_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.Handle_PLib_HermitJacobi_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_PLib_HermitJacobi self)

        Memory deallocator for transient classes


        """
        return _PLib.Handle_PLib_HermitJacobi_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_PLib_HermitJacobi self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_PLib_HermitJacobi self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.Handle_PLib_HermitJacobi_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_PLib_HermitJacobi self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_PLib_HermitJacobi self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.Handle_PLib_HermitJacobi_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_PLib_HermitJacobi self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _PLib.Handle_PLib_HermitJacobi_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_PLib_HermitJacobi self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_HermitJacobi_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_PLib_HermitJacobi self)

        Increments the reference counter of this object


        """
        return _PLib.Handle_PLib_HermitJacobi_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_PLib_HermitJacobi self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_HermitJacobi_DecrementRefCounter(self, *args)

Handle_PLib_HermitJacobi_swigregister = _PLib.Handle_PLib_HermitJacobi_swigregister
Handle_PLib_HermitJacobi_swigregister(Handle_PLib_HermitJacobi)

def Handle_PLib_HermitJacobi_DownCast(thing):
    return _PLib.Handle_PLib_HermitJacobi_DownCast(thing)
Handle_PLib_HermitJacobi_DownCast = _PLib.Handle_PLib_HermitJacobi_DownCast

class PLib_DoubleJacobiPolynomial(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(PLib_DoubleJacobiPolynomial self) -> PLib_DoubleJacobiPolynomial
        __init__(PLib_DoubleJacobiPolynomial self, Handle_PLib_JacobiPolynomial JacPolU, Handle_PLib_JacobiPolynomial JacPolV) -> PLib_DoubleJacobiPolynomial

        :type JacPolU: OCC.wrapper.PLib.Handle_PLib_JacobiPolynomial
        :type JacPolV: OCC.wrapper.PLib.Handle_PLib_JacobiPolynomial

        """
        this = _PLib.new_PLib_DoubleJacobiPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MaxErrorU(self, *args):
        """
        MaxErrorU(PLib_DoubleJacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const DegreeU, Standard_Integer const DegreeV, Standard_Integer const dJacCoeff, NCollection_Array1_Standard_Real JacCoeff) -> Standard_Real

        :type Dimension: int
        :type DegreeU: int
        :type DegreeV: int
        :type dJacCoeff: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxErrorU(self, *args)


    def MaxErrorV(self, *args):
        """
        MaxErrorV(PLib_DoubleJacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const DegreeU, Standard_Integer const DegreeV, Standard_Integer const dJacCoeff, NCollection_Array1_Standard_Real JacCoeff) -> Standard_Real

        :type Dimension: int
        :type DegreeU: int
        :type DegreeV: int
        :type dJacCoeff: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxErrorV(self, *args)


    def MaxError(self, *args):
        """
        MaxError(PLib_DoubleJacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const MinDegreeU, Standard_Integer const MaxDegreeU, Standard_Integer const MinDegreeV, Standard_Integer const MaxDegreeV, Standard_Integer const dJacCoeff, NCollection_Array1_Standard_Real JacCoeff, Standard_Real const Error) -> Standard_Real

        :type Dimension: int
        :type MinDegreeU: int
        :type MaxDegreeU: int
        :type MinDegreeV: int
        :type MaxDegreeV: int
        :type dJacCoeff: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxError(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(PLib_DoubleJacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const MinDegreeU, Standard_Integer const MaxDegreeU, Standard_Integer const MinDegreeV, Standard_Integer const MaxDegreeV, Standard_Integer const dJacCoeff, NCollection_Array1_Standard_Real JacCoeff, Standard_Real const EpmsCut)

        :type Dimension: int
        :type MinDegreeU: int
        :type MaxDegreeU: int
        :type MinDegreeV: int
        :type MaxDegreeV: int
        :type dJacCoeff: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type EpmsCut: float
        :type MaxError: float
        :type NewDegreeU: int
        :type NewDegreeV: int

        """
        return _PLib.PLib_DoubleJacobiPolynomial_ReduceDegree(self, *args)


    def AverageError(self, *args):
        """
        AverageError(PLib_DoubleJacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const DegreeU, Standard_Integer const DegreeV, Standard_Integer const dJacCoeff, NCollection_Array1_Standard_Real JacCoeff) -> Standard_Real

        :type Dimension: int
        :type DegreeU: int
        :type DegreeV: int
        :type dJacCoeff: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _PLib.PLib_DoubleJacobiPolynomial_AverageError(self, *args)


    def WDoubleJacobiToCoefficients(self, *args):
        """
        WDoubleJacobiToCoefficients(PLib_DoubleJacobiPolynomial self, Standard_Integer const Dimension, Standard_Integer const DegreeU, Standard_Integer const DegreeV, NCollection_Array1_Standard_Real JacCoeff, NCollection_Array1_Standard_Real Coefficients)

        :type Dimension: int
        :type DegreeU: int
        :type DegreeV: int
        :type JacCoeff: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.PLib_DoubleJacobiPolynomial_WDoubleJacobiToCoefficients(self, *args)


    def U(self, *args):
        """
        U(PLib_DoubleJacobiPolynomial self) -> Handle_PLib_JacobiPolynomial

        returns myJacPolU;

        :rtype: OCC.wrapper.PLib.Handle_PLib_JacobiPolynomial

        """
        return _PLib.PLib_DoubleJacobiPolynomial_U(self, *args)


    def V(self, *args):
        """
        V(PLib_DoubleJacobiPolynomial self) -> Handle_PLib_JacobiPolynomial

        returns myJacPolV;

        :rtype: OCC.wrapper.PLib.Handle_PLib_JacobiPolynomial

        """
        return _PLib.PLib_DoubleJacobiPolynomial_V(self, *args)


    def TabMaxU(self, *args):
        """
        TabMaxU(PLib_DoubleJacobiPolynomial self) -> Handle_TColStd_HArray1OfReal

        returns myTabMaxU;

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _PLib.PLib_DoubleJacobiPolynomial_TabMaxU(self, *args)


    def TabMaxV(self, *args):
        """
        TabMaxV(PLib_DoubleJacobiPolynomial self) -> Handle_TColStd_HArray1OfReal

        returns myTabMaxV;

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _PLib.PLib_DoubleJacobiPolynomial_TabMaxV(self, *args)

    __swig_destroy__ = _PLib.delete_PLib_DoubleJacobiPolynomial
PLib_DoubleJacobiPolynomial_swigregister = _PLib.PLib_DoubleJacobiPolynomial_swigregister
PLib_DoubleJacobiPolynomial_swigregister(PLib_DoubleJacobiPolynomial)

class Handle_PLib_Base(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_PLib_Base self)

        Nullify the handle


        """
        return _PLib.Handle_PLib_Base_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_PLib_Base self) -> bool

        Check for being null

        :rtype: bool

        """
        return _PLib.Handle_PLib_Base_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_PLib_Base self, PLib_Base thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _PLib.Handle_PLib_Base_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_PLib_Base self, Handle_PLib_Base theHandle) -> Handle_PLib_Base
        assign(Handle_PLib_Base self, PLib_Base thePtr) -> Handle_PLib_Base
        assign(Handle_PLib_Base self, Handle_PLib_Base theHandle) -> Handle_PLib_Base

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _PLib.Handle_PLib_Base_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_PLib_Base self) -> PLib_Base

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _PLib.Handle_PLib_Base_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_PLib_Base self) -> PLib_Base

        Member access operator (note non-const)

        :rtype: T *

        """
        return _PLib.Handle_PLib_Base___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_PLib_Base self) -> PLib_Base

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _PLib.Handle_PLib_Base___ref__(self, *args)


    def __hash__(self):
        return _PLib.Handle_PLib_Base___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _PLib.Handle_PLib_Base___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _PLib.new_Handle_PLib_Base(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_PLib.Handle_PLib_Base_DownCast)
    __swig_destroy__ = _PLib.delete_Handle_PLib_Base

    def ToCoefficients(self, *args):
        """
        ToCoefficients(Handle_PLib_Base self, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real CoeffinBase, NCollection_Array1_Standard_Real Coefficients)

        Convert the polynomial P(t) in the canonical base.

        :type Dimension: int
        :type Degree: int
        :type CoeffinBase: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Coefficients: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_Base_ToCoefficients(self, *args)


    def D0(self, *args):
        """
        D0(Handle_PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue)

        Compute the values of the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_Base_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_Base_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_Base_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_PLib_Base self, Standard_Real const U, NCollection_Array1_Standard_Real BasisValue, NCollection_Array1_Standard_Real BasisD1, NCollection_Array1_Standard_Real BasisD2, NCollection_Array1_Standard_Real BasisD3)

        Compute the values and the derivatives values of
        the basis functions in u

        :type U: float
        :type BasisValue: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BasisD3: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _PLib.Handle_PLib_Base_D3(self, *args)


    def WorkDegree(self, *args):
        """
        WorkDegree(Handle_PLib_Base self) -> Standard_Integer

        returns WorkDegree

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_Base_WorkDegree(self, *args)


    def ReduceDegree(self, *args):
        """
        ReduceDegree(Handle_PLib_Base self, Standard_Integer const Dimension, Standard_Integer const MaxDegree, Standard_Real const Tol)

        Compute NewDegree <= MaxDegree so that MaxError is lower
        than Tol.
        MaxError can be greater than Tol if it is not possible
        to find a NewDegree <= MaxDegree.
        In this case NewDegree = MaxDegree

        :type Dimension: int
        :type MaxDegree: int
        :type Tol: float
        :type BaseCoeff: float
        :type NewDegree: int
        :type MaxError: float

        """
        return _PLib.Handle_PLib_Base_ReduceDegree(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_PLib_Base self) -> char const *

        :rtype: const char *

        """
        return _PLib.Handle_PLib_Base_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.Handle_PLib_Base_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _PLib.Handle_PLib_Base_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_PLib_Base self)

        Memory deallocator for transient classes


        """
        return _PLib.Handle_PLib_Base_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_PLib_Base self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_PLib_Base self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.Handle_PLib_Base_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_PLib_Base self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_PLib_Base self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _PLib.Handle_PLib_Base_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_PLib_Base self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _PLib.Handle_PLib_Base_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_PLib_Base self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_Base_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_PLib_Base self)

        Increments the reference counter of this object


        """
        return _PLib.Handle_PLib_Base_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_PLib_Base self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _PLib.Handle_PLib_Base_DecrementRefCounter(self, *args)

Handle_PLib_Base_swigregister = _PLib.Handle_PLib_Base_swigregister
Handle_PLib_Base_swigregister(Handle_PLib_Base)

def Handle_PLib_Base_DownCast(thing):
    return _PLib.Handle_PLib_Base_DownCast(thing)
Handle_PLib_Base_DownCast = _PLib.Handle_PLib_Base_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BOPDS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BOPDS')
    _BOPDS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BOPDS', [dirname(__file__)])
        except ImportError:
            import _BOPDS
            return _BOPDS
        try:
            _mod = imp.load_module('_BOPDS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BOPDS = swig_import_helper()
    del swig_import_helper
else:
    import _BOPDS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BOPDS.delete_SwigPyIterator

    def value(self):
        return _BOPDS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BOPDS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BOPDS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BOPDS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BOPDS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BOPDS.SwigPyIterator_copy(self)

    def next(self):
        return _BOPDS.SwigPyIterator_next(self)

    def __next__(self):
        return _BOPDS.SwigPyIterator___next__(self)

    def previous(self):
        return _BOPDS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BOPDS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BOPDS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BOPDS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BOPDS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BOPDS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BOPDS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BOPDS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BOPDS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BOPDS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BOPDS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BOPDS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BOPDS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BOPDS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BOPDS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BOPDS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BOPDS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BOPDS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BOPDS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BOPDS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BOPDS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BOPDS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BOPDS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BOPDS.ptr_to_number(item)
ptr_to_number = _BOPDS.ptr_to_number

def HashCode(*args):
    return _BOPDS.HashCode(*args)
HashCode = _BOPDS.HashCode

def ptr_equal(a, b):
    return _BOPDS.ptr_equal(a, b)
ptr_equal = _BOPDS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
class BOPDS_Interf(object):
    """
    The class BOPDS_Interf is is to store the information about
    the interference between two shapes. 
    The class BOPDS_Interf is root class 

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetIndices(self, *args):
        """
        SetIndices(BOPDS_Interf self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Sets the indices of interferred shapes
        @param theIndex1
        index of the first shape
        @param theIndex2
        index of the second shape

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_Interf_SetIndices(self, *args)


    def Indices(self, *args):
        """
        Indices(BOPDS_Interf self)

        Returns the indices of interferred shapes
        @param theIndex1
        index of the first shape
        @param theIndex2
        index of the second shape

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_Interf_Indices(self, *args)


    def SetIndex1(self, *args):
        """
        SetIndex1(BOPDS_Interf self, Standard_Integer const theIndex)

        Sets the index of the first interferred shape
        @param theIndex
        index of the first shape 

        :type theIndex: int

        """
        return _BOPDS.BOPDS_Interf_SetIndex1(self, *args)


    def SetIndex2(self, *args):
        """
        SetIndex2(BOPDS_Interf self, Standard_Integer const theIndex)

        Sets the index of the second interferred shape
        @param theIndex
        index of the second shape 

        :type theIndex: int

        """
        return _BOPDS.BOPDS_Interf_SetIndex2(self, *args)


    def Index1(self, *args):
        """
        Index1(BOPDS_Interf self) -> Standard_Integer

        Returns the index of the first interferred shape
        @return
        index of the first shape 

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Interf_Index1(self, *args)


    def Index2(self, *args):
        """
        Index2(BOPDS_Interf self) -> Standard_Integer

        Returns the index of the second interferred shape
        @return
        index of the second shape 

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Interf_Index2(self, *args)


    def OppositeIndex(self, *args):
        """
        OppositeIndex(BOPDS_Interf self, Standard_Integer const theI) -> Standard_Integer

        Returns the index of that are opposite to the given index
        @param theI
        the index
        @return
        index of opposite shape 

        :type theI: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Interf_OppositeIndex(self, *args)


    def Contains(self, *args):
        """
        Contains(BOPDS_Interf self, Standard_Integer const theIndex) -> Standard_Boolean

        Returns true if the interference contains given index
        @param theIndex 
        the index
        @return
        true if the interference contains given index

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Interf_Contains(self, *args)


    def SetIndexNew(self, *args):
        """
        SetIndexNew(BOPDS_Interf self, Standard_Integer const theIndex)

        Sets the index of new shape 
        @param theIndex 
        the index

        :type theIndex: int

        """
        return _BOPDS.BOPDS_Interf_SetIndexNew(self, *args)


    def IndexNew(self, *args):
        """
        IndexNew(BOPDS_Interf self) -> Standard_Integer

        Returns the index of new shape 
        @return theIndex 
        the index of new shape 

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Interf_IndexNew(self, *args)


    def HasIndexNew(self, *args):
        """
        HasIndexNew(BOPDS_Interf self) -> Standard_Boolean
        HasIndexNew(BOPDS_Interf self) -> Standard_Boolean

        Returns true if the interference has index of new shape
        the index
        @return true if the interference has index of new shape

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Interf_HasIndexNew(self, *args)

BOPDS_Interf_swigregister = _BOPDS.BOPDS_Interf_swigregister
BOPDS_Interf_swigregister(BOPDS_Interf)

class BOPDS_InterfFZ(BOPDS_Interf):
    """
    The class BOPDS_InterfFZ is is to store the information about
    the interference of the type face/solid. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfFZ self) -> BOPDS_InterfFZ
        __init__(BOPDS_InterfFZ self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfFZ

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfFZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfFZ
BOPDS_InterfFZ_swigregister = _BOPDS.BOPDS_InterfFZ_swigregister
BOPDS_InterfFZ_swigregister(BOPDS_InterfFZ)

class BOPDS_Iterator(object):
    """
    The class BOPDS_Iterator is
    1.to compute intersections between BRep sub-shapes
    of arguments of an operation (see the class BOPDS_DS)
    in terms of theirs bounding boxes
    2.provides interface to iterare the pairs of
    intersected sub-shapes of given type
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_Iterator self) -> BOPDS_Iterator
        __init__(BOPDS_Iterator self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_Iterator

        Contructor
        theAllocator - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_Iterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDS(self, *args):
        """
        SetDS(BOPDS_Iterator self, BOPDS_DS pDS)

        Modifier
        Sets the data structure <pDS> to process

        :type pDS: OCC.wrapper.BOPDS.BOPDS_PDS

        """
        return _BOPDS.BOPDS_Iterator_SetDS(self, *args)


    def DS(self, *args):
        """
        Selector
        Returns the data structure

        :rtype: OCC.wrapper.BOPDS.BOPDS_DS

        """
        res = _BOPDS.BOPDS_Iterator_DS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Initialize(self, *args):
        """
        Initialize(BOPDS_Iterator self, TopAbs_ShapeEnum const theType1, TopAbs_ShapeEnum const theType2)

        Initializes the  iterator
        theType1 - the first type of shape
        theType2 - the second type of shape

        :type theType1: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type theType2: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BOPDS.BOPDS_Iterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(BOPDS_Iterator self) -> Standard_Boolean

        Returns  true if still there are pairs
        of intersected shapes

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Iterator_More(self, *args)


    def Next(self, *args):
        """
        Next(BOPDS_Iterator self)

        Moves iterations ahead


        """
        return _BOPDS.BOPDS_Iterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(BOPDS_Iterator self)

        Returns indices (DS) of intersected shapes
        theIndex1 - the index of the first shape
        theIndex2 - the index of the second shape

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_Iterator_Value(self, *args)


    def Prepare(self, *args):
        """
        Prepare(BOPDS_Iterator self, Handle_IntTools_Context theCtx, Standard_Boolean const theCheckOBB, Standard_Real const theFuzzyValue)

        Perform the intersection algorithm and prepare
        the results to be used

        :type theCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theCheckOBB: bool
        :type theFuzzyValue: float

        """
        return _BOPDS.BOPDS_Iterator_Prepare(self, *args)


    def ExpectedLength(self, *args):
        """
        ExpectedLength(BOPDS_Iterator self) -> Standard_Integer

        Returns the number of intersections founded

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Iterator_ExpectedLength(self, *args)


    def BlockLength(self, *args):
        """
        BlockLength(BOPDS_Iterator self) -> Standard_Integer

        Returns the block length

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Iterator_BlockLength(self, *args)


    def SetRunParallel(self, *args):
        """
        SetRunParallel(BOPDS_Iterator self, Standard_Boolean const theFlag)

        Set the flag of parallel processing
        if <theFlag> is true  the parallel processing is switched on
        if <theFlag> is false the parallel processing is switched off

        :type theFlag: bool

        """
        return _BOPDS.BOPDS_Iterator_SetRunParallel(self, *args)


    def RunParallel(self, *args):
        """
        RunParallel(BOPDS_Iterator self) -> Standard_Boolean

        Returns the flag of parallel processing

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Iterator_RunParallel(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_Iterator
BOPDS_Iterator_swigregister = _BOPDS.BOPDS_Iterator_swigregister
BOPDS_Iterator_swigregister(BOPDS_Iterator)

class BOPDS_Pair(object):
    """The class is to provide the pair of indices of interfering shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_Pair self) -> BOPDS_Pair
        __init__(BOPDS_Pair self, Standard_Integer const theIndex1, Standard_Integer const theIndex2) -> BOPDS_Pair

        :type theIndex1: int
        :type theIndex2: int

        """
        this = _BOPDS.new_BOPDS_Pair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetIndices(self, *args):
        """
        SetIndices(BOPDS_Pair self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Sets the indices

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_Pair_SetIndices(self, *args)


    def Indices(self, *args):
        """
        Indices(BOPDS_Pair self)

        Gets the indices

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_Pair_Indices(self, *args)


    def __lt__(self, *args):
        """
        __lt__(BOPDS_Pair self, BOPDS_Pair theOther) -> Standard_Boolean

        Operator less

        :type theOther: OCC.wrapper.BOPDS.BOPDS_Pair
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Pair___lt__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BOPDS_Pair self, BOPDS_Pair theOther) -> Standard_Boolean

        Returns true if the Pair is equal to <the theOther>

        :type theOther: OCC.wrapper.BOPDS.BOPDS_Pair
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Pair_IsEqual(self, *args)


    def HashCode(self, *args):
        """
        HashCode(BOPDS_Pair self, Standard_Integer const theUpper) -> Standard_Integer

        Returns hash code

        :type theUpper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Pair_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(BOPDS_Pair self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _BOPDS.BOPDS_Pair___hash__(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_Pair
BOPDS_Pair_swigregister = _BOPDS.BOPDS_Pair_swigregister
BOPDS_Pair_swigregister(BOPDS_Pair)

class BOPDS_Point(object):
    """
    The class BOPDS_Point is to store
    the information about intersection point
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_Point self) -> BOPDS_Point

        Empty contructor


        """
        this = _BOPDS.new_BOPDS_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetPnt(self, *args):
        """
        SetPnt(BOPDS_Point self, gp_Pnt thePnt)

        Modifier
        Sets 3D point <thePnt>

        :type thePnt: OCC.wrapper.gp.gp_Pnt

        """
        return _BOPDS.BOPDS_Point_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        Selector
        Returns 3D point

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BOPDS.BOPDS_Point_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt2D1(self, *args):
        """
        SetPnt2D1(BOPDS_Point self, gp_Pnt2d thePnt)

        Modifier
        Sets 2D point on the first face <thePnt>

        :type thePnt: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BOPDS.BOPDS_Point_SetPnt2D1(self, *args)


    def Pnt2D1(self, *args):
        """
        Selector
        Returns 2D point on the first face <thePnt>

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BOPDS.BOPDS_Point_Pnt2D1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt2D2(self, *args):
        """
        SetPnt2D2(BOPDS_Point self, gp_Pnt2d thePnt)

        Modifier
        Sets 2D point on the second face <thePnt>

        :type thePnt: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BOPDS.BOPDS_Point_SetPnt2D2(self, *args)


    def Pnt2D2(self, *args):
        """
        Selector
        Returns 2D point on the second face <thePnt>

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _BOPDS.BOPDS_Point_Pnt2D2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIndex(self, *args):
        """
        SetIndex(BOPDS_Point self, Standard_Integer const theIndex)

        Modifier
        Sets the index of the vertex <theIndex>

        :type theIndex: int

        """
        return _BOPDS.BOPDS_Point_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(BOPDS_Point self) -> Standard_Integer

        Selector
        Returns index of the vertex

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Point_Index(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_Point
BOPDS_Point_swigregister = _BOPDS.BOPDS_Point_swigregister
BOPDS_Point_swigregister(BOPDS_Point)

class BOPDS_Curve(object):
    """
    The class BOPDS_Curve is to store
    the information about intersection curve
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_Curve self) -> BOPDS_Curve
        __init__(BOPDS_Curve self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_Curve

        Contructor
        <theAllocator> - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurve(self, *args):
        """
        SetCurve(BOPDS_Curve self, IntTools_Curve theC)

        Modifier
        Sets the curve <theC>

        :type theC: OCC.wrapper.IntTools.IntTools_Curve

        """
        return _BOPDS.BOPDS_Curve_SetCurve(self, *args)


    def Curve(self, *args):
        """
        Selector
        Returns the curve

        :rtype: OCC.wrapper.IntTools.IntTools_Curve

        """
        res = _BOPDS.BOPDS_Curve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBox(self, *args):
        """
        SetBox(BOPDS_Curve self, Bnd_Box theBox)

        Modifier
        Sets the bounding box <theBox> of the curve

        :type theBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BOPDS.BOPDS_Curve_SetBox(self, *args)


    def Box(self, *args):
        """
        Selector
        Returns the bounding box of the curve

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _BOPDS.BOPDS_Curve_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBox(self, *args):
        """
        ChangeBox(BOPDS_Curve self) -> Bnd_Box

        Selector/Modifier
        Returns the bounding box of the curve

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BOPDS.BOPDS_Curve_ChangeBox(self, *args)


    def SetPaveBlocks(self, *args):
        """
        SetPaveBlocks(BOPDS_Curve self, NCollection_List_Handle_BOPDS_PaveBlock theLPB)

        :type theLPB: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        return _BOPDS.BOPDS_Curve_SetPaveBlocks(self, *args)


    def PaveBlocks(self, *args):
        """
        Selector
        Returns the list of pave blocks
        of the curve

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        res = _BOPDS.BOPDS_Curve_PaveBlocks(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePaveBlocks(self, *args):
        """
        ChangePaveBlocks(BOPDS_Curve self) -> NCollection_List_Handle_BOPDS_PaveBlock

        Selector/Modifier
        Returns the list of pave blocks
        of the curve

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        return _BOPDS.BOPDS_Curve_ChangePaveBlocks(self, *args)


    def InitPaveBlock1(self, *args):
        """
        InitPaveBlock1(BOPDS_Curve self)

        Creates  initial pave block
        of the curve


        """
        return _BOPDS.BOPDS_Curve_InitPaveBlock1(self, *args)


    def ChangePaveBlock1(self, *args):
        """
        ChangePaveBlock1(BOPDS_Curve self) -> Handle_BOPDS_PaveBlock

        Selector/Modifier
        Returns  initial pave block
        of the curve

        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_Curve_ChangePaveBlock1(self, *args)


    def TechnoVertices(self, *args):
        """
        Selector
        Returns list of indices of technologic vertices
        of the curve

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPDS.BOPDS_Curve_TechnoVertices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTechnoVertices(self, *args):
        """
        ChangeTechnoVertices(BOPDS_Curve self) -> NCollection_List_Standard_Integer

        Selector/Modifier
        Returns list of indices of technologic vertices
        of the curve

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_Curve_ChangeTechnoVertices(self, *args)


    def HasEdge(self, *args):
        """
        HasEdge(BOPDS_Curve self) -> Standard_Boolean

        Query
        Returns true if at least one pave block of the curve
        has edge

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Curve_HasEdge(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BOPDS_Curve self, Standard_Real const theTol)

        Sets the tolerance for the curve.

        :type theTol: float

        """
        return _BOPDS.BOPDS_Curve_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BOPDS_Curve self) -> Standard_Real

        Returns the tolerance of the curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPDS.BOPDS_Curve_Tolerance(self, *args)


    def TangentialTolerance(self, *args):
        """
        TangentialTolerance(BOPDS_Curve self) -> Standard_Real

        Returns the tangential tolerance of the curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPDS.BOPDS_Curve_TangentialTolerance(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_Curve
BOPDS_Curve_swigregister = _BOPDS.BOPDS_Curve_swigregister
BOPDS_Curve_swigregister(BOPDS_Curve)

class BOPDS_CommonBlock(Standard.Standard_Transient):
    """
    The class BOPDS_CommonBlock is to store the information
    about pave blocks that have geometrical coincidence
    (in terms of a tolerance) with:<br>
    a) other pave block(s);<br>
    b) face(s).<br>
    First pave block in the common block (real pave block)
    is always a pave block with the minimal index of the original edge.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPDS_CommonBlock
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPDS_CommonBlock(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPDS_CommonBlock self) -> BOPDS_CommonBlock
        __init__(BOPDS_CommonBlock self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_CommonBlock

        Contructor
        <theAllocator> - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_CommonBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddPaveBlock(self, *args):
        """
        AddPaveBlock(BOPDS_CommonBlock self, Handle_BOPDS_PaveBlock aPB)

        Modifier
        Adds the pave block <aPB> to the list of pave blocks
        of the common block

        :type aPB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CommonBlock_AddPaveBlock(self, *args)


    def SetPaveBlocks(self, *args):
        """
        SetPaveBlocks(BOPDS_CommonBlock self, NCollection_List_Handle_BOPDS_PaveBlock aLPB)

        Modifier
        Adds the list of pave blocks <aLPB>
        to the list of pave blocks
        of the common block

        :type aLPB: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        return _BOPDS.BOPDS_CommonBlock_SetPaveBlocks(self, *args)


    def AddFace(self, *args):
        """
        AddFace(BOPDS_CommonBlock self, Standard_Integer const aF)

        Modifier
        Adds the index of the face <aF>
        to the list of indices of faces
        of the common block

        :type aF: int

        """
        return _BOPDS.BOPDS_CommonBlock_AddFace(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(BOPDS_CommonBlock self, NCollection_List_Standard_Integer aLF)

        Modifier
        Sets the list of indices of faces <aLF>
        of the common block

        :type aLF: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_CommonBlock_SetFaces(self, *args)


    def AppendFaces(self, *args):
        """
        AppendFaces(BOPDS_CommonBlock self, NCollection_List_Standard_Integer aLF)

        Modifier
        Appends the list of indices of faces <aLF>
        to the list of indices of faces
        of the common block (the input list is emptied)

        :type aLF: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_CommonBlock_AppendFaces(self, *args)


    def PaveBlocks(self, *args):
        """
        Selector
        Returns the list of pave blocks
        of the common block

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        res = _BOPDS.BOPDS_CommonBlock_PaveBlocks(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Faces(self, *args):
        """
        Selector
        Returns the list of indices of faces
        of the common block

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPDS.BOPDS_CommonBlock_Faces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PaveBlock1(self, *args):
        """
        Selector
        Returns the first pave block
        of the common block

        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        res = _BOPDS.BOPDS_CommonBlock_PaveBlock1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PaveBlockOnEdge(self, *args):
        """
        PaveBlockOnEdge(BOPDS_CommonBlock self, Standard_Integer const theIndex) -> Handle_BOPDS_PaveBlock

        Selector
        Returns the pave block that belongs
        to the edge with index <theIx>

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CommonBlock_PaveBlockOnEdge(self, *args)


    def IsPaveBlockOnFace(self, *args):
        """
        IsPaveBlockOnFace(BOPDS_CommonBlock self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the common block contains
        a pave block that belongs
        to the face with index <theIx>

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_CommonBlock_IsPaveBlockOnFace(self, *args)


    def IsPaveBlockOnEdge(self, *args):
        """
        IsPaveBlockOnEdge(BOPDS_CommonBlock self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the common block contains
        a pave block that belongs
        to the edge with index <theIx>

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_CommonBlock_IsPaveBlockOnEdge(self, *args)


    def Contains(self, *args):
        """
        Contains(BOPDS_CommonBlock self, Handle_BOPDS_PaveBlock thePB) -> Standard_Boolean
        Contains(BOPDS_CommonBlock self, Standard_Integer const theF) -> Standard_Boolean

        Query
        Returns true if the common block contains
        the face with index equal  to <theF>

        :type theF: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_CommonBlock_Contains(self, *args)


    def SetEdge(self, *args):
        """
        SetEdge(BOPDS_CommonBlock self, Standard_Integer const theEdge)

        Modifier
        Assign the index <theEdge> as the edge index
        to all pave blocks of the common block

        :type theEdge: int

        """
        return _BOPDS.BOPDS_CommonBlock_SetEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(BOPDS_CommonBlock self) -> Standard_Integer

        Selector
        Returns the index of the edge
        of  all pave blocks of the common block

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_CommonBlock_Edge(self, *args)


    def Dump(self, *args):
        """Dump(BOPDS_CommonBlock self)"""
        return _BOPDS.BOPDS_CommonBlock_Dump(self, *args)


    def SetRealPaveBlock(self, *args):
        """
        SetRealPaveBlock(BOPDS_CommonBlock self, Handle_BOPDS_PaveBlock thePB)

        Moves the pave blocks in the list to make the given
        pave block to be the first.
        It will be representative for the whole group.

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CommonBlock_SetRealPaveBlock(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPDS.BOPDS_CommonBlock_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPDS.BOPDS_CommonBlock_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPDS.BOPDS_CommonBlock_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPDS.delete_BOPDS_CommonBlock
BOPDS_CommonBlock_swigregister = _BOPDS.BOPDS_CommonBlock_swigregister
BOPDS_CommonBlock_swigregister(BOPDS_CommonBlock)

def BOPDS_CommonBlock_get_type_name(*args):
    """
    BOPDS_CommonBlock_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPDS.BOPDS_CommonBlock_get_type_name(*args)

def BOPDS_CommonBlock_get_type_descriptor(*args):
    """
    BOPDS_CommonBlock_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPDS.BOPDS_CommonBlock_get_type_descriptor(*args)

class BOPDS_FaceInfo(object):
    """
    The class BOPDS_FaceInfo is to store
    handy information about state of face
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_FaceInfo self) -> BOPDS_FaceInfo
        __init__(BOPDS_FaceInfo self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_FaceInfo

        Contructor
        theAllocator - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_FaceInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPDS_FaceInfo self)

        Clears the contents


        """
        return _BOPDS.BOPDS_FaceInfo_Clear(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(BOPDS_FaceInfo self, Standard_Integer const theI)

        Modifier
        Sets the index of the face <theI>

        :type theI: int

        """
        return _BOPDS.BOPDS_FaceInfo_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(BOPDS_FaceInfo self) -> Standard_Integer

        Selector
        Returns the index of the face

        In

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_FaceInfo_Index(self, *args)


    def PaveBlocksIn(self, *args):
        """
        Selector
        Returns the pave blocks of the face
        that  have state In

        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock

        """
        res = _BOPDS.BOPDS_FaceInfo_PaveBlocksIn(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePaveBlocksIn(self, *args):
        """
        ChangePaveBlocksIn(BOPDS_FaceInfo self) -> NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        Selector/Modifier
        Returns the pave blocks
        of the face
        that  have state In

        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock

        """
        return _BOPDS.BOPDS_FaceInfo_ChangePaveBlocksIn(self, *args)


    def VerticesIn(self, *args):
        """
        Selector
        Returns the list of indices for vertices
        of the face
        that have state In

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _BOPDS.BOPDS_FaceInfo_VerticesIn(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVerticesIn(self, *args):
        """
        ChangeVerticesIn(BOPDS_FaceInfo self) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Selector/Modifier
        Returns the list of indices for vertices
        of the face
        that have state In

        On

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        return _BOPDS.BOPDS_FaceInfo_ChangeVerticesIn(self, *args)


    def PaveBlocksOn(self, *args):
        """
        Selector
        Returns the pave blocks of the face
        that  have state On

        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock

        """
        res = _BOPDS.BOPDS_FaceInfo_PaveBlocksOn(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePaveBlocksOn(self, *args):
        """
        ChangePaveBlocksOn(BOPDS_FaceInfo self) -> NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        Selector/Modifier
        Returns the pave blocks
        of the face
        that  have state On

        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock

        """
        return _BOPDS.BOPDS_FaceInfo_ChangePaveBlocksOn(self, *args)


    def VerticesOn(self, *args):
        """
        Selector
        Returns the list of indices for vertices
        of the face
        that have state On

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _BOPDS.BOPDS_FaceInfo_VerticesOn(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVerticesOn(self, *args):
        """
        ChangeVerticesOn(BOPDS_FaceInfo self) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Selector/Modifier
        Returns the list of indices for vertices
        of the face
        that have state On

        Sections

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        return _BOPDS.BOPDS_FaceInfo_ChangeVerticesOn(self, *args)


    def PaveBlocksSc(self, *args):
        """
        Selector
        Returns the pave blocks of the face
        that are  pave blocks of section edges

        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock

        """
        res = _BOPDS.BOPDS_FaceInfo_PaveBlocksSc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePaveBlocksSc(self, *args):
        """
        ChangePaveBlocksSc(BOPDS_FaceInfo self) -> NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock

        """
        return _BOPDS.BOPDS_FaceInfo_ChangePaveBlocksSc(self, *args)


    def VerticesSc(self, *args):
        """
        Selector
        Returns the list of indices for section  vertices
        of the face

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _BOPDS.BOPDS_FaceInfo_VerticesSc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVerticesSc(self, *args):
        """
        ChangeVerticesSc(BOPDS_FaceInfo self) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Selector/Modifier
        Returns the list of indices for section  vertices
        of the face

        Others

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        return _BOPDS.BOPDS_FaceInfo_ChangeVerticesSc(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_FaceInfo
BOPDS_FaceInfo_swigregister = _BOPDS.BOPDS_FaceInfo_swigregister
BOPDS_FaceInfo_swigregister(BOPDS_FaceInfo)

class BOPDS_InterfFF(BOPDS_Interf):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfFF self) -> BOPDS_InterfFF

        Constructor


        """
        this = _BOPDS.new_BOPDS_InterfFF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BOPDS_InterfFF self, Standard_Integer const theNbCurves, Standard_Integer const theNbPoints)

        Initializer
        @param theNbCurves
        number of intersection curves
        @param theNbPoints
        number of intersection points

        :type theNbCurves: int
        :type theNbPoints: int

        """
        return _BOPDS.BOPDS_InterfFF_Init(self, *args)


    def SetTangentFaces(self, *args):
        """
        SetTangentFaces(BOPDS_InterfFF self, Standard_Boolean const theFlag)

        Modifier
        Sets the flag of whether the faces are tangent  
        @param theFlag
        the flag 

        :type theFlag: bool

        """
        return _BOPDS.BOPDS_InterfFF_SetTangentFaces(self, *args)


    def TangentFaces(self, *args):
        """
        TangentFaces(BOPDS_InterfFF self) -> Standard_Boolean

        Selector
        Returns the flag whether the faces are tangent  
        @return
        the flag 

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_InterfFF_TangentFaces(self, *args)


    def Curves(self, *args):
        """
        Selector
        Returns the intersection curves  
        @return
        intersection curves 

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfCurve

        """
        res = _BOPDS.BOPDS_InterfFF_Curves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurves(self, *args):
        """
        ChangeCurves(BOPDS_InterfFF self) -> NCollection_Vector_BOPDS_Curve

        Selector/Modifier
        Returns the intersection curves  
        @return
        intersection curves 

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfCurve

        """
        return _BOPDS.BOPDS_InterfFF_ChangeCurves(self, *args)


    def Points(self, *args):
        """
        Selector
        Returns the intersection points  
        @return
        intersection points

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfPoint

        """
        res = _BOPDS.BOPDS_InterfFF_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePoints(self, *args):
        """
        ChangePoints(BOPDS_InterfFF self) -> NCollection_Vector_BOPDS_Point

        Selector/Modifier
        Returns the intersection points  
        @return
        intersection points

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfPoint

        """
        return _BOPDS.BOPDS_InterfFF_ChangePoints(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfFF
BOPDS_InterfFF_swigregister = _BOPDS.BOPDS_InterfFF_swigregister
BOPDS_InterfFF_swigregister(BOPDS_InterfFF)

class BOPDS_Pave(object):
    """
    The class BOPDS_Pave is to store
    information about vertex on an edge
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_Pave self) -> BOPDS_Pave

        Empty contructor


        """
        this = _BOPDS.new_BOPDS_Pave(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetIndex(self, *args):
        """
        SetIndex(BOPDS_Pave self, Standard_Integer const theIndex)

        Modifier
        Sets the index of vertex <theIndex>

        :type theIndex: int

        """
        return _BOPDS.BOPDS_Pave_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(BOPDS_Pave self) -> Standard_Integer

        Selector
        Returns the index of vertex

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Pave_Index(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(BOPDS_Pave self, Standard_Real const theParameter)

        Modifier
        Sets the parameter of vertex <theParameter>

        :type theParameter: float

        """
        return _BOPDS.BOPDS_Pave_SetParameter(self, *args)


    def Parameter(self, *args):
        """
        Parameter(BOPDS_Pave self) -> Standard_Real

        Selector
        Returns the parameter of vertex

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPDS.BOPDS_Pave_Parameter(self, *args)


    def Contents(self, *args):
        """
        Contents(BOPDS_Pave self)

        Selector
        Returns the index of vertex <theIndex>
        Returns the parameter of vertex <theParameter>

        :type theIndex: int
        :type theParameter: float

        """
        return _BOPDS.BOPDS_Pave_Contents(self, *args)


    def IsLess(self, *args):
        """
        IsLess(BOPDS_Pave self, BOPDS_Pave theOther) -> Standard_Boolean

        Query
        Returns true if thr parameter od this is less
        than the parameter of  <theOther>

        :type theOther: OCC.wrapper.BOPDS.BOPDS_Pave
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Pave_IsLess(self, *args)


    def __lt__(self, *args):
        """
        __lt__(BOPDS_Pave self, BOPDS_Pave theOther) -> Standard_Boolean

        :type theOther: OCC.wrapper.BOPDS.BOPDS_Pave
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Pave___lt__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BOPDS_Pave self, BOPDS_Pave theOther) -> Standard_Boolean

        Query
        Returns true if thr parameter od this is equal
        to the parameter of  <theOther>

        :type theOther: OCC.wrapper.BOPDS.BOPDS_Pave
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Pave_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(BOPDS_Pave self, BOPDS_Pave theOther) -> Standard_Boolean

        :type theOther: OCC.wrapper.BOPDS.BOPDS_Pave
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Pave___eq__(self, *args)


    def Dump(self, *args):
        """Dump(BOPDS_Pave self)"""
        return _BOPDS.BOPDS_Pave_Dump(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_Pave
BOPDS_Pave_swigregister = _BOPDS.BOPDS_Pave_swigregister
BOPDS_Pave_swigregister(BOPDS_Pave)

class BOPDS_InterfVE(BOPDS_Interf):
    """
    The class BOPDS_InterfVE is is to store the information about
    the interference of the type vertex/edge. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfVE self) -> BOPDS_InterfVE
        __init__(BOPDS_InterfVE self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfVE

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfVE(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParameter(self, *args):
        """
        SetParameter(BOPDS_InterfVE self, Standard_Real const theT)

        Modifier
        Sets the value of parameter 
        of the point of the vertex 
        on the curve of the edge
        @param theT
        value of parameter 

        :type theT: float

        """
        return _BOPDS.BOPDS_InterfVE_SetParameter(self, *args)


    def Parameter(self, *args):
        """
        Parameter(BOPDS_InterfVE self) -> Standard_Real

        Selector
        Returrns the value of parameter 
        of the point of the vertex 
        on the curve of the edge
        @return
        value of parameter 

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPDS.BOPDS_InterfVE_Parameter(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfVE
BOPDS_InterfVE_swigregister = _BOPDS.BOPDS_InterfVE_swigregister
BOPDS_InterfVE_swigregister(BOPDS_InterfVE)

class BOPDS_InterfZZ(BOPDS_Interf):
    """
    The class BOPDS_InterfZZ is is to store the information about
    the interference of the type solid/solid. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfZZ self) -> BOPDS_InterfZZ
        __init__(BOPDS_InterfZZ self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfZZ

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfZZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfZZ
BOPDS_InterfZZ_swigregister = _BOPDS.BOPDS_InterfZZ_swigregister
BOPDS_InterfZZ_swigregister(BOPDS_InterfZZ)

class BOPDS_PaveMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(BOPDS_Pave aPave, Standard_Integer const Upper) -> Standard_Integer

        :type aPave: OCC.wrapper.BOPDS.BOPDS_Pave
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_PaveMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(BOPDS_Pave aPave1, BOPDS_Pave aPave2) -> Standard_Boolean

        :type aPave1: OCC.wrapper.BOPDS.BOPDS_Pave
        :type aPave2: OCC.wrapper.BOPDS.BOPDS_Pave
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _BOPDS.new_BOPDS_PaveMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_PaveMapHasher
BOPDS_PaveMapHasher_swigregister = _BOPDS.BOPDS_PaveMapHasher_swigregister
BOPDS_PaveMapHasher_swigregister(BOPDS_PaveMapHasher)

def BOPDS_PaveMapHasher_HashCode(*args):
    """
    BOPDS_PaveMapHasher_HashCode(BOPDS_Pave aPave, Standard_Integer const Upper) -> Standard_Integer

    :type aPave: OCC.wrapper.BOPDS.BOPDS_Pave
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPDS.BOPDS_PaveMapHasher_HashCode(*args)

def BOPDS_PaveMapHasher_IsEqual(*args):
    """
    BOPDS_PaveMapHasher_IsEqual(BOPDS_Pave aPave1, BOPDS_Pave aPave2) -> Standard_Boolean

    :type aPave1: OCC.wrapper.BOPDS.BOPDS_Pave
    :type aPave2: OCC.wrapper.BOPDS.BOPDS_Pave
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPDS.BOPDS_PaveMapHasher_IsEqual(*args)

class BOPDS_IndexRange(object):
    """
    The class BOPDS_IndexRange is to store
    the information about range of two indices
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_IndexRange self) -> BOPDS_IndexRange

        Empty contructor


        """
        this = _BOPDS.new_BOPDS_IndexRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFirst(self, *args):
        """
        SetFirst(BOPDS_IndexRange self, Standard_Integer const theI1)

        Modifier
        Sets the first index <theI1>  of the range

        :type theI1: int

        """
        return _BOPDS.BOPDS_IndexRange_SetFirst(self, *args)


    def SetLast(self, *args):
        """
        SetLast(BOPDS_IndexRange self, Standard_Integer const theI2)

        Modifier
        Sets the second index <theI2>  of the range

        :type theI2: int

        """
        return _BOPDS.BOPDS_IndexRange_SetLast(self, *args)


    def First(self, *args):
        """
        First(BOPDS_IndexRange self) -> Standard_Integer

        Selector
        Returns the first index of the range

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_IndexRange_First(self, *args)


    def Last(self, *args):
        """
        Last(BOPDS_IndexRange self) -> Standard_Integer

        Selector
        Returns the second index of the range

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_IndexRange_Last(self, *args)


    def SetIndices(self, *args):
        """
        SetIndices(BOPDS_IndexRange self, Standard_Integer const theI1, Standard_Integer const theI2)

        Modifier
        Sets the first index of the range  <theI1>
        Sets the second index of the range <theI2>

        :type theI1: int
        :type theI2: int

        """
        return _BOPDS.BOPDS_IndexRange_SetIndices(self, *args)


    def Indices(self, *args):
        """
        Indices(BOPDS_IndexRange self)

        Selector
        Returns the first index of the range  <theI1>
        Returns the second index of the range <theI2>

        :type theI1: int
        :type theI2: int

        """
        return _BOPDS.BOPDS_IndexRange_Indices(self, *args)


    def Contains(self, *args):
        """
        Contains(BOPDS_IndexRange self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the range contains <theIndex>

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_IndexRange_Contains(self, *args)


    def Dump(self, *args):
        """Dump(BOPDS_IndexRange self)"""
        return _BOPDS.BOPDS_IndexRange_Dump(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_IndexRange
BOPDS_IndexRange_swigregister = _BOPDS.BOPDS_IndexRange_swigregister
BOPDS_IndexRange_swigregister(BOPDS_IndexRange)

class BOPDS_InterfEZ(BOPDS_Interf):
    """
    The class BOPDS_InterfEZ is is to store the information about
    the interference of the type edge/solid. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfEZ self) -> BOPDS_InterfEZ
        __init__(BOPDS_InterfEZ self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfEZ

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfEZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfEZ
BOPDS_InterfEZ_swigregister = _BOPDS.BOPDS_InterfEZ_swigregister
BOPDS_InterfEZ_swigregister(BOPDS_InterfEZ)

class BOPDS_InterfVV(BOPDS_Interf):
    """
    The class BOPDS_InterfVV is is to store the information about
    the interference of the type vertex/vertex. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfVV self) -> BOPDS_InterfVV
        __init__(BOPDS_InterfVV self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfVV

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfVV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfVV
BOPDS_InterfVV_swigregister = _BOPDS.BOPDS_InterfVV_swigregister
BOPDS_InterfVV_swigregister(BOPDS_InterfVV)

class BOPDS_PaveBlock(Standard.Standard_Transient):
    """
    The class BOPDS_PaveBlock is to store
    the information about pave block on an edge.
    Two adjacent paves on edge make up pave block.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BOPDS_PaveBlock
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BOPDS_PaveBlock(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BOPDS_PaveBlock self) -> BOPDS_PaveBlock
        __init__(BOPDS_PaveBlock self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_PaveBlock

        Contructor
        <theAllocator> - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_PaveBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetPave1(self, *args):
        """
        SetPave1(BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Sets the first pave <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.BOPDS_PaveBlock_SetPave1(self, *args)


    def Pave1(self, *args):
        """
        Selector
        Returns the first pave

        :rtype: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        res = _BOPDS.BOPDS_PaveBlock_Pave1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPave2(self, *args):
        """
        SetPave2(BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Sets the second pave <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.BOPDS_PaveBlock_SetPave2(self, *args)


    def Pave2(self, *args):
        """
        Selector
        Returns the second pave

        :rtype: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        res = _BOPDS.BOPDS_PaveBlock_Pave2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdge(self, *args):
        """
        SetEdge(BOPDS_PaveBlock self, Standard_Integer const theEdge)

        Modifier
        Sets the index of edge of pave block <theEdge>

        :type theEdge: int

        """
        return _BOPDS.BOPDS_PaveBlock_SetEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(BOPDS_PaveBlock self) -> Standard_Integer

        Selector
        Returns the index of edge of pave block

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_PaveBlock_Edge(self, *args)


    def HasEdge(self, *args):
        """
        HasEdge(BOPDS_PaveBlock self) -> Standard_Boolean
        HasEdge(BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the pave block has edge
        Returns the index of edge <theEdge>

        :type theEdge: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_HasEdge(self, *args)


    def SetOriginalEdge(self, *args):
        """
        SetOriginalEdge(BOPDS_PaveBlock self, Standard_Integer const theEdge)

        Modifier
        Sets the index of original edge
        of the pave block <theEdge>

        :type theEdge: int

        """
        return _BOPDS.BOPDS_PaveBlock_SetOriginalEdge(self, *args)


    def OriginalEdge(self, *args):
        """
        OriginalEdge(BOPDS_PaveBlock self) -> Standard_Integer

        Selector
        Returns the index of original edge of pave block

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_PaveBlock_OriginalEdge(self, *args)


    def IsSplitEdge(self, *args):
        """
        IsSplitEdge(BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the edge is equal to the original edge
        of the pave block

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_IsSplitEdge(self, *args)


    def Range(self, *args):
        """
        Range(BOPDS_PaveBlock self)

        Selector
        Returns the parametric range <theT1,theT2>
        of the pave block

        :type theT1: float
        :type theT2: float

        """
        return _BOPDS.BOPDS_PaveBlock_Range(self, *args)


    def HasSameBounds(self, *args):
        """
        HasSameBounds(BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theOther) -> Standard_Boolean

        Query
        Returns true if the pave block has pave indices
        that equal to the  pave indices of the pave block
        <theOther>

        :type theOther: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_HasSameBounds(self, *args)


    def Indices(self, *args):
        """
        Indices(BOPDS_PaveBlock self)

        Selector
        Returns the pave indices  <theIndex1,theIndex2>
        of the pave block

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_PaveBlock_Indices(self, *args)


    def IsToUpdate(self, *args):
        """
        IsToUpdate(BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the pave block contains extra paves

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_IsToUpdate(self, *args)


    def AppendExtPave(self, *args):
        """
        AppendExtPave(BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Appends extra paves <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.BOPDS_PaveBlock_AppendExtPave(self, *args)


    def AppendExtPave1(self, *args):
        """
        AppendExtPave1(BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Appends extra pave <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.BOPDS_PaveBlock_AppendExtPave1(self, *args)


    def RemoveExtPave(self, *args):
        """
        RemoveExtPave(BOPDS_PaveBlock self, Standard_Integer const theVertNum)

        Modifier
        Removes a pave with the given vertex number from extra paves

        :type theVertNum: int

        """
        return _BOPDS.BOPDS_PaveBlock_RemoveExtPave(self, *args)


    def ExtPaves(self, *args):
        """
        Selector
        Returns the  extra paves

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPave

        """
        res = _BOPDS.BOPDS_PaveBlock_ExtPaves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeExtPaves(self, *args):
        """
        ChangeExtPaves(BOPDS_PaveBlock self) -> NCollection_List_BOPDS_Pave

        Selector / Modifier
        Returns the extra paves

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPave

        """
        return _BOPDS.BOPDS_PaveBlock_ChangeExtPaves(self, *args)


    def Update(self, *args):
        """
        Update(BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theLPB, Standard_Boolean const theFlag)

        Modifier
        Updates the pave block. The extra paves are used
        to create new pave blocks <theLPB>.
        <theFlag> - if true, the first pave and the second
        pave are used to produce new pave blocks.

        :type theLPB: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock
        :type theFlag: bool

        """
        return _BOPDS.BOPDS_PaveBlock_Update(self, *args)


    def ContainsParameter(self, *args):
        """
        ContainsParameter(BOPDS_PaveBlock self, Standard_Real const thePrm, Standard_Real const theTol) -> Standard_Boolean

        Query
        Returns true if the extra paves contain the pave
        with given value of the parameter <thePrm>
        <theTol>  - the value of the tolerance to compare
        <theInd>  - index of the found pave

        :type thePrm: float
        :type theTol: float
        :type theInd: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_ContainsParameter(self, *args)


    def SetShrunkData(self, *args):
        """
        SetShrunkData(BOPDS_PaveBlock self, Standard_Real const theTS1, Standard_Real const theTS2, Bnd_Box theBox, Standard_Boolean const theIsSplittable)

        Modifier
        Sets the shrunk data for the pave block
        <theTS1>,  <theTS2> - shrunk range
        <theBox> - the bounding box
        <theIsSplittable> - defines whether the edge can be split

        :type theTS1: float
        :type theTS2: float
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theIsSplittable: bool

        """
        return _BOPDS.BOPDS_PaveBlock_SetShrunkData(self, *args)


    def ShrunkData(self, *args):
        """
        ShrunkData(BOPDS_PaveBlock self, Bnd_Box theBox)

        Selector
        Returns  the shrunk data for the pave block
        <theTS1>,  <theTS2> - shrunk range
        <theBox> - the bounding box
        <theIsSplittable> - defines whether the edge can be split

        :type theTS1: float
        :type theTS2: float
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theIsSplittable: bool

        """
        return _BOPDS.BOPDS_PaveBlock_ShrunkData(self, *args)


    def HasShrunkData(self, *args):
        """
        HasShrunkData(BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the pave block contains
        the shrunk data

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_HasShrunkData(self, *args)


    def Dump(self, *args):
        """Dump(BOPDS_PaveBlock self)"""
        return _BOPDS.BOPDS_PaveBlock_Dump(self, *args)


    def IsSplittable(self, *args):
        """
        IsSplittable(BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns FALSE if the pave block has a too short
        shrunk range and cannot be split, otherwise returns TRUE

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PaveBlock_IsSplittable(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BOPDS.BOPDS_PaveBlock_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BOPDS.BOPDS_PaveBlock_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPDS.BOPDS_PaveBlock_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPDS.delete_BOPDS_PaveBlock
BOPDS_PaveBlock_swigregister = _BOPDS.BOPDS_PaveBlock_swigregister
BOPDS_PaveBlock_swigregister(BOPDS_PaveBlock)

def BOPDS_PaveBlock_get_type_name(*args):
    """
    BOPDS_PaveBlock_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BOPDS.BOPDS_PaveBlock_get_type_name(*args)

def BOPDS_PaveBlock_get_type_descriptor(*args):
    """
    BOPDS_PaveBlock_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BOPDS.BOPDS_PaveBlock_get_type_descriptor(*args)

class NCollection_Vector_BOPDS_FaceInfo(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_FaceInfo self) -> NCollection_Vector< BOPDS_FaceInfo >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_FaceInfo self) -> NCollection_Vector< BOPDS_FaceInfo >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_FaceInfo self) -> NCollection_Vector< BOPDS_FaceInfo >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_FaceInfo self) -> NCollection_Vector< BOPDS_FaceInfo >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_FaceInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_FaceInfo self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_FaceInfo self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_FaceInfo self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_FaceInfo self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_FaceInfo self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_FaceInfo self, NCollection_Vector_BOPDS_FaceInfo theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_FaceInfo self, NCollection_Vector_BOPDS_FaceInfo theOther) -> NCollection_Vector_BOPDS_FaceInfo

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_FaceInfo self, BOPDS_FaceInfo theValue) -> BOPDS_FaceInfo

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_FaceInfo self) -> BOPDS_FaceInfo

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_FaceInfo_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_FaceInfo self) -> BOPDS_FaceInfo

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_FaceInfo_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_FaceInfo self) -> BOPDS_FaceInfo

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_FaceInfo___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_FaceInfo_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_FaceInfo self, Standard_Integer const theIndex) -> BOPDS_FaceInfo

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_FaceInfo self, Standard_Integer const theIndex, BOPDS_FaceInfo theValue) -> BOPDS_FaceInfo

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_FaceInfo_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_FaceInfo
NCollection_Vector_BOPDS_FaceInfo_swigregister = _BOPDS.NCollection_Vector_BOPDS_FaceInfo_swigregister
NCollection_Vector_BOPDS_FaceInfo_swigregister(NCollection_Vector_BOPDS_FaceInfo)


try:
	BOPDS_VectorOfFaceInfo = NCollection_Vector_BOPDS_FaceInfo
except NameError:
	pass # does not exist, probably ignored

class BOPDS_DS(object):
    """
    The class BOPDS_DS provides the control
    of data structure for the algorithms in the
    Boolean Component such as General Fuse, Boolean operations,
    Section, Maker Volume, Splitter and Cells Builder.<br>

    The data structure has the  following contents:<br>
    1. the arguments of an operation [myArguments];<br>
    2  the information about arguments/new shapes
    and their sub-shapes (type of the shape,
    bounding box, etc) [myLines];<br>
    3. each argument shape(and its subshapes)
    has/have own range of indices (rank);<br>
    4. pave blocks on source edges [myPaveBlocksPool];<br>
    5. the state of source faces  [myFaceInfoPool];<br>
    6  the collection of same domain shapes [myShapesSD];<br>
    7  the collection of interferences  [myInterfTB,
    myInterfVV,..myInterfFF]
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_DS self) -> BOPDS_DS
        __init__(BOPDS_DS self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_DS

        Contructor
        theAllocator - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_DS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BOPDS_DS self)

        Clears the contents


        """
        return _BOPDS.BOPDS_DS_Clear(self, *args)


    def Allocator(self, *args):
        """
        Selector

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _BOPDS.BOPDS_DS_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArguments(self, *args):
        """
        SetArguments(BOPDS_DS self, NCollection_List_TopoDS_Shape theLS)

        Modifier
        Sets the arguments [theLS] of an operation

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPDS.BOPDS_DS_SetArguments(self, *args)


    def Arguments(self, *args):
        """
        Selector
        Returns the arguments of an operation

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPDS.BOPDS_DS_Arguments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(BOPDS_DS self, Standard_Real const theFuzz)

        Initializes the data structure for
        the arguments

        :type theFuzz: float

        """
        return _BOPDS.BOPDS_DS_Init(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(BOPDS_DS self) -> Standard_Integer

        Selector
        Returns the total number of shapes stored

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_NbShapes(self, *args)


    def NbSourceShapes(self, *args):
        """
        NbSourceShapes(BOPDS_DS self) -> Standard_Integer

        Selector
        Returns the total number of source shapes stored

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_NbSourceShapes(self, *args)


    def NbRanges(self, *args):
        """
        NbRanges(BOPDS_DS self) -> Standard_Integer

        Selector
        Returns the number of index ranges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_NbRanges(self, *args)


    def Range(self, *args):
        """
        Selector
        Returns the index range "i"

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_IndexRange

        """
        res = _BOPDS.BOPDS_DS_Range(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Rank(self, *args):
        """
        Rank(BOPDS_DS self, Standard_Integer const theIndex) -> Standard_Integer

        Selector
        Returns the rank of the shape of index "i"

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_Rank(self, *args)


    def IsNewShape(self, *args):
        """
        IsNewShape(BOPDS_DS self, Standard_Integer const theIndex) -> Standard_Boolean

        Returns true if the shape of index "i" is not
        the source shape/sub-shape

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_IsNewShape(self, *args)


    def Append(self, *args):
        """
        Append(BOPDS_DS self, BOPDS_ShapeInfo theSI) -> Standard_Integer
        Append(BOPDS_DS self, TopoDS_Shape theS) -> Standard_Integer

        Modifier
        Appends the default information about the shape [theS]
        to the data structure
        Returns the index of theS in the data structure

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_Append(self, *args)


    def ShapeInfo(self, *args):
        """
        Selector
        Returns the information about the shape
        with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_ShapeInfo

        """
        res = _BOPDS.BOPDS_DS_ShapeInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShapeInfo(self, *args):
        """
        ChangeShapeInfo(BOPDS_DS self, Standard_Integer const theIndex) -> BOPDS_ShapeInfo

        Selector/Modifier
        Returns the information about the shape
        with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_ShapeInfo

        """
        return _BOPDS.BOPDS_DS_ChangeShapeInfo(self, *args)


    def Shape(self, *args):
        """
        Selector
        Returns the shape
        with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPDS.BOPDS_DS_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(BOPDS_DS self, TopoDS_Shape theS) -> Standard_Integer

        Selector
        Returns the index  of the shape theS

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_Index(self, *args)


    def PaveBlocksPool(self, *args):
        """
        Selector
        Returns the information about pave blocks on source edges

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfListOfPaveBlock

        """
        res = _BOPDS.BOPDS_DS_PaveBlocksPool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePaveBlocksPool(self, *args):
        """
        ChangePaveBlocksPool(BOPDS_DS self) -> NCollection_Vector_BOPDS_ListOfPaveBlock

        Selector/Modifier
        Returns the information about pave blocks on source edges

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfListOfPaveBlock

        """
        return _BOPDS.BOPDS_DS_ChangePaveBlocksPool(self, *args)


    def HasPaveBlocks(self, *args):
        """
        HasPaveBlocks(BOPDS_DS self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the shape with index theIndex has the
        information about pave blocks

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_HasPaveBlocks(self, *args)


    def PaveBlocks(self, *args):
        """
        Selector
        Returns the pave blocks for the shape with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        res = _BOPDS.BOPDS_DS_PaveBlocks(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePaveBlocks(self, *args):
        """
        ChangePaveBlocks(BOPDS_DS self, Standard_Integer const theIndex) -> NCollection_List_Handle_BOPDS_PaveBlock

        Selector/Modifier
        Returns the pave blocks for the shape with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        return _BOPDS.BOPDS_DS_ChangePaveBlocks(self, *args)


    def UpdatePaveBlocks(self, *args):
        """
        UpdatePaveBlocks(BOPDS_DS self)

        Update the pave blocks for the all shapes in data structure


        """
        return _BOPDS.BOPDS_DS_UpdatePaveBlocks(self, *args)


    def UpdatePaveBlock(self, *args):
        """
        UpdatePaveBlock(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB)

        Update the pave block thePB

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_DS_UpdatePaveBlock(self, *args)


    def UpdateCommonBlock(self, *args):
        """
        UpdateCommonBlock(BOPDS_DS self, Handle_BOPDS_CommonBlock theCB, Standard_Real const theFuzz)

        Update the common block theCB

        :type theCB: OCC.wrapper.BOPDS.Handle_BOPDS_CommonBlock
        :type theFuzz: float

        """
        return _BOPDS.BOPDS_DS_UpdateCommonBlock(self, *args)


    def IsCommonBlock(self, *args):
        """
        IsCommonBlock(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB) -> Standard_Boolean

        Query
        Returns true if the pave block is common block

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_IsCommonBlock(self, *args)


    def CommonBlock(self, *args):
        """
        CommonBlock(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB) -> Handle_BOPDS_CommonBlock

        Selector
        Returns the common block

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_CommonBlock

        """
        return _BOPDS.BOPDS_DS_CommonBlock(self, *args)


    def SetCommonBlock(self, *args):
        """
        SetCommonBlock(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB, Handle_BOPDS_CommonBlock theCB)

        Modifier
        Sets the common block <theCB>

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :type theCB: OCC.wrapper.BOPDS.Handle_BOPDS_CommonBlock

        """
        return _BOPDS.BOPDS_DS_SetCommonBlock(self, *args)


    def RealPaveBlock(self, *args):
        """
        RealPaveBlock(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB) -> Handle_BOPDS_PaveBlock

        Selector
        Returns the real first pave block

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_DS_RealPaveBlock(self, *args)


    def IsCommonBlockOnEdge(self, *args):
        """
        IsCommonBlockOnEdge(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB) -> Standard_Boolean

        Query
        Returns true if common block contains more then one pave block

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_IsCommonBlockOnEdge(self, *args)


    def FaceInfoPool(self, *args):
        """
        Selector
        Returns the information about state of faces

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfFaceInfo

        """
        res = _BOPDS.BOPDS_DS_FaceInfoPool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFaceInfo(self, *args):
        """
        HasFaceInfo(BOPDS_DS self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the shape with index theIndex has the
        information about state of face

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_HasFaceInfo(self, *args)


    def FaceInfo(self, *args):
        """
        Selector
        Returns the state of face with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_FaceInfo

        """
        res = _BOPDS.BOPDS_DS_FaceInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFaceInfo(self, *args):
        """
        ChangeFaceInfo(BOPDS_DS self, Standard_Integer const theIndex) -> BOPDS_FaceInfo

        Selector/Modifier
        Returns the state of face with index theIndex

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.BOPDS_FaceInfo

        """
        return _BOPDS.BOPDS_DS_ChangeFaceInfo(self, *args)


    def UpdateFaceInfoIn(self, *args):
        """
        UpdateFaceInfoIn(BOPDS_DS self, Standard_Integer const theIndex)

        Update the state In of face with index theIndex

        :type theIndex: int

        """
        return _BOPDS.BOPDS_DS_UpdateFaceInfoIn(self, *args)


    def UpdateFaceInfoOn(self, *args):
        """
        UpdateFaceInfoOn(BOPDS_DS self, Standard_Integer const theIndex)

        Update the state On of face with index theIndex

        :type theIndex: int

        """
        return _BOPDS.BOPDS_DS_UpdateFaceInfoOn(self, *args)


    def FaceInfoOn(self, *args):
        """
        FaceInfoOn(BOPDS_DS self, Standard_Integer const theIndex, NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theMPB, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theMVP)

        Selector
        Returns the state On
        [theMPB,theMVP] of face with index theIndex

        :type theIndex: int
        :type theMPB: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock
        :type theMVP: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        return _BOPDS.BOPDS_DS_FaceInfoOn(self, *args)


    def FaceInfoIn(self, *args):
        """
        FaceInfoIn(BOPDS_DS self, Standard_Integer const theIndex, NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theMPB, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theMVP)

        Selector
        Returns the state In
        [theMPB,theMVP] of face with index theIndex

        :type theIndex: int
        :type theMPB: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock
        :type theMVP: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        return _BOPDS.BOPDS_DS_FaceInfoIn(self, *args)


    def AloneVertices(self, *args):
        """
        AloneVertices(BOPDS_DS self, Standard_Integer const theF, NCollection_List_Standard_Integer theLI)

        Selector
        Returns the indices of alone vertices
        for the face with index theIndex

        :type theF: int
        :type theLI: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_DS_AloneVertices(self, *args)


    def RefineFaceInfoOn(self, *args):
        """
        RefineFaceInfoOn(BOPDS_DS self)

        Refine the state On for the all faces having
        state information

        ++


        """
        return _BOPDS.BOPDS_DS_RefineFaceInfoOn(self, *args)


    def SubShapesOnIn(self, *args):
        """
        SubShapesOnIn(BOPDS_DS self, Standard_Integer const theNF1, Standard_Integer const theNF2, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theMVOnIn, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theMVCommon, NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher thePBOnIn, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theCommonPB)

        Returns information about ON/IN sub-shapes of the given faces.
        @param theMVOnIn  the indices of ON/IN vertices from both faces
        @param theMVCommon the indices of common vertices for both faces
        @param thePBOnIn  all On/In pave blocks from both faces
        @param theCommonPB  the common pave blocks (that are shared by both faces).

        :type theNF1: int
        :type theNF2: int
        :type theMVOnIn: OCC.wrapper.TColStd.TColStd_MapOfInteger
        :type theMVCommon: OCC.wrapper.TColStd.TColStd_MapOfInteger
        :type thePBOnIn: OCC.wrapper.BOPDS.BOPDS_IndexedMapOfPaveBlock
        :type theCommonPB: OCC.wrapper.BOPDS.BOPDS_MapOfPaveBlock

        """
        return _BOPDS.BOPDS_DS_SubShapesOnIn(self, *args)


    def SharedEdges(self, *args):
        """
        SharedEdges(BOPDS_DS self, Standard_Integer const theF1, Standard_Integer const theF2, NCollection_List_Standard_Integer theLI, Handle_NCollection_BaseAllocator theAllocator)

        Returns the indices of edges that are  shared
        for the faces with indices theF1, theF2

        same domain shapes

        :type theF1: int
        :type theF2: int
        :type theLI: OCC.wrapper.TColStd.TColStd_ListOfInteger
        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.BOPDS_DS_SharedEdges(self, *args)


    def ShapesSD(self, *args):
        """
        ShapesSD(BOPDS_DS self) -> NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher

        Selector
        Returns the collection same domain shapes

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfIntegerInteger

        """
        return _BOPDS.BOPDS_DS_ShapesSD(self, *args)


    def AddShapeSD(self, *args):
        """
        AddShapeSD(BOPDS_DS self, Standard_Integer const theIndex, Standard_Integer const theIndexSD)

        Modifier
        Adds the information about same domain shapes
        with indices theIndex, theIndexSD

        :type theIndex: int
        :type theIndexSD: int

        """
        return _BOPDS.BOPDS_DS_AddShapeSD(self, *args)


    def HasShapeSD(self, *args):
        """
        HasShapeSD(BOPDS_DS self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the shape with index theIndex has the
        same domain shape. In this case theIndexSD will contain
        the index of same domain shape found

        interferences

        :type theIndex: int
        :type theIndexSD: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_HasShapeSD(self, *args)


    def InterfVV(self, *args):
        """
        InterfVV(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfVV

        Selector/Modifier
        Returns the collection of interferences Vertex/Vertex

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfVV

        """
        return _BOPDS.BOPDS_DS_InterfVV(self, *args)


    def InterfVE(self, *args):
        """
        InterfVE(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfVE

        Selector/Modifier
        Returns the collection of interferences Vertex/Edge

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfVE

        """
        return _BOPDS.BOPDS_DS_InterfVE(self, *args)


    def InterfVF(self, *args):
        """
        InterfVF(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfVF

        Selector/Modifier
        Returns the collection of interferences Vertex/Face

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfVF

        """
        return _BOPDS.BOPDS_DS_InterfVF(self, *args)


    def InterfEE(self, *args):
        """
        InterfEE(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfEE

        Selector/Modifier
        Returns the collection of interferences Edge/Edge

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfEE

        """
        return _BOPDS.BOPDS_DS_InterfEE(self, *args)


    def InterfEF(self, *args):
        """
        InterfEF(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfEF

        Selector/Modifier
        Returns the collection of interferences Edge/Face

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfEF

        """
        return _BOPDS.BOPDS_DS_InterfEF(self, *args)


    def InterfFF(self, *args):
        """
        InterfFF(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfFF

        Selector/Modifier
        Returns the collection of interferences Face/Face

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfFF

        """
        return _BOPDS.BOPDS_DS_InterfFF(self, *args)


    def InterfVZ(self, *args):
        """
        InterfVZ(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfVZ

        Selector/Modifier
        Returns the collection of interferences Vertex/Solid

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfVZ

        """
        return _BOPDS.BOPDS_DS_InterfVZ(self, *args)


    def InterfEZ(self, *args):
        """
        InterfEZ(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfEZ

        Selector/Modifier
        Returns the collection of interferences Edge/Solid

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfEZ

        """
        return _BOPDS.BOPDS_DS_InterfEZ(self, *args)


    def InterfFZ(self, *args):
        """
        InterfFZ(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfFZ

        Selector/Modifier
        Returns the collection of interferences Face/Solid

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfFZ

        """
        return _BOPDS.BOPDS_DS_InterfFZ(self, *args)


    def InterfZZ(self, *args):
        """
        InterfZZ(BOPDS_DS self) -> NCollection_Vector_BOPDS_InterfZZ

        Selector/Modifier
        Returns the collection of interferences Solid/Solid

        :rtype: OCC.wrapper.BOPDS.BOPDS_VectorOfInterfZZ

        """
        return _BOPDS.BOPDS_DS_InterfZZ(self, *args)


    def NbInterfTypes(*args):
        """
        NbInterfTypes() -> Standard_Integer

        Returns the number of types of the interferences

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_DS_NbInterfTypes(*args)

    NbInterfTypes = staticmethod(NbInterfTypes)

    def AddInterf(self, *args):
        """
        AddInterf(BOPDS_DS self, Standard_Integer const theI1, Standard_Integer const theI2)

        Modifier
        Adds the information about an interference between
        shapes with indices theI1, theI2 to the summary
        table of interferences

        :type theI1: int
        :type theI2: int

        """
        return _BOPDS.BOPDS_DS_AddInterf(self, *args)


    def HasInterf(self, *args):
        """
        HasInterf(BOPDS_DS self, Standard_Integer const theI) -> Standard_Boolean
        HasInterf(BOPDS_DS self, Standard_Integer const theI1, Standard_Integer const theI2) -> Standard_Boolean

        Query
        Returns true if the shapes with indices theI1, theI2
        are interferred

        :type theI1: int
        :type theI2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_HasInterf(self, *args)


    def HasInterfShapeSubShapes(self, *args):
        """
        HasInterfShapeSubShapes(BOPDS_DS self, Standard_Integer const theI1, Standard_Integer const theI2, Standard_Boolean const theFlag) -> Standard_Boolean

        Query
        Returns true if the shape with index theI1 is interfered
        with
        any sub-shape of the shape with index theI2  (theFlag=true)
        all sub-shapes of the shape with index theI2 (theFlag=false)

        :type theI1: int
        :type theI2: int
        :type theFlag: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_HasInterfShapeSubShapes(self, *args)


    def HasInterfSubShapes(self, *args):
        """
        HasInterfSubShapes(BOPDS_DS self, Standard_Integer const theI1, Standard_Integer const theI2) -> Standard_Boolean

        Query
        Returns true if the shapes with indices theI1, theI2
        have interferred sub-shapes

        :type theI1: int
        :type theI2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_HasInterfSubShapes(self, *args)


    def Interferences(self, *args):
        """
        Selector
        Returns the table of interferences

        debug

        :rtype: OCC.wrapper.BOPDS.BOPDS_MapOfPair

        """
        res = _BOPDS.BOPDS_DS_Interferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """Dump(BOPDS_DS self)"""
        return _BOPDS.BOPDS_DS_Dump(self, *args)


    def IsSubShape(self, *args):
        """
        IsSubShape(BOPDS_DS self, Standard_Integer const theI1, Standard_Integer const theI2) -> Standard_Boolean

        :type theI1: int
        :type theI2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_IsSubShape(self, *args)


    def Paves(self, *args):
        """
        Paves(BOPDS_DS self, Standard_Integer const theIndex, NCollection_List_BOPDS_Pave theLP)

        Fills theLP with sorted paves
        of the shape with index theIndex

        :type theIndex: int
        :type theLP: OCC.wrapper.BOPDS.BOPDS_ListOfPave

        """
        return _BOPDS.BOPDS_DS_Paves(self, *args)


    def UpdateEdgeTolerance(self, *args):
        """
        UpdateEdgeTolerance(BOPDS_DS self, Standard_Integer const theIndex, Standard_Real const theTolerance, Standard_Real const theFuzz)

        Updates tolerance of the sub-shapes of the shape with index <theIndex>.

        :type theIndex: int
        :type theTolerance: float
        :type theFuzz: float

        """
        return _BOPDS.BOPDS_DS_UpdateEdgeTolerance(self, *args)


    def UpdatePaveBlocksWithSDVertices(self, *args):
        """
        UpdatePaveBlocksWithSDVertices(BOPDS_DS self)

        Update the pave blocks for all shapes in data structure


        """
        return _BOPDS.BOPDS_DS_UpdatePaveBlocksWithSDVertices(self, *args)


    def UpdatePaveBlockWithSDVertices(self, *args):
        """
        UpdatePaveBlockWithSDVertices(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB)

        Update the pave block for all shapes in data structure

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_DS_UpdatePaveBlockWithSDVertices(self, *args)


    def UpdateCommonBlockWithSDVertices(self, *args):
        """
        UpdateCommonBlockWithSDVertices(BOPDS_DS self, Handle_BOPDS_CommonBlock theCB)

        Update the pave block of the common block for all shapes in data structure

        :type theCB: OCC.wrapper.BOPDS.Handle_BOPDS_CommonBlock

        """
        return _BOPDS.BOPDS_DS_UpdateCommonBlockWithSDVertices(self, *args)


    def InitPaveBlocksForVertex(self, *args):
        """
        InitPaveBlocksForVertex(BOPDS_DS self, Standard_Integer const theNV)

        :type theNV: int

        """
        return _BOPDS.BOPDS_DS_InitPaveBlocksForVertex(self, *args)


    def ReleasePaveBlocks(self, *args):
        """
        ReleasePaveBlocks(BOPDS_DS self)

        Clears information about PaveBlocks for the untouched edges


        """
        return _BOPDS.BOPDS_DS_ReleasePaveBlocks(self, *args)


    def IsValidShrunkData(self, *args):
        """
        IsValidShrunkData(BOPDS_DS self, Handle_BOPDS_PaveBlock thePB) -> Standard_Boolean

        Checks if the existing shrunk data of the pave block is still valid.<br>
        The shrunk data may become invalid if e.g. the vertices of the pave block
        have been replaced with the new one with bigger tolerances, or the tolerances
        of the existing vertices have been increased.

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_DS_IsValidShrunkData(self, *args)


    def BuildBndBoxSolid(self, *args):
        """
        BuildBndBoxSolid(BOPDS_DS self, Standard_Integer const theIndex, Bnd_Box theBox, Standard_Boolean const theCheckInverted)

        Computes bounding box <theBox> for the solid with DS-index <theIndex>.
        The flag <theCheckInverted> enables/disables the check of the solid
        for inverted status. By default the solids will be checked.

        :type theIndex: int
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theCheckInverted: bool

        """
        return _BOPDS.BOPDS_DS_BuildBndBoxSolid(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_DS
BOPDS_DS_swigregister = _BOPDS.BOPDS_DS_swigregister
BOPDS_DS_swigregister(BOPDS_DS)

def BOPDS_DS_NbInterfTypes(*args):
    """
    BOPDS_DS_NbInterfTypes() -> Standard_Integer

    Returns the number of types of the interferences

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPDS.BOPDS_DS_NbInterfTypes(*args)

class BOPDS_ShapeInfo(object):
    """
    The class BOPDS_ShapeInfo is to store
    handy information about shape
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_ShapeInfo self) -> BOPDS_ShapeInfo
        __init__(BOPDS_ShapeInfo self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_ShapeInfo

        Contructor
        theAllocator - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_ShapeInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape(self, *args):
        """
        SetShape(BOPDS_ShapeInfo self, TopoDS_Shape theS)

        Modifier
        Sets the shape <theS>

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPDS.BOPDS_ShapeInfo_SetShape(self, *args)


    def Shape(self, *args):
        """
        Selector
        Returns the shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPDS.BOPDS_ShapeInfo_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShapeType(self, *args):
        """
        SetShapeType(BOPDS_ShapeInfo self, TopAbs_ShapeEnum const theType)

        Modifier
        Sets the type of shape theType

        :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BOPDS.BOPDS_ShapeInfo_SetShapeType(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(BOPDS_ShapeInfo self) -> TopAbs_ShapeEnum

        Selector
        Returns the type of shape

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BOPDS.BOPDS_ShapeInfo_ShapeType(self, *args)


    def SetBox(self, *args):
        """
        SetBox(BOPDS_ShapeInfo self, Bnd_Box theBox)

        Modifier
        Sets the boundung box of the shape theBox

        :type theBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BOPDS.BOPDS_ShapeInfo_SetBox(self, *args)


    def Box(self, *args):
        """
        Selector
        Returns the boundung box of the shape

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _BOPDS.BOPDS_ShapeInfo_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBox(self, *args):
        """
        ChangeBox(BOPDS_ShapeInfo self) -> Bnd_Box

        Selector/Modifier
        Returns the boundung box of the shape

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BOPDS.BOPDS_ShapeInfo_ChangeBox(self, *args)


    def SubShapes(self, *args):
        """
        Selector
        Returns the list of indices of sub-shapes

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPDS.BOPDS_ShapeInfo_SubShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSubShapes(self, *args):
        """
        ChangeSubShapes(BOPDS_ShapeInfo self) -> NCollection_List_Standard_Integer

        Selector/ Modifier
        Returns the list of indices of sub-shapes

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_ShapeInfo_ChangeSubShapes(self, *args)


    def HasSubShape(self, *args):
        """
        HasSubShape(BOPDS_ShapeInfo self, Standard_Integer const theI) -> Standard_Boolean

        Query
        Returns true if the shape has sub-shape with
        index theI

        :type theI: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_ShapeInfo_HasSubShape(self, *args)


    def HasReference(self, *args):
        """
        HasReference(BOPDS_ShapeInfo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_ShapeInfo_HasReference(self, *args)


    def SetReference(self, *args):
        """
        SetReference(BOPDS_ShapeInfo self, Standard_Integer const theI)

        Modifier
        Sets the index of a reference information

        :type theI: int

        """
        return _BOPDS.BOPDS_ShapeInfo_SetReference(self, *args)


    def Reference(self, *args):
        """
        Reference(BOPDS_ShapeInfo self) -> Standard_Integer

        Selector
        Returns the index of a reference information

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_ShapeInfo_Reference(self, *args)


    def HasBRep(self, *args):
        """
        HasBRep(BOPDS_ShapeInfo self) -> Standard_Boolean

        Query
        Returns true if the shape has boundary representation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_ShapeInfo_HasBRep(self, *args)


    def IsInterfering(self, *args):
        """
        IsInterfering(BOPDS_ShapeInfo self) -> Standard_Boolean

        Returns true if the shape can be participant of
        an interference

        Flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_ShapeInfo_IsInterfering(self, *args)


    def HasFlag(self, *args):
        """
        HasFlag(BOPDS_ShapeInfo self) -> Standard_Boolean
        HasFlag(BOPDS_ShapeInfo self) -> Standard_Boolean

        Query
        Returns true if there is flag.
        Returns the the  flag theFlag

        :type theFlag: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_ShapeInfo_HasFlag(self, *args)


    def SetFlag(self, *args):
        """
        SetFlag(BOPDS_ShapeInfo self, Standard_Integer const theI)

        Modifier
        Sets the flag

        :type theI: int

        """
        return _BOPDS.BOPDS_ShapeInfo_SetFlag(self, *args)


    def Flag(self, *args):
        """
        Flag(BOPDS_ShapeInfo self) -> Standard_Integer

        Returns the flag

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_ShapeInfo_Flag(self, *args)


    def Dump(self, *args):
        """Dump(BOPDS_ShapeInfo self)"""
        return _BOPDS.BOPDS_ShapeInfo_Dump(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_ShapeInfo
BOPDS_ShapeInfo_swigregister = _BOPDS.BOPDS_ShapeInfo_swigregister
BOPDS_ShapeInfo_swigregister(BOPDS_ShapeInfo)

class BOPDS_InterfEF(BOPDS_Interf):
    """
    The class BOPDS_InterfEF is is to store the information about
    the interference of the type edge/face. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfEF self) -> BOPDS_InterfEF
        __init__(BOPDS_InterfEF self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfEF

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfEF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCommonPart(self, *args):
        """
        SetCommonPart(BOPDS_InterfEF self, IntTools_CommonPrt theCP)

        Modifier
        Sets the info of common part 
        @param theCP
        common part

        :type theCP: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        return _BOPDS.BOPDS_InterfEF_SetCommonPart(self, *args)


    def CommonPart(self, *args):
        """
        Selector
        Returns the info of common part 
        @return
        common part

        :rtype: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        res = _BOPDS.BOPDS_InterfEF_CommonPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfEF
BOPDS_InterfEF_swigregister = _BOPDS.BOPDS_InterfEF_swigregister
BOPDS_InterfEF_swigregister(BOPDS_InterfEF)

class NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< BOPDS_PaveBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< BOPDS_PaveBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _BOPDS.new_NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Differ(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher
NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_swigregister
NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_swigregister(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher)

class NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_MapOfPaveBlock = NCollection_Map_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class BOPDS_InterfEE(BOPDS_Interf):
    """
    The class BOPDS_InterfEE is is to store the information about
    the interference of the type edge/edge. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfEE self) -> BOPDS_InterfEE
        __init__(BOPDS_InterfEE self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfEE

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfEE(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCommonPart(self, *args):
        """
        SetCommonPart(BOPDS_InterfEE self, IntTools_CommonPrt theCP)

        Modifier
        Sets the info of common part 
        @param theCP
        common part

        :type theCP: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        return _BOPDS.BOPDS_InterfEE_SetCommonPart(self, *args)


    def CommonPart(self, *args):
        """
        Selector
        Returns the info of common part 
        @return
        common part

        :rtype: OCC.wrapper.IntTools.IntTools_CommonPrt

        """
        res = _BOPDS.BOPDS_InterfEE_CommonPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfEE
BOPDS_InterfEE_swigregister = _BOPDS.BOPDS_InterfEE_swigregister
BOPDS_InterfEE_swigregister(BOPDS_InterfEE)

class BOPDS_IteratorSI(BOPDS_Iterator):
    """
    The class BOPDS_IteratorSI is
    1.to compute self-intersections between BRep sub-shapes
    of each argument of an operation (see the class BOPDS_DS)
    in terms of theirs bounding boxes
    2.provides interface to iterare the pairs of
    intersected sub-shapes of given type
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_IteratorSI self) -> BOPDS_IteratorSI
        __init__(BOPDS_IteratorSI self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_IteratorSI

        Contructor
        theAllocator - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_IteratorSI(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def UpdateByLevelOfCheck(self, *args):
        """
        UpdateByLevelOfCheck(BOPDS_IteratorSI self, Standard_Integer const theLevel)

        Updates the lists of possible intersections
        according to the value of <theLevel>.
        It defines which interferferences will be checked:
        0 - only V/V;
        1 - V/V and V/E;
        2 - V/V, V/E and E/E;
        3 - V/V, V/E, E/E and V/F;
        4 - V/V, V/E, E/E, V/F and E/F;
        other - all interferences.

        :type theLevel: int

        """
        return _BOPDS.BOPDS_IteratorSI_UpdateByLevelOfCheck(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_IteratorSI
BOPDS_IteratorSI_swigregister = _BOPDS.BOPDS_IteratorSI_swigregister
BOPDS_IteratorSI_swigregister(BOPDS_IteratorSI)

class NCollection_Vector_BOPDS_InterfEZ(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfEZ self) -> NCollection_Vector< BOPDS_InterfEZ >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfEZ self) -> NCollection_Vector< BOPDS_InterfEZ >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfEZ self) -> NCollection_Vector< BOPDS_InterfEZ >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfEZ self) -> NCollection_Vector< BOPDS_InterfEZ >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfEZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfEZ self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfEZ self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfEZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfEZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfEZ self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfEZ self, NCollection_Vector_BOPDS_InterfEZ theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfEZ self, NCollection_Vector_BOPDS_InterfEZ theOther) -> NCollection_Vector_BOPDS_InterfEZ

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfEZ self, BOPDS_InterfEZ theValue) -> BOPDS_InterfEZ

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfEZ self) -> BOPDS_InterfEZ

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEZ_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfEZ self) -> BOPDS_InterfEZ

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEZ_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfEZ self) -> BOPDS_InterfEZ

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEZ___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEZ_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfEZ self, Standard_Integer const theIndex) -> BOPDS_InterfEZ

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfEZ self, Standard_Integer const theIndex, BOPDS_InterfEZ theValue) -> BOPDS_InterfEZ

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEZ_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfEZ
NCollection_Vector_BOPDS_InterfEZ_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfEZ_swigregister
NCollection_Vector_BOPDS_InterfEZ_swigregister(NCollection_Vector_BOPDS_InterfEZ)


try:
	BOPDS_VectorOfInterfEZ = NCollection_Vector_BOPDS_InterfEZ
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_Curve(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_Curve self) -> NCollection_Vector< BOPDS_Curve >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_Curve self) -> NCollection_Vector< BOPDS_Curve >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_Curve self) -> NCollection_Vector< BOPDS_Curve >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_Curve self) -> NCollection_Vector< BOPDS_Curve >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_Curve self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_Curve self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_Curve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_Curve self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_Curve self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_Curve self, NCollection_Vector_BOPDS_Curve theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_Curve self, NCollection_Vector_BOPDS_Curve theOther) -> NCollection_Vector_BOPDS_Curve

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_Curve self, BOPDS_Curve theValue) -> BOPDS_Curve

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_Curve self) -> BOPDS_Curve

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Curve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Curve_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_Curve self) -> BOPDS_Curve

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Curve_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_Curve self) -> BOPDS_Curve

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Curve___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Curve_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_Curve self, Standard_Integer const theIndex) -> BOPDS_Curve

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_Curve self, Standard_Integer const theIndex, BOPDS_Curve theValue) -> BOPDS_Curve

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Curve_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_Curve
NCollection_Vector_BOPDS_Curve_swigregister = _BOPDS.NCollection_Vector_BOPDS_Curve_swigregister
NCollection_Vector_BOPDS_Curve_swigregister(NCollection_Vector_BOPDS_Curve)


try:
	BOPDS_VectorOfCurve = NCollection_Vector_BOPDS_Curve
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< BOPDS_CommonBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< BOPDS_CommonBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _BOPDS.new_NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_CommonBlock K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_CommonBlock K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_CommonBlock K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Differ(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher
NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_swigregister
NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_swigregister(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher)

class NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_MapOfCommonBlock = NCollection_Map_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfFZ(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfFZ self) -> NCollection_Vector< BOPDS_InterfFZ >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfFZ self) -> NCollection_Vector< BOPDS_InterfFZ >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfFZ self) -> NCollection_Vector< BOPDS_InterfFZ >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfFZ self) -> NCollection_Vector< BOPDS_InterfFZ >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfFZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfFZ self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfFZ self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfFZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfFZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfFZ self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfFZ self, NCollection_Vector_BOPDS_InterfFZ theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfFZ self, NCollection_Vector_BOPDS_InterfFZ theOther) -> NCollection_Vector_BOPDS_InterfFZ

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfFZ self, BOPDS_InterfFZ theValue) -> BOPDS_InterfFZ

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfFZ self) -> BOPDS_InterfFZ

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFZ_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfFZ self) -> BOPDS_InterfFZ

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFZ_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfFZ self) -> BOPDS_InterfFZ

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFZ___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFZ_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfFZ self, Standard_Integer const theIndex) -> BOPDS_InterfFZ

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfFZ self, Standard_Integer const theIndex, BOPDS_InterfFZ theValue) -> BOPDS_InterfFZ

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFZ_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfFZ
NCollection_Vector_BOPDS_InterfFZ_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfFZ_swigregister
NCollection_Vector_BOPDS_InterfFZ_swigregister(NCollection_Vector_BOPDS_InterfFZ)


try:
	BOPDS_VectorOfInterfFZ = NCollection_Vector_BOPDS_InterfFZ
except NameError:
	pass # does not exist, probably ignored

class BOPDS_InterfVZ(BOPDS_Interf):
    """
    The class BOPDS_InterfVZ is is to store the information about
    the interference of the type vertex/solid. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfVZ self) -> BOPDS_InterfVZ
        __init__(BOPDS_InterfVZ self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfVZ

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfVZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfVZ
BOPDS_InterfVZ_swigregister = _BOPDS.BOPDS_InterfVZ_swigregister
BOPDS_InterfVZ_swigregister(BOPDS_InterfVZ)

class NCollection_Vector_BOPDS_VectorOfPair(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector< BOPDS_VectorOfPair >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector< BOPDS_VectorOfPair >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector< BOPDS_VectorOfPair >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector< BOPDS_VectorOfPair >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_VectorOfPair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_VectorOfPair self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_VectorOfPair self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_VectorOfPair self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_VectorOfPair self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_VectorOfPair self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_VectorOfPair self, NCollection_Vector_BOPDS_VectorOfPair theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_VectorOfPair self, NCollection_Vector_BOPDS_VectorOfPair theOther) -> NCollection_Vector_BOPDS_VectorOfPair

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_VectorOfPair self, NCollection_Vector_BOPDS_Pair theValue) -> NCollection_Vector_BOPDS_Pair

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector_BOPDS_Pair

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector_BOPDS_Pair

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_VectorOfPair self) -> NCollection_Vector_BOPDS_Pair

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_VectorOfPair___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_VectorOfPair self, Standard_Integer const theIndex) -> NCollection_Vector_BOPDS_Pair

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_VectorOfPair self, Standard_Integer const theIndex, NCollection_Vector_BOPDS_Pair theValue) -> NCollection_Vector_BOPDS_Pair

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_VectorOfPair
NCollection_Vector_BOPDS_VectorOfPair_swigregister = _BOPDS.NCollection_Vector_BOPDS_VectorOfPair_swigregister
NCollection_Vector_BOPDS_VectorOfPair_swigregister(NCollection_Vector_BOPDS_VectorOfPair)


try:
	BOPDS_VectorOfVectorOfPair = NCollection_Vector_BOPDS_VectorOfPair
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfEE(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfEE self) -> NCollection_Vector< BOPDS_InterfEE >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfEE self) -> NCollection_Vector< BOPDS_InterfEE >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfEE self) -> NCollection_Vector< BOPDS_InterfEE >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfEE self) -> NCollection_Vector< BOPDS_InterfEE >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfEE(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfEE self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfEE self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfEE self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfEE self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfEE self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfEE self, NCollection_Vector_BOPDS_InterfEE theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfEE self, NCollection_Vector_BOPDS_InterfEE theOther) -> NCollection_Vector_BOPDS_InterfEE

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfEE self, BOPDS_InterfEE theValue) -> BOPDS_InterfEE

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfEE self) -> BOPDS_InterfEE

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEE_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEE_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfEE self) -> BOPDS_InterfEE

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEE_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfEE self) -> BOPDS_InterfEE

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEE___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEE_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfEE self, Standard_Integer const theIndex) -> BOPDS_InterfEE

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfEE self, Standard_Integer const theIndex, BOPDS_InterfEE theValue) -> BOPDS_InterfEE

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEE_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfEE
NCollection_Vector_BOPDS_InterfEE_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfEE_swigregister
NCollection_Vector_BOPDS_InterfEE_swigregister(NCollection_Vector_BOPDS_InterfEE)


try:
	BOPDS_VectorOfInterfEE = NCollection_Vector_BOPDS_InterfEE
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfFF(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfFF self) -> NCollection_Vector< BOPDS_InterfFF >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfFF self) -> NCollection_Vector< BOPDS_InterfFF >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfFF self) -> NCollection_Vector< BOPDS_InterfFF >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfFF self) -> NCollection_Vector< BOPDS_InterfFF >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfFF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfFF self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfFF self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfFF self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfFF self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfFF self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfFF self, NCollection_Vector_BOPDS_InterfFF theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfFF self, NCollection_Vector_BOPDS_InterfFF theOther) -> NCollection_Vector_BOPDS_InterfFF

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfFF self, BOPDS_InterfFF theValue) -> BOPDS_InterfFF

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfFF self) -> BOPDS_InterfFF

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFF_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFF_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfFF self) -> BOPDS_InterfFF

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFF_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfFF self) -> BOPDS_InterfFF

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFF___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfFF_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfFF self, Standard_Integer const theIndex) -> BOPDS_InterfFF

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfFF self, Standard_Integer const theIndex, BOPDS_InterfFF theValue) -> BOPDS_InterfFF

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfFF_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfFF
NCollection_Vector_BOPDS_InterfFF_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfFF_swigregister
NCollection_Vector_BOPDS_InterfFF_swigregister(NCollection_Vector_BOPDS_InterfFF)


try:
	BOPDS_VectorOfInterfFF = NCollection_Vector_BOPDS_InterfFF
except NameError:
	pass # does not exist, probably ignored

class BOPDS_CoupleOfPaveBlocks(object):
    """
    The Class BOPDS_CoupleOfPaveBlocks is to store
    the information about two pave blocks 
    and some satellite information 

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_CoupleOfPaveBlocks self) -> BOPDS_CoupleOfPaveBlocks
        __init__(BOPDS_CoupleOfPaveBlocks self, Handle_BOPDS_PaveBlock thePB1, Handle_BOPDS_PaveBlock thePB2) -> BOPDS_CoupleOfPaveBlocks

        Constructor
        @param thePB1
        first pave block
        @param thePB2
        secondt pave block

        :type thePB1: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :type thePB2: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        this = _BOPDS.new_BOPDS_CoupleOfPaveBlocks(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetIndex(self, *args):
        """
        SetIndex(BOPDS_CoupleOfPaveBlocks self, Standard_Integer const theIndex)

        Sets an index
        @param theIndex
        index

        :type theIndex: int

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(BOPDS_CoupleOfPaveBlocks self) -> Standard_Integer

        Returns the index
        @return 
        index

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_Index(self, *args)


    def SetIndexInterf(self, *args):
        """
        SetIndexInterf(BOPDS_CoupleOfPaveBlocks self, Standard_Integer const theIndex)

        Sets an index of an interference 
        @param theIndex
        index of an interference 

        :type theIndex: int

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_SetIndexInterf(self, *args)


    def IndexInterf(self, *args):
        """
        IndexInterf(BOPDS_CoupleOfPaveBlocks self) -> Standard_Integer

        Returns the index of an interference 
        @return 
        index of an interference 

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_IndexInterf(self, *args)


    def SetPaveBlocks(self, *args):
        """
        SetPaveBlocks(BOPDS_CoupleOfPaveBlocks self, Handle_BOPDS_PaveBlock thePB1, Handle_BOPDS_PaveBlock thePB2)

        Sets pave blocks
        @param thePB1
        first pave block
        @param thePB2
        secondt pave block

        :type thePB1: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :type thePB2: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_SetPaveBlocks(self, *args)


    def PaveBlocks(self, *args):
        """
        PaveBlocks(BOPDS_CoupleOfPaveBlocks self, Handle_BOPDS_PaveBlock thePB1, Handle_BOPDS_PaveBlock thePB2)

        Returns pave blocks
        @param thePB1
        the first pave block
        @param thePB2
        the second pave block

        :type thePB1: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :type thePB2: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_PaveBlocks(self, *args)


    def SetPaveBlock1(self, *args):
        """
        SetPaveBlock1(BOPDS_CoupleOfPaveBlocks self, Handle_BOPDS_PaveBlock thePB)

        Sets the first pave block
        @param thePB
        the first pave block

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_SetPaveBlock1(self, *args)


    def PaveBlock1(self, *args):
        """
        Returns the first pave block
        @return 
        the first pave block

        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        res = _BOPDS.BOPDS_CoupleOfPaveBlocks_PaveBlock1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPaveBlock2(self, *args):
        """
        SetPaveBlock2(BOPDS_CoupleOfPaveBlocks self, Handle_BOPDS_PaveBlock thePB)

        Sets the second pave block
        @param thePB
        the second pave block

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_SetPaveBlock2(self, *args)


    def PaveBlock2(self, *args):
        """
        Returns the second pave block
        @return 
        the second pave block

        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        res = _BOPDS.BOPDS_CoupleOfPaveBlocks_PaveBlock2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(BOPDS_CoupleOfPaveBlocks self, Standard_Real const theTol)

        Sets the tolerance associated with this couple

        :type theTol: float

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BOPDS_CoupleOfPaveBlocks self) -> Standard_Real

        Returns the tolerance associated with this couple

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPDS.BOPDS_CoupleOfPaveBlocks_Tolerance(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_CoupleOfPaveBlocks
BOPDS_CoupleOfPaveBlocks_swigregister = _BOPDS.BOPDS_CoupleOfPaveBlocks_swigregister
BOPDS_CoupleOfPaveBlocks_swigregister(BOPDS_CoupleOfPaveBlocks)

class BOPDS_PairMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(BOPDS_Pair thePair, Standard_Integer const Upper) -> Standard_Integer

        :type thePair: OCC.wrapper.BOPDS.BOPDS_Pair
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_PairMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(BOPDS_Pair thePair1, BOPDS_Pair thePair2) -> Standard_Boolean

        :type thePair1: OCC.wrapper.BOPDS.BOPDS_Pair
        :type thePair2: OCC.wrapper.BOPDS.BOPDS_Pair
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_PairMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _BOPDS.new_BOPDS_PairMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_PairMapHasher
BOPDS_PairMapHasher_swigregister = _BOPDS.BOPDS_PairMapHasher_swigregister
BOPDS_PairMapHasher_swigregister(BOPDS_PairMapHasher)

def BOPDS_PairMapHasher_HashCode(*args):
    """
    BOPDS_PairMapHasher_HashCode(BOPDS_Pair thePair, Standard_Integer const Upper) -> Standard_Integer

    :type thePair: OCC.wrapper.BOPDS.BOPDS_Pair
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPDS.BOPDS_PairMapHasher_HashCode(*args)

def BOPDS_PairMapHasher_IsEqual(*args):
    """
    BOPDS_PairMapHasher_IsEqual(BOPDS_Pair thePair1, BOPDS_Pair thePair2) -> Standard_Boolean

    :type thePair1: OCC.wrapper.BOPDS.BOPDS_Pair
    :type thePair2: OCC.wrapper.BOPDS.BOPDS_Pair
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPDS.BOPDS_PairMapHasher_IsEqual(*args)

class BOPDS_SubIterator(object):
    """
    The class BOPDS_SubIterator is used to compute intersections between
    bounding boxes of two sub-sets of BRep sub-shapes of arguments
    of an operation (see the class BOPDS_DS).
    The class provides interface to iterate the pairs of intersected sub-shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_SubIterator self) -> BOPDS_SubIterator
        __init__(BOPDS_SubIterator self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_SubIterator

        Constructor
        theAllocator - the allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_SubIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDS(self, *args):
        """
        SetDS(BOPDS_SubIterator self, BOPDS_DS pDS)

        Sets the data structure <pDS> to process.
        It is used to access the shapes and their bounding boxes.

        :type pDS: OCC.wrapper.BOPDS.BOPDS_PDS

        """
        return _BOPDS.BOPDS_SubIterator_SetDS(self, *args)


    def DS(self, *args):
        """
        Returns the data structure

        :rtype: OCC.wrapper.BOPDS.BOPDS_DS

        """
        res = _BOPDS.BOPDS_SubIterator_DS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSubSet1(self, *args):
        """
        SetSubSet1(BOPDS_SubIterator self, NCollection_List_Standard_Integer theLI)

        Sets the first set of indices <theLI> to process

        :type theLI: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_SubIterator_SetSubSet1(self, *args)


    def SubSet1(self, *args):
        """
        Returns the first set of indices to process

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPDS.BOPDS_SubIterator_SubSet1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSubSet2(self, *args):
        """
        SetSubSet2(BOPDS_SubIterator self, NCollection_List_Standard_Integer theLI)

        Sets the second set of indices <theLI> to process

        :type theLI: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.BOPDS_SubIterator_SetSubSet2(self, *args)


    def SubSet2(self, *args):
        """
        Returns the second set of indices to process

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPDS.BOPDS_SubIterator_SubSet2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Initialize(self, *args):
        """
        Initialize(BOPDS_SubIterator self)

        Initializes the iterator


        """
        return _BOPDS.BOPDS_SubIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(BOPDS_SubIterator self) -> Standard_Boolean

        Returns true if there are more pairs of intersected shapes

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_SubIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(BOPDS_SubIterator self)

        Moves iterations ahead


        """
        return _BOPDS.BOPDS_SubIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(BOPDS_SubIterator self)

        Returns indices (DS) of intersected shapes
        theIndex1 - the index of the first shape
        theIndex2 - the index of the second shape

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.BOPDS_SubIterator_Value(self, *args)


    def Prepare(self, *args):
        """
        Prepare(BOPDS_SubIterator self)

        Perform the intersection algorithm and prepare
        the results to be used


        """
        return _BOPDS.BOPDS_SubIterator_Prepare(self, *args)


    def ExpectedLength(self, *args):
        """
        ExpectedLength(BOPDS_SubIterator self) -> Standard_Integer

        Returns the number of interfering pairs

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_SubIterator_ExpectedLength(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_SubIterator
BOPDS_SubIterator_swigregister = _BOPDS.BOPDS_SubIterator_swigregister
BOPDS_SubIterator_swigregister(BOPDS_SubIterator)

class NCollection_Vector_BOPDS_Point(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_Point self) -> NCollection_Vector< BOPDS_Point >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_Point self) -> NCollection_Vector< BOPDS_Point >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_Point self) -> NCollection_Vector< BOPDS_Point >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_Point self) -> NCollection_Vector< BOPDS_Point >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_Point self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_Point self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_Point self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_Point self, NCollection_Vector_BOPDS_Point theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_Point self, NCollection_Vector_BOPDS_Point theOther) -> NCollection_Vector_BOPDS_Point

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_Point self, BOPDS_Point theValue) -> BOPDS_Point

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_Point self) -> BOPDS_Point

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Point_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Point_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_Point self) -> BOPDS_Point

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Point_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_Point self) -> BOPDS_Point

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Point___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Point_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_Point self, Standard_Integer const theIndex) -> BOPDS_Point

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_Point self, Standard_Integer const theIndex, BOPDS_Point theValue) -> BOPDS_Point

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Point_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_Point
NCollection_Vector_BOPDS_Point_swigregister = _BOPDS.NCollection_Vector_BOPDS_Point_swigregister
NCollection_Vector_BOPDS_Point_swigregister(NCollection_Vector_BOPDS_Point)


try:
	BOPDS_VectorOfPoint = NCollection_Vector_BOPDS_Point
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self) -> NCollection_Map< BOPDS_Pair,BOPDS_PairMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self) -> NCollection_Map< BOPDS_Pair,BOPDS_PairMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _BOPDS.new_NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, BOPDS_Pair K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, BOPDS_Pair K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, BOPDS_Pair K) -> Standard_Boolean
        Contains(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theLeft, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theLeft, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theLeft, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theLeft, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher self, NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_Differ(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher
NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_swigregister = _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_swigregister
NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_swigregister(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher)

class NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper___next__(self)
NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper_swigregister = _BOPDS.NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper_swigregister
NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper_swigregister(NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher_IteratorHelper)


try:
	BOPDS_MapOfPair = NCollection_Map_BOPDS_Pair_BOPDS_PairMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BOPDS.new_NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey, NCollection_List_Standard_Integer theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey, NCollection_List_Standard_Integer theItem) -> NCollection_List_Standard_Integer

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> NCollection_List_Standard_Integer

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> NCollection_List_Standard_Integer

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> NCollection_List_Standard_Integer

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher
NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_DataMapOfPaveBlockListOfInteger = NCollection_DataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfZZ(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfZZ self) -> NCollection_Vector< BOPDS_InterfZZ >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfZZ self) -> NCollection_Vector< BOPDS_InterfZZ >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfZZ self) -> NCollection_Vector< BOPDS_InterfZZ >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfZZ self) -> NCollection_Vector< BOPDS_InterfZZ >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfZZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfZZ self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfZZ self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfZZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfZZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfZZ self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfZZ self, NCollection_Vector_BOPDS_InterfZZ theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfZZ self, NCollection_Vector_BOPDS_InterfZZ theOther) -> NCollection_Vector_BOPDS_InterfZZ

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfZZ self, BOPDS_InterfZZ theValue) -> BOPDS_InterfZZ

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfZZ self) -> BOPDS_InterfZZ

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfZZ_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfZZ self) -> BOPDS_InterfZZ

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfZZ_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfZZ self) -> BOPDS_InterfZZ

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfZZ___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfZZ_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfZZ self, Standard_Integer const theIndex) -> BOPDS_InterfZZ

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfZZ self, Standard_Integer const theIndex, BOPDS_InterfZZ theValue) -> BOPDS_InterfZZ

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfZZ_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfZZ
NCollection_Vector_BOPDS_InterfZZ_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfZZ_swigregister
NCollection_Vector_BOPDS_InterfZZ_swigregister(NCollection_Vector_BOPDS_InterfZZ)


try:
	BOPDS_VectorOfInterfZZ = NCollection_Vector_BOPDS_InterfZZ
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfVE(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfVE self) -> NCollection_Vector< BOPDS_InterfVE >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfVE self) -> NCollection_Vector< BOPDS_InterfVE >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfVE self) -> NCollection_Vector< BOPDS_InterfVE >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfVE self) -> NCollection_Vector< BOPDS_InterfVE >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfVE(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfVE self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfVE self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfVE self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfVE self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfVE self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfVE self, NCollection_Vector_BOPDS_InterfVE theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfVE self, NCollection_Vector_BOPDS_InterfVE theOther) -> NCollection_Vector_BOPDS_InterfVE

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfVE self, BOPDS_InterfVE theValue) -> BOPDS_InterfVE

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfVE self) -> BOPDS_InterfVE

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVE_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVE_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfVE self) -> BOPDS_InterfVE

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVE_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfVE self) -> BOPDS_InterfVE

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVE___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVE_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfVE self, Standard_Integer const theIndex) -> BOPDS_InterfVE

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfVE self, Standard_Integer const theIndex, BOPDS_InterfVE theValue) -> BOPDS_InterfVE

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVE_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfVE
NCollection_Vector_BOPDS_InterfVE_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfVE_swigregister
NCollection_Vector_BOPDS_InterfVE_swigregister(NCollection_Vector_BOPDS_InterfVE)


try:
	BOPDS_VectorOfInterfVE = NCollection_Vector_BOPDS_InterfVE
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _BOPDS.new_NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, BOPDS_CoupleOfPaveBlocks theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, BOPDS_CoupleOfPaveBlocks theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> BOPDS_CoupleOfPaveBlocks

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> BOPDS_CoupleOfPaveBlocks

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> BOPDS_CoupleOfPaveBlocks

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> BOPDS_CoupleOfPaveBlocks

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_swigregister = _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BOPDS.NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BOPDS_IndexedDataMapOfShapeCoupleOfPaveBlocks = NCollection_IndexedDataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BOPDS_InterfVF(BOPDS_Interf):
    """
    The class BOPDS_InterfVF is is to store the information about
    the interference of the type vertex/face 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPDS_InterfVF self) -> BOPDS_InterfVF
        __init__(BOPDS_InterfVF self, Handle_NCollection_BaseAllocator theAllocator) -> BOPDS_InterfVF

        Constructor
        @param theAllocator
        allocator to manage the memory

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPDS.new_BOPDS_InterfVF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetUV(self, *args):
        """
        SetUV(BOPDS_InterfVF self, Standard_Real const theU, Standard_Real const theV)

        Modifier
        Sets the value of parameters 
        of the point of the vertex 
        on the surface of of the face
        @param theU
        value of U parameter
        @param theV 
        value of U parameter 

        :type theU: float
        :type theV: float

        """
        return _BOPDS.BOPDS_InterfVF_SetUV(self, *args)


    def UV(self, *args):
        """
        UV(BOPDS_InterfVF self)

        Selector
        Returns the value of parameters 
        of the point of the vertex 
        on the surface of of the face
        @param theU
        value of U parameter
        @param theV 
        value of U parameter 

        :type theU: float
        :type theV: float

        """
        return _BOPDS.BOPDS_InterfVF_UV(self, *args)

    __swig_destroy__ = _BOPDS.delete_BOPDS_InterfVF
BOPDS_InterfVF_swigregister = _BOPDS.BOPDS_InterfVF_swigregister
BOPDS_InterfVF_swigregister(BOPDS_InterfVF)


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class Handle_BOPDS_PaveBlock(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BOPDS_PaveBlock self)

        Nullify the handle


        """
        return _BOPDS.Handle_BOPDS_PaveBlock_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BOPDS_PaveBlock self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BOPDS_PaveBlock self, BOPDS_PaveBlock thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theHandle) -> Handle_BOPDS_PaveBlock
        assign(Handle_BOPDS_PaveBlock self, BOPDS_PaveBlock thePtr) -> Handle_BOPDS_PaveBlock
        assign(Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theHandle) -> Handle_BOPDS_PaveBlock

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BOPDS_PaveBlock self) -> BOPDS_PaveBlock

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BOPDS_PaveBlock self) -> BOPDS_PaveBlock

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BOPDS.Handle_BOPDS_PaveBlock___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BOPDS_PaveBlock self) -> BOPDS_PaveBlock

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BOPDS.Handle_BOPDS_PaveBlock___ref__(self, *args)


    def __hash__(self):
        return _BOPDS.Handle_BOPDS_PaveBlock___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BOPDS.Handle_BOPDS_PaveBlock___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BOPDS.new_Handle_BOPDS_PaveBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BOPDS.Handle_BOPDS_PaveBlock_DownCast)
    __swig_destroy__ = _BOPDS.delete_Handle_BOPDS_PaveBlock

    def SetPave1(self, *args):
        """
        SetPave1(Handle_BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Sets the first pave <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_SetPave1(self, *args)


    def Pave1(self, *args):
        """
        Selector
        Returns the first pave

        :rtype: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        res = _BOPDS.Handle_BOPDS_PaveBlock_Pave1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPave2(self, *args):
        """
        SetPave2(Handle_BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Sets the second pave <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_SetPave2(self, *args)


    def Pave2(self, *args):
        """
        Selector
        Returns the second pave

        :rtype: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        res = _BOPDS.Handle_BOPDS_PaveBlock_Pave2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdge(self, *args):
        """
        SetEdge(Handle_BOPDS_PaveBlock self, Standard_Integer const theEdge)

        Modifier
        Sets the index of edge of pave block <theEdge>

        :type theEdge: int

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_SetEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(Handle_BOPDS_PaveBlock self) -> Standard_Integer

        Selector
        Returns the index of edge of pave block

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_Edge(self, *args)


    def HasEdge(self, *args):
        """
        HasEdge(Handle_BOPDS_PaveBlock self) -> Standard_Boolean
        HasEdge(Handle_BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the pave block has edge
        Returns the index of edge <theEdge>

        :type theEdge: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_HasEdge(self, *args)


    def SetOriginalEdge(self, *args):
        """
        SetOriginalEdge(Handle_BOPDS_PaveBlock self, Standard_Integer const theEdge)

        Modifier
        Sets the index of original edge
        of the pave block <theEdge>

        :type theEdge: int

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_SetOriginalEdge(self, *args)


    def OriginalEdge(self, *args):
        """
        OriginalEdge(Handle_BOPDS_PaveBlock self) -> Standard_Integer

        Selector
        Returns the index of original edge of pave block

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_OriginalEdge(self, *args)


    def IsSplitEdge(self, *args):
        """
        IsSplitEdge(Handle_BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the edge is equal to the original edge
        of the pave block

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IsSplitEdge(self, *args)


    def Range(self, *args):
        """
        Range(Handle_BOPDS_PaveBlock self)

        Selector
        Returns the parametric range <theT1,theT2>
        of the pave block

        :type theT1: float
        :type theT2: float

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_Range(self, *args)


    def HasSameBounds(self, *args):
        """
        HasSameBounds(Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theOther) -> Standard_Boolean

        Query
        Returns true if the pave block has pave indices
        that equal to the  pave indices of the pave block
        <theOther>

        :type theOther: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_HasSameBounds(self, *args)


    def Indices(self, *args):
        """
        Indices(Handle_BOPDS_PaveBlock self)

        Selector
        Returns the pave indices  <theIndex1,theIndex2>
        of the pave block

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_Indices(self, *args)


    def IsToUpdate(self, *args):
        """
        IsToUpdate(Handle_BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the pave block contains extra paves

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IsToUpdate(self, *args)


    def AppendExtPave(self, *args):
        """
        AppendExtPave(Handle_BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Appends extra paves <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_AppendExtPave(self, *args)


    def AppendExtPave1(self, *args):
        """
        AppendExtPave1(Handle_BOPDS_PaveBlock self, BOPDS_Pave thePave)

        Modifier
        Appends extra pave <thePave>

        :type thePave: OCC.wrapper.BOPDS.BOPDS_Pave

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_AppendExtPave1(self, *args)


    def RemoveExtPave(self, *args):
        """
        RemoveExtPave(Handle_BOPDS_PaveBlock self, Standard_Integer const theVertNum)

        Modifier
        Removes a pave with the given vertex number from extra paves

        :type theVertNum: int

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_RemoveExtPave(self, *args)


    def ExtPaves(self, *args):
        """
        Selector
        Returns the  extra paves

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPave

        """
        res = _BOPDS.Handle_BOPDS_PaveBlock_ExtPaves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeExtPaves(self, *args):
        """
        ChangeExtPaves(Handle_BOPDS_PaveBlock self) -> NCollection_List_BOPDS_Pave

        Selector / Modifier
        Returns the extra paves

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPave

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_ChangeExtPaves(self, *args)


    def Update(self, *args):
        """
        Update(Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theLPB, Standard_Boolean const theFlag)

        Modifier
        Updates the pave block. The extra paves are used
        to create new pave blocks <theLPB>.
        <theFlag> - if true, the first pave and the second
        pave are used to produce new pave blocks.

        :type theLPB: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock
        :type theFlag: bool

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_Update(self, *args)


    def ContainsParameter(self, *args):
        """
        ContainsParameter(Handle_BOPDS_PaveBlock self, Standard_Real const thePrm, Standard_Real const theTol) -> Standard_Boolean

        Query
        Returns true if the extra paves contain the pave
        with given value of the parameter <thePrm>
        <theTol>  - the value of the tolerance to compare
        <theInd>  - index of the found pave

        :type thePrm: float
        :type theTol: float
        :type theInd: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_ContainsParameter(self, *args)


    def SetShrunkData(self, *args):
        """
        SetShrunkData(Handle_BOPDS_PaveBlock self, Standard_Real const theTS1, Standard_Real const theTS2, Bnd_Box theBox, Standard_Boolean const theIsSplittable)

        Modifier
        Sets the shrunk data for the pave block
        <theTS1>,  <theTS2> - shrunk range
        <theBox> - the bounding box
        <theIsSplittable> - defines whether the edge can be split

        :type theTS1: float
        :type theTS2: float
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theIsSplittable: bool

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_SetShrunkData(self, *args)


    def ShrunkData(self, *args):
        """
        ShrunkData(Handle_BOPDS_PaveBlock self, Bnd_Box theBox)

        Selector
        Returns  the shrunk data for the pave block
        <theTS1>,  <theTS2> - shrunk range
        <theBox> - the bounding box
        <theIsSplittable> - defines whether the edge can be split

        :type theTS1: float
        :type theTS2: float
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theIsSplittable: bool

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_ShrunkData(self, *args)


    def HasShrunkData(self, *args):
        """
        HasShrunkData(Handle_BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns true if the pave block contains
        the shrunk data

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_HasShrunkData(self, *args)


    def Dump(self, *args):
        """Dump(Handle_BOPDS_PaveBlock self)"""
        return _BOPDS.Handle_BOPDS_PaveBlock_Dump(self, *args)


    def IsSplittable(self, *args):
        """
        IsSplittable(Handle_BOPDS_PaveBlock self) -> Standard_Boolean

        Query
        Returns FALSE if the pave block has a too short
        shrunk range and cannot be split, otherwise returns TRUE

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IsSplittable(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BOPDS_PaveBlock self) -> char const *

        :rtype: const char *

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPDS.Handle_BOPDS_PaveBlock_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPDS.Handle_BOPDS_PaveBlock_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BOPDS_PaveBlock self)

        Memory deallocator for transient classes


        """
        return _BOPDS.Handle_BOPDS_PaveBlock_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BOPDS_PaveBlock self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BOPDS_PaveBlock self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BOPDS_PaveBlock self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BOPDS_PaveBlock self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BOPDS_PaveBlock self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BOPDS_PaveBlock self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BOPDS_PaveBlock self)

        Increments the reference counter of this object


        """
        return _BOPDS.Handle_BOPDS_PaveBlock_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BOPDS_PaveBlock self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_PaveBlock_DecrementRefCounter(self, *args)

Handle_BOPDS_PaveBlock_swigregister = _BOPDS.Handle_BOPDS_PaveBlock_swigregister
Handle_BOPDS_PaveBlock_swigregister(Handle_BOPDS_PaveBlock)

def Handle_BOPDS_PaveBlock_DownCast(thing):
    return _BOPDS.Handle_BOPDS_PaveBlock_DownCast(thing)
Handle_BOPDS_PaveBlock_DownCast = _BOPDS.Handle_BOPDS_PaveBlock_DownCast

class BOPDS_Tools(object):
    """
    The class BOPDS_Tools contains
    a set auxiliary static functions
    of the package BOPDS
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def TypeToInteger(*args):
        """
        TypeToInteger(TopAbs_ShapeEnum const theT1, TopAbs_ShapeEnum const theT2) -> Standard_Integer
        TypeToInteger(TopAbs_ShapeEnum const theT) -> Standard_Integer

        Converts the type of shape <theT>,
        to integer value, that is returned

        :type theT: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.BOPDS_Tools_TypeToInteger(*args)

    TypeToInteger = staticmethod(TypeToInteger)

    def HasBRep(*args):
        """
        HasBRep(TopAbs_ShapeEnum const theT) -> Standard_Boolean

        Returns true if the type  <theT> correspond
        to a shape having boundary representation

        :type theT: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Tools_HasBRep(*args)

    HasBRep = staticmethod(HasBRep)

    def IsInterfering(*args):
        """
        IsInterfering(TopAbs_ShapeEnum const theT) -> Standard_Boolean

        Returns true if the type <theT> can be participant of
        an interference

        :type theT: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.BOPDS_Tools_IsInterfering(*args)

    IsInterfering = staticmethod(IsInterfering)

    def __init__(self):
        """
        The class BOPDS_Tools contains
        a set auxiliary static functions
        of the package BOPDS
        """
        this = _BOPDS.new_BOPDS_Tools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_BOPDS_Tools
BOPDS_Tools_swigregister = _BOPDS.BOPDS_Tools_swigregister
BOPDS_Tools_swigregister(BOPDS_Tools)

def BOPDS_Tools_TypeToInteger(*args):
    """
    TypeToInteger(TopAbs_ShapeEnum const theT1, TopAbs_ShapeEnum const theT2) -> Standard_Integer
    BOPDS_Tools_TypeToInteger(TopAbs_ShapeEnum const theT) -> Standard_Integer

    Converts the type of shape <theT>,
    to integer value, that is returned

    :type theT: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPDS.BOPDS_Tools_TypeToInteger(*args)

def BOPDS_Tools_HasBRep(*args):
    """
    BOPDS_Tools_HasBRep(TopAbs_ShapeEnum const theT) -> Standard_Boolean

    Returns true if the type  <theT> correspond
    to a shape having boundary representation

    :type theT: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPDS.BOPDS_Tools_HasBRep(*args)

def BOPDS_Tools_IsInterfering(*args):
    """
    BOPDS_Tools_IsInterfering(TopAbs_ShapeEnum const theT) -> Standard_Boolean

    Returns true if the type <theT> can be participant of
    an interference

    :type theT: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPDS.BOPDS_Tools_IsInterfering(*args)

class NCollection_List_BOPDS_Pave(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_BOPDS_Pave self) -> NCollection_List< BOPDS_Pave >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_BOPDS_Pave self) -> NCollection_List< BOPDS_Pave >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_BOPDS_Pave self) -> NCollection_List< BOPDS_Pave >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_BOPDS_Pave self) -> NCollection_List< BOPDS_Pave >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _BOPDS.new_NCollection_List_BOPDS_Pave(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_BOPDS_Pave self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_BOPDS_Pave self, NCollection_List_BOPDS_Pave theOther) -> NCollection_List_BOPDS_Pave

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_BOPDS_Pave self, NCollection_List_BOPDS_Pave theOther) -> NCollection_List_BOPDS_Pave

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_BOPDS_Pave self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_List_BOPDS_Pave_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_List_BOPDS_Pave_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_BOPDS_Pave self, BOPDS_Pave theItem) -> BOPDS_Pave
        Append(NCollection_List_BOPDS_Pave self, BOPDS_Pave theItem, NCollection_List< BOPDS_Pave >::Iterator & theIter)
        Append(NCollection_List_BOPDS_Pave self, NCollection_List_BOPDS_Pave theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_BOPDS_Pave self, BOPDS_Pave theItem) -> BOPDS_Pave
        Prepend(NCollection_List_BOPDS_Pave self, NCollection_List_BOPDS_Pave theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_BOPDS_Pave self)

        RemoveFirst item


        """
        return _BOPDS.NCollection_List_BOPDS_Pave_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_BOPDS_Pave self, NCollection_List< BOPDS_Pave >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_BOPDS_Pave self, BOPDS_Pave theItem, NCollection_List< BOPDS_Pave >::Iterator & theIter) -> BOPDS_Pave
        InsertBefore(NCollection_List_BOPDS_Pave self, NCollection_List_BOPDS_Pave theOther, NCollection_List< BOPDS_Pave >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_BOPDS_Pave self, BOPDS_Pave theItem, NCollection_List< BOPDS_Pave >::Iterator & theIter) -> BOPDS_Pave
        InsertAfter(NCollection_List_BOPDS_Pave self, NCollection_List_BOPDS_Pave theOther, NCollection_List< BOPDS_Pave >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BOPDS.NCollection_List_BOPDS_Pave_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_BOPDS_Pave self)

        Reverse the list


        """
        return _BOPDS.NCollection_List_BOPDS_Pave_Reverse(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_List_BOPDS_Pave___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_List_BOPDS_Pave
NCollection_List_BOPDS_Pave_swigregister = _BOPDS.NCollection_List_BOPDS_Pave_swigregister
NCollection_List_BOPDS_Pave_swigregister(NCollection_List_BOPDS_Pave)

class NCollection_List_BOPDS_Pave_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_List_BOPDS_Pave_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_List_BOPDS_Pave_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_List_BOPDS_Pave_IteratorHelper___next__(self)
NCollection_List_BOPDS_Pave_IteratorHelper_swigregister = _BOPDS.NCollection_List_BOPDS_Pave_IteratorHelper_swigregister
NCollection_List_BOPDS_Pave_IteratorHelper_swigregister(NCollection_List_BOPDS_Pave_IteratorHelper)


try:
	BOPDS_ListOfPave = NCollection_List_BOPDS_Pave
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BOPDS_CoupleOfPaveBlocks,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BOPDS.new_NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, BOPDS_CoupleOfPaveBlocks theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, BOPDS_CoupleOfPaveBlocks theItem) -> BOPDS_CoupleOfPaveBlocks

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> BOPDS_CoupleOfPaveBlocks

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> BOPDS_CoupleOfPaveBlocks

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> BOPDS_CoupleOfPaveBlocks

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_swigregister = _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BOPDS.NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BOPDS_DataMapOfShapeCoupleOfPaveBlocks = NCollection_DataMap_TopoDS_Shape_BOPDS_CoupleOfPaveBlocks_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self) -> NCollection_Map< BOPDS_Pave,BOPDS_PaveMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self) -> NCollection_Map< BOPDS_Pave,BOPDS_PaveMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _BOPDS.new_NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, BOPDS_Pave K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, BOPDS_Pave K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, BOPDS_Pave K) -> Standard_Boolean
        Contains(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theLeft, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theLeft, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theLeft, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theLeft, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher self, NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_Differ(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher
NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_swigregister = _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_swigregister
NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_swigregister(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher)

class NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper___next__(self)
NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper_swigregister = _BOPDS.NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper_swigregister
NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper_swigregister(NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher_IteratorHelper)


try:
	BOPDS_MapOfPave = NCollection_Map_BOPDS_Pave_BOPDS_PaveMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfVZ(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfVZ self) -> NCollection_Vector< BOPDS_InterfVZ >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfVZ self) -> NCollection_Vector< BOPDS_InterfVZ >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfVZ self) -> NCollection_Vector< BOPDS_InterfVZ >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfVZ self) -> NCollection_Vector< BOPDS_InterfVZ >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfVZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfVZ self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfVZ self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfVZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfVZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfVZ self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfVZ self, NCollection_Vector_BOPDS_InterfVZ theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfVZ self, NCollection_Vector_BOPDS_InterfVZ theOther) -> NCollection_Vector_BOPDS_InterfVZ

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfVZ self, BOPDS_InterfVZ theValue) -> BOPDS_InterfVZ

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfVZ self) -> BOPDS_InterfVZ

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVZ_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfVZ self) -> BOPDS_InterfVZ

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVZ_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfVZ self) -> BOPDS_InterfVZ

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVZ___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVZ_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfVZ self, Standard_Integer const theIndex) -> BOPDS_InterfVZ

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfVZ self, Standard_Integer const theIndex, BOPDS_InterfVZ theValue) -> BOPDS_InterfVZ

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVZ_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfVZ
NCollection_Vector_BOPDS_InterfVZ_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfVZ_swigregister
NCollection_Vector_BOPDS_InterfVZ_swigregister(NCollection_Vector_BOPDS_InterfVZ)


try:
	BOPDS_VectorOfInterfVZ = NCollection_Vector_BOPDS_InterfVZ
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_ListOfPaveBlock(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_Vector< BOPDS_ListOfPaveBlock >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_Vector< BOPDS_ListOfPaveBlock >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_Vector< BOPDS_ListOfPaveBlock >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_Vector< BOPDS_ListOfPaveBlock >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_ListOfPaveBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_ListOfPaveBlock self, NCollection_Vector_BOPDS_ListOfPaveBlock theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_ListOfPaveBlock self, NCollection_Vector_BOPDS_ListOfPaveBlock theOther) -> NCollection_Vector_BOPDS_ListOfPaveBlock

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_ListOfPaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theValue) -> NCollection_List_Handle_BOPDS_PaveBlock

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_List_Handle_BOPDS_PaveBlock

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_List_Handle_BOPDS_PaveBlock

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_ListOfPaveBlock self) -> NCollection_List_Handle_BOPDS_PaveBlock

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_ListOfPaveBlock self, Standard_Integer const theIndex) -> NCollection_List_Handle_BOPDS_PaveBlock

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_ListOfPaveBlock self, Standard_Integer const theIndex, NCollection_List_Handle_BOPDS_PaveBlock theValue) -> NCollection_List_Handle_BOPDS_PaveBlock

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_ListOfPaveBlock
NCollection_Vector_BOPDS_ListOfPaveBlock_swigregister = _BOPDS.NCollection_Vector_BOPDS_ListOfPaveBlock_swigregister
NCollection_Vector_BOPDS_ListOfPaveBlock_swigregister(NCollection_Vector_BOPDS_ListOfPaveBlock)


try:
	BOPDS_VectorOfListOfPaveBlock = NCollection_Vector_BOPDS_ListOfPaveBlock
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_ShapeInfo(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_ShapeInfo self) -> NCollection_Vector< BOPDS_ShapeInfo >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_ShapeInfo self) -> NCollection_Vector< BOPDS_ShapeInfo >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_ShapeInfo self) -> NCollection_Vector< BOPDS_ShapeInfo >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_ShapeInfo self) -> NCollection_Vector< BOPDS_ShapeInfo >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_ShapeInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_ShapeInfo self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_ShapeInfo self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_ShapeInfo self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_ShapeInfo self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_ShapeInfo self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_ShapeInfo self, NCollection_Vector_BOPDS_ShapeInfo theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_ShapeInfo self, NCollection_Vector_BOPDS_ShapeInfo theOther) -> NCollection_Vector_BOPDS_ShapeInfo

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_ShapeInfo self, BOPDS_ShapeInfo theValue) -> BOPDS_ShapeInfo

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_ShapeInfo self) -> BOPDS_ShapeInfo

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_ShapeInfo self) -> BOPDS_ShapeInfo

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_ShapeInfo self) -> BOPDS_ShapeInfo

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ShapeInfo___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_ShapeInfo self, Standard_Integer const theIndex) -> BOPDS_ShapeInfo

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_ShapeInfo self, Standard_Integer const theIndex, BOPDS_ShapeInfo theValue) -> BOPDS_ShapeInfo

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_ShapeInfo
NCollection_Vector_BOPDS_ShapeInfo_swigregister = _BOPDS.NCollection_Vector_BOPDS_ShapeInfo_swigregister
NCollection_Vector_BOPDS_ShapeInfo_swigregister(NCollection_Vector_BOPDS_ShapeInfo)


try:
	BOPDS_VectorOfShapeInfo = NCollection_Vector_BOPDS_ShapeInfo
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_Pair(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_Pair self) -> NCollection_Vector< BOPDS_Pair >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_Pair self) -> NCollection_Vector< BOPDS_Pair >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_Pair self) -> NCollection_Vector< BOPDS_Pair >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_Pair self) -> NCollection_Vector< BOPDS_Pair >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_Pair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_Pair self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_Pair self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_Pair self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_Pair self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_Pair self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_Pair self, NCollection_Vector_BOPDS_Pair theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_Pair self, NCollection_Vector_BOPDS_Pair theOther) -> NCollection_Vector_BOPDS_Pair

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_Pair self, BOPDS_Pair theValue) -> BOPDS_Pair

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_Pair self) -> BOPDS_Pair

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Pair_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Pair_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_Pair self) -> BOPDS_Pair

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Pair_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_Pair self) -> BOPDS_Pair

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Pair___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_Pair_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_Pair self, Standard_Integer const theIndex) -> BOPDS_Pair

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_Pair self, Standard_Integer const theIndex, BOPDS_Pair theValue) -> BOPDS_Pair

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_Pair_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_Pair
NCollection_Vector_BOPDS_Pair_swigregister = _BOPDS.NCollection_Vector_BOPDS_Pair_swigregister
NCollection_Vector_BOPDS_Pair_swigregister(NCollection_Vector_BOPDS_Pair)


try:
	BOPDS_VectorOfPair = NCollection_Vector_BOPDS_Pair
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfVV(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfVV self) -> NCollection_Vector< BOPDS_InterfVV >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfVV self) -> NCollection_Vector< BOPDS_InterfVV >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfVV self) -> NCollection_Vector< BOPDS_InterfVV >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfVV self) -> NCollection_Vector< BOPDS_InterfVV >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfVV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfVV self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfVV self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfVV self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfVV self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfVV self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfVV self, NCollection_Vector_BOPDS_InterfVV theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfVV self, NCollection_Vector_BOPDS_InterfVV theOther) -> NCollection_Vector_BOPDS_InterfVV

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfVV self, BOPDS_InterfVV theValue) -> BOPDS_InterfVV

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfVV self) -> BOPDS_InterfVV

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVV_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVV_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfVV self) -> BOPDS_InterfVV

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVV_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfVV self) -> BOPDS_InterfVV

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVV___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVV_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfVV self, Standard_Integer const theIndex) -> BOPDS_InterfVV

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfVV self, Standard_Integer const theIndex, BOPDS_InterfVV theValue) -> BOPDS_InterfVV

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVV_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfVV
NCollection_Vector_BOPDS_InterfVV_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfVV_swigregister
NCollection_Vector_BOPDS_InterfVV_swigregister(NCollection_Vector_BOPDS_InterfVV)


try:
	BOPDS_VectorOfInterfVV = NCollection_Vector_BOPDS_InterfVV
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BOPDS.new_NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey, NCollection_List_Handle_BOPDS_PaveBlock theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey, NCollection_List_Handle_BOPDS_PaveBlock theItem) -> NCollection_List_Handle_BOPDS_PaveBlock

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> NCollection_List_Handle_BOPDS_PaveBlock

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher
NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_DataMapOfPaveBlockListOfPaveBlock = NCollection_DataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,BOPDS_ListOfPaveBlock,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,BOPDS_ListOfPaveBlock,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,BOPDS_ListOfPaveBlock,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,BOPDS_ListOfPaveBlock,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BOPDS.new_NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Handle_BOPDS_PaveBlock theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Handle_BOPDS_PaveBlock theItem) -> NCollection_List_Handle_BOPDS_PaveBlock

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_BOPDS_PaveBlock

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_swigregister = _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _BOPDS.NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher_IteratorHelper)


try:
	BOPDS_DataMapOfIntegerListOfPaveBlock = NCollection_DataMap_Standard_Integer_BOPDS_ListOfPaveBlock_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _BOPDS.new_NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_BOPDS_PaveBlock theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher
NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_swigregister
NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_swigregister(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher)

class NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_IndexedMapOfPaveBlock = NCollection_IndexedMap_Handle_BOPDS_PaveBlock_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,BOPDS_ListOfPaveBlock,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _BOPDS.new_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1, NCollection_List_Handle_BOPDS_PaveBlock theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_BOPDS_PaveBlock theKey1, NCollection_List_Handle_BOPDS_PaveBlock theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Integer const theIndex) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> NCollection_List_Handle_BOPDS_PaveBlock

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> NCollection_List_Handle_BOPDS_PaveBlock

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_swigregister
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_swigregister(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher)

class NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_IndexedDataMapOfPaveBlockListOfPaveBlock = NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_BOPDS_ListOfPaveBlock_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_BOPDS_PaveBlock(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_BOPDS_PaveBlock self) -> NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_BOPDS_PaveBlock self) -> NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_BOPDS_PaveBlock self) -> NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_BOPDS_PaveBlock self) -> NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _BOPDS.new_NCollection_List_Handle_BOPDS_PaveBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_BOPDS_PaveBlock self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theOther) -> NCollection_List_Handle_BOPDS_PaveBlock

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theOther) -> NCollection_List_Handle_BOPDS_PaveBlock

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_BOPDS_PaveBlock self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theItem) -> Handle_BOPDS_PaveBlock
        Append(NCollection_List_Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theItem, NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::Iterator & theIter)
        Append(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theItem) -> Handle_BOPDS_PaveBlock
        Prepend(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_BOPDS_PaveBlock self)

        RemoveFirst item


        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theItem, NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::Iterator & theIter) -> Handle_BOPDS_PaveBlock
        InsertBefore(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theOther, NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_BOPDS_PaveBlock self, Handle_BOPDS_PaveBlock theItem, NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::Iterator & theIter) -> Handle_BOPDS_PaveBlock
        InsertAfter(NCollection_List_Handle_BOPDS_PaveBlock self, NCollection_List_Handle_BOPDS_PaveBlock theOther, NCollection_List< opencascade::handle< BOPDS_PaveBlock > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_BOPDS_PaveBlock self)

        Reverse the list


        """
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_Reverse(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_List_Handle_BOPDS_PaveBlock
NCollection_List_Handle_BOPDS_PaveBlock_swigregister = _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_swigregister
NCollection_List_Handle_BOPDS_PaveBlock_swigregister(NCollection_List_Handle_BOPDS_PaveBlock)

class NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper___next__(self)
NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper_swigregister = _BOPDS.NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper_swigregister
NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper_swigregister(NCollection_List_Handle_BOPDS_PaveBlock_IteratorHelper)


try:
	BOPDS_ListOfPaveBlock = NCollection_List_Handle_BOPDS_PaveBlock
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfVF(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfVF self) -> NCollection_Vector< BOPDS_InterfVF >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfVF self) -> NCollection_Vector< BOPDS_InterfVF >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfVF self) -> NCollection_Vector< BOPDS_InterfVF >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfVF self) -> NCollection_Vector< BOPDS_InterfVF >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfVF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfVF self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfVF self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfVF self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfVF self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfVF self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfVF self, NCollection_Vector_BOPDS_InterfVF theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfVF self, NCollection_Vector_BOPDS_InterfVF theOther) -> NCollection_Vector_BOPDS_InterfVF

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfVF self, BOPDS_InterfVF theValue) -> BOPDS_InterfVF

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfVF self) -> BOPDS_InterfVF

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVF_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVF_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfVF self) -> BOPDS_InterfVF

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVF_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfVF self) -> BOPDS_InterfVF

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVF___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfVF_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfVF self, Standard_Integer const theIndex) -> BOPDS_InterfVF

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfVF self, Standard_Integer const theIndex, BOPDS_InterfVF theValue) -> BOPDS_InterfVF

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfVF_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfVF
NCollection_Vector_BOPDS_InterfVF_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfVF_swigregister
NCollection_Vector_BOPDS_InterfVF_swigregister(NCollection_Vector_BOPDS_InterfVF)


try:
	BOPDS_VectorOfInterfVF = NCollection_Vector_BOPDS_InterfVF
except NameError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_IndexRange(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_IndexRange self) -> NCollection_Vector< BOPDS_IndexRange >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_IndexRange self) -> NCollection_Vector< BOPDS_IndexRange >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_IndexRange self) -> NCollection_Vector< BOPDS_IndexRange >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_IndexRange self) -> NCollection_Vector< BOPDS_IndexRange >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_IndexRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_IndexRange self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_IndexRange self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_IndexRange self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_IndexRange self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_IndexRange self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_IndexRange self, NCollection_Vector_BOPDS_IndexRange theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_IndexRange self, NCollection_Vector_BOPDS_IndexRange theOther) -> NCollection_Vector_BOPDS_IndexRange

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_IndexRange self, BOPDS_IndexRange theValue) -> BOPDS_IndexRange

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_IndexRange self) -> BOPDS_IndexRange

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_IndexRange_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_IndexRange_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_IndexRange self) -> BOPDS_IndexRange

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_IndexRange_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_IndexRange self) -> BOPDS_IndexRange

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_IndexRange___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_IndexRange_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_IndexRange self, Standard_Integer const theIndex) -> BOPDS_IndexRange

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_IndexRange self, Standard_Integer const theIndex, BOPDS_IndexRange theValue) -> BOPDS_IndexRange

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_IndexRange_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_IndexRange
NCollection_Vector_BOPDS_IndexRange_swigregister = _BOPDS.NCollection_Vector_BOPDS_IndexRange_swigregister
NCollection_Vector_BOPDS_IndexRange_swigregister(NCollection_Vector_BOPDS_IndexRange)


try:
	BOPDS_VectorOfIndexRange = NCollection_Vector_BOPDS_IndexRange
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< BOPDS_PaveBlock >,TColStd_ListOfInteger,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _BOPDS.new_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1, NCollection_List_Standard_Integer theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_BOPDS_PaveBlock theKey1, NCollection_List_Standard_Integer theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Integer const theIndex) -> NCollection_List_Standard_Integer

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> NCollection_List_Standard_Integer

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> NCollection_List_Standard_Integer

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey1) -> NCollection_List_Standard_Integer

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_swigregister
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_swigregister(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher)

class NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_IndexedDataMapOfPaveBlockListOfInteger = NCollection_IndexedDataMap_Handle_BOPDS_PaveBlock_TColStd_ListOfInteger_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,opencascade::handle< BOPDS_CommonBlock >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,opencascade::handle< BOPDS_CommonBlock >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,opencascade::handle< BOPDS_CommonBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< BOPDS_PaveBlock >,opencascade::handle< BOPDS_CommonBlock >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BOPDS.new_NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey, Handle_BOPDS_CommonBlock theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey, Handle_BOPDS_CommonBlock theItem) -> Handle_BOPDS_CommonBlock

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Handle_BOPDS_CommonBlock

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Handle_BOPDS_CommonBlock

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_BOPDS_PaveBlock theKey) -> Handle_BOPDS_CommonBlock

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher
NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_swigregister = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPDS.new_NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPDS.delete_NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BOPDS.NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher_IteratorHelper)


try:
	BOPDS_DataMapOfPaveBlockCommonBlock = NCollection_DataMap_Handle_BOPDS_PaveBlock_Handle_BOPDS_CommonBlock_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_ListOfInteger = TColStd.NCollection_List_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Vector_BOPDS_InterfEF(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_BOPDS_InterfEF self) -> NCollection_Vector< BOPDS_InterfEF >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_BOPDS_InterfEF self) -> NCollection_Vector< BOPDS_InterfEF >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_BOPDS_InterfEF self) -> NCollection_Vector< BOPDS_InterfEF >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_BOPDS_InterfEF self) -> NCollection_Vector< BOPDS_InterfEF >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BOPDS.new_NCollection_Vector_BOPDS_InterfEF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_BOPDS_InterfEF self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_BOPDS_InterfEF self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_BOPDS_InterfEF self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_BOPDS_InterfEF self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_BOPDS_InterfEF self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_BOPDS_InterfEF self, NCollection_Vector_BOPDS_InterfEF theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_BOPDS_InterfEF self, NCollection_Vector_BOPDS_InterfEF theOther) -> NCollection_Vector_BOPDS_InterfEF

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_BOPDS_InterfEF self, BOPDS_InterfEF theValue) -> BOPDS_InterfEF

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_BOPDS_InterfEF self) -> BOPDS_InterfEF

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEF_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEF_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_BOPDS_InterfEF self) -> BOPDS_InterfEF

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEF_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_BOPDS_InterfEF self) -> BOPDS_InterfEF

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEF___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Vector_BOPDS_InterfEF_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_BOPDS_InterfEF self, Standard_Integer const theIndex) -> BOPDS_InterfEF

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_BOPDS_InterfEF self, Standard_Integer const theIndex, BOPDS_InterfEF theValue) -> BOPDS_InterfEF

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Vector_BOPDS_InterfEF_SetValue(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Vector_BOPDS_InterfEF
NCollection_Vector_BOPDS_InterfEF_swigregister = _BOPDS.NCollection_Vector_BOPDS_InterfEF_swigregister
NCollection_Vector_BOPDS_InterfEF_swigregister(NCollection_Vector_BOPDS_InterfEF)


try:
	BOPDS_VectorOfInterfEF = NCollection_Vector_BOPDS_InterfEF
except NameError:
	pass # does not exist, probably ignored

class Handle_BOPDS_CommonBlock(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BOPDS_CommonBlock self)

        Nullify the handle


        """
        return _BOPDS.Handle_BOPDS_CommonBlock_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BOPDS_CommonBlock self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BOPDS_CommonBlock self, BOPDS_CommonBlock thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BOPDS_CommonBlock self, Handle_BOPDS_CommonBlock theHandle) -> Handle_BOPDS_CommonBlock
        assign(Handle_BOPDS_CommonBlock self, BOPDS_CommonBlock thePtr) -> Handle_BOPDS_CommonBlock
        assign(Handle_BOPDS_CommonBlock self, Handle_BOPDS_CommonBlock theHandle) -> Handle_BOPDS_CommonBlock

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BOPDS_CommonBlock self) -> BOPDS_CommonBlock

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BOPDS_CommonBlock self) -> BOPDS_CommonBlock

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BOPDS.Handle_BOPDS_CommonBlock___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BOPDS_CommonBlock self) -> BOPDS_CommonBlock

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BOPDS.Handle_BOPDS_CommonBlock___ref__(self, *args)


    def __hash__(self):
        return _BOPDS.Handle_BOPDS_CommonBlock___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BOPDS.Handle_BOPDS_CommonBlock___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BOPDS.new_Handle_BOPDS_CommonBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BOPDS.Handle_BOPDS_CommonBlock_DownCast)
    __swig_destroy__ = _BOPDS.delete_Handle_BOPDS_CommonBlock

    def AddPaveBlock(self, *args):
        """
        AddPaveBlock(Handle_BOPDS_CommonBlock self, Handle_BOPDS_PaveBlock aPB)

        Modifier
        Adds the pave block <aPB> to the list of pave blocks
        of the common block

        :type aPB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_AddPaveBlock(self, *args)


    def SetPaveBlocks(self, *args):
        """
        SetPaveBlocks(Handle_BOPDS_CommonBlock self, NCollection_List_Handle_BOPDS_PaveBlock aLPB)

        Modifier
        Adds the list of pave blocks <aLPB>
        to the list of pave blocks
        of the common block

        :type aLPB: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_SetPaveBlocks(self, *args)


    def AddFace(self, *args):
        """
        AddFace(Handle_BOPDS_CommonBlock self, Standard_Integer const aF)

        Modifier
        Adds the index of the face <aF>
        to the list of indices of faces
        of the common block

        :type aF: int

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_AddFace(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(Handle_BOPDS_CommonBlock self, NCollection_List_Standard_Integer aLF)

        Modifier
        Sets the list of indices of faces <aLF>
        of the common block

        :type aLF: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_SetFaces(self, *args)


    def AppendFaces(self, *args):
        """
        AppendFaces(Handle_BOPDS_CommonBlock self, NCollection_List_Standard_Integer aLF)

        Modifier
        Appends the list of indices of faces <aLF>
        to the list of indices of faces
        of the common block (the input list is emptied)

        :type aLF: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_AppendFaces(self, *args)


    def PaveBlocks(self, *args):
        """
        Selector
        Returns the list of pave blocks
        of the common block

        :rtype: OCC.wrapper.BOPDS.BOPDS_ListOfPaveBlock

        """
        res = _BOPDS.Handle_BOPDS_CommonBlock_PaveBlocks(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Faces(self, *args):
        """
        Selector
        Returns the list of indices of faces
        of the common block

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPDS.Handle_BOPDS_CommonBlock_Faces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PaveBlock1(self, *args):
        """
        Selector
        Returns the first pave block
        of the common block

        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        res = _BOPDS.Handle_BOPDS_CommonBlock_PaveBlock1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PaveBlockOnEdge(self, *args):
        """
        PaveBlockOnEdge(Handle_BOPDS_CommonBlock self, Standard_Integer const theIndex) -> Handle_BOPDS_PaveBlock

        Selector
        Returns the pave block that belongs
        to the edge with index <theIx>

        :type theIndex: int
        :rtype: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_PaveBlockOnEdge(self, *args)


    def IsPaveBlockOnFace(self, *args):
        """
        IsPaveBlockOnFace(Handle_BOPDS_CommonBlock self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the common block contains
        a pave block that belongs
        to the face with index <theIx>

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_IsPaveBlockOnFace(self, *args)


    def IsPaveBlockOnEdge(self, *args):
        """
        IsPaveBlockOnEdge(Handle_BOPDS_CommonBlock self, Standard_Integer const theIndex) -> Standard_Boolean

        Query
        Returns true if the common block contains
        a pave block that belongs
        to the edge with index <theIx>

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_IsPaveBlockOnEdge(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_BOPDS_CommonBlock self, Handle_BOPDS_PaveBlock thePB) -> Standard_Boolean
        Contains(Handle_BOPDS_CommonBlock self, Standard_Integer const theF) -> Standard_Boolean

        Query
        Returns true if the common block contains
        the face with index equal  to <theF>

        :type theF: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_Contains(self, *args)


    def SetEdge(self, *args):
        """
        SetEdge(Handle_BOPDS_CommonBlock self, Standard_Integer const theEdge)

        Modifier
        Assign the index <theEdge> as the edge index
        to all pave blocks of the common block

        :type theEdge: int

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_SetEdge(self, *args)


    def Edge(self, *args):
        """
        Edge(Handle_BOPDS_CommonBlock self) -> Standard_Integer

        Selector
        Returns the index of the edge
        of  all pave blocks of the common block

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_Edge(self, *args)


    def Dump(self, *args):
        """Dump(Handle_BOPDS_CommonBlock self)"""
        return _BOPDS.Handle_BOPDS_CommonBlock_Dump(self, *args)


    def SetRealPaveBlock(self, *args):
        """
        SetRealPaveBlock(Handle_BOPDS_CommonBlock self, Handle_BOPDS_PaveBlock thePB)

        Moves the pave blocks in the list to make the given
        pave block to be the first.
        It will be representative for the whole group.

        :type thePB: OCC.wrapper.BOPDS.Handle_BOPDS_PaveBlock

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_SetRealPaveBlock(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BOPDS_CommonBlock self) -> char const *

        :rtype: const char *

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPDS.Handle_BOPDS_CommonBlock_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BOPDS.Handle_BOPDS_CommonBlock_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BOPDS_CommonBlock self)

        Memory deallocator for transient classes


        """
        return _BOPDS.Handle_BOPDS_CommonBlock_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BOPDS_CommonBlock self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BOPDS_CommonBlock self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BOPDS_CommonBlock self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BOPDS_CommonBlock self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BOPDS_CommonBlock self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BOPDS_CommonBlock self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BOPDS_CommonBlock self)

        Increments the reference counter of this object


        """
        return _BOPDS.Handle_BOPDS_CommonBlock_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BOPDS_CommonBlock self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.Handle_BOPDS_CommonBlock_DecrementRefCounter(self, *args)

Handle_BOPDS_CommonBlock_swigregister = _BOPDS.Handle_BOPDS_CommonBlock_swigregister
Handle_BOPDS_CommonBlock_swigregister(Handle_BOPDS_CommonBlock)

def Handle_BOPDS_CommonBlock_DownCast(thing):
    return _BOPDS.Handle_BOPDS_CommonBlock_DownCast(thing)
Handle_BOPDS_CommonBlock_DownCast = _BOPDS.Handle_BOPDS_CommonBlock_DownCast

class NCollection_Array1_BOPDS_Pave(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_BOPDS_Pave self) -> NCollection_Array1< BOPDS_Pave >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_BOPDS_Pave self) -> NCollection_Array1< BOPDS_Pave >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_BOPDS_Pave self) -> NCollection_Array1< BOPDS_Pave >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_BOPDS_Pave self) -> NCollection_Array1< BOPDS_Pave >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _BOPDS.new_NCollection_Array1_BOPDS_Pave(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_BOPDS_Pave self, BOPDS_Pave theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_BOPDS_Pave self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_BOPDS_Pave self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_BOPDS_Pave self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_BOPDS_Pave self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_BOPDS_Pave self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_BOPDS_Pave self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_BOPDS_Pave self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_BOPDS_Pave self, NCollection_Array1_BOPDS_Pave theOther) -> NCollection_Array1_BOPDS_Pave

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_BOPDS_Pave self, NCollection_Array1_BOPDS_Pave theOther) -> NCollection_Array1_BOPDS_Pave

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_BOPDS_Pave self, NCollection_Array1_BOPDS_Pave theOther) -> NCollection_Array1_BOPDS_Pave
        assign(NCollection_Array1_BOPDS_Pave self, NCollection_Array1_BOPDS_Pave theOther) -> NCollection_Array1_BOPDS_Pave

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Array1_BOPDS_Pave_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_BOPDS_Pave self) -> BOPDS_Pave

        @return first element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Array1_BOPDS_Pave_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_BOPDS_Pave self) -> BOPDS_Pave

        @return last element

        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Array1_BOPDS_Pave_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_BOPDS_Pave self, Standard_Integer const theIndex) -> BOPDS_Pave

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Array1_BOPDS_Pave___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPDS.NCollection_Array1_BOPDS_Pave_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_BOPDS_Pave self, Standard_Integer const theIndex, BOPDS_Pave theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_BOPDS_Pave self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _BOPDS.NCollection_Array1_BOPDS_Pave_Resize(self, *args)

    __swig_destroy__ = _BOPDS.delete_NCollection_Array1_BOPDS_Pave
NCollection_Array1_BOPDS_Pave_swigregister = _BOPDS.NCollection_Array1_BOPDS_Pave_swigregister
NCollection_Array1_BOPDS_Pave_swigregister(NCollection_Array1_BOPDS_Pave)


try:
	BOPDS_VectorOfPave = NCollection_Array1_BOPDS_Pave
except NameError:
	pass # does not exist, probably ignored




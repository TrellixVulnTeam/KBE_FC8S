# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomLib')
    _GeomLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomLib', [dirname(__file__)])
        except ImportError:
            import _GeomLib
            return _GeomLib
        try:
            _mod = imp.load_module('_GeomLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomLib = swig_import_helper()
    del swig_import_helper
else:
    import _GeomLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomLib.delete_SwigPyIterator

    def value(self):
        return _GeomLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GeomLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GeomLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GeomLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GeomLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GeomLib.SwigPyIterator_copy(self)

    def next(self):
        return _GeomLib.SwigPyIterator_next(self)

    def __next__(self):
        return _GeomLib.SwigPyIterator___next__(self)

    def previous(self):
        return _GeomLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GeomLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GeomLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GeomLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GeomLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GeomLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GeomLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GeomLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GeomLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GeomLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GeomLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GeomLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GeomLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GeomLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GeomLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GeomLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GeomLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GeomLib.ptr_to_number(item)
ptr_to_number = _GeomLib.ptr_to_number

def HashCode(*args):
    return _GeomLib.HashCode(*args)
HashCode = _GeomLib.HashCode

def ptr_equal(a, b):
    return _GeomLib.ptr_equal(a, b)
ptr_equal = _GeomLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
GeomLib_NoError = _GeomLib.GeomLib_NoError
GeomLib_NotEnoughtPoints = _GeomLib.GeomLib_NotEnoughtPoints
GeomLib_DegreeSmallerThan3 = _GeomLib.GeomLib_DegreeSmallerThan3
GeomLib_InversionProblem = _GeomLib.GeomLib_InversionProblem
class GeomLib_IsPlanarSurface(object):
    """Find if a surface is a planar  surface."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_IsPlanarSurface self, Handle_Geom_Surface S, Standard_Real const Tol=1.0e-7) -> GeomLib_IsPlanarSurface

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float

        """
        this = _GeomLib.new_GeomLib_IsPlanarSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsPlanar(self, *args):
        """
        IsPlanar(GeomLib_IsPlanarSurface self) -> Standard_Boolean

        Return if the Surface is a plan

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_IsPlanarSurface_IsPlanar(self, *args)


    def Plan(self, *args):
        """
        Return the plan definition

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _GeomLib.GeomLib_IsPlanarSurface_Plan(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomLib.delete_GeomLib_IsPlanarSurface
GeomLib_IsPlanarSurface_swigregister = _GeomLib.GeomLib_IsPlanarSurface_swigregister
GeomLib_IsPlanarSurface_swigregister(GeomLib_IsPlanarSurface)

class GeomLib_Check2dBSplineCurve(object):
    """
    Checks for the end  tangents : wether or not those
    are reversed
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_Check2dBSplineCurve self, Handle_Geom2d_BSplineCurve Curve, Standard_Real const Tolerance, Standard_Real const AngularTolerance) -> GeomLib_Check2dBSplineCurve

        :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type Tolerance: float
        :type AngularTolerance: float

        """
        this = _GeomLib.new_GeomLib_Check2dBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomLib_Check2dBSplineCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_IsDone(self, *args)


    def NeedTangentFix(self, *args):
        """
        NeedTangentFix(GeomLib_Check2dBSplineCurve self)

        :type FirstFlag: bool
        :type SecondFlag: bool

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_NeedTangentFix(self, *args)


    def FixTangent(self, *args):
        """
        FixTangent(GeomLib_Check2dBSplineCurve self, Standard_Boolean const FirstFlag, Standard_Boolean const LastFlag)

        :type FirstFlag: bool
        :type LastFlag: bool

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_FixTangent(self, *args)


    def FixedTangent(self, *args):
        """
        FixedTangent(GeomLib_Check2dBSplineCurve self, Standard_Boolean const FirstFlag, Standard_Boolean const LastFlag) -> Handle_Geom2d_BSplineCurve

        modifies the curve
        by fixing the first or the last tangencies

        if Index3D not in the Range [1,Nb3dSpaces]
        if the Approx is not Done

        :type FirstFlag: bool
        :type LastFlag: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_FixedTangent(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_Check2dBSplineCurve
GeomLib_Check2dBSplineCurve_swigregister = _GeomLib.GeomLib_Check2dBSplineCurve_swigregister
GeomLib_Check2dBSplineCurve_swigregister(GeomLib_Check2dBSplineCurve)

class GeomLib_PolyFunc(math.math_FunctionWithDerivative):
    """Polynomial  Function"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_PolyFunc self, math_Vector Coeffs) -> GeomLib_PolyFunc

        :type Coeffs: OCC.wrapper.math.math_Vector

        """
        this = _GeomLib.new_GeomLib_PolyFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GeomLib_PolyFunc self, Standard_Real const X) -> Standard_Boolean

        computes the value <F>of the function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_PolyFunc_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(GeomLib_PolyFunc self, Standard_Real const X) -> Standard_Boolean

        computes the derivative <D> of the function
        for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_PolyFunc_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(GeomLib_PolyFunc self, Standard_Real const X) -> Standard_Boolean

        computes the value <F> and the derivative <D> of the
        function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_PolyFunc_Values(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_PolyFunc
GeomLib_PolyFunc_swigregister = _GeomLib.GeomLib_PolyFunc_swigregister
GeomLib_PolyFunc_swigregister(GeomLib_PolyFunc)

class GeomLib_DenominatorMultiplier(object):
    """
    this defines an evaluator for a function of 2 variables
    that will be used by CancelDenominatorDerivative in one
    direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_DenominatorMultiplier self, Handle_Geom_BSplineSurface Surface, NCollection_Array1_Standard_Real KnotVector) -> GeomLib_DenominatorMultiplier

        if the surface is rational this will define the evaluator
        of a real function of 2 variables a(u,v) such that
        if we define a new surface by :
        a(u,v) * N(u,v)
        NewF(u,v) = ----------------
        a(u,v) * D(u,v)

        :type Surface: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type KnotVector: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _GeomLib.new_GeomLib_DenominatorMultiplier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GeomLib_DenominatorMultiplier self, Standard_Real const UParameter, Standard_Real const VParameter) -> Standard_Real

        Returns the value of
        a(UParameter,VParameter)=

        H0(UParameter)/Denominator(Umin,Vparameter)

        D Denominator(Umin,Vparameter)
        - ------------------------------[H1(u)]/(Denominator(Umin,Vparameter)^2)
        D U

        + H3(UParameter)/Denominator(Umax,Vparameter)

        D Denominator(Umax,Vparameter)
        - ------------------------------[H2(u)]/(Denominator(Umax,Vparameter)^2)
        D U

        :type UParameter: float
        :type VParameter: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomLib.GeomLib_DenominatorMultiplier_Value(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_DenominatorMultiplier
GeomLib_DenominatorMultiplier_swigregister = _GeomLib.GeomLib_DenominatorMultiplier_swigregister
GeomLib_DenominatorMultiplier_swigregister(GeomLib_DenominatorMultiplier)

class GeomLib_LogSample(math.math_FunctionSample):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_LogSample self, Standard_Real const A, Standard_Real const B, Standard_Integer const N) -> GeomLib_LogSample

        :type A: float
        :type B: float
        :type N: int

        """
        this = _GeomLib.new_GeomLib_LogSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetParameter(self, *args):
        """
        GetParameter(GeomLib_LogSample self, Standard_Integer const Index) -> Standard_Real

        Returns the value of parameter of the point of
        range Index : A + ((Index-1)/(NbPoints-1))*B.
        An exception is raised if Index<=0 or Index>NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomLib.GeomLib_LogSample_GetParameter(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_LogSample
GeomLib_LogSample_swigregister = _GeomLib.GeomLib_LogSample_swigregister
GeomLib_LogSample_swigregister(GeomLib_LogSample)

class GeomLib_CheckBSplineCurve(object):
    """
    Checks for the end  tangents : wether or not those
    are reversed regarding the third or n-3rd control
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_CheckBSplineCurve self, Handle_Geom_BSplineCurve Curve, Standard_Real const Tolerance, Standard_Real const AngularTolerance) -> GeomLib_CheckBSplineCurve

        :type Curve: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type Tolerance: float
        :type AngularTolerance: float

        """
        this = _GeomLib.new_GeomLib_CheckBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomLib_CheckBSplineCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_IsDone(self, *args)


    def NeedTangentFix(self, *args):
        """
        NeedTangentFix(GeomLib_CheckBSplineCurve self)

        :type FirstFlag: bool
        :type SecondFlag: bool

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_NeedTangentFix(self, *args)


    def FixTangent(self, *args):
        """
        FixTangent(GeomLib_CheckBSplineCurve self, Standard_Boolean const FirstFlag, Standard_Boolean const LastFlag)

        :type FirstFlag: bool
        :type LastFlag: bool

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_FixTangent(self, *args)


    def FixedTangent(self, *args):
        """
        FixedTangent(GeomLib_CheckBSplineCurve self, Standard_Boolean const FirstFlag, Standard_Boolean const LastFlag) -> Handle_Geom_BSplineCurve

        modifies the curve
        by fixing the first or the last tangencies

        if Index3D not in the Range [1,Nb3dSpaces]
        if the Approx is not Done

        :type FirstFlag: bool
        :type LastFlag: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_FixedTangent(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_CheckBSplineCurve
GeomLib_CheckBSplineCurve_swigregister = _GeomLib.GeomLib_CheckBSplineCurve_swigregister
GeomLib_CheckBSplineCurve_swigregister(GeomLib_CheckBSplineCurve)

class GeomLib_MakeCurvefromApprox(object):
    """
    this class is used to  construct the BSpline curve
    from an Approximation ( ApproxAFunction from AdvApprox).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_MakeCurvefromApprox self, AdvApprox_ApproxAFunction Approx) -> GeomLib_MakeCurvefromApprox

        :type Approx: OCC.wrapper.AdvApprox.AdvApprox_ApproxAFunction

        """
        this = _GeomLib.new_GeomLib_MakeCurvefromApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomLib_MakeCurvefromApprox self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_IsDone(self, *args)


    def Nb1DSpaces(self, *args):
        """
        Nb1DSpaces(GeomLib_MakeCurvefromApprox self) -> Standard_Integer

        returns the number of 1D spaces of the Approx

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb1DSpaces(self, *args)


    def Nb2DSpaces(self, *args):
        """
        Nb2DSpaces(GeomLib_MakeCurvefromApprox self) -> Standard_Integer

        returns the number of 3D spaces of the Approx

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb2DSpaces(self, *args)


    def Nb3DSpaces(self, *args):
        """
        Nb3DSpaces(GeomLib_MakeCurvefromApprox self) -> Standard_Integer

        returns the number of 3D spaces of the Approx

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb3DSpaces(self, *args)


    def Curve2dFromTwo1d(self, *args):
        """
        Curve2dFromTwo1d(GeomLib_MakeCurvefromApprox self, Standard_Integer const Index1d, Standard_Integer const Index2d) -> Handle_Geom2d_BSplineCurve

        returns a 2D curve building it from the 1D curve
        in x at Index1d and y at Index2d amongst the
        1D curves
        if Index1d not in the Range [1,Nb1dSpaces]
        if Index2d not in the Range [1,Nb1dSpaces]
        if the Approx is not Done

        :type Index1d: int
        :type Index2d: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve2dFromTwo1d(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(GeomLib_MakeCurvefromApprox self, Standard_Integer const Index2d) -> Handle_Geom2d_BSplineCurve
        Curve2d(GeomLib_MakeCurvefromApprox self, Standard_Integer const Index1d, Standard_Integer const Index2d) -> Handle_Geom2d_BSplineCurve

        returns a rational curve whose poles correspond to
        the index2d of the 2D space and whose weights correspond
        to one dimensional space of index 1d
        if Index1d not in the Range [1,Nb1dSpaces]
        if Index2d not in the Range [1,Nb2dSpaces]
        if the Approx is not Done

        :type Index1d: int
        :type Index2d: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve2d(self, *args)


    def Curve(self, *args):
        """
        Curve(GeomLib_MakeCurvefromApprox self, Standard_Integer const Index3d) -> Handle_Geom_BSplineCurve
        Curve(GeomLib_MakeCurvefromApprox self, Standard_Integer const Index1D, Standard_Integer const Index3D) -> Handle_Geom_BSplineCurve

        returns a rational curve whose poles correspond to
        the index3D of the 3D space and whose weights correspond
        to the index1d 1D space.
        if Index1D not in the Range [1,Nb1dSpaces]
        if Index3D not in the Range [1,Nb3dSpaces]
        if the Approx is not Done

        :type Index1D: int
        :type Index3D: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_MakeCurvefromApprox
GeomLib_MakeCurvefromApprox_swigregister = _GeomLib.GeomLib_MakeCurvefromApprox_swigregister
GeomLib_MakeCurvefromApprox_swigregister(GeomLib_MakeCurvefromApprox)

class GeomLib_Interpolate(object):
    """
    this class is used to construct a BSpline curve by
    interpolation  of points  at given parameters  The
    continuity   of the curve   is degree -  1 and the
    method used when boundary  condition are not given
    is to use odd degrees  and null the derivatives on
    both sides from degree -1 down to (degree+1) / 2
    When even degree is given the returned curve is of
    degree - 1 so that the degree of the curve is odd
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_Interpolate self, Standard_Integer const Degree, Standard_Integer const NumPoints, NCollection_Array1_gp_Pnt Points, NCollection_Array1_Standard_Real Parameters) -> GeomLib_Interpolate

        :type Degree: int
        :type NumPoints: int
        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _GeomLib.new_GeomLib_Interpolate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomLib_Interpolate self) -> Standard_Boolean

        returns if everything went OK

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_Interpolate_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(GeomLib_Interpolate self) -> GeomLib_InterpolationErrors

        returns the error type if any

        :rtype: OCC.wrapper.GeomLib.GeomLib_InterpolationErrors

        """
        return _GeomLib.GeomLib_Interpolate_Error(self, *args)


    def Curve(self, *args):
        """
        Curve(GeomLib_Interpolate self) -> Handle_Geom_BSplineCurve

        returns the interpolated curve of the requested degree

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomLib.GeomLib_Interpolate_Curve(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_Interpolate
GeomLib_Interpolate_swigregister = _GeomLib.GeomLib_Interpolate_swigregister
GeomLib_Interpolate_swigregister(GeomLib_Interpolate)

class GeomLib_(object):
    """
    Geom    Library.    This   package   provides   an
    implementation of  functions for basic computation
    on geometric entity from packages Geom and Geom2d.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def To3d(*args):
        """
        To3d(gp_Ax2 Position, Handle_Geom2d_Curve Curve2d) -> Handle_Geom_Curve

        Computes     the  curve  3d    from  package  Geom
        corresponding to curve 2d  from package Geom2d, on
        the plan defined with the local coordinate system
        Position.

        :type Position: OCC.wrapper.gp.gp_Ax2
        :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomLib.GeomLib__To3d(*args)

    To3d = staticmethod(To3d)

    def GTransform(*args):
        """
        GTransform(Handle_Geom2d_Curve Curve, gp_GTrsf2d GTrsf) -> Handle_Geom2d_Curve

        Computes the    curve    3d  from   package   Geom
        corresponding  to the curve  3d from package Geom,
        transformed with the transformation <GTrsf>
        WARNING : this method may return a null Handle if
        it's impossible to compute the transformation of
        a curve. It's not implemented when :
        1) the curve is an infinite parabola or hyperbola
        2) the curve is an offsetcurve

        :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type GTrsf: OCC.wrapper.gp.gp_GTrsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _GeomLib.GeomLib__GTransform(*args)

    GTransform = staticmethod(GTransform)

    def SameRange(*args):
        """
        SameRange(Standard_Real const Tolerance, Handle_Geom2d_Curve Curve2dPtr, Standard_Real const First, Standard_Real const Last, Standard_Real const RequestedFirst, Standard_Real const RequestedLast, Handle_Geom2d_Curve NewCurve2dPtr)

        Make the curve Curve2dPtr have the imposed
        range First to List the most economic way,
        that is if it can change the range without
        changing the nature of the curve it will try
        to do that. Otherwise it will produce a Bspline
        curve that has the required range

        :type Tolerance: float
        :type Curve2dPtr: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :type RequestedFirst: float
        :type RequestedLast: float
        :type NewCurve2dPtr: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _GeomLib.GeomLib__SameRange(*args)

    SameRange = staticmethod(SameRange)

    def BuildCurve3d(*args):
        """
        BuildCurve3d(Standard_Real const Tolerance, Adaptor3d_CurveOnSurface CurvePtr, Standard_Real const FirstParameter, Standard_Real const LastParameter, Handle_Geom_Curve NewCurvePtr, GeomAbs_Shape const Continuity=GeomAbs_C1, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=30)

        :type Tolerance: float
        :type CurvePtr: OCC.wrapper.Adaptor3d.Adaptor3d_CurveOnSurface
        :type FirstParameter: float
        :type LastParameter: float
        :type NewCurvePtr: OCC.wrapper.Geom.Handle_Geom_Curve
        :type MaxDeviation: float
        :type AverageDeviation: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSegment: int

        """
        return _GeomLib.GeomLib__BuildCurve3d(*args)

    BuildCurve3d = staticmethod(BuildCurve3d)

    def AdjustExtremity(*args):
        """
        AdjustExtremity(Handle_Geom_BoundedCurve Curve, gp_Pnt P1, gp_Pnt P2, gp_Vec T1, gp_Vec T2)

        :type Curve: OCC.wrapper.Geom.Handle_Geom_BoundedCurve
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type T1: OCC.wrapper.gp.gp_Vec
        :type T2: OCC.wrapper.gp.gp_Vec

        """
        return _GeomLib.GeomLib__AdjustExtremity(*args)

    AdjustExtremity = staticmethod(AdjustExtremity)

    def ExtendCurveToPoint(*args):
        """
        ExtendCurveToPoint(Handle_Geom_BoundedCurve Curve, gp_Pnt Point, Standard_Integer const Cont, Standard_Boolean const After)

        Extends the bounded curve Curve to the point Point.
        The extension is built:
        -      at the end of the curve if After equals true, or
        -      at the beginning of the curve if After equals false.
        The extension is performed according to a degree of
        continuity equal to Cont, which in its turn must be equal to 1, 2 or 3.
        This function converts the bounded curve Curve into a BSpline curve.
        Warning
        -   Nothing is done, and Curve is not modified if Cont is
        not equal to 1, 2 or 3.
        -   It is recommended that the extension should not be
        too large with respect to the size of the bounded
        curve Curve: Point must not be located too far from
        one of the extremities of Curve.

        :type Curve: OCC.wrapper.Geom.Handle_Geom_BoundedCurve
        :type Point: OCC.wrapper.gp.gp_Pnt
        :type Cont: int
        :type After: bool

        """
        return _GeomLib.GeomLib__ExtendCurveToPoint(*args)

    ExtendCurveToPoint = staticmethod(ExtendCurveToPoint)

    def ExtendSurfByLength(*args):
        """
        ExtendSurfByLength(Handle_Geom_BoundedSurface Surf, Standard_Real const Length, Standard_Integer const Cont, Standard_Boolean const InU, Standard_Boolean const After)

        Extends the bounded surface Surf along one of its
        boundaries. The chord length of the extension is equal to Length.
        The direction of the extension is given as:
        -   the u parametric direction of Surf, if InU equals true,   or
        -   the v parametric direction of Surf, if InU equals false.
        In this parametric direction, the extension is built on the side of:
        -   the last parameter of Surf, if After equals true, or
        -   the first parameter of Surf, if After equals false.
        The extension is performed according to a degree of
        continuity equal to Cont, which in its turn must be equal to 1, 2 or 3.
        This function converts the bounded surface Surf into a BSpline surface.
        Warning
        -   Nothing is done, and Surf is not modified if Cont is
        not equal to 1, 2 or 3.
        -   It is recommended that Length, the size of the
        extension should not be too large with respect to the
        size of the bounded surface Surf.
        -   Surf must not be a periodic BSpline surface in the
        parametric direction corresponding to the direction of extension.

        :type Surf: OCC.wrapper.Geom.Handle_Geom_BoundedSurface
        :type Length: float
        :type Cont: int
        :type InU: bool
        :type After: bool

        """
        return _GeomLib.GeomLib__ExtendSurfByLength(*args)

    ExtendSurfByLength = staticmethod(ExtendSurfByLength)

    def AxeOfInertia(*args):
        """
        AxeOfInertia(NCollection_Array1_gp_Pnt Points, gp_Ax2 Axe, Standard_Real const Tol=1.0e-7)

        Compute   axes of inertia,  of some  points --  -- --
        <Axe>.Location() is the   BaryCentre -- -- --   -- --
        <Axe>.XDirection is the axe of upper inertia -- -- --
        -- <Axe>.Direction is the Normal to the average plane
        -- -- -- IsSingular is True if  points are on line --
        Tol is used to determine singular cases.

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Axe: OCC.wrapper.gp.gp_Ax2
        :type IsSingular: bool
        :type Tol: float

        """
        return _GeomLib.GeomLib__AxeOfInertia(*args)

    AxeOfInertia = staticmethod(AxeOfInertia)

    def Inertia(*args):
        """
        Inertia(NCollection_Array1_gp_Pnt Points, gp_Pnt Bary, gp_Dir XDir, gp_Dir YDir)

        Compute principale axes  of  inertia, and dispertion
        value  of some  points.

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Bary: OCC.wrapper.gp.gp_Pnt
        :type XDir: OCC.wrapper.gp.gp_Dir
        :type YDir: OCC.wrapper.gp.gp_Dir
        :type Xgap: float
        :type YGap: float
        :type ZGap: float

        """
        return _GeomLib.GeomLib__Inertia(*args)

    Inertia = staticmethod(Inertia)

    def RemovePointsFromArray(*args):
        """
        RemovePointsFromArray(Standard_Integer const NumPoints, NCollection_Array1_Standard_Real InParameters, Handle_TColStd_HArray1OfReal OutParameters)

        Warning!  This assume that the InParameter is an increasing sequence
        of real number and it will not check for that : Unpredictable
        result can happen if this is not satisfied. It is the caller
        responsability to check for that property.

        This  method makes uniform NumPoints segments S1,...SNumPoints out
        of the segment defined by the first parameter and the
        last  parameter ofthe  InParameter ; keeps   only one
        point of the InParameters set of parameter in each of
        the uniform segments taking care of the first and the
        last   parameters. For the ith segment the element of
        the InParameter is the one that is the first to exceed
        the midpoint of the segment and to fall before the
        midpoint of the next segment
        There  will be  at  the  end at   most NumPoints + 1  if
        NumPoints > 2 in the OutParameters Array

        :type NumPoints: int
        :type InParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type OutParameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _GeomLib.GeomLib__RemovePointsFromArray(*args)

    RemovePointsFromArray = staticmethod(RemovePointsFromArray)

    def DensifyArray1OfReal(*args):
        """
        DensifyArray1OfReal(Standard_Integer const MinNumPoints, NCollection_Array1_Standard_Real InParameters, Handle_TColStd_HArray1OfReal OutParameters)

        this  makes sure that there  is at least MinNumPoints
        in OutParameters taking into account the parameters in
        the InParameters array provided those are in order,
        that is the sequence of real in the InParameter is strictly
        non decreasing

        :type MinNumPoints: int
        :type InParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type OutParameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _GeomLib.GeomLib__DensifyArray1OfReal(*args)

    DensifyArray1OfReal = staticmethod(DensifyArray1OfReal)

    def FuseIntervals(*args):
        """
        FuseIntervals(NCollection_Array1_Standard_Real Interval1, NCollection_Array1_Standard_Real Interval2, NCollection_Sequence_Standard_Real Fusion, Standard_Real const Confusion=1.0e-9)

        :type Interval1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Interval2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Fusion: OCC.wrapper.TColStd.TColStd_SequenceOfReal
        :type Confusion: float

        """
        return _GeomLib.GeomLib__FuseIntervals(*args)

    FuseIntervals = staticmethod(FuseIntervals)

    def EvalMaxParametricDistance(*args):
        """
        EvalMaxParametricDistance(Adaptor3d_Curve Curve, Adaptor3d_Curve AReferenceCurve, Standard_Real const Tolerance, NCollection_Array1_Standard_Real Parameters)

        this  will compute   the   maximum distance  at  the
        parameters  given    in   the Parameters  array    by
        evaluating each parameter  the two curves  and taking
        the maximum of the evaluated distance

        :type Curve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type AReferenceCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Tolerance: float
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type MaxDistance: float

        """
        return _GeomLib.GeomLib__EvalMaxParametricDistance(*args)

    EvalMaxParametricDistance = staticmethod(EvalMaxParametricDistance)

    def EvalMaxDistanceAlongParameter(*args):
        """
        EvalMaxDistanceAlongParameter(Adaptor3d_Curve Curve, Adaptor3d_Curve AReferenceCurve, Standard_Real const Tolerance, NCollection_Array1_Standard_Real Parameters)

        this will compute the maximum distancef at the parameters
        given in the Parameters array by projecting from the Curve
        to the reference curve and taking the minimum distance
        Than the maximum will be taken on those minimas.

        :type Curve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type AReferenceCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Tolerance: float
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type MaxDistance: float

        """
        return _GeomLib.GeomLib__EvalMaxDistanceAlongParameter(*args)

    EvalMaxDistanceAlongParameter = staticmethod(EvalMaxDistanceAlongParameter)

    def CancelDenominatorDerivative(*args):
        """
        CancelDenominatorDerivative(Handle_Geom_BSplineSurface BSurf, Standard_Boolean const UDirection, Standard_Boolean const VDirection)

        Cancel,on the boudaries,the denominator  first derivative
        in  the directions wished by the user and set its value to 1.

        :type BSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type UDirection: bool
        :type VDirection: bool

        """
        return _GeomLib.GeomLib__CancelDenominatorDerivative(*args)

    CancelDenominatorDerivative = staticmethod(CancelDenominatorDerivative)

    def NormEstim(*args):
        """
        NormEstim(Handle_Geom_Surface S, gp_Pnt2d UV, Standard_Real const Tol, gp_Dir N) -> Standard_Integer

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UV: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float
        :type N: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.GeomLib__NormEstim(*args)

    NormEstim = staticmethod(NormEstim)

    def IsClosed(*args):
        """
        IsClosed(Handle_Geom_Surface S, Standard_Real const Tol)

        This method defines if opposite boundaries of surface
        coincide with given tolerance

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float
        :type isUClosed: bool
        :type isVClosed: bool

        """
        return _GeomLib.GeomLib__IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsBSplUClosed(*args):
        """
        IsBSplUClosed(Handle_Geom_BSplineSurface S, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Boolean

        Returns true if the poles of U1 isoline and the poles of
        U2 isoline of surface are identical according to tolerance criterion.
        For rational surfaces Weights(i)*Poles(i) are checked.

        :type S: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type U1: float
        :type U2: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib__IsBSplUClosed(*args)

    IsBSplUClosed = staticmethod(IsBSplUClosed)

    def IsBSplVClosed(*args):
        """
        IsBSplVClosed(Handle_Geom_BSplineSurface S, Standard_Real const V1, Standard_Real const V2, Standard_Real const Tol) -> Standard_Boolean

        Returns true if the poles of V1 isoline and the poles of
        V2 isoline of surface are identical according to tolerance criterion.
        For rational surfaces Weights(i)*Poles(i) are checked.

        :type S: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type V1: float
        :type V2: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib__IsBSplVClosed(*args)

    IsBSplVClosed = staticmethod(IsBSplVClosed)

    def IsBzUClosed(*args):
        """
        IsBzUClosed(Handle_Geom_BezierSurface S, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Boolean

        Returns true if the poles of U1 isoline and the poles of
        U2 isoline of surface are identical according to tolerance criterion.

        :type S: OCC.wrapper.Geom.Handle_Geom_BezierSurface
        :type U1: float
        :type U2: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib__IsBzUClosed(*args)

    IsBzUClosed = staticmethod(IsBzUClosed)

    def IsBzVClosed(*args):
        """
        IsBzVClosed(Handle_Geom_BezierSurface S, Standard_Real const V1, Standard_Real const V2, Standard_Real const Tol) -> Standard_Boolean

        Returns true if the poles of V1 isoline and the poles of
        V2 isoline of surface are identical according to tolerance criterion.

        :type S: OCC.wrapper.Geom.Handle_Geom_BezierSurface
        :type V1: float
        :type V2: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib__IsBzVClosed(*args)

    IsBzVClosed = staticmethod(IsBzVClosed)

    def __init__(self):
        """
        Geom    Library.    This   package   provides   an
        implementation of  functions for basic computation
        on geometric entity from packages Geom and Geom2d.
        """
        this = _GeomLib.new_GeomLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomLib.delete_GeomLib_
GeomLib__swigregister = _GeomLib.GeomLib__swigregister
GeomLib__swigregister(GeomLib_)

def GeomLib__To3d(*args):
    """
    GeomLib__To3d(gp_Ax2 Position, Handle_Geom2d_Curve Curve2d) -> Handle_Geom_Curve

    Computes     the  curve  3d    from  package  Geom
    corresponding to curve 2d  from package Geom2d, on
    the plan defined with the local coordinate system
    Position.

    :type Position: OCC.wrapper.gp.gp_Ax2
    :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _GeomLib.GeomLib__To3d(*args)

def GeomLib__GTransform(*args):
    """
    GeomLib__GTransform(Handle_Geom2d_Curve Curve, gp_GTrsf2d GTrsf) -> Handle_Geom2d_Curve

    Computes the    curve    3d  from   package   Geom
    corresponding  to the curve  3d from package Geom,
    transformed with the transformation <GTrsf>
    WARNING : this method may return a null Handle if
    it's impossible to compute the transformation of
    a curve. It's not implemented when :
    1) the curve is an infinite parabola or hyperbola
    2) the curve is an offsetcurve

    :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type GTrsf: OCC.wrapper.gp.gp_GTrsf2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _GeomLib.GeomLib__GTransform(*args)

def GeomLib__SameRange(*args):
    """
    GeomLib__SameRange(Standard_Real const Tolerance, Handle_Geom2d_Curve Curve2dPtr, Standard_Real const First, Standard_Real const Last, Standard_Real const RequestedFirst, Standard_Real const RequestedLast, Handle_Geom2d_Curve NewCurve2dPtr)

    Make the curve Curve2dPtr have the imposed
    range First to List the most economic way,
    that is if it can change the range without
    changing the nature of the curve it will try
    to do that. Otherwise it will produce a Bspline
    curve that has the required range

    :type Tolerance: float
    :type Curve2dPtr: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type First: float
    :type Last: float
    :type RequestedFirst: float
    :type RequestedLast: float
    :type NewCurve2dPtr: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _GeomLib.GeomLib__SameRange(*args)

def GeomLib__BuildCurve3d(*args):
    """
    GeomLib__BuildCurve3d(Standard_Real const Tolerance, Adaptor3d_CurveOnSurface CurvePtr, Standard_Real const FirstParameter, Standard_Real const LastParameter, Handle_Geom_Curve NewCurvePtr, GeomAbs_Shape const Continuity=GeomAbs_C1, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=30)

    :type Tolerance: float
    :type CurvePtr: OCC.wrapper.Adaptor3d.Adaptor3d_CurveOnSurface
    :type FirstParameter: float
    :type LastParameter: float
    :type NewCurvePtr: OCC.wrapper.Geom.Handle_Geom_Curve
    :type MaxDeviation: float
    :type AverageDeviation: float
    :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type MaxDegree: int
    :type MaxSegment: int

    """
    return _GeomLib.GeomLib__BuildCurve3d(*args)

def GeomLib__AdjustExtremity(*args):
    """
    GeomLib__AdjustExtremity(Handle_Geom_BoundedCurve Curve, gp_Pnt P1, gp_Pnt P2, gp_Vec T1, gp_Vec T2)

    :type Curve: OCC.wrapper.Geom.Handle_Geom_BoundedCurve
    :type P1: OCC.wrapper.gp.gp_Pnt
    :type P2: OCC.wrapper.gp.gp_Pnt
    :type T1: OCC.wrapper.gp.gp_Vec
    :type T2: OCC.wrapper.gp.gp_Vec

    """
    return _GeomLib.GeomLib__AdjustExtremity(*args)

def GeomLib__ExtendCurveToPoint(*args):
    """
    GeomLib__ExtendCurveToPoint(Handle_Geom_BoundedCurve Curve, gp_Pnt Point, Standard_Integer const Cont, Standard_Boolean const After)

    Extends the bounded curve Curve to the point Point.
    The extension is built:
    -      at the end of the curve if After equals true, or
    -      at the beginning of the curve if After equals false.
    The extension is performed according to a degree of
    continuity equal to Cont, which in its turn must be equal to 1, 2 or 3.
    This function converts the bounded curve Curve into a BSpline curve.
    Warning
    -   Nothing is done, and Curve is not modified if Cont is
    not equal to 1, 2 or 3.
    -   It is recommended that the extension should not be
    too large with respect to the size of the bounded
    curve Curve: Point must not be located too far from
    one of the extremities of Curve.

    :type Curve: OCC.wrapper.Geom.Handle_Geom_BoundedCurve
    :type Point: OCC.wrapper.gp.gp_Pnt
    :type Cont: int
    :type After: bool

    """
    return _GeomLib.GeomLib__ExtendCurveToPoint(*args)

def GeomLib__ExtendSurfByLength(*args):
    """
    GeomLib__ExtendSurfByLength(Handle_Geom_BoundedSurface Surf, Standard_Real const Length, Standard_Integer const Cont, Standard_Boolean const InU, Standard_Boolean const After)

    Extends the bounded surface Surf along one of its
    boundaries. The chord length of the extension is equal to Length.
    The direction of the extension is given as:
    -   the u parametric direction of Surf, if InU equals true,   or
    -   the v parametric direction of Surf, if InU equals false.
    In this parametric direction, the extension is built on the side of:
    -   the last parameter of Surf, if After equals true, or
    -   the first parameter of Surf, if After equals false.
    The extension is performed according to a degree of
    continuity equal to Cont, which in its turn must be equal to 1, 2 or 3.
    This function converts the bounded surface Surf into a BSpline surface.
    Warning
    -   Nothing is done, and Surf is not modified if Cont is
    not equal to 1, 2 or 3.
    -   It is recommended that Length, the size of the
    extension should not be too large with respect to the
    size of the bounded surface Surf.
    -   Surf must not be a periodic BSpline surface in the
    parametric direction corresponding to the direction of extension.

    :type Surf: OCC.wrapper.Geom.Handle_Geom_BoundedSurface
    :type Length: float
    :type Cont: int
    :type InU: bool
    :type After: bool

    """
    return _GeomLib.GeomLib__ExtendSurfByLength(*args)

def GeomLib__AxeOfInertia(*args):
    """
    GeomLib__AxeOfInertia(NCollection_Array1_gp_Pnt Points, gp_Ax2 Axe, Standard_Real const Tol=1.0e-7)

    Compute   axes of inertia,  of some  points --  -- --
    <Axe>.Location() is the   BaryCentre -- -- --   -- --
    <Axe>.XDirection is the axe of upper inertia -- -- --
    -- <Axe>.Direction is the Normal to the average plane
    -- -- -- IsSingular is True if  points are on line --
    Tol is used to determine singular cases.

    :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type Axe: OCC.wrapper.gp.gp_Ax2
    :type IsSingular: bool
    :type Tol: float

    """
    return _GeomLib.GeomLib__AxeOfInertia(*args)

def GeomLib__Inertia(*args):
    """
    GeomLib__Inertia(NCollection_Array1_gp_Pnt Points, gp_Pnt Bary, gp_Dir XDir, gp_Dir YDir)

    Compute principale axes  of  inertia, and dispertion
    value  of some  points.

    :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type Bary: OCC.wrapper.gp.gp_Pnt
    :type XDir: OCC.wrapper.gp.gp_Dir
    :type YDir: OCC.wrapper.gp.gp_Dir
    :type Xgap: float
    :type YGap: float
    :type ZGap: float

    """
    return _GeomLib.GeomLib__Inertia(*args)

def GeomLib__RemovePointsFromArray(*args):
    """
    GeomLib__RemovePointsFromArray(Standard_Integer const NumPoints, NCollection_Array1_Standard_Real InParameters, Handle_TColStd_HArray1OfReal OutParameters)

    Warning!  This assume that the InParameter is an increasing sequence
    of real number and it will not check for that : Unpredictable
    result can happen if this is not satisfied. It is the caller
    responsability to check for that property.

    This  method makes uniform NumPoints segments S1,...SNumPoints out
    of the segment defined by the first parameter and the
    last  parameter ofthe  InParameter ; keeps   only one
    point of the InParameters set of parameter in each of
    the uniform segments taking care of the first and the
    last   parameters. For the ith segment the element of
    the InParameter is the one that is the first to exceed
    the midpoint of the segment and to fall before the
    midpoint of the next segment
    There  will be  at  the  end at   most NumPoints + 1  if
    NumPoints > 2 in the OutParameters Array

    :type NumPoints: int
    :type InParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type OutParameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _GeomLib.GeomLib__RemovePointsFromArray(*args)

def GeomLib__DensifyArray1OfReal(*args):
    """
    GeomLib__DensifyArray1OfReal(Standard_Integer const MinNumPoints, NCollection_Array1_Standard_Real InParameters, Handle_TColStd_HArray1OfReal OutParameters)

    this  makes sure that there  is at least MinNumPoints
    in OutParameters taking into account the parameters in
    the InParameters array provided those are in order,
    that is the sequence of real in the InParameter is strictly
    non decreasing

    :type MinNumPoints: int
    :type InParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type OutParameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _GeomLib.GeomLib__DensifyArray1OfReal(*args)

def GeomLib__FuseIntervals(*args):
    """
    GeomLib__FuseIntervals(NCollection_Array1_Standard_Real Interval1, NCollection_Array1_Standard_Real Interval2, NCollection_Sequence_Standard_Real Fusion, Standard_Real const Confusion=1.0e-9)

    :type Interval1: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Interval2: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Fusion: OCC.wrapper.TColStd.TColStd_SequenceOfReal
    :type Confusion: float

    """
    return _GeomLib.GeomLib__FuseIntervals(*args)

def GeomLib__EvalMaxParametricDistance(*args):
    """
    GeomLib__EvalMaxParametricDistance(Adaptor3d_Curve Curve, Adaptor3d_Curve AReferenceCurve, Standard_Real const Tolerance, NCollection_Array1_Standard_Real Parameters)

    this  will compute   the   maximum distance  at  the
    parameters  given    in   the Parameters  array    by
    evaluating each parameter  the two curves  and taking
    the maximum of the evaluated distance

    :type Curve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type AReferenceCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type Tolerance: float
    :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type MaxDistance: float

    """
    return _GeomLib.GeomLib__EvalMaxParametricDistance(*args)

def GeomLib__EvalMaxDistanceAlongParameter(*args):
    """
    GeomLib__EvalMaxDistanceAlongParameter(Adaptor3d_Curve Curve, Adaptor3d_Curve AReferenceCurve, Standard_Real const Tolerance, NCollection_Array1_Standard_Real Parameters)

    this will compute the maximum distancef at the parameters
    given in the Parameters array by projecting from the Curve
    to the reference curve and taking the minimum distance
    Than the maximum will be taken on those minimas.

    :type Curve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type AReferenceCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type Tolerance: float
    :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type MaxDistance: float

    """
    return _GeomLib.GeomLib__EvalMaxDistanceAlongParameter(*args)

def GeomLib__CancelDenominatorDerivative(*args):
    """
    GeomLib__CancelDenominatorDerivative(Handle_Geom_BSplineSurface BSurf, Standard_Boolean const UDirection, Standard_Boolean const VDirection)

    Cancel,on the boudaries,the denominator  first derivative
    in  the directions wished by the user and set its value to 1.

    :type BSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
    :type UDirection: bool
    :type VDirection: bool

    """
    return _GeomLib.GeomLib__CancelDenominatorDerivative(*args)

def GeomLib__NormEstim(*args):
    """
    GeomLib__NormEstim(Handle_Geom_Surface S, gp_Pnt2d UV, Standard_Real const Tol, gp_Dir N) -> Standard_Integer

    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type UV: OCC.wrapper.gp.gp_Pnt2d
    :type Tol: float
    :type N: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GeomLib.GeomLib__NormEstim(*args)

def GeomLib__IsClosed(*args):
    """
    GeomLib__IsClosed(Handle_Geom_Surface S, Standard_Real const Tol)

    This method defines if opposite boundaries of surface
    coincide with given tolerance

    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type Tol: float
    :type isUClosed: bool
    :type isVClosed: bool

    """
    return _GeomLib.GeomLib__IsClosed(*args)

def GeomLib__IsBSplUClosed(*args):
    """
    GeomLib__IsBSplUClosed(Handle_Geom_BSplineSurface S, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Boolean

    Returns true if the poles of U1 isoline and the poles of
    U2 isoline of surface are identical according to tolerance criterion.
    For rational surfaces Weights(i)*Poles(i) are checked.

    :type S: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
    :type U1: float
    :type U2: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomLib.GeomLib__IsBSplUClosed(*args)

def GeomLib__IsBSplVClosed(*args):
    """
    GeomLib__IsBSplVClosed(Handle_Geom_BSplineSurface S, Standard_Real const V1, Standard_Real const V2, Standard_Real const Tol) -> Standard_Boolean

    Returns true if the poles of V1 isoline and the poles of
    V2 isoline of surface are identical according to tolerance criterion.
    For rational surfaces Weights(i)*Poles(i) are checked.

    :type S: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
    :type V1: float
    :type V2: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomLib.GeomLib__IsBSplVClosed(*args)

def GeomLib__IsBzUClosed(*args):
    """
    GeomLib__IsBzUClosed(Handle_Geom_BezierSurface S, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Boolean

    Returns true if the poles of U1 isoline and the poles of
    U2 isoline of surface are identical according to tolerance criterion.

    :type S: OCC.wrapper.Geom.Handle_Geom_BezierSurface
    :type U1: float
    :type U2: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomLib.GeomLib__IsBzUClosed(*args)

def GeomLib__IsBzVClosed(*args):
    """
    GeomLib__IsBzVClosed(Handle_Geom_BezierSurface S, Standard_Real const V1, Standard_Real const V2, Standard_Real const Tol) -> Standard_Boolean

    Returns true if the poles of V1 isoline and the poles of
    V2 isoline of surface are identical according to tolerance criterion.

    :type S: OCC.wrapper.Geom.Handle_Geom_BezierSurface
    :type V1: float
    :type V2: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomLib.GeomLib__IsBzVClosed(*args)

class GeomLib_CheckCurveOnSurface(object):
    """
    Computes the max distance between 3D-curve and 2D-curve
    in some surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomLib_CheckCurveOnSurface self) -> GeomLib_CheckCurveOnSurface
        __init__(GeomLib_CheckCurveOnSurface self, Handle_Geom_Curve theCurve, Handle_Geom_Surface theSurface, Standard_Real const theFirst, Standard_Real const theLast, Standard_Real const theTolRange) -> GeomLib_CheckCurveOnSurface

        Contructor

        :type theCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theFirst: float
        :type theLast: float
        :type theTolRange: float

        """
        this = _GeomLib.new_GeomLib_CheckCurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomLib_CheckCurveOnSurface self, Handle_Geom_Curve theCurve, Handle_Geom_Surface theSurface, Standard_Real const theFirst, Standard_Real const theLast, Standard_Real const theTolRange)
        Init(GeomLib_CheckCurveOnSurface self)

        Initializes all members by dafault values


        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomLib_CheckCurveOnSurface self, Handle_Geom2d_Curve thePCurve, Standard_Boolean const isTheMultyTheradDisabled)

        Computes the max distance for the 3d curve <myCurve>
        and 2d curve <thePCurve>
        If isTheMultyTheadDisabled == TRUE then computation will be made
        without any parallelization.

        :type thePCurve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type isTheMultyTheradDisabled: bool

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_Perform(self, *args)


    def Curve(self, *args):
        """
        Returns my3DCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _GeomLib.GeomLib_CheckCurveOnSurface_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        Returns mySurface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _GeomLib.GeomLib_CheckCurveOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Range(self, *args):
        """
        Range(GeomLib_CheckCurveOnSurface self)

        Returns first and last parameter of the curves
        (2D- and 3D-curves are considered to have same range)

        :type theFirst: float
        :type theLast: float

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_Range(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomLib_CheckCurveOnSurface self) -> Standard_Boolean

        Returns true if the max distance has been found

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_IsDone(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GeomLib_CheckCurveOnSurface self) -> Standard_Integer

        Returns error status
        The possible values are:
        0 - OK;
        1 - null curve or surface or 2d curve;
        2 - invalid parametric range;
        3 - error in calculations.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_ErrorStatus(self, *args)


    def MaxDistance(self, *args):
        """
        MaxDistance(GeomLib_CheckCurveOnSurface self) -> Standard_Real

        Returns max distance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_MaxDistance(self, *args)


    def MaxParameter(self, *args):
        """
        MaxParameter(GeomLib_CheckCurveOnSurface self) -> Standard_Real

        Returns parameter in which the distance is maximal

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_MaxParameter(self, *args)

    __swig_destroy__ = _GeomLib.delete_GeomLib_CheckCurveOnSurface
GeomLib_CheckCurveOnSurface_swigregister = _GeomLib.GeomLib_CheckCurveOnSurface_swigregister
GeomLib_CheckCurveOnSurface_swigregister(GeomLib_CheckCurveOnSurface)

class NCollection_Array1_gp_Mat(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_gp_Mat self) -> NCollection_Array1< gp_Mat >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _GeomLib.NCollection_Array1_gp_Mat_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_gp_Mat self) -> NCollection_Array1< gp_Mat >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _GeomLib.NCollection_Array1_gp_Mat_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_gp_Mat self) -> NCollection_Array1< gp_Mat >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _GeomLib.NCollection_Array1_gp_Mat_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_gp_Mat self) -> NCollection_Array1< gp_Mat >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _GeomLib.NCollection_Array1_gp_Mat_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _GeomLib.new_NCollection_Array1_gp_Mat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_gp_Mat self, gp_Mat theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_gp_Mat self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_gp_Mat self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_gp_Mat self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.NCollection_Array1_gp_Mat_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_gp_Mat self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_gp_Mat self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_gp_Mat self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.NCollection_Array1_gp_Mat_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_gp_Mat self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.NCollection_Array1_gp_Mat_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_gp_Mat self, NCollection_Array1_gp_Mat theOther) -> NCollection_Array1_gp_Mat

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_gp_Mat self, NCollection_Array1_gp_Mat theOther) -> NCollection_Array1_gp_Mat

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_gp_Mat self, NCollection_Array1_gp_Mat theOther) -> NCollection_Array1_gp_Mat
        assign(NCollection_Array1_gp_Mat self, NCollection_Array1_gp_Mat theOther) -> NCollection_Array1_gp_Mat

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomLib.NCollection_Array1_gp_Mat_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _GeomLib.NCollection_Array1_gp_Mat_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_gp_Mat self) -> gp_Mat

        @return first element

        :rtype: TheItemType &

        """
        return _GeomLib.NCollection_Array1_gp_Mat_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _GeomLib.NCollection_Array1_gp_Mat_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_gp_Mat self) -> gp_Mat

        @return last element

        :rtype: TheItemType &

        """
        return _GeomLib.NCollection_Array1_gp_Mat_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomLib.NCollection_Array1_gp_Mat_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_gp_Mat self, Standard_Integer const theIndex) -> gp_Mat

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomLib.NCollection_Array1_gp_Mat_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomLib.NCollection_Array1_gp_Mat___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomLib.NCollection_Array1_gp_Mat_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_gp_Mat self, Standard_Integer const theIndex, gp_Mat theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomLib.NCollection_Array1_gp_Mat_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_gp_Mat self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _GeomLib.NCollection_Array1_gp_Mat_Resize(self, *args)

    __swig_destroy__ = _GeomLib.delete_NCollection_Array1_gp_Mat
NCollection_Array1_gp_Mat_swigregister = _GeomLib.NCollection_Array1_gp_Mat_swigregister
NCollection_Array1_gp_Mat_swigregister(NCollection_Array1_gp_Mat)


try:
	GeomLib_Array1OfMat = NCollection_Array1_gp_Mat
except NameError:
	pass # does not exist, probably ignored

class GeomLib_Tool(object):
    """
    Provides various methods with Geom2d and Geom curves and surfaces.
    The methods of this class compute the parameter(s) of a given point on a
    curve or a surface. To get the valid result the point must be located rather close 
    to the curve (surface) or at least to allow getting unambiguous result
    (do not put point at center of circle...),
    but choice of "trust" distance between curve/surface and point is 
    responcibility of user (parameter MaxDist).
    Return FALSE if the point is beyond the MaxDist
    limit or if computation fails.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Parameters(*args):
        """
        Parameters(Handle_Geom_Surface Surface, gp_Pnt Point, Standard_Real const MaxDist) -> Standard_Boolean

        Extracts the parameter of a 3D point lying on a surface
        or at a distance less than the MaxDist value.

        :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Point: OCC.wrapper.gp.gp_Pnt
        :type MaxDist: float
        :type U: float
        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_Tool_Parameters(*args)

    Parameters = staticmethod(Parameters)

    def Parameter(*args):
        """
        Parameter(Handle_Geom_Curve Curve, gp_Pnt Point, Standard_Real const MaxDist) -> Standard_Boolean
        Parameter(Handle_Geom2d_Curve Curve, gp_Pnt2d Point, Standard_Real const MaxDist) -> Standard_Boolean

        Extracts the parameter of a 2D point lying on a 2D curve
        or at a distance less than the MaxDist value.

        :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type MaxDist: float
        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomLib.GeomLib_Tool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def __init__(self):
        """
        Provides various methods with Geom2d and Geom curves and surfaces.
        The methods of this class compute the parameter(s) of a given point on a
        curve or a surface. To get the valid result the point must be located rather close 
        to the curve (surface) or at least to allow getting unambiguous result
        (do not put point at center of circle...),
        but choice of "trust" distance between curve/surface and point is 
        responcibility of user (parameter MaxDist).
        Return FALSE if the point is beyond the MaxDist
        limit or if computation fails.
        """
        this = _GeomLib.new_GeomLib_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomLib.delete_GeomLib_Tool
GeomLib_Tool_swigregister = _GeomLib.GeomLib_Tool_swigregister
GeomLib_Tool_swigregister(GeomLib_Tool)

def GeomLib_Tool_Parameters(*args):
    """
    GeomLib_Tool_Parameters(Handle_Geom_Surface Surface, gp_Pnt Point, Standard_Real const MaxDist) -> Standard_Boolean

    Extracts the parameter of a 3D point lying on a surface
    or at a distance less than the MaxDist value.

    :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type Point: OCC.wrapper.gp.gp_Pnt
    :type MaxDist: float
    :type U: float
    :type V: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomLib.GeomLib_Tool_Parameters(*args)

def GeomLib_Tool_Parameter(*args):
    """
    Parameter(Handle_Geom_Curve Curve, gp_Pnt Point, Standard_Real const MaxDist) -> Standard_Boolean
    GeomLib_Tool_Parameter(Handle_Geom2d_Curve Curve, gp_Pnt2d Point, Standard_Real const MaxDist) -> Standard_Boolean

    Extracts the parameter of a 2D point lying on a 2D curve
    or at a distance less than the MaxDist value.

    :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type MaxDist: float
    :type U: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomLib.GeomLib_Tool_Parameter(*args)




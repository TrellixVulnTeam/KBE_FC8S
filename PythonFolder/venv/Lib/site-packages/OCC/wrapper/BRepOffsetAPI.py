# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepOffsetAPI')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepOffsetAPI')
    _BRepOffsetAPI = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepOffsetAPI', [dirname(__file__)])
        except ImportError:
            import _BRepOffsetAPI
            return _BRepOffsetAPI
        try:
            _mod = imp.load_module('_BRepOffsetAPI', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepOffsetAPI = swig_import_helper()
    del swig_import_helper
else:
    import _BRepOffsetAPI
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepOffsetAPI.delete_SwigPyIterator

    def value(self):
        return _BRepOffsetAPI.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepOffsetAPI.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepOffsetAPI.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepOffsetAPI.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepOffsetAPI.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepOffsetAPI.SwigPyIterator_copy(self)

    def next(self):
        return _BRepOffsetAPI.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepOffsetAPI.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepOffsetAPI.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepOffsetAPI.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepOffsetAPI.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepOffsetAPI.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepOffsetAPI.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepOffsetAPI.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepOffsetAPI.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepOffsetAPI.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepOffsetAPI.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepOffsetAPI.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepOffsetAPI.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepOffsetAPI.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepOffsetAPI.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffsetAPI.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepOffsetAPI.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepOffsetAPI.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepOffsetAPI.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepOffsetAPI.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepOffsetAPI.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepOffsetAPI.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepOffsetAPI.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffsetAPI.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepOffsetAPI.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepOffsetAPI.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepOffsetAPI.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepOffsetAPI.ptr_to_number(item)
ptr_to_number = _BRepOffsetAPI.ptr_to_number

def HashCode(*args):
    return _BRepOffsetAPI.HashCode(*args)
HashCode = _BRepOffsetAPI.HashCode

def ptr_equal(a, b):
    return _BRepOffsetAPI.ptr_equal(a, b)
ptr_equal = _BRepOffsetAPI.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepOffset
else:
    import BRepOffset
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAlgo
else:
    import BRepAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepDS
else:
    import TopOpeBRepDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepBuild
else:
    import TopOpeBRepBuild
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomFill
else:
    import GeomFill
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppBlend
else:
    import AppBlend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Draft
else:
    import Draft
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepFill
else:
    import BRepFill
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepMAT2d
else:
    import BRepMAT2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom2d
else:
    import TColGeom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MAT
else:
    import MAT
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bisector
else:
    import Bisector
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccInt
else:
    import GccInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomPlate
else:
    import GeomPlate
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Plate
else:
    import Plate
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomLProp
else:
    import GeomLProp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApp2Var
else:
    import AdvApp2Var
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepPrimAPI
else:
    import BRepPrimAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepPrim
else:
    import BRepPrim
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepSweep
else:
    import BRepSweep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Sweep
else:
    import Sweep
del _swig_python_version_info
class NCollection_Sequence_TopTools_SequenceOfShape(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TopTools_SequenceOfShape self) -> NCollection_Sequence< TopTools_SequenceOfShape >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TopTools_SequenceOfShape self) -> NCollection_Sequence< TopTools_SequenceOfShape >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TopTools_SequenceOfShape self) -> NCollection_Sequence< TopTools_SequenceOfShape >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TopTools_SequenceOfShape self) -> NCollection_Sequence< TopTools_SequenceOfShape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepOffsetAPI.new_NCollection_Sequence_TopTools_SequenceOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TopTools_SequenceOfShape self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TopTools_SequenceOfShape self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TopTools_SequenceOfShape self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TopTools_SequenceOfShape self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TopTools_SequenceOfShape self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TopTools_SequenceOfShape self)

        Reverse sequence


        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TopTools_SequenceOfShape self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence_TopTools_SequenceOfShape theOther) -> NCollection_Sequence_TopTools_SequenceOfShape

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence_TopTools_SequenceOfShape theOther) -> NCollection_Sequence_TopTools_SequenceOfShape

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence< TopTools_SequenceOfShape >::Iterator & thePosition)
        Remove(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence_TopoDS_Shape theItem)
        Append(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence_TopTools_SequenceOfShape theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence_TopoDS_Shape theItem)
        Prepend(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence_TopTools_SequenceOfShape theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex, NCollection_Sequence_TopoDS_Shape theItem)
        InsertBefore(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex, NCollection_Sequence_TopTools_SequenceOfShape theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TopTools_SequenceOfShape self, NCollection_Sequence< TopTools_SequenceOfShape >::Iterator & thePosition, NCollection_Sequence_TopoDS_Shape theItem)
        InsertAfter(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex, NCollection_Sequence_TopTools_SequenceOfShape theSeq)
        InsertAfter(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex, NCollection_Sequence_TopoDS_Shape theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex, NCollection_Sequence_TopTools_SequenceOfShape theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TopTools_SequenceOfShape self) -> NCollection_Sequence_TopoDS_Shape

        First item access

        :rtype: TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TopTools_SequenceOfShape self) -> NCollection_Sequence_TopoDS_Shape

        Last item access

        :rtype: TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex) -> NCollection_Sequence_TopoDS_Shape

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TopTools_SequenceOfShape self, Standard_Integer const theIndex, NCollection_Sequence_TopoDS_Shape theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_SetValue(self, *args)


    def __iter__(self):
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape___iter__(self)
    __swig_destroy__ = _BRepOffsetAPI.delete_NCollection_Sequence_TopTools_SequenceOfShape
NCollection_Sequence_TopTools_SequenceOfShape_swigregister = _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_swigregister
NCollection_Sequence_TopTools_SequenceOfShape_swigregister(NCollection_Sequence_TopTools_SequenceOfShape)

def NCollection_Sequence_TopTools_SequenceOfShape_delNode(*args):
    """
    NCollection_Sequence_TopTools_SequenceOfShape_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_delNode(*args)

class NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepOffsetAPI.new_NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffsetAPI.delete_NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper

    def __next__(self):
        return _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper___next__(self)
NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper_swigregister = _BRepOffsetAPI.NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper_swigregister
NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper_swigregister(NCollection_Sequence_TopTools_SequenceOfShape_IteratorHelper)


try:
	BRepOffsetAPI_SequenceOfSequenceOfShape = NCollection_Sequence_TopTools_SequenceOfShape
except NameError:
	pass # does not exist, probably ignored

class BRepOffsetAPI_DraftAngle(BRepBuilderAPI.BRepBuilderAPI_ModifyShape):
    """
    Taper-adding transformations on a shape.
    The resulting shape is constructed by defining one face
    to be tapered after another one, as well as the
    geometric properties of their tapered transformation.
    Each tapered transformation is propagated along the
    series of faces which are tangential to one another and
    which contains the face to be tapered.
    This algorithm is useful in the construction of molds or
    dies. It facilitates the removal of the article being produced.
    A DraftAngle object provides a framework for:
    - initializing the construction algorithm with a given shape,
    - acquiring the data characterizing the faces to be tapered,
    - implementing the construction algorithm, and
    - consulting the results.
    Warning
    - This algorithm treats planar, cylindrical and conical faces.
    - Do not use shapes, which with a draft angle added to
    a face would modify the topology. This would, for
    example, involve creation of new vertices, edges or
    faces, or suppression of existing vertices, edges or faces.
    - Any face, which is continuous in tangency with the
    face to be tapered, will also be tapered. These
    connected faces must also respect the above criteria.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_DraftAngle self) -> BRepOffsetAPI_DraftAngle
        __init__(BRepOffsetAPI_DraftAngle self, TopoDS_Shape S) -> BRepOffsetAPI_DraftAngle

        Initializes an algorithm to perform taper-adding
        transformations on faces of the shape S.
        S will be referred to as the initial shape of the algorithm.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_DraftAngle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepOffsetAPI_DraftAngle self)

        Cancels the results of all taper-adding transformations
        performed by this algorithm on the initial shape. These
        results will have been defined by successive calls to the function Add.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Clear(self, *args)


    def Init(self, *args):
        """
        Init(BRepOffsetAPI_DraftAngle self, TopoDS_Shape S)

        Initializes, or reinitializes this taper-adding algorithm with the shape S.
        S will be referred to as the initial shape of this algorithm.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepOffsetAPI_DraftAngle self, TopoDS_Face F, gp_Dir Direction, Standard_Real const Angle, gp_Pln NeutralPlane, Standard_Boolean const Flag)

        Adds the face F, the direction
        Direction, the angle Angle, the plane NeutralPlane, and the flag
        Flag to the framework created at construction time, and with this
        data, defines the taper-adding transformation.
        F is a face, which belongs to the initial shape of this algorithm or
        to the shape loaded by the function Init.
        Only planar, cylindrical or conical faces can be tapered:
        - If the face F is planar, it is tapered by inclining it
        through the angle Angle about the line of intersection between the
        plane NeutralPlane and F.
        Direction indicates the side of NeutralPlane from which matter is
        removed if Angle is positive or added if Angle is negative.
        - If F is cylindrical or conical, it is transformed in the
        same way on a single face, resulting in a conical face if F
        is cylindrical, and a conical or cylindrical face if it is already conical.
        The taper-adding transformation is propagated from the face F along
        the series of planar, cylindrical or conical faces containing F,
        which are tangential to one another.
        Use the function AddDone to check if this taper-adding transformation is successful.
        Warning
        Nothing is done if:
        - the face F does not belong to the initial shape of this algorithm, or
        - the face F is not planar, cylindrical or conical.
        Exceptions
        - Standard_NullObject if the initial shape is not
        defined, i.e. if this algorithm has not been initialized
        with the non-empty constructor or the Init function.
        - Standard_ConstructionError if the previous call to
        Add has failed. The function AddDone ought to have
        been used to check for this, and the function Remove
        to cancel the results of the unsuccessful taper-adding
        transformation and to retrieve the previous shape.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Direction: OCC.wrapper.gp.gp_Dir
        :type Angle: float
        :type NeutralPlane: OCC.wrapper.gp.gp_Pln
        :type Flag: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Add(self, *args)


    def AddDone(self, *args):
        """
        AddDone(BRepOffsetAPI_DraftAngle self) -> Standard_Boolean

        Returns true if the previous taper-adding
        transformation performed by this algorithm in the last
        call to Add, was successful.
        If AddDone returns false:
        - the function ProblematicShape returns the face
        on which the error occurred,
        - the function Remove has to be used to cancel the
        results of the unsuccessful taper-adding
        transformation and to retrieve the previous shape.
        Exceptions
        Standard_NullObject if the initial shape has not
        been defined, i.e. if this algorithm has not been
        initialized with the non-empty constructor or the .Init function.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_AddDone(self, *args)


    def Remove(self, *args):
        """
        Remove(BRepOffsetAPI_DraftAngle self, TopoDS_Face F)

        Cancels the taper-adding transformation previously
        performed by this algorithm on the face F and the
        series of tangential faces which contain F, and retrieves
        the shape before the last taper-adding transformation.
        Warning
        You will have to use this function if the previous call to
        Add fails. Use the function AddDone to check it.
        Exceptions
        - Standard_NullObject if the initial shape has not
        been defined, i.e. if this algorithm has not been
        initialized with the non-empty constructor or the Init function.
        - Standard_NoSuchObject if F has not been added
        or has already been removed.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Remove(self, *args)


    def ProblematicShape(self, *args):
        """
        Returns the shape on which an error occurred after an
        unsuccessful call to Add or when IsDone returns false.
        Exceptions
        Standard_NullObject if the initial shape has not been
        defined, i.e. if this algorithm has not been initialized with
        the non-empty constructor or the Init function.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_ProblematicShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(BRepOffsetAPI_DraftAngle self) -> Draft_ErrorStatus

        Returns an error  status when an error has occured
        (Face,   Edge    or Vertex  recomputaion problem).
        Otherwise returns Draft_NoError. The method may be
        called if AddDone  returns Standard_False, or when
        IsDone returns Standard_False.

        :rtype: OCC.wrapper.Draft.Draft_ErrorStatus

        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Status(self, *args)


    def ConnectedFaces(self, *args):
        """
        Returns all  the  faces   which  have been   added
        together with the face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_ConnectedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedFaces(self, *args):
        """
        Returns all the faces  on which a modification has
        been given.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_ModifiedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepOffsetAPI_DraftAngle self)

        Builds the resulting shape (redefined from MakeShape).


        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Build(self, *args)


    def CorrectWires(self, *args):
        """CorrectWires(BRepOffsetAPI_DraftAngle self)"""
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_CorrectWires(self, *args)


    def Generated(self, *args):
        """
        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepOffsetAPI_DraftAngle self, TopoDS_Shape S) -> TopoDS_Shape

        Returns the modified shape corresponding to <S>.
        S can correspond to the entire initial shape or to its subshape.
        Raises exceptions
        Standard_NoSuchObject if S is not the initial shape or
        a subshape of the initial shape to which the
        transformation has been applied. 

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_ModifiedShape(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_DraftAngle
BRepOffsetAPI_DraftAngle_swigregister = _BRepOffsetAPI.BRepOffsetAPI_DraftAngle_swigregister
BRepOffsetAPI_DraftAngle_swigregister(BRepOffsetAPI_DraftAngle)

class BRepOffsetAPI_MiddlePath(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Describes functions to build a middle path of a
    pipe-like shape
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MiddlePath self, TopoDS_Shape aShape, TopoDS_Shape StartShape, TopoDS_Shape EndShape) -> BRepOffsetAPI_MiddlePath

        General constructor.
        StartShape and EndShape may be
        a wire or a face

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type StartShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type EndShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MiddlePath(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MiddlePath self)

        This is  called by  Shape().  It does  nothing but
        may be redefined.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MiddlePath_Build(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MiddlePath
BRepOffsetAPI_MiddlePath_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MiddlePath_swigregister
BRepOffsetAPI_MiddlePath_swigregister(BRepOffsetAPI_MiddlePath)

class BRepOffsetAPI_MakeOffsetShape(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Describes functions to build a shell out of a shape. The
    result is an unlooped shape parallel to the source shape.
    A MakeOffsetShape object provides a framework for:
    - defining the construction of a shell
    - implementing the construction algorithm
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakeOffsetShape self) -> BRepOffsetAPI_MakeOffsetShape
        __init__(BRepOffsetAPI_MakeOffsetShape self, TopoDS_Shape S, Standard_Real const Offset, Standard_Real const Tol, BRepOffset_Mode const Mode=BRepOffset_Skin, Standard_Boolean const Intersection, Standard_Boolean const SelfInter, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const RemoveIntEdges) -> BRepOffsetAPI_MakeOffsetShape

        Deprecated constructor. Please avoid usage of this constructor.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Offset: float
        :type Tol: float
        :type Mode: OCC.wrapper.BRepOffset.BRepOffset_Mode
        :type Intersection: bool
        :type SelfInter: bool
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type RemoveIntEdges: bool

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakeOffsetShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def PerformBySimple(self, *args):
        """
        PerformBySimple(BRepOffsetAPI_MakeOffsetShape self, TopoDS_Shape theS, Standard_Real const theOffsetValue)

        Constructs offset shape for the given one using simple algorithm without intersections computation.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOffsetValue: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_PerformBySimple(self, *args)


    def PerformByJoin(self, *args):
        """
        PerformByJoin(BRepOffsetAPI_MakeOffsetShape self, TopoDS_Shape S, Standard_Real const Offset, Standard_Real const Tol, BRepOffset_Mode const Mode=BRepOffset_Skin, Standard_Boolean const Intersection, Standard_Boolean const SelfInter, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const RemoveIntEdges)

        Constructs a shape parallel to the shape S, where
        - S may be a face, a shell, a solid or a compound of these shape kinds;
        - Offset is the offset value. The offset shape is constructed:
        - outside S, if Offset is positive,
        - inside S, if Offset is negative;
        - Tol defines the coincidence tolerance criterion for generated shapes;
        - Mode defines the construction type of parallels
        applied to the free edges of shape S; currently, only one
        construction type is implemented, namely the one where the free
        edges do not generate parallels; this corresponds to the default
        value BRepOffset_Skin;
        - Intersection specifies how the algorithm must work in
        order to limit the parallels to two adjacent shapes:
        - if Intersection is false (default value), the intersection
        is calculated with the parallels to the two adjacent shapes,
        - if Intersection is true, the intersection is calculated by
        taking all generated parallels into account; this computation method is
        more general as it avoids some self-intersections generated in the
        offset shape from features of small dimensions on shape S, however this
        method has not been completely implemented and therefore is not
        recommended for use;
        - SelfInter tells the algorithm whether a computation
        to eliminate self-intersections must be applied to the resulting
        shape; however, as this functionality is not yet
        implemented, it is recommended to use the default value (false);
        - Join defines how to fill the holes that may appear between
        parallels to the two adjacent faces. It may take values
        GeomAbs_Arc or GeomAbs_Intersection:
        - if Join is equal to GeomAbs_Arc, then pipes are generated
        between two free edges of two adjacent parallels,
        and spheres are generated on "images" of vertices;
        it is the default value,
        - if Join is equal to GeomAbs_Intersection, then the parallels to the
        two adjacent faces are enlarged and intersected,
        so that there are no free edges on parallels to faces.
        RemoveIntEdges flag defines whether to remove the INTERNAL edges 
        from the result or not.
        Warnings
        1. All the faces of the shape S should be based on the surfaces
        with continuity at least C1.
        2. The offset value should be sufficiently small to avoid
        self-intersections in resulting shape. Otherwise these
        self-intersections may appear inside an offset face if its
        initial surface is not plane or sphere or cylinder, also some
        non-adjacent offset faces may intersect each other. Also, some
        offset surfaces may "turn inside out".
        3. The algorithm may fail if the shape S contains vertices where
        more than 3 edges converge.
        4. Since 3d-offset algorithm involves intersection of surfaces,
        it is under limitations of surface intersection algorithm.
        5. A result cannot be generated if the underlying geometry of S is
        BSpline with continuity C0.
        Exceptions
        Geom_UndefinedDerivative if the underlying
        geometry of S is BSpline with continuity C0.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Offset: float
        :type Tol: float
        :type Mode: OCC.wrapper.BRepOffset.BRepOffset_Mode
        :type Intersection: bool
        :type SelfInter: bool
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type RemoveIntEdges: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_PerformByJoin(self, *args)


    def MakeOffset(self, *args):
        """
        Returns instance of the unrelying intersection / arc algorithm.

        :rtype: OCC.wrapper.BRepOffset.BRepOffset_MakeOffset

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_MakeOffset(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakeOffsetShape self)

        Does nothing.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_Build(self, *args)


    def Generated(self, *args):
        """
        Returns the  list   of shapes generated from the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GeneratedEdge(self, *args):
        """
        Returns the list of edges generated from the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_GeneratedEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetJoinType(self, *args):
        """
        GetJoinType(BRepOffsetAPI_MakeOffsetShape self) -> GeomAbs_JoinType

        Returns offset join type.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_JoinType

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_GetJoinType(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakeOffsetShape
BRepOffsetAPI_MakeOffsetShape_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakeOffsetShape_swigregister
BRepOffsetAPI_MakeOffsetShape_swigregister(BRepOffsetAPI_MakeOffsetShape)


try:
	TColStd_SequenceOfReal = TColStd.NCollection_Sequence_Standard_Real
except AttributeError:
	pass # does not exist, probably ignored

class BRepOffsetAPI_MakeDraft(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """Build a draft surface along a wire"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakeDraft self, TopoDS_Shape Shape, gp_Dir Dir, Standard_Real const Angle) -> BRepOffsetAPI_MakeDraft

        Constructs the draft surface object defined by the shape
        Shape, the direction Dir, and the angle Angle.
        Shape must be a TopoDS_Wire, Topo_DS_Face or
        TopoDS_Shell with free boundaries.
        Exceptions
        Standard_NotDone if Shape is not a TopoDS_Wire,
        Topo_DS_Face or TopoDS_Shell with free boundaries.

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Dir: OCC.wrapper.gp.gp_Dir
        :type Angle: float

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakeDraft(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetOptions(self, *args):
        """
        SetOptions(BRepOffsetAPI_MakeDraft self, BRepBuilderAPI_TransitionMode const Style=BRepBuilderAPI_RightCorner, Standard_Real const AngleMin=0.01, Standard_Real const AngleMax=3.0)

        Sets the options of this draft tool.
        If a transition has to be performed, it can be defined by
        the mode Style as RightCorner or RoundCorner,
        RightCorner being a corner defined by a sharp angle,
        and RoundCorner being a rounded corner.
        AngleMin is an angular tolerance used to detect
        whether a transition has to be performed or not.
        AngleMax sets the maximum value within which a
        RightCorner transition can be performed.
        AngleMin and AngleMax are expressed in radians.

        :type Style: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_TransitionMode
        :type AngleMin: float
        :type AngleMax: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeDraft_SetOptions(self, *args)


    def SetDraft(self, *args):
        """
        SetDraft(BRepOffsetAPI_MakeDraft self, Standard_Boolean const IsInternal)

        Sets the direction of the draft for this object.
        If IsInternal is true, the draft is internal to the argument
        Shape used in the constructor.

        :type IsInternal: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeDraft_SetDraft(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepOffsetAPI_MakeDraft self, Standard_Real const LengthMax)
        Perform(BRepOffsetAPI_MakeDraft self, Handle_Geom_Surface Surface, Standard_Boolean const KeepInsideSurface)
        Perform(BRepOffsetAPI_MakeDraft self, TopoDS_Shape StopShape, Standard_Boolean const KeepOutSide)

        Performs the draft up to the shape StopShape.
        If KeepOutSide is true, the part of StopShape which is
        outside the Draft is kept in the result.

        :type StopShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type KeepOutSide: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeDraft_Perform(self, *args)


    def Shell(self, *args):
        """
        Shell(BRepOffsetAPI_MakeDraft self) -> TopoDS_Shell

        Returns the shell resulting from performance of the
        draft along the wire.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeDraft_Shell(self, *args)


    def Generated(self, *args):
        """
        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeDraft_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakeDraft
BRepOffsetAPI_MakeDraft_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakeDraft_swigregister
BRepOffsetAPI_MakeDraft_swigregister(BRepOffsetAPI_MakeDraft)

class BRepOffsetAPI_MakePipeShell(BRepPrimAPI.BRepPrimAPI_MakeSweep):
    """
    This class provides for a framework to construct a shell
    or a solid along a spine consisting in a wire.
    To produce a solid, the initial wire must be closed.
    Two approaches are used:
    - definition by section
    - by a section and a scaling law
    - by addition of successive intermediary sections
    - definition by sweep mode.
    - pseudo-Frenet
    - constant
    - binormal constant
    - normal defined by a surface support
    - normal defined by a guiding contour.
    The two global approaches can also be combined.
    You can also close the surface later in order to form a solid.
    Warning: some limitations exist
    -- Mode with auxilary spine is incompatible with hometetic laws
    -- Mode with auxilary spine and keep contact produce only CO surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakePipeShell self, TopoDS_Wire Spine) -> BRepOffsetAPI_MakePipeShell

        Constructs the shell-generating framework defined by the wire Spine.
        Sets an sweep's mode
        If no mode are setted, the mode use in MakePipe is used

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakePipeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDiscreteMode(self, *args):
        """
        SetDiscreteMode(BRepOffsetAPI_MakePipeShell self)

        Sets a Discrete trihedron
        to  perform  the  sweeping


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetDiscreteMode(self, *args)


    def SetMode(self, *args):
        """
        SetMode(BRepOffsetAPI_MakePipeShell self, Standard_Boolean const IsFrenet)
        SetMode(BRepOffsetAPI_MakePipeShell self, gp_Ax2 Axe)
        SetMode(BRepOffsetAPI_MakePipeShell self, gp_Dir BiNormal)
        SetMode(BRepOffsetAPI_MakePipeShell self, TopoDS_Shape SpineSupport) -> Standard_Boolean
        SetMode(BRepOffsetAPI_MakePipeShell self, TopoDS_Wire AuxiliarySpine, Standard_Boolean const CurvilinearEquivalence, BRepFill_TypeOfContact const KeepContact=BRepFill_NoContact)

        Sets  an  auxiliary  spine  to  define  the Normal
        For  each  Point  of  the  Spine  P,  an  Point  Q  is  evalued
        on  <AuxiliarySpine>
        If <CurvilinearEquivalence>
        Q split <AuxiliarySpine> with  the  same  length ratio
        than P split  <Spline>.
        Else  the  plan  define  by  P  and  the  tangent  to  the  <Spine>
        intersect <AuxiliarySpine> in Q.
        If <KeepContact> equals BRepFill_NoContact: The Normal is defined
        by the vector PQ.
        If <KeepContact> equals BRepFill_Contact: The Normal is defined to
        achieve that the sweeped section is in contact to the
        auxiliarySpine. The width of section is constant all along the path.
        In other words, the auxiliary spine lies on the swept surface,
        but not necessarily is a boundary of this surface. However,
        the auxiliary spine has to be close enough to the main spine
        to provide intersection with any section all along the path.
        If <KeepContact> equals BRepFill_ContactOnBorder: The auxiliary spine
        becomes a boundary of the swept surface and the width of section varies
        along the path.
        Give section to sweep.
        Possibilities are :
        - Give one or sevral section
        - Give one profile and an homotetic law.
        - Automatic compute of correspondance beetween spine, and section
        on the sweeped shape
        - correspondance beetween spine, and section on the sweeped shape
        defined by a vertex of the spine

        :type AuxiliarySpine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type CurvilinearEquivalence: bool
        :type KeepContact: OCC.wrapper.BRepFill.BRepFill_TypeOfContact

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetMode(self, *args)


    def Add(self, *args):
        """
        Add(BRepOffsetAPI_MakePipeShell self, TopoDS_Shape Profile, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)
        Add(BRepOffsetAPI_MakePipeShell self, TopoDS_Shape Profile, TopoDS_Vertex Location, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)

        Adds the section Profile to this framework.
        Correspondent point on the spine is given by Location.
        Warning:
        To be effective, it is not recommended to combine methods Add and SetLaw.

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Location: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Add(self, *args)


    def SetLaw(self, *args):
        """
        SetLaw(BRepOffsetAPI_MakePipeShell self, TopoDS_Shape Profile, Handle_Law_Function L, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)
        SetLaw(BRepOffsetAPI_MakePipeShell self, TopoDS_Shape Profile, Handle_Law_Function L, TopoDS_Vertex Location, Standard_Boolean const WithContact, Standard_Boolean const WithCorrection)

        Sets the evolution law defined by the wire Profile with
        its position (Location, WithContact, WithCorrection
        are the same options as in methods Add) and a
        homotetic law defined by the function L.
        Warning:
        To be effective, it is not recommended to combine methods Add and SetLaw.

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.Law.Handle_Law_Function
        :type Location: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type WithContact: bool
        :type WithCorrection: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetLaw(self, *args)


    def Delete(self, *args):
        """
        Delete(BRepOffsetAPI_MakePipeShell self, TopoDS_Shape Profile)

        Removes the section Profile from this framework.

        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Delete(self, *args)


    def IsReady(self, *args):
        """
        IsReady(BRepOffsetAPI_MakePipeShell self) -> Standard_Boolean

        Returns true if this tool object is ready to build the
        shape, i.e. has a definition for the wire section Profile.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_IsReady(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(BRepOffsetAPI_MakePipeShell self) -> BRepBuilderAPI_PipeError

        Get a status, when Simulate or Build failed.       It can be
        BRepBuilderAPI_PipeDone,
        BRepBuilderAPI_PipeNotDone,
        BRepBuilderAPI_PlaneNotIntersectGuide,
        BRepBuilderAPI_ImpossibleContact.

        :rtype: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_PipeError

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_GetStatus(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepOffsetAPI_MakePipeShell self, Standard_Real const Tol3d=1.0e-4, Standard_Real const BoundTol=1.0e-4, Standard_Real const TolAngular=1.0e-2)

        Sets the following tolerance values
        - 3D tolerance Tol3d
        - boundary tolerance BoundTol
        - angular tolerance TolAngular.

        :type Tol3d: float
        :type BoundTol: float
        :type TolAngular: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetTolerance(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(BRepOffsetAPI_MakePipeShell self, Standard_Integer const NewMaxDegree)

        Define the maximum V degree of resulting surface

        :type NewMaxDegree: int

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetMaxDegree(self, *args)


    def SetMaxSegments(self, *args):
        """
        SetMaxSegments(BRepOffsetAPI_MakePipeShell self, Standard_Integer const NewMaxSegments)

        Define the maximum number of spans in V-direction
        on resulting surface

        :type NewMaxSegments: int

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetMaxSegments(self, *args)


    def SetForceApproxC1(self, *args):
        """
        SetForceApproxC1(BRepOffsetAPI_MakePipeShell self, Standard_Boolean const ForceApproxC1)

        Set the flag that indicates attempt to approximate
        a C1-continuous surface if a swept surface proved
        to be C0.

        :type ForceApproxC1: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetForceApproxC1(self, *args)


    def SetTransitionMode(self, *args):
        """
        SetTransitionMode(BRepOffsetAPI_MakePipeShell self, BRepBuilderAPI_TransitionMode const Mode=BRepBuilderAPI_Transformed)

        Sets the transition mode to manage discontinuities on
        the swept shape caused by fractures on the spine. The
        transition mode can be BRepBuilderAPI_Transformed
        (default value), BRepBuilderAPI_RightCorner,
        BRepBuilderAPI_RoundCorner:
        -              RepBuilderAPI_Transformed:
        discontinuities are treated by
        modification of the sweeping mode. The
        pipe is "transformed" at the fractures of
        the spine. This mode assumes building a
        self-intersected shell.
        -              BRepBuilderAPI_RightCorner:
        discontinuities are treated like right
        corner. Two pieces of the pipe
        corresponding to two adjacent
        segments of the spine are extended
        and intersected at a fracture of the spine.
        -              BRepBuilderAPI_RoundCorner:
        discontinuities are treated like round
        corner. The corner is treated as rotation
        of the profile around an axis which
        passes through the point of the spine?s
        fracture. This axis is based on cross
        product of directions tangent to the
        adjacent segments of the spine at their common point.
        Warnings
        The mode BRepBuilderAPI_RightCorner provides a
        valid result if intersection of two pieces of the pipe
        (corresponding to two adjacent segments of the spine)
        in the neighborhood of the spine?s fracture is
        connected and planar. This condition can be violated if
        the spine is non-linear in some neighborhood of the
        fracture or if the profile was set with a scaling law.
        The last mode, BRepBuilderAPI_RoundCorner, will
        assuredly provide a good result only if a profile was set
        with option WithCorrection = True, i.e. it is strictly
        orthogonal to the spine.

        :type Mode: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_TransitionMode

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_SetTransitionMode(self, *args)


    def Simulate(self, *args):
        """
        Simulate(BRepOffsetAPI_MakePipeShell self, Standard_Integer const NumberOfSection, NCollection_List_TopoDS_Shape Result)

        Simulates the resulting shape by calculating its
        cross-sections. The spine is devided by this
        cross-sections into (NumberOfSection - 1) equal
        parts, the number of cross-sections is
        NumberOfSection. The cross-sections are wires and
        they are returned in the list Result.
        This gives a rapid preview of the resulting shape,
        which will be obtained using the settings you have provided.
        Raises  NotDone if  <me> it is not Ready

        :type NumberOfSection: int
        :type Result: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Simulate(self, *args)


    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakePipeShell self)

        Builds the resulting shape (redefined from MakeShape).


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Build(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(BRepOffsetAPI_MakePipeShell self) -> Standard_Boolean

        Transforms the sweeping Shell in Solid.
        If a propfile is not closed returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_MakeSolid(self, *args)


    def FirstShape(self, *args):
        """
        FirstShape(BRepOffsetAPI_MakePipeShell self) -> TopoDS_Shape

        Returns the  TopoDS  Shape of the bottom of the sweep.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_FirstShape(self, *args)


    def LastShape(self, *args):
        """
        LastShape(BRepOffsetAPI_MakePipeShell self) -> TopoDS_Shape

        Returns the TopoDS Shape of the top of the sweep.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_LastShape(self, *args)


    def Generated(self, *args):
        """
        Returns a list of new shapes generated from the shape
        S by the shell-generating algorithm.
        This function is redefined from BRepOffsetAPI_MakeShape::Generated.
        S can be an edge or a vertex of a given Profile (see methods Add).

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(BRepOffsetAPI_MakePipeShell self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_ErrorOnSurface(self, *args)


    def Profiles(self, *args):
        """
        Profiles(BRepOffsetAPI_MakePipeShell self, NCollection_List_TopoDS_Shape theProfiles)

        Returns the list of original profiles

        :type theProfiles: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Profiles(self, *args)


    def Spine(self, *args):
        """
        Returns the spine

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakePipeShell
BRepOffsetAPI_MakePipeShell_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakePipeShell_swigregister
BRepOffsetAPI_MakePipeShell_swigregister(BRepOffsetAPI_MakePipeShell)

class BRepOffsetAPI_MakePipe(BRepPrimAPI.BRepPrimAPI_MakeSweep):
    """
    Describes functions to build pipes.
    A pipe is built a basis shape (called the profile) along
    a wire (called the spine) by sweeping.
    The profile must not contain solids.
    A MakePipe object provides a framework for:
    - defining the construction of a pipe,
    - implementing the construction algorithm, and
    - consulting the result.
    Warning
    The MakePipe class implements pipe constructions
    with G1 continuous spines only.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakePipe self, TopoDS_Wire Spine, TopoDS_Shape Profile) -> BRepOffsetAPI_MakePipe
        __init__(BRepOffsetAPI_MakePipe self, TopoDS_Wire Spine, TopoDS_Shape Profile, GeomFill_Trihedron const aMode, Standard_Boolean const ForceApproxC1) -> BRepOffsetAPI_MakePipe

        the same as previous but with setting of
        mode of sweep and the flag that indicates attempt
        to approximate a C1-continuous surface if a swept
        surface proved to be C0.

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Profile: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aMode: OCC.wrapper.GeomFill.GeomFill_Trihedron
        :type ForceApproxC1: bool

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakePipe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Pipe(self, *args):
        """
        :rtype: OCC.wrapper.BRepFill.BRepFill_Pipe

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakePipe_Pipe(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakePipe self)

        Builds the resulting shape (redefined from MakeShape).


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipe_Build(self, *args)


    def FirstShape(self, *args):
        """
        FirstShape(BRepOffsetAPI_MakePipe self) -> TopoDS_Shape

        Returns the  TopoDS  Shape of the bottom of the prism.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipe_FirstShape(self, *args)


    def LastShape(self, *args):
        """
        LastShape(BRepOffsetAPI_MakePipe self) -> TopoDS_Shape

        Returns the TopoDS Shape of the top of the prism.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipe_LastShape(self, *args)


    def Generated(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakePipe_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(BRepOffsetAPI_MakePipe self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakePipe_ErrorOnSurface(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakePipe
BRepOffsetAPI_MakePipe_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakePipe_swigregister
BRepOffsetAPI_MakePipe_swigregister(BRepOffsetAPI_MakePipe)

class NCollection_Sequence_TColStd_SequenceOfReal(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TColStd_SequenceOfReal self) -> NCollection_Sequence< TColStd_SequenceOfReal >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TColStd_SequenceOfReal self) -> NCollection_Sequence< TColStd_SequenceOfReal >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TColStd_SequenceOfReal self) -> NCollection_Sequence< TColStd_SequenceOfReal >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TColStd_SequenceOfReal self) -> NCollection_Sequence< TColStd_SequenceOfReal >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepOffsetAPI.new_NCollection_Sequence_TColStd_SequenceOfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TColStd_SequenceOfReal self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TColStd_SequenceOfReal self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TColStd_SequenceOfReal self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TColStd_SequenceOfReal self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TColStd_SequenceOfReal self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TColStd_SequenceOfReal self)

        Reverse sequence


        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TColStd_SequenceOfReal self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence_TColStd_SequenceOfReal theOther) -> NCollection_Sequence_TColStd_SequenceOfReal

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence_TColStd_SequenceOfReal theOther) -> NCollection_Sequence_TColStd_SequenceOfReal

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence< TColStd_SequenceOfReal >::Iterator & thePosition)
        Remove(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence_Standard_Real theItem)
        Append(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence_TColStd_SequenceOfReal theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence_Standard_Real theItem)
        Prepend(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence_TColStd_SequenceOfReal theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Real theItem)
        InsertBefore(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex, NCollection_Sequence_TColStd_SequenceOfReal theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TColStd_SequenceOfReal self, NCollection_Sequence< TColStd_SequenceOfReal >::Iterator & thePosition, NCollection_Sequence_Standard_Real theItem)
        InsertAfter(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex, NCollection_Sequence_TColStd_SequenceOfReal theSeq)
        InsertAfter(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Real theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex, NCollection_Sequence_TColStd_SequenceOfReal theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TColStd_SequenceOfReal self) -> NCollection_Sequence_Standard_Real

        First item access

        :rtype: TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TColStd_SequenceOfReal self) -> NCollection_Sequence_Standard_Real

        Last item access

        :rtype: TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex) -> NCollection_Sequence_Standard_Real

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TColStd_SequenceOfReal self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Real theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_SetValue(self, *args)


    def __iter__(self):
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal___iter__(self)
    __swig_destroy__ = _BRepOffsetAPI.delete_NCollection_Sequence_TColStd_SequenceOfReal
NCollection_Sequence_TColStd_SequenceOfReal_swigregister = _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_swigregister
NCollection_Sequence_TColStd_SequenceOfReal_swigregister(NCollection_Sequence_TColStd_SequenceOfReal)

def NCollection_Sequence_TColStd_SequenceOfReal_delNode(*args):
    """
    NCollection_Sequence_TColStd_SequenceOfReal_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_delNode(*args)

class NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepOffsetAPI.new_NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffsetAPI.delete_NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper

    def __next__(self):
        return _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper___next__(self)
NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper_swigregister = _BRepOffsetAPI.NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper_swigregister
NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper_swigregister(NCollection_Sequence_TColStd_SequenceOfReal_IteratorHelper)


try:
	BRepOffsetAPI_SequenceOfSequenceOfReal = NCollection_Sequence_TColStd_SequenceOfReal
except NameError:
	pass # does not exist, probably ignored


try:
	TopTools_SequenceOfShape = TopTools.NCollection_Sequence_TopoDS_Shape
except AttributeError:
	pass # does not exist, probably ignored

class BRepOffsetAPI_MakeOffset(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Describes algorithms for offsetting wires from a set of
    wires contained in a planar face.
    A MakeOffset object provides a framework for:
    - defining the construction of an offset,
    - implementing the construction algorithm, and
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakeOffset self) -> BRepOffsetAPI_MakeOffset
        __init__(BRepOffsetAPI_MakeOffset self, TopoDS_Face Spine, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const IsOpenResult) -> BRepOffsetAPI_MakeOffset
        __init__(BRepOffsetAPI_MakeOffset self, TopoDS_Wire Spine, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const IsOpenResult) -> BRepOffsetAPI_MakeOffset

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type IsOpenResult: bool

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakeOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepOffsetAPI_MakeOffset self, TopoDS_Face Spine, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const IsOpenResult)
        Init(BRepOffsetAPI_MakeOffset self, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const IsOpenResult)

        Initialize the evaluation of Offseting.

        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type IsOpenResult: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffset_Init(self, *args)


    def AddWire(self, *args):
        """
        AddWire(BRepOffsetAPI_MakeOffset self, TopoDS_Wire Spine)

        Initializes the algorithm to construct parallels to the wire Spine.

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffset_AddWire(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepOffsetAPI_MakeOffset self, Standard_Real const Offset, Standard_Real const Alt=0.0)

        Computes a parallel to the spine at distance Offset and
        at an altitude Alt from the plane of the spine in relation
        to the normal to the spine.
        Exceptions: StdFail_NotDone if the offset is not built.

        :type Offset: float
        :type Alt: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffset_Perform(self, *args)


    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakeOffset self)

        Builds the resulting shape (redefined from MakeShape).


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeOffset_Build(self, *args)


    def Generated(self, *args):
        """
        returns a list of the created shapes
        from the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeOffset_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakeOffset
BRepOffsetAPI_MakeOffset_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakeOffset_swigregister
BRepOffsetAPI_MakeOffset_swigregister(BRepOffsetAPI_MakeOffset)

class BRepOffsetAPI_MakeEvolved(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Describes functions to build evolved shapes.
    An evolved shape is built from a planar spine (face or
    wire) and a profile (wire). The evolved shape is the
    unlooped sweep (pipe) of the profile along the spine.
    Self-intersections are removed.
    A MakeEvolved object provides a framework for:
    - defining the construction of an evolved shape,
    - implementing the construction algorithm, and
    - consulting the result.
    Computes an Evolved by
    1 - sweeping a profil along a spine.
    2 - removing the self-intersections.

    The profile is defined in a Referential R. The position of
    the profile at the current point of the  spine is given by
    confusing R  and the local  referential given by (  D0, D1
    and the normal of the Spine)

    If the Boolean <AxeProf> is  true, R is  O,X,Y,Z
    else R is defined as the local refential at the nearest
    point of the profil to the spine.

    if <Solid> is TRUE the Shape result  is completed to be a
    solid or a compound of solids.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakeEvolved self) -> BRepOffsetAPI_MakeEvolved
        __init__(BRepOffsetAPI_MakeEvolved self, TopoDS_Wire Spine, TopoDS_Wire Profil, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const AxeProf, Standard_Boolean const Solid, Standard_Boolean const ProfOnSpine, Standard_Real const Tol=0.0000001) -> BRepOffsetAPI_MakeEvolved
        __init__(BRepOffsetAPI_MakeEvolved self, TopoDS_Face Spine, TopoDS_Wire Profil, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const AxeProf, Standard_Boolean const Solid, Standard_Boolean const ProfOnSpine, Standard_Real const Tol=0.0000001) -> BRepOffsetAPI_MakeEvolved

        These constructors construct an evolved shape by sweeping the profile
        Profile along the spine Spine.
        The profile is defined in a coordinate system R.
        The coordinate system is determined by AxeProf:
        - if AxeProf is true, R is the global coordinate system,
        - if AxeProf is false, R is computed so that:
        - its origin is given by the point on the spine which is
        closest to the profile,
        - its "X Axis" is given by the tangent to the spine at this point, and
        - its "Z Axis" is the normal to the plane which contains the spine.
        The position of the profile at the current point of the
        spine is given by making R coincident with the local
        coordinate system given by the current point, the
        tangent vector and the normal to the spine.
        Join defines the type of pipe generated by the salient
        vertices of the spine. The default type is GeomAbs_Arc
        where the vertices generate revolved pipes about the
        axis passing along the vertex and the normal to the
        plane of the spine. At present, this is the only
        construction type implemented.

        :type Spine: OCC.wrapper.TopoDS.TopoDS_Face
        :type Profil: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type AxeProf: bool
        :type Solid: bool
        :type ProfOnSpine: bool
        :type Tol: float

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakeEvolved(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Evolved(self, *args):
        """
        :rtype: OCC.wrapper.BRepFill.BRepFill_Evolved

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeEvolved_Evolved(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakeEvolved self)

        Builds the resulting shape (redefined from MakeShape).


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeEvolved_Build(self, *args)


    def GeneratedShapes(self, *args):
        """
        Returns   the  shapes  created  from   a  subshape
        <SpineShape>  of     the  spine   and   a subshape
        <ProfShape> on the profile.

        :type SpineShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ProfShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeEvolved_GeneratedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Top(self, *args):
        """
        Return the face Top if <Solid> is True in the constructor.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeEvolved_Top(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bottom(self, *args):
        """
        Return the face Bottom  if <Solid> is True in the constructor.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeEvolved_Bottom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakeEvolved
BRepOffsetAPI_MakeEvolved_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakeEvolved_swigregister
BRepOffsetAPI_MakeEvolved_swigregister(BRepOffsetAPI_MakeEvolved)

class BRepOffsetAPI_MakeThickSolid(BRepOffsetAPI_MakeOffsetShape):
    """
    Describes functions to build hollowed solids.
    A hollowed solid is built from an initial solid and a set of
    faces on this solid, which are to be removed. The
    remaining faces of the solid become the walls of the
    hollowed solid, their thickness defined at the time of construction.
    the solid is built from an initial
    solid  <S> and a  set of  faces {Fi} from  <S>,
    builds a   solid  composed  by two shells closed  by
    the {Fi}. First shell <SS>   is composed by all
    the faces of <S> expected {Fi}.  Second shell is
    the offset shell of <SS>.
    A MakeThickSolid object provides a framework for:
    - defining the cross-section of a hollowed solid,
    - implementing the construction algorithm, and
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakeThickSolid self) -> BRepOffsetAPI_MakeThickSolid
        __init__(BRepOffsetAPI_MakeThickSolid self, TopoDS_Shape S, NCollection_List_TopoDS_Shape ClosingFaces, Standard_Real const Offset, Standard_Real const Tol, BRepOffset_Mode const Mode=BRepOffset_Skin, Standard_Boolean const Intersection, Standard_Boolean const SelfInter, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const RemoveIntEdges) -> BRepOffsetAPI_MakeThickSolid

        Deprecated constructor. Please avoid usage of this constructor.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ClosingFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Offset: float
        :type Tol: float
        :type Mode: OCC.wrapper.BRepOffset.BRepOffset_Mode
        :type Intersection: bool
        :type SelfInter: bool
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type RemoveIntEdges: bool

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakeThickSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeThickSolidBySimple(self, *args):
        """
        MakeThickSolidBySimple(BRepOffsetAPI_MakeThickSolid self, TopoDS_Shape theS, Standard_Real const theOffsetValue)

        Constructs solid using simple algorithm. 
        According to its nature it is not possible to set list of the closing faces.
        This algorithm does not support faces removing. It is caused by fact that 
        intersections are not computed during offset creation.
        Non-closed shell or face is expected as input.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOffsetValue: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid_MakeThickSolidBySimple(self, *args)


    def MakeThickSolidByJoin(self, *args):
        """
        MakeThickSolidByJoin(BRepOffsetAPI_MakeThickSolid self, TopoDS_Shape S, NCollection_List_TopoDS_Shape ClosingFaces, Standard_Real const Offset, Standard_Real const Tol, BRepOffset_Mode const Mode=BRepOffset_Skin, Standard_Boolean const Intersection, Standard_Boolean const SelfInter, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const RemoveIntEdges)

        Constructs a hollowed solid from
        the solid S by removing the set of faces ClosingFaces from S, where:
        Offset defines the thickness of the walls. Its sign indicates
        which side of the surface of the solid the hollowed shape is built on;
        - Tol defines the tolerance criterion for coincidence in generated shapes;
        - Mode defines the construction type of parallels applied to free
        edges of shape S. Currently, only one construction type is
        implemented, namely the one where the free edges do not generate
        parallels; this corresponds to the default value BRepOffset_Skin;
        Intersection specifies how the algorithm must work in order to
        limit the parallels to two adjacent shapes:
        - if Intersection is false (default value), the intersection
        is calculated with the parallels to the two adjacent shapes,
        -     if Intersection is true, the intersection is calculated by
        taking account of all parallels generated; this computation
        method is more general as it avoids self-intersections
        generated in the offset shape from features of small dimensions
        on shape S, however this method has not been completely
        implemented and therefore is not recommended for use;
        -     SelfInter tells the algorithm whether a computation to
        eliminate self-intersections needs to be applied to the
        resulting shape. However, as this functionality is not yet
        implemented, you should use the default value (false);
        - Join defines how to fill the holes that may appear between
        parallels to the two adjacent faces. It may take values
        GeomAbs_Arc or GeomAbs_Intersection:
        - if Join is equal to GeomAbs_Arc, then pipes are generated
        between two free edges of two adjacent parallels,
        and spheres are generated on "images" of vertices;
        it is the default value,
        - if Join is equal to GeomAbs_Intersection,
        then the parallels to the two adjacent faces are
        enlarged and intersected, so that there are no free
        edges on parallels to faces.
        RemoveIntEdges flag defines whether to remove the INTERNAL edges 
        from the result or not.
        Warnings
        Since the algorithm of MakeThickSolid is based on
        MakeOffsetShape algorithm, the warnings are the same as for
        MakeOffsetShape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ClosingFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Offset: float
        :type Tol: float
        :type Mode: OCC.wrapper.BRepOffset.BRepOffset_Mode
        :type Intersection: bool
        :type SelfInter: bool
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type RemoveIntEdges: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid_MakeThickSolidByJoin(self, *args)


    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakeThickSolid self)

        Does nothing.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid_Build(self, *args)


    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakeThickSolid
BRepOffsetAPI_MakeThickSolid_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid_swigregister
BRepOffsetAPI_MakeThickSolid_swigregister(BRepOffsetAPI_MakeThickSolid)

class BRepOffsetAPI_FindContigousEdges(object):
    """
    Provides methods to identify contigous boundaries
    for continuity control (C0, C1, ...)

    Use this function as following:
    - create an object
    - default tolerance 1.E-06
    - with analysis of degenerated faces on
    - define if necessary a new tolerance
    - set if necessary analysis of degenerated shapes off
    - add shapes to be controlled -> Add
    - compute -> Perfom
    - output couples of connected edges for control
    - output the problems if any
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_FindContigousEdges self, Standard_Real const tolerance=1.0e-06, Standard_Boolean const option) -> BRepOffsetAPI_FindContigousEdges

        Initializes an algorithm for identifying contiguous edges
        on shapes with tolerance as the tolerance of contiguity
        (defaulted to 1.0e-6). This tolerance value is used to
        determine whether two edges or sections of edges are coincident.
        Use the function Add to define the shapes to be checked.
        Set option to false. This argument (defaulted to true) will
        serve in subsequent software releases for performing an
        analysis of degenerated shapes.

        :type tolerance: float
        :type option: bool

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_FindContigousEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepOffsetAPI_FindContigousEdges self, Standard_Real const tolerance, Standard_Boolean const option)

        Initializes this algorithm for identifying contiguous edges
        on shapes using the tolerance of contiguity tolerance.
        This tolerance value is used to determine whether two
        edges or sections of edges are coincident.
        Use the function Add to define the shapes to be checked.
        Sets <option> to false.

        :type tolerance: float
        :type option: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepOffsetAPI_FindContigousEdges self, TopoDS_Shape shape)

        Adds the shape shape to the list of shapes to be
        checked by this algorithm.
        Once all the shapes to be checked have been added,
        use the function Perform to find the contiguous edges
        and the function ContigousEdge to return these edges.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepOffsetAPI_FindContigousEdges self)

        Finds coincident parts of edges of two or more shapes
        added to this algorithm and breaks down these edges
        into contiguous and non-contiguous sections on copies
        of the initial shapes.
        The function ContigousEdge returns contiguous
        edges. The function Modified can be used to return
        modified copies of the initial shapes where one or more
        edges were broken down into contiguous and non-contiguous sections.
        Warning
        This function must be used once all the shapes to be
        checked have been added. It is not possible to add
        further shapes subsequently and then to repeat the call to Perform.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_Perform(self, *args)


    def NbContigousEdges(self, *args):
        """
        NbContigousEdges(BRepOffsetAPI_FindContigousEdges self) -> Standard_Integer

        Returns the number of contiguous edges found by the
        function Perform on the shapes added to this algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_NbContigousEdges(self, *args)


    def ContigousEdge(self, *args):
        """
        Returns the contiguous edge of index index found by
        the function Perform on the shapes added to this algorithm.
        Exceptions
        Standard_OutOfRange if:
        - index is less than 1, or
        - index is greater than the number of contiguous
        edges found by the function Perform on the shapes added to this algorithm.

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_ContigousEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContigousEdgeCouple(self, *args):
        """
        Returns a list of edges coincident with the contiguous
        edge of index index found by the function Perform.
        There are as many edges in the list as there are faces
        adjacent to this contiguous edge.
        Exceptions
        Standard_OutOfRange if:
        - index is less than 1, or
        - index is greater than the number of contiguous edges
        found by the function Perform on the shapes added to this algorithm.

        :type index: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_ContigousEdgeCouple(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SectionToBoundary(self, *args):
        """
        Returns the edge on the initial shape, of which the
        modified copy contains the edge section.
        section is coincident with a contiguous edge found by
        the function Perform. Use the function
        ContigousEdgeCouple to obtain a valid section.
        This information is useful for verification purposes, since
        it provides a means of determining the surface to which
        the contiguous edge belongs.
        Exceptions
        Standard_NoSuchObject if section is not coincident
        with a contiguous edge. Use the function
        ContigousEdgeCouple to obtain a valid section.

        :type section: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_SectionToBoundary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbDegeneratedShapes(self, *args):
        """
        NbDegeneratedShapes(BRepOffsetAPI_FindContigousEdges self) -> Standard_Integer

        Gives the number of degenerated shapes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_NbDegeneratedShapes(self, *args)


    def DegeneratedShape(self, *args):
        """
        Gives a degenerated shape

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_DegeneratedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDegenerated(self, *args):
        """
        IsDegenerated(BRepOffsetAPI_FindContigousEdges self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input shape is degenerated

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_IsDegenerated(self, *args)


    def IsModified(self, *args):
        """
        IsModified(BRepOffsetAPI_FindContigousEdges self, TopoDS_Shape shape) -> Standard_Boolean

        Returns true if the copy of the initial shape shape was
        modified by the function Perform (i.e. if one or more of
        its edges was broken down into contiguous and non-contiguous sections).
        Warning
        Returns false if shape is not one of the initial shapes
        added to this algorithm.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_IsModified(self, *args)


    def Modified(self, *args):
        """
        Gives a modifieded shape
        Raises   NoSuchObject if shape has not been modified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(BRepOffsetAPI_FindContigousEdges self)

        Dump properties of resulting shape.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_Dump(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_FindContigousEdges
BRepOffsetAPI_FindContigousEdges_swigregister = _BRepOffsetAPI.BRepOffsetAPI_FindContigousEdges_swigregister
BRepOffsetAPI_FindContigousEdges_swigregister(BRepOffsetAPI_FindContigousEdges)

class BRepOffsetAPI_ThruSections(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Describes functions to build a loft. This is a shell or a
    solid passing through a set of sections in a given
    sequence. Usually sections are wires, but the first and
    the last sections may be vertices (punctual sections).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_ThruSections self, Standard_Boolean const isSolid, Standard_Boolean const ruled, Standard_Real const pres3d=1.0e-06) -> BRepOffsetAPI_ThruSections

        Initializes an algorithm for building a shell or a solid
        passing through a set of sections, where:
        -          isSolid is set to true if the construction algorithm is
        required to build a solid or to false if it is required to build
        a shell (the default value),
        -          ruled is set to true if the faces generated between
        the edges of two consecutive wires are ruled surfaces or to
        false (the default value) if they are smoothed out by approximation,
        -          pres3d defines the precision criterion used by the
        approximation algorithm; the default value is 1.0e-6.
        Use AddWire and AddVertex to define the
        successive sections of the shell or solid to be built.

        :type isSolid: bool
        :type ruled: bool
        :type pres3d: float

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_ThruSections(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepOffsetAPI_ThruSections self, Standard_Boolean const isSolid, Standard_Boolean const ruled, Standard_Real const pres3d=1.0e-06)

        Initializes this algorithm for building a shell or a solid
        passing through a set of sections, where:
        - isSolid is set to true if this construction algorithm is
        required to build a solid or to false if it is required to
        build a shell. false is the default value;
        - ruled is set to true if the faces generated between the
        edges of two consecutive wires are ruled surfaces or
        to false (the default value) if they are smoothed out by approximation,
        - pres3d defines the precision criterion used by the
        approximation algorithm; the default value is 1.0e-6.
        Use AddWire and AddVertex to define the successive
        sections of the shell or solid to be built.

        :type isSolid: bool
        :type ruled: bool
        :type pres3d: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_Init(self, *args)


    def AddWire(self, *args):
        """
        AddWire(BRepOffsetAPI_ThruSections self, TopoDS_Wire wire)

        Adds the wire wire to the set of
        sections through which the shell or solid is built.
        Use the Build function to construct the shape.

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_AddWire(self, *args)


    def AddVertex(self, *args):
        """
        AddVertex(BRepOffsetAPI_ThruSections self, TopoDS_Vertex aVertex)

        Adds the vertex Vertex (punctual section) to the set of sections
        through which the shell or solid is built. A vertex may be added to the
        set of sections only as first or last section. At least one wire
        must be added to the set of sections by the method AddWire.
        Use the Build function to construct the shape.

        :type aVertex: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_AddVertex(self, *args)


    def CheckCompatibility(self, *args):
        """
        CheckCompatibility(BRepOffsetAPI_ThruSections self, Standard_Boolean const check)

        Sets/unsets the option to
        compute origin and orientation on wires to avoid twisted results
        and update wires to have same number of edges.

        :type check: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_CheckCompatibility(self, *args)


    def SetSmoothing(self, *args):
        """
        SetSmoothing(BRepOffsetAPI_ThruSections self, Standard_Boolean const UseSmoothing)

        Define the approximation algorithm

        :type UseSmoothing: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_SetSmoothing(self, *args)


    def SetParType(self, *args):
        """
        SetParType(BRepOffsetAPI_ThruSections self, Approx_ParametrizationType const ParType)

        Define the type of parametrization   used in the approximation

        :type ParType: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_SetParType(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(BRepOffsetAPI_ThruSections self, GeomAbs_Shape const C)

        Define the Continuity used in the approximation

        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args):
        """
        SetCriteriumWeight(BRepOffsetAPI_ThruSections self, Standard_Real const W1, Standard_Real const W2, Standard_Real const W3)

        define the Weights  associed to the criterium used in
        the  optimization.

        if Wi <= 0

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_SetCriteriumWeight(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(BRepOffsetAPI_ThruSections self, Standard_Integer const MaxDeg)

        Define the maximal U degree of result surface

        :type MaxDeg: int

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_SetMaxDegree(self, *args)


    def ParType(self, *args):
        """
        ParType(BRepOffsetAPI_ThruSections self) -> Approx_ParametrizationType

        returns the type of parametrization used in the approximation

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_ParType(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepOffsetAPI_ThruSections self) -> GeomAbs_Shape

        returns the Continuity used in the approximation

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_Continuity(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(BRepOffsetAPI_ThruSections self) -> Standard_Integer

        returns the maximal U degree of result surface

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_MaxDegree(self, *args)


    def UseSmoothing(self, *args):
        """
        UseSmoothing(BRepOffsetAPI_ThruSections self) -> Standard_Boolean

        Define the approximation algorithm

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_UseSmoothing(self, *args)


    def CriteriumWeight(self, *args):
        """
        CriteriumWeight(BRepOffsetAPI_ThruSections self)

        returns the Weights associed  to the criterium used in
        the  optimization.

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_CriteriumWeight(self, *args)


    def Build(self, *args):
        """
        Build(BRepOffsetAPI_ThruSections self)

        This is  called by  Shape().  It does  nothing but
        may be redefined.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_Build(self, *args)


    def FirstShape(self, *args):
        """
        Returns the TopoDS Shape of the bottom of the loft if solid

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_ThruSections_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        Returns the TopoDS Shape of the top of the loft if solid

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_ThruSections_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GeneratedFace(self, *args):
        """
        GeneratedFace(BRepOffsetAPI_ThruSections self, TopoDS_Shape Edge) -> TopoDS_Shape

        if Ruled
        Returns the Face generated by each edge
        except the last wire
        if smoothed
        Returns the Face generated by each edge of the first wire

        :type Edge: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_ThruSections_GeneratedFace(self, *args)


    def Generated(self, *args):
        """
        Returns a list of new shapes generated from the shape
        S by the shell-generating algorithm.
        This function is redefined from BRepBuilderAPI_MakeShape::Generated.
        S can be an edge or a vertex of a given Profile (see methods AddWire and AddVertex).

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_ThruSections_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wires(self, *args):
        """
        Returns the list of original wires

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_ThruSections_Wires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_ThruSections
BRepOffsetAPI_ThruSections_swigregister = _BRepOffsetAPI.BRepOffsetAPI_ThruSections_swigregister
BRepOffsetAPI_ThruSections_swigregister(BRepOffsetAPI_ThruSections)

class BRepOffsetAPI_NormalProjection(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    A framework to define projection onto a shape
    according to the normal from each point to be projected.
    The target shape is a face, and the source shape is an edge or a wire.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_NormalProjection self) -> BRepOffsetAPI_NormalProjection
        __init__(BRepOffsetAPI_NormalProjection self, TopoDS_Shape S) -> BRepOffsetAPI_NormalProjection

        Constructs a framework to define projection onto the
        basis shape S according to the normal from each point
        to be projected from the shape added to this framework by Add.
        Default parameters of the algorithm: Tol3D = 1.e-04, Tol2D =sqr(tol3d)
        , InternalContinuity = GeomAbs_C2, MaxDegree = 14, MaxSeg = 16.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_NormalProjection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepOffsetAPI_NormalProjection self, TopoDS_Shape S)

        Initializes the empty constructor framework with the shape S.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepOffsetAPI_NormalProjection self, TopoDS_Shape ToProj)

        Adds the shape ToProj to the framework for calculation
        of the projection by Compute3d.
        ToProj is an edge or a wire and will be projected onto the basis shape.
        Exceptions
        Standard_ConstructionError if ToProj is not added.

        :type ToProj: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Add(self, *args)


    def SetParams(self, *args):
        """
        SetParams(BRepOffsetAPI_NormalProjection self, Standard_Real const Tol3D, Standard_Real const Tol2D, GeomAbs_Shape const InternalContinuity, Standard_Integer const MaxDegree, Standard_Integer const MaxSeg)

        Sets the parameters  used  for computation
        Tol3 is the requiered  tolerance between the  3d projected
        curve  and     its    2d    representation
        InternalContinuity  is the order of constraints
        used for  approximation
        MaxDeg and MaxSeg are the maximum degree and the maximum
        number of segment for BSpline resulting of an approximation.

        :type Tol3D: float
        :type Tol2D: float
        :type InternalContinuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSeg: int

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_SetParams(self, *args)


    def SetMaxDistance(self, *args):
        """
        SetMaxDistance(BRepOffsetAPI_NormalProjection self, Standard_Real const MaxDist)

        Sets the maximum distance between target shape and
        shape to project. If this condition is not satisfied then corresponding
        part of solution is discarded.
        if MaxDist < 0 then this method does not affect the algorithm

        :type MaxDist: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_SetMaxDistance(self, *args)


    def SetLimit(self, *args):
        """
        SetLimit(BRepOffsetAPI_NormalProjection self, Standard_Boolean const FaceBoundaries)

        Manage  limitation  of  projected  edges.

        :type FaceBoundaries: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_SetLimit(self, *args)


    def Compute3d(self, *args):
        """
        Compute3d(BRepOffsetAPI_NormalProjection self, Standard_Boolean const With3d)

        Returns true if a 3D curve is computed. If not, false is
        returned and an initial 3D curve is kept to build the resulting edges.

        :type With3d: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Compute3d(self, *args)


    def Build(self, *args):
        """
        Build(BRepOffsetAPI_NormalProjection self)

        Builds the result of the projection as a compound of
        wires. Tries to build oriented wires.


        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepOffsetAPI_NormalProjection self) -> Standard_Boolean

        Returns true if the object was correctly built by the shape
        construction algorithm.
        If at the construction time of the shape, the algorithm
        cannot be completed, or the original data is corrupted,
        IsDone returns false and therefore protects the use of
        functions to access the result of the construction
        (typically the Shape function).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_IsDone(self, *args)


    def Projection(self, *args):
        """
        Performs the projection.
        The construction of the result is performed by Build.
        Exceptions
        StdFail_NotDone if the projection was not performed.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Projection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Couple(self, *args):
        """
        Returns the initial face corresponding to the projected edge E.
        Exceptions
        StdFail_NotDone if no face was found.
        Standard_NoSuchObject if if a face corresponding to
        E has already been found.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Couple(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Ancestor(self, *args):
        """
        Returns the initial edge corresponding to the edge E
        resulting from the computation of the projection.
        Exceptions
        StdFail_NotDone if no edge was found.
        Standard_NoSuchObject if an edge corresponding to
        E has already been found.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_Ancestor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BuildWire(self, *args):
        """
        BuildWire(BRepOffsetAPI_NormalProjection self, NCollection_List_TopoDS_Shape Liste) -> Standard_Boolean

        build the result as a list of wire if possible in --
        a first returns a wire only if there is only a wire.

        :type Liste: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_BuildWire(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_NormalProjection
BRepOffsetAPI_NormalProjection_swigregister = _BRepOffsetAPI.BRepOffsetAPI_NormalProjection_swigregister
BRepOffsetAPI_NormalProjection_swigregister(BRepOffsetAPI_NormalProjection)

class BRepOffsetAPI_MakeFilling(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    N-Side Filling
    This algorithm avoids to build a face from:
    * a set of edges defining the bounds of the face and some
    constraints the surface of the face has to satisfy
    * a set of edges and points defining some constraints
    the support surface has to satisfy
    * an initial surface to deform for satisfying the constraints
    * a set of parameters to control the constraints.

    The support surface of the face is computed by deformation
    of the initial surface in order to satisfy the given constraints.
    The set of bounding edges defines the wire of the face.

    If no initial surface is given, the algorithm computes it
    automatically.
    If the set of edges is not connected (Free constraint)
    missing edges are automatically computed.

    Limitations:
    * If some constraints are not compatible
    The algorithm does not take them into account.
    So the constraints will not be satisfyed in an area containing
    the incompatibilitries.
    * The constraints defining the bound of the face have to be
    entered in order to have a continuous wire.

    Other Applications:
    * Deformation of a face to satisfy internal constraints
    * Deformation of a face to improve Gi continuity with
    connected faces
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffsetAPI_MakeFilling self, Standard_Integer const Degree=3, Standard_Integer const NbPtsOnCur=15, Standard_Integer const NbIter=2, Standard_Boolean const Anisotropie, Standard_Real const Tol2d=0.00001, Standard_Real const Tol3d=0.0001, Standard_Real const TolAng=0.01, Standard_Real const TolCurv=0.1, Standard_Integer const MaxDeg=8, Standard_Integer const MaxSegments=9) -> BRepOffsetAPI_MakeFilling

        Constructs a wire filling object defined by
        - the energy minimizing criterion Degree
        - the number of points on the curve NbPntsOnCur
        - the number of iterations NbIter
        - the Boolean Anisotropie
        - the 2D tolerance Tol2d
        - the 3D tolerance Tol3d
        - the angular tolerance TolAng
        - the tolerance for curvature TolCur
        - the highest polynomial degree MaxDeg
        - the greatest number of segments MaxSeg.
        If the Boolean Anistropie is true, the algorithm's
        performance is better in cases where the ratio of the
        length U and the length V indicate a great difference
        between the two. In other words, when the surface is, for
        example, extremely long.

        :type Degree: int
        :type NbPtsOnCur: int
        :type NbIter: int
        :type Anisotropie: bool
        :type Tol2d: float
        :type Tol3d: float
        :type TolAng: float
        :type TolCurv: float
        :type MaxDeg: int
        :type MaxSegments: int

        """
        this = _BRepOffsetAPI.new_BRepOffsetAPI_MakeFilling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetConstrParam(self, *args):
        """
        SetConstrParam(BRepOffsetAPI_MakeFilling self, Standard_Real const Tol2d=0.00001, Standard_Real const Tol3d=0.0001, Standard_Real const TolAng=0.01, Standard_Real const TolCurv=0.1)

        Sets the values of Tolerances used to control the constraint.
        Tol2d:
        Tol3d:   it is the maximum distance allowed between the support surface
        and the constraints
        TolAng:  it is the maximum angle allowed between the normal of the surface
        and the constraints
        TolCurv: it is the maximum difference of curvature allowed between
        the surface and the constraint

        :type Tol2d: float
        :type Tol3d: float
        :type TolAng: float
        :type TolCurv: float

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_SetConstrParam(self, *args)


    def SetResolParam(self, *args):
        """
        SetResolParam(BRepOffsetAPI_MakeFilling self, Standard_Integer const Degree=3, Standard_Integer const NbPtsOnCur=15, Standard_Integer const NbIter=2, Standard_Boolean const Anisotropie)

        Sets the parameters used for resolution.
        The default values of these parameters have been chosen for a good
        ratio quality/performance.
        Degree:      it is the order of energy criterion to minimize for computing
        the deformation of the surface.
        The default value is 3
        The recommanded value is i+2 where i is the maximum order of the
        constraints.
        NbPtsOnCur:  it is the average number of points for discretisation
        of the edges.
        NbIter:      it is the maximum number of iterations of the process.
        For each iteration the number of discretisation points is
        increased.
        Anisotropie:

        :type Degree: int
        :type NbPtsOnCur: int
        :type NbIter: int
        :type Anisotropie: bool

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_SetResolParam(self, *args)


    def SetApproxParam(self, *args):
        """
        SetApproxParam(BRepOffsetAPI_MakeFilling self, Standard_Integer const MaxDeg=8, Standard_Integer const MaxSegments=9)

        Sets the parameters used to approximate the filling
        surface. These include:
        - MaxDeg - the highest degree which the polynomial
        defining the filling surface can have
        - MaxSegments - the greatest number of segments
        which the filling surface can have.

        :type MaxDeg: int
        :type MaxSegments: int

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_SetApproxParam(self, *args)


    def LoadInitSurface(self, *args):
        """
        LoadInitSurface(BRepOffsetAPI_MakeFilling self, TopoDS_Face Surf)

        Loads the initial surface Surf to
        begin the construction of the surface.
        This optional function is useful if the surface resulting from
        construction for the algorithm is likely to be complex.
        The support surface of the face under construction is computed by a
        deformation of Surf which satisfies the given constraints.
        The set of bounding edges defines the wire of the face.
        If no initial surface is given, the algorithm computes it
        automatically. If the set of edges is not connected (Free constraint),
        missing edges are automatically computed.
        Important: the initial surface must have orthogonal local coordinates,
        i.e. partial derivatives dS/du and dS/dv must be orthogonal
        at each point of surface.
        If this condition breaks, distortions of resulting surface
        are possible.

        :type Surf: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_LoadInitSurface(self, *args)


    def Add(self, *args):
        """
        Add(BRepOffsetAPI_MakeFilling self, TopoDS_Edge Constr, GeomAbs_Shape const Order, Standard_Boolean const IsBound) -> Standard_Integer
        Add(BRepOffsetAPI_MakeFilling self, TopoDS_Edge Constr, TopoDS_Face Support, GeomAbs_Shape const Order, Standard_Boolean const IsBound) -> Standard_Integer
        Add(BRepOffsetAPI_MakeFilling self, TopoDS_Face Support, GeomAbs_Shape const Order) -> Standard_Integer
        Add(BRepOffsetAPI_MakeFilling self, gp_Pnt Point) -> Standard_Integer
        Add(BRepOffsetAPI_MakeFilling self, Standard_Real const U, Standard_Real const V, TopoDS_Face Support, GeomAbs_Shape const Order) -> Standard_Integer

        Adds a punctual constraint.

        :type U: float
        :type V: float
        :type Support: OCC.wrapper.TopoDS.TopoDS_Face
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_Add(self, *args)


    def Build(self, *args):
        """
        Build(BRepOffsetAPI_MakeFilling self)

        Builds the resulting faces


        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepOffsetAPI_MakeFilling self) -> Standard_Boolean

        Tests whether computation of the filling plate has been completed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_IsDone(self, *args)


    def Generated(self, *args):
        """
        Returns the list of shapes generated from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def G0Error(self, *args):
        """
        G0Error(BRepOffsetAPI_MakeFilling self) -> Standard_Real
        G0Error(BRepOffsetAPI_MakeFilling self, Standard_Integer const Index) -> Standard_Real

        Returns the maximum distance attained between the
        result and the constraint Index. This is set at construction time.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_G0Error(self, *args)


    def G1Error(self, *args):
        """
        G1Error(BRepOffsetAPI_MakeFilling self) -> Standard_Real
        G1Error(BRepOffsetAPI_MakeFilling self, Standard_Integer const Index) -> Standard_Real

        Returns the maximum angle between the result and the
        constraints. This is set at construction time.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_G1Error(self, *args)


    def G2Error(self, *args):
        """
        G2Error(BRepOffsetAPI_MakeFilling self) -> Standard_Real
        G2Error(BRepOffsetAPI_MakeFilling self, Standard_Integer const Index) -> Standard_Real

        Returns the greatest difference in curvature found
        between the result and the constraint Index.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_G2Error(self, *args)

    __swig_destroy__ = _BRepOffsetAPI.delete_BRepOffsetAPI_MakeFilling
BRepOffsetAPI_MakeFilling_swigregister = _BRepOffsetAPI.BRepOffsetAPI_MakeFilling_swigregister
BRepOffsetAPI_MakeFilling_swigregister(BRepOffsetAPI_MakeFilling)




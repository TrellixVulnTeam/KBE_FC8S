# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Interface')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Interface')
    _Interface = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Interface', [dirname(__file__)])
        except ImportError:
            import _Interface
            return _Interface
        try:
            _mod = imp.load_module('_Interface', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Interface = swig_import_helper()
    del swig_import_helper
else:
    import _Interface
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Interface.delete_SwigPyIterator

    def value(self):
        return _Interface.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Interface.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Interface.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Interface.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Interface.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Interface.SwigPyIterator_copy(self)

    def next(self):
        return _Interface.SwigPyIterator_next(self)

    def __next__(self):
        return _Interface.SwigPyIterator___next__(self)

    def previous(self):
        return _Interface.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Interface.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Interface.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Interface.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Interface.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Interface.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Interface.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Interface.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Interface.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Interface.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Interface.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Interface.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Interface.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Interface.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Interface.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Interface.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Interface.ptr_to_number(item)
ptr_to_number = _Interface.ptr_to_number

def HashCode(*args):
    return _Interface.HashCode(*args)
HashCode = _Interface.HashCode

def ptr_equal(a, b):
    return _Interface.ptr_equal(a, b)
ptr_equal = _Interface.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
Interface_ParamMisc = _Interface.Interface_ParamMisc
Interface_ParamInteger = _Interface.Interface_ParamInteger
Interface_ParamReal = _Interface.Interface_ParamReal
Interface_ParamIdent = _Interface.Interface_ParamIdent
Interface_ParamVoid = _Interface.Interface_ParamVoid
Interface_ParamText = _Interface.Interface_ParamText
Interface_ParamEnum = _Interface.Interface_ParamEnum
Interface_ParamLogical = _Interface.Interface_ParamLogical
Interface_ParamSub = _Interface.Interface_ParamSub
Interface_ParamHexa = _Interface.Interface_ParamHexa
Interface_ParamBinary = _Interface.Interface_ParamBinary
Interface_CheckOK = _Interface.Interface_CheckOK
Interface_CheckWarning = _Interface.Interface_CheckWarning
Interface_CheckFail = _Interface.Interface_CheckFail
Interface_CheckAny = _Interface.Interface_CheckAny
Interface_CheckMessage = _Interface.Interface_CheckMessage
Interface_CheckNoFail = _Interface.Interface_CheckNoFail
Interface_StateOK = _Interface.Interface_StateOK
Interface_LoadWarning = _Interface.Interface_LoadWarning
Interface_LoadFail = _Interface.Interface_LoadFail
Interface_DataWarning = _Interface.Interface_DataWarning
Interface_DataFail = _Interface.Interface_DataFail
Interface_StateUnloaded = _Interface.Interface_StateUnloaded
Interface_StateUnknown = _Interface.Interface_StateUnknown
class Interface_InterfaceError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_InterfaceError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_InterfaceError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_InterfaceError self) -> Interface_InterfaceError
        __init__(Interface_InterfaceError self, Standard_CString const theMessage) -> Interface_InterfaceError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Interface.new_Interface_InterfaceError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Interface_InterfaceError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceError

        """
        return _Interface.Interface_InterfaceError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_InterfaceError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_InterfaceError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_InterfaceError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_InterfaceError
Interface_InterfaceError_swigregister = _Interface.Interface_InterfaceError_swigregister
Interface_InterfaceError_swigregister(Interface_InterfaceError)

def Interface_InterfaceError_NewInstance(*args):
    """
    Interface_InterfaceError_NewInstance(Standard_CString const theMessage) -> Handle_Interface_InterfaceError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceError

    """
    return _Interface.Interface_InterfaceError_NewInstance(*args)

def Interface_InterfaceError_get_type_name(*args):
    """
    Interface_InterfaceError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_InterfaceError_get_type_name(*args)

def Interface_InterfaceError_get_type_descriptor(*args):
    """
    Interface_InterfaceError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_InterfaceError_get_type_descriptor(*args)

class Interface_GlobalNodeOfGeneralLib(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_GlobalNodeOfGeneralLib
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_GlobalNodeOfGeneralLib(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_GlobalNodeOfGeneralLib self) -> Interface_GlobalNodeOfGeneralLib

        Creates an empty GlobalNode, with no Next


        """
        this = _Interface.new_Interface_GlobalNodeOfGeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(Interface_GlobalNodeOfGeneralLib self, Handle_Interface_GeneralModule amodule, Handle_Interface_Protocol aprotocol)

        Adds a Module bound with a Protocol to the list : does
        nothing if already in the list, THAT IS, Same Type (exact
        match) and Same State (that is, IsEqual is not required)
        Once added, stores its attached Protocol in correspondance

        :type amodule: OCC.wrapper.Interface.Handle_Interface_GeneralModule
        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Add(self, *args)


    def Module(self, *args):
        """
        Returns the Module stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_GeneralModule

        """
        res = _Interface.Interface_GlobalNodeOfGeneralLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the attached Protocol stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Interface_GlobalNodeOfGeneralLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next GlobalNode. If none is defined, returned
        value is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfGeneralLib

        """
        res = _Interface.Interface_GlobalNodeOfGeneralLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_GlobalNodeOfGeneralLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_GlobalNodeOfGeneralLib
Interface_GlobalNodeOfGeneralLib_swigregister = _Interface.Interface_GlobalNodeOfGeneralLib_swigregister
Interface_GlobalNodeOfGeneralLib_swigregister(Interface_GlobalNodeOfGeneralLib)

def Interface_GlobalNodeOfGeneralLib_get_type_name(*args):
    """
    Interface_GlobalNodeOfGeneralLib_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_GlobalNodeOfGeneralLib_get_type_name(*args)

def Interface_GlobalNodeOfGeneralLib_get_type_descriptor(*args):
    """
    Interface_GlobalNodeOfGeneralLib_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_GlobalNodeOfGeneralLib_get_type_descriptor(*args)

class Interface_GTool(Standard.Standard_Transient):
    """
    GTool - General Tool for a Model
    Provides the functions performed by Protocol/GeneralModule for
    entities of a Model, and recorded in a GeneralLib
    Optimized : once an entity has been queried, the GeneralLib is
    not longer queried
    Shareable between several users : as a Handle
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_GTool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_GTool(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_GTool self) -> Interface_GTool
        __init__(Interface_GTool self, Handle_Interface_Protocol proto, Standard_Integer const nbent=0) -> Interface_GTool

        Creates a GTool from a Protocol
        Optional starting count of entities

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type nbent: int

        """
        this = _Interface.new_Interface_GTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetSignType(self, *args):
        """
        SetSignType(Interface_GTool self, Handle_Interface_SignType sign)

        Sets a new SignType

        :type sign: OCC.wrapper.Interface.Handle_Interface_SignType

        """
        return _Interface.Interface_GTool_SetSignType(self, *args)


    def SignType(self, *args):
        """
        SignType(Interface_GTool self) -> Handle_Interface_SignType

        Returns the SignType. Can be null

        :rtype: OCC.wrapper.Interface.Handle_Interface_SignType

        """
        return _Interface.Interface_GTool_SignType(self, *args)


    def SignValue(self, *args):
        """
        SignValue(Interface_GTool self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient Object in a Model
        It calls SignType to do that
        If SignType is not defined, return ClassName of <ent>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_GTool_SignValue(self, *args)


    def SignName(self, *args):
        """
        SignName(Interface_GTool self) -> Standard_CString

        Returns the Name of the SignType, or "Class Name"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_GTool_SignName(self, *args)


    def SetProtocol(self, *args):
        """
        SetProtocol(Interface_GTool self, Handle_Interface_Protocol proto, Standard_Boolean const enforce)

        Sets a new Protocol
        if <enforce> is False and the new Protocol equates the old one
        then nothing is done

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type enforce: bool

        """
        return _Interface.Interface_GTool_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Protocol(Interface_GTool self) -> Handle_Interface_Protocol

        Returns the Protocol.  Warning : it can be Null

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_GTool_Protocol(self, *args)


    def Lib(self, *args):
        """
        Lib(Interface_GTool self) -> Interface_GeneralLib

        Returns the GeneralLib itself

        :rtype: OCC.wrapper.Interface.Interface_GeneralLib

        """
        return _Interface.Interface_GTool_Lib(self, *args)


    def Reservate(self, *args):
        """
        Reservate(Interface_GTool self, Standard_Integer const nb, Standard_Boolean const enforce)

        Reservates maps for a count of entities
        <enforce> False : minimum count
        <enforce> True  : clears former reservations
        Does not clear the maps

        :type nb: int
        :type enforce: bool

        """
        return _Interface.Interface_GTool_Reservate(self, *args)


    def ClearEntities(self, *args):
        """
        ClearEntities(Interface_GTool self)

        Clears the maps which record, for each already recorded entity
        its Module and Case Number


        """
        return _Interface.Interface_GTool_ClearEntities(self, *args)


    def Select(self, *args):
        """
        Select(Interface_GTool self, Handle_Standard_Transient ent, Handle_Interface_GeneralModule gmod, Standard_Boolean const enforce) -> Standard_Boolean

        Selects for an entity, its Module and Case Number
        It is optimised : once done for each entity, the result is
        mapped and the GeneralLib is not longer queried
        <enforce> True overpasses this optimisation

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type gmod: OCC.wrapper.Interface.Handle_Interface_GeneralModule
        :type CN: int
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GTool_Select(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_GTool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_GTool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_GTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_GTool
Interface_GTool_swigregister = _Interface.Interface_GTool_swigregister
Interface_GTool_swigregister(Interface_GTool)

def Interface_GTool_get_type_name(*args):
    """
    Interface_GTool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_GTool_get_type_name(*args)

def Interface_GTool_get_type_descriptor(*args):
    """
    Interface_GTool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_GTool_get_type_descriptor(*args)

class Interface_NodeOfReaderLib(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_NodeOfReaderLib
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_NodeOfReaderLib(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_NodeOfReaderLib self) -> Interface_NodeOfReaderLib

        Creates an empty Node, with no Next


        """
        this = _Interface.new_Interface_NodeOfReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddNode(self, *args):
        """
        AddNode(Interface_NodeOfReaderLib self, Handle_Interface_GlobalNodeOfReaderLib anode)

        Adds a couple (Module,Protocol), that is, stores it into
        itself if not yet done, else creates a Next Node to do it

        :type anode: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfReaderLib

        """
        return _Interface.Interface_NodeOfReaderLib_AddNode(self, *args)


    def Module(self, *args):
        """
        Returns the Module designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_ReaderModule

        """
        res = _Interface.Interface_NodeOfReaderLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the Protocol designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Interface_NodeOfReaderLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next Node. If none was defined, returned value
        is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_NodeOfReaderLib

        """
        res = _Interface.Interface_NodeOfReaderLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_NodeOfReaderLib_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_NodeOfReaderLib_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_NodeOfReaderLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_NodeOfReaderLib
Interface_NodeOfReaderLib_swigregister = _Interface.Interface_NodeOfReaderLib_swigregister
Interface_NodeOfReaderLib_swigregister(Interface_NodeOfReaderLib)

def Interface_NodeOfReaderLib_get_type_name(*args):
    """
    Interface_NodeOfReaderLib_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_NodeOfReaderLib_get_type_name(*args)

def Interface_NodeOfReaderLib_get_type_descriptor(*args):
    """
    Interface_NodeOfReaderLib_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_NodeOfReaderLib_get_type_descriptor(*args)

class Interface_ReportEntity(Standard.Standard_Transient):
    """
    A ReportEntity is produced to aknowledge and memorize the
    binding between a Check and an Entity. The Check can bring
    Fails (+ Warnings if any), or only Warnings. If it is empty,
    the Report Entity is for an Unknown Entity.

    The ReportEntity brings : the Concerned Entity, the
    Check, and if the Entity is empty (Fails due to Read
    Errors, hence the Entity could not be loaded), a Content.
    The Content is itself an Transient Object, but remains in a
    literal form : it is an "Unknown Entity". If the Concerned
    Entity is itself Unknown, Concerned and Content are equal.

    According to the Check, if it brings Fail messages,
    the ReportEntity is an "Error Entity", the Concerned Entity is
    an "Erroneous Entity". Else it is a "Correction Entity", the
    Concerned Entity is a "Corrected Entity". With no Check
    message and if Concerened and Content are equal, it reports
    for an "Unknown Entity".

    Each norm must produce its own type of Unknown Entity, but can
    use the class UndefinedContent to brings parameters : it is
    enough for most of information and avoids to redefine them,
    only the specific part remains to be defined for each norm.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_ReportEntity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_ReportEntity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_ReportEntity self, Handle_Standard_Transient unknown) -> Interface_ReportEntity
        __init__(Interface_ReportEntity self, Handle_Interface_Check acheck, Handle_Standard_Transient concerned) -> Interface_ReportEntity

        Creates a ReportEntity with its features :
        - <acheck> is the Check to be memorised
        - <concerned> is the Entity to which the Check is bound
        Later, a Content can be set : it is required for an Error

        :type acheck: OCC.wrapper.Interface.Handle_Interface_Check
        :type concerned: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _Interface.new_Interface_ReportEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetContent(self, *args):
        """
        SetContent(Interface_ReportEntity self, Handle_Standard_Transient content)

        Sets a Content : it brings non interpreted data which belong
        to the Concerned Entity. It can be empty then loaded later.
        Remark that for an Unknown Entity, Content is set by Create.

        :type content: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ReportEntity_SetContent(self, *args)


    def Check(self, *args):
        """
        Returns the stored Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Interface_ReportEntity_Check(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CCheck(self, *args):
        """
        CCheck(Interface_ReportEntity self) -> Handle_Interface_Check

        Returns the stored Check in order to change it

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_ReportEntity_CCheck(self, *args)


    def Concerned(self, *args):
        """
        Concerned(Interface_ReportEntity self) -> Handle_Standard_Transient

        Returns the stored Concerned Entity. It equates the Content
        in the case of an Unknown Entity

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ReportEntity_Concerned(self, *args)


    def HasContent(self, *args):
        """
        HasContent(Interface_ReportEntity self) -> Standard_Boolean

        Returns True if a Content is stored (it can equate Concerned)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReportEntity_HasContent(self, *args)


    def HasNewContent(self, *args):
        """
        HasNewContent(Interface_ReportEntity self) -> Standard_Boolean

        Returns True if a Content is stored AND differs from Concerned
        (i.e. redefines content) : used when Concerned could not be
        loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReportEntity_HasNewContent(self, *args)


    def Content(self, *args):
        """
        Content(Interface_ReportEntity self) -> Handle_Standard_Transient

        Returns the stored Content, or a Null Handle
        Remark that it must be an "Unknown Entity" suitable for
        the norm of the containing Model

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ReportEntity_Content(self, *args)


    def IsError(self, *args):
        """
        IsError(Interface_ReportEntity self) -> Standard_Boolean

        Returns True for an Error Entity, i.e. if the Check
        brings at least one Fail message

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReportEntity_IsError(self, *args)


    def IsUnknown(self, *args):
        """
        IsUnknown(Interface_ReportEntity self) -> Standard_Boolean

        Returns True for an Unknown Entity, i,e. if the Check
        is empty and Concerned equates Content

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReportEntity_IsUnknown(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_ReportEntity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_ReportEntity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_ReportEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_ReportEntity
Interface_ReportEntity_swigregister = _Interface.Interface_ReportEntity_swigregister
Interface_ReportEntity_swigregister(Interface_ReportEntity)

def Interface_ReportEntity_get_type_name(*args):
    """
    Interface_ReportEntity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_ReportEntity_get_type_name(*args)

def Interface_ReportEntity_get_type_descriptor(*args):
    """
    Interface_ReportEntity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_ReportEntity_get_type_descriptor(*args)

class Interface_ParamList(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_ParamList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_ParamList(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_ParamList self, Standard_Integer const theIncrement=256) -> Interface_ParamList

        Creates an vector with size of memmory blok equal to theIncrement

        :type theIncrement: int

        """
        this = _Interface.new_Interface_ParamList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Length(self, *args):
        """
        Length(Interface_ParamList self) -> Standard_Integer

        Returns the number of elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ParamList_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(Interface_ParamList self) -> Standard_Integer

        Returns the lower bound.
        Warning

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ParamList_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Interface_ParamList self) -> Standard_Integer

        Returns the upper bound.
        Warning

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ParamList_Upper(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Interface_ParamList self, Standard_Integer const Index, Interface_FileParameter Value)

        Assigns the value <Value> to the <Index>-th item of this array.

        :type Index: int
        :type Value: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_ParamList_SetValue(self, *args)


    def Value(self, *args):
        """
        Return the value of  the  <Index>th element of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Interface_ParamList_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Interface_ParamList self, Standard_Integer const Index) -> Interface_FileParameter

        return the value  of the <Index>th element  of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_ParamList_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Interface_ParamList___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """Clear(Interface_ParamList self)"""
        return _Interface.Interface_ParamList_Clear(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_ParamList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_ParamList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_ParamList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_ParamList
Interface_ParamList_swigregister = _Interface.Interface_ParamList_swigregister
Interface_ParamList_swigregister(Interface_ParamList)

def Interface_ParamList_get_type_name(*args):
    """
    Interface_ParamList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_ParamList_get_type_name(*args)

def Interface_ParamList_get_type_descriptor(*args):
    """
    Interface_ParamList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_ParamList_get_type_descriptor(*args)

class Interface_SignType(MoniTool.MoniTool_SignText):
    """
    Provides the basic service to get a type name, according
    to a norm
    It can be used for other classes (general signatures ...)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_SignType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_SignType(self) 
            return h


    def Text(self, *args):
        """
        Text(Interface_SignType self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Interface_SignType_Text(self, *args)


    def Value(self, *args):
        """
        Value(Interface_SignType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_SignType_Value(self, *args)


    def ClassName(*args):
        """
        ClassName(Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_SignType_ClassName(*args)

    ClassName = staticmethod(ClassName)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_SignType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_SignType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_SignType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_SignType
Interface_SignType_swigregister = _Interface.Interface_SignType_swigregister
Interface_SignType_swigregister(Interface_SignType)

def Interface_SignType_ClassName(*args):
    """
    Interface_SignType_ClassName(Standard_CString const typnam) -> Standard_CString

    From a CDL Type Name, returns the Class part (package dropped)
    WARNING : buffered, to be immediately copied or printed

    :type typnam: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_SignType_ClassName(*args)

def Interface_SignType_get_type_name(*args):
    """
    Interface_SignType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_SignType_get_type_name(*args)

def Interface_SignType_get_type_descriptor(*args):
    """
    Interface_SignType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_SignType_get_type_descriptor(*args)

class Interface_FileParameter(object):
    """
    Auxiliary class to store a litteral parameter in a file
    intermediate directory or in an UndefinedContent : a reference
    type Parameter detains an Integer which is used to address a
    record in the directory.
    FileParameter is intended to be stored in a ParamSet : hence
    memory management is performed by ParamSet, which calls Clear
    to work, while the Destructor (see Destroy) does nothing.
    Also a FileParameter can be read for consultation only, not to
    be read from a Structure to be included into another one.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_FileParameter self) -> Interface_FileParameter

        Auxiliary class to store a litteral parameter in a file
        intermediate directory or in an UndefinedContent : a reference
        type Parameter detains an Integer which is used to address a
        record in the directory.
        FileParameter is intended to be stored in a ParamSet : hence
        memory management is performed by ParamSet, which calls Clear
        to work, while the Destructor (see Destroy) does nothing.
        Also a FileParameter can be read for consultation only, not to
        be read from a Structure to be included into another one.
        """
        this = _Interface.new_Interface_FileParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(Interface_FileParameter self, TCollection_AsciiString val, Interface_ParamType const typ)
        Init(Interface_FileParameter self, Standard_CString const val, Interface_ParamType const typ)

        Same as above, but builds the Value from a CString

        :type val: OCC.wrapper.Standard.Standard_CString
        :type typ: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Interface_FileParameter_Init(self, *args)


    def CValue(self, *args):
        """
        CValue(Interface_FileParameter self) -> Standard_CString

        Same as above, but as a CString (for immediate exploitation)
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_FileParameter_CValue(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Interface_FileParameter self) -> Interface_ParamType

        Returns the type of the parameter

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Interface_FileParameter_ParamType(self, *args)


    def SetEntityNumber(self, *args):
        """
        SetEntityNumber(Interface_FileParameter self, Standard_Integer const num)

        Allows to set a reference to an Entity in a numbered list

        :type num: int

        """
        return _Interface.Interface_FileParameter_SetEntityNumber(self, *args)


    def EntityNumber(self, *args):
        """
        EntityNumber(Interface_FileParameter self) -> Standard_Integer

        Returns value set by SetEntityNumber

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileParameter_EntityNumber(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_FileParameter self)

        Clears stored data : frees memory taken for the String Value


        """
        return _Interface.Interface_FileParameter_Clear(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Interface_FileParameter self)

        Destructor. Does nothing because Memory is managed by ParamSet


        """
        return _Interface.Interface_FileParameter_Destroy(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_FileParameter
Interface_FileParameter_swigregister = _Interface.Interface_FileParameter_swigregister
Interface_FileParameter_swigregister(Interface_FileParameter)

class Interface_CopyControl(Standard.Standard_Transient):
    """
    This deferred class describes the services required by
    CopyTool to work. They are very simple and correspond
    basically to the management of an indexed map.
    But they can be provided by various classes which can
    control a Transfer. Each Starting Entity have at most
    one Result (Mapping one-one)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_CopyControl
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_CopyControl(self) 
            return h


    def Clear(self, *args):
        """
        Clear(Interface_CopyControl self)

        Clears List of Copy Results. Gets Ready to begin another Copy
        Process.


        """
        return _Interface.Interface_CopyControl_Clear(self, *args)


    def Bind(self, *args):
        """
        Bind(Interface_CopyControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Bind a Result to a Starting Entity identified by its Number

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_CopyControl_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Interface_CopyControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Searches for the Result bound to a Startingf Entity identified
        by its Number.
        If Found, returns True and fills <res>
        Else, returns False and nullifies <res>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CopyControl_Search(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_CopyControl_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_CopyControl_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_CopyControl_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_CopyControl
Interface_CopyControl_swigregister = _Interface.Interface_CopyControl_swigregister
Interface_CopyControl_swigregister(Interface_CopyControl)

def Interface_CopyControl_get_type_name(*args):
    """
    Interface_CopyControl_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_CopyControl_get_type_name(*args)

def Interface_CopyControl_get_type_descriptor(*args):
    """
    Interface_CopyControl_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_CopyControl_get_type_descriptor(*args)

class Interface_IntVal(Standard.Standard_Transient):
    """An Integer through a Handle (i.e. managed as TShared)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_IntVal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_IntVal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_IntVal self) -> Interface_IntVal

        An Integer through a Handle (i.e. managed as TShared)
        """
        this = _Interface.new_Interface_IntVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(Interface_IntVal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_IntVal_Value(self, *args)


    def CValue(self, *args):
        """
        CValue(Interface_IntVal self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_IntVal_CValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_IntVal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_IntVal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_IntVal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_IntVal
Interface_IntVal_swigregister = _Interface.Interface_IntVal_swigregister
Interface_IntVal_swigregister(Interface_IntVal)

def Interface_IntVal_get_type_name(*args):
    """
    Interface_IntVal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_IntVal_get_type_name(*args)

def Interface_IntVal_get_type_descriptor(*args):
    """
    Interface_IntVal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_IntVal_get_type_descriptor(*args)

class Interface_CheckFailure(Interface_InterfaceError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_CheckFailure
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_CheckFailure(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_CheckFailure self) -> Interface_CheckFailure
        __init__(Interface_CheckFailure self, Standard_CString const theMessage) -> Interface_CheckFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Interface.new_Interface_CheckFailure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Interface_CheckFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_CheckFailure

        """
        return _Interface.Interface_CheckFailure_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_CheckFailure_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_CheckFailure_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_CheckFailure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_CheckFailure
Interface_CheckFailure_swigregister = _Interface.Interface_CheckFailure_swigregister
Interface_CheckFailure_swigregister(Interface_CheckFailure)

def Interface_CheckFailure_NewInstance(*args):
    """
    Interface_CheckFailure_NewInstance(Standard_CString const theMessage) -> Handle_Interface_CheckFailure

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Interface.Handle_Interface_CheckFailure

    """
    return _Interface.Interface_CheckFailure_NewInstance(*args)

def Interface_CheckFailure_get_type_name(*args):
    """
    Interface_CheckFailure_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_CheckFailure_get_type_name(*args)

def Interface_CheckFailure_get_type_descriptor(*args):
    """
    Interface_CheckFailure_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_CheckFailure_get_type_descriptor(*args)

class Interface_MapAsciiStringHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(TCollection_AsciiString K, Standard_Integer const Upper) -> Standard_Integer

        :type K: OCC.wrapper.TCollection.TCollection_AsciiString
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_MapAsciiStringHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(TCollection_AsciiString K1, TCollection_AsciiString K2) -> Standard_Boolean

        :type K1: OCC.wrapper.TCollection.TCollection_AsciiString
        :type K2: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_MapAsciiStringHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _Interface.new_Interface_MapAsciiStringHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_Interface_MapAsciiStringHasher
Interface_MapAsciiStringHasher_swigregister = _Interface.Interface_MapAsciiStringHasher_swigregister
Interface_MapAsciiStringHasher_swigregister(Interface_MapAsciiStringHasher)

def Interface_MapAsciiStringHasher_HashCode(*args):
    """
    Interface_MapAsciiStringHasher_HashCode(TCollection_AsciiString K, Standard_Integer const Upper) -> Standard_Integer

    :type K: OCC.wrapper.TCollection.TCollection_AsciiString
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_MapAsciiStringHasher_HashCode(*args)

def Interface_MapAsciiStringHasher_IsEqual(*args):
    """
    Interface_MapAsciiStringHasher_IsEqual(TCollection_AsciiString K1, TCollection_AsciiString K2) -> Standard_Boolean

    :type K1: OCC.wrapper.TCollection.TCollection_AsciiString
    :type K2: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_MapAsciiStringHasher_IsEqual(*args)

class Interface_UndefinedContent(Standard.Standard_Transient):
    """
    Defines resources for an "Undefined Entity" : such an Entity
    is used to describe an Entity which complies with the Norm,
    but of an Unknown Type : hence it is kept under a literal
    form (avoiding to loose data). UndefinedContent offers a way
    to store a list of Parameters, as literals or references to
    other Entities

    Each Interface must provide one "UndefinedEntity", which must
    have same basic description as all its types of entities :
    the best way would be double inheritance : on the Entity Root
    of the Norm and on an general "UndefinedEntity"

    While it is not possible to do so, the UndefinedEntity of each
    Interface can define its own UndefinedEntity by INCLUDING
    (in a field) this UndefinedContent

    Hence, for that UndefinedEntity, define a Constructor which
    creates this UndefinedContent, plus access methods to it
    (or to its data, calling methods defined here).

    Finally, the Protocols of each norm have to Create and
    Recognize Unknown Entities of this norm
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_UndefinedContent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_UndefinedContent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_UndefinedContent self) -> Interface_UndefinedContent

        Defines an empty UndefinedContent


        """
        this = _Interface.new_Interface_UndefinedContent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbParams(self, *args):
        """
        NbParams(Interface_UndefinedContent self) -> Standard_Integer

        Gives count of recorded parameters

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_UndefinedContent_NbParams(self, *args)


    def NbLiterals(self, *args):
        """
        NbLiterals(Interface_UndefinedContent self) -> Standard_Integer

        Gives count of Literal Parameters

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_UndefinedContent_NbLiterals(self, *args)


    def ParamData(self, *args):
        """
        ParamData(Interface_UndefinedContent self, Standard_Integer const num, Handle_Standard_Transient ent, Handle_TCollection_HAsciiString val) -> Standard_Boolean

        Returns data of a Parameter : its type, and the entity if it
        designates en entity ("ent") or its literal value else ("str")
        Returned value (Boolean) : True if it is an Entity, False else

        :type num: int
        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_UndefinedContent_ParamData(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Interface_UndefinedContent self, Standard_Integer const num) -> Interface_ParamType

        Returns the ParamType of a Param, given its rank
        Error if num is not between 1 and NbParams

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Interface_UndefinedContent_ParamType(self, *args)


    def IsParamEntity(self, *args):
        """
        IsParamEntity(Interface_UndefinedContent self, Standard_Integer const num) -> Standard_Boolean

        Returns True if a Parameter is recorded as an entity
        Error if num is not between 1 and NbParams

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_UndefinedContent_IsParamEntity(self, *args)


    def ParamEntity(self, *args):
        """
        ParamEntity(Interface_UndefinedContent self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns Entity corresponding to a Param, given its rank

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_UndefinedContent_ParamEntity(self, *args)


    def ParamValue(self, *args):
        """
        ParamValue(Interface_UndefinedContent self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns litteral value of a Parameter, given its rank

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_UndefinedContent_ParamValue(self, *args)


    def Reservate(self, *args):
        """
        Reservate(Interface_UndefinedContent self, Standard_Integer const nb, Standard_Integer const nblit)

        Manages reservation for parameters (internal use)
        (nb : total count of parameters, nblit : count of literals)

        :type nb: int
        :type nblit: int

        """
        return _Interface.Interface_UndefinedContent_Reservate(self, *args)


    def AddLiteral(self, *args):
        """
        AddLiteral(Interface_UndefinedContent self, Interface_ParamType const ptype, Handle_TCollection_HAsciiString val)

        Adds a literal Parameter to the list

        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_UndefinedContent_AddLiteral(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Interface_UndefinedContent self, Interface_ParamType const ptype, Handle_Standard_Transient ent)

        Adds a Parameter which references an Entity

        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_UndefinedContent_AddEntity(self, *args)


    def RemoveParam(self, *args):
        """
        RemoveParam(Interface_UndefinedContent self, Standard_Integer const num)

        Removes a Parameter given its rank

        :type num: int

        """
        return _Interface.Interface_UndefinedContent_RemoveParam(self, *args)


    def SetLiteral(self, *args):
        """
        SetLiteral(Interface_UndefinedContent self, Standard_Integer const num, Interface_ParamType const ptype, Handle_TCollection_HAsciiString val)

        Sets a new value for the Parameter <num>, to a literal value
        (if it referenced formerly an Entity, this Entity is removed)

        :type num: int
        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_UndefinedContent_SetLiteral(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(Interface_UndefinedContent self, Standard_Integer const num, Interface_ParamType const ptype, Handle_Standard_Transient ent)
        SetEntity(Interface_UndefinedContent self, Standard_Integer const num, Handle_Standard_Transient ent)

        Changes the Entity referenced by the Parameter <num>
        (with same ParamType)

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_UndefinedContent_SetEntity(self, *args)


    def EntityList(self, *args):
        """
        EntityList(Interface_UndefinedContent self) -> Interface_EntityList

        Returns globally the list of param entities. Note that it can
        be used as shared entity list for the UndefinedEntity

        :rtype: OCC.wrapper.Interface.Interface_EntityList

        """
        return _Interface.Interface_UndefinedContent_EntityList(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(Interface_UndefinedContent self, Handle_Interface_UndefinedContent other, Interface_CopyTool TC)

        Copies contents of undefined entities; deigned to be called by
        GetFromAnother method from Undefined entity of each Interface
        (the basic operation is the same regardless the norm)

        :type other: OCC.wrapper.Interface.Handle_Interface_UndefinedContent
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _Interface.Interface_UndefinedContent_GetFromAnother(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_UndefinedContent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_UndefinedContent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_UndefinedContent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_UndefinedContent
Interface_UndefinedContent_swigregister = _Interface.Interface_UndefinedContent_swigregister
Interface_UndefinedContent_swigregister(Interface_UndefinedContent)

def Interface_UndefinedContent_get_type_name(*args):
    """
    Interface_UndefinedContent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_UndefinedContent_get_type_name(*args)

def Interface_UndefinedContent_get_type_descriptor(*args):
    """
    Interface_UndefinedContent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_UndefinedContent_get_type_descriptor(*args)

class Interface_SignLabel(MoniTool.MoniTool_SignText):
    """Signature to give the Label from the Model"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_SignLabel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_SignLabel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_SignLabel self) -> Interface_SignLabel

        Signature to give the Label from the Model
        """
        this = _Interface.new_Interface_SignLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Name(Interface_SignLabel self) -> Standard_CString

        Returns "Entity Label"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_SignLabel_Name(self, *args)


    def Text(self, *args):
        """
        Text(Interface_SignLabel self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Considers context as an InterfaceModel and returns the Label
        computed by it

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Interface_SignLabel_Text(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_SignLabel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_SignLabel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_SignLabel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_SignLabel
Interface_SignLabel_swigregister = _Interface.Interface_SignLabel_swigregister
Interface_SignLabel_swigregister(Interface_SignLabel)

def Interface_SignLabel_get_type_name(*args):
    """
    Interface_SignLabel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_SignLabel_get_type_name(*args)

def Interface_SignLabel_get_type_descriptor(*args):
    """
    Interface_SignLabel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_SignLabel_get_type_descriptor(*args)

class Interface_EntityCluster(Standard.Standard_Transient):
    """
    Auxiliary class for EntityList. An EntityList designates an
    EntityCluster, which brings itself an fixed maximum count of
    Entities. If it is full, it gives access to another cluster
    ("Next"). This class is intended to give a good compromise
    between access time (faster than a Sequence, good for little
    count) and memory use (better than a Sequence in any case,
    overall for little count, better than an Array for a very
    little count. It is designed for a light management.
    Remark that a new Item may not be Null, because this is the
    criterium used for "End of List" 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_EntityCluster
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_EntityCluster(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_EntityCluster self) -> Interface_EntityCluster
        __init__(Interface_EntityCluster self, Handle_Standard_Transient ent) -> Interface_EntityCluster
        __init__(Interface_EntityCluster self, Handle_Interface_EntityCluster ec) -> Interface_EntityCluster
        __init__(Interface_EntityCluster self, Handle_Standard_Transient ant, Handle_Interface_EntityCluster ec) -> Interface_EntityCluster

        Creates an EntityCluster, filled with a first Entity, and
        chained to another EntityCluster (BEFORE it, as above)

        :type ant: OCC.wrapper.Standard.Handle_Standard_Transient
        :type ec: OCC.wrapper.Interface.Handle_Interface_EntityCluster

        """
        this = _Interface.new_Interface_EntityCluster(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Append(self, *args):
        """
        Append(Interface_EntityCluster self, Handle_Standard_Transient ent)

        Appends an Entity to the Cluster. If it is not full, adds the
        entity directly inside itself. Else, transmits to its Next
        and Creates it if it does not yet exist

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityCluster_Append(self, *args)


    def Remove(self, *args):
        """
        Remove(Interface_EntityCluster self, Handle_Standard_Transient ent) -> Standard_Boolean
        Remove(Interface_EntityCluster self, Standard_Integer const num) -> Standard_Boolean

        Removes an Entity from the Cluster, given its rank. If <num>
        is greater than NbLocal, calls its Next with (num - NbLocal),
        Returns True if it becomes itself empty, False else

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_EntityCluster_Remove(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Interface_EntityCluster self) -> Standard_Integer

        Returns total count of Entities (including Next)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_EntityCluster_NbEntities(self, *args)


    def Value(self, *args):
        """
        Returns the Entity identified by its rank in the list
        (including Next)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_EntityCluster_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Interface_EntityCluster self, Standard_Integer const num, Handle_Standard_Transient ent)

        Changes an Entity given its rank.

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityCluster_SetValue(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Interface_EntityCluster self, Interface_EntityIterator iter)

        Fills an Iterator with designated Entities (includes Next)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_EntityCluster_FillIterator(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_EntityCluster_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_EntityCluster_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_EntityCluster_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_EntityCluster
Interface_EntityCluster_swigregister = _Interface.Interface_EntityCluster_swigregister
Interface_EntityCluster_swigregister(Interface_EntityCluster)

def Interface_EntityCluster_get_type_name(*args):
    """
    Interface_EntityCluster_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_EntityCluster_get_type_name(*args)

def Interface_EntityCluster_get_type_descriptor(*args):
    """
    Interface_EntityCluster_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_EntityCluster_get_type_descriptor(*args)

class Interface_GeneralModule(Standard.Standard_Transient):
    """
    This class defines general services, which must be provided
    for each type of Entity (i.e. of Transient Object processed
    by an Interface) : Shared List, Check, Copy, Delete, Category

    To optimise processing (e.g. firstly bind an Entity to a Module
    then calls  Module), each recognized Entity Type corresponds
    to a Case Number, determined by the Protocol each class of
    GeneralModule belongs to.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_GeneralModule
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_GeneralModule(self) 
            return h


    def FillShared(self, *args):
        """
        FillShared(Interface_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum), considered in the context of a Model <model>
        Default calls FillSharedCase (i.e., ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_GeneralModule_FillShared(self, *args)


    def FillSharedCase(self, *args):
        """
        FillSharedCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum). Can use the internal utility method Share, below

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_GeneralModule_FillSharedCase(self, *args)


    def Share(self, *args):
        """
        Share(Interface_GeneralModule self, Interface_EntityIterator iter, Handle_Standard_Transient shared)

        Adds an Entity to a Shared List (uses GetOneItem on <iter>)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type shared: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_GeneralModule_Share(self, *args)


    def ListImplied(self, *args):
        """
        ListImplied(Interface_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> considered in the context
        of a Model <model> : i.e. the Entities which are Referenced
        while not considered as Shared (not copied if <ent> is,
        references not renewed by CopyCase but by ImpliedCase, only
        if referenced Entities have been Copied too)
        FillShared + ListImplied give the complete list of References
        Default calls ListImpliedCase (i.e. ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_GeneralModule_ListImplied(self, *args)


    def ListImpliedCase(self, *args):
        """
        ListImpliedCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> (see above)
        are Referenced while not considered as Shared (not copied if
        <ent> is, references not renewed by CopyCase but by
        ImpliedCase, only if referenced Entities have been Copied too)
        FillSharedCase + ListImpliedCase give the complete list of
        Referenced Entities
        The provided default method does nothing (Implied References
        are specific of a little amount of Entity Classes).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_GeneralModule_ListImpliedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>
        Can check context queried through a ShareTool, as required

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_GeneralModule_CheckCase(self, *args)


    def CanCopy(self, *args):
        """
        CanCopy(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific answer to the question "is Copy properly implemented"
        Remark that it should be in phase with the implementation of
        NewVoid+CopyCase/NewCopyCase
        Default returns always False, can be redefined

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GeneralModule_CanCopy(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Dispatches an entity
        Returns True if it works by copy, False if it just duplicates
        the starting Handle

        Dispatching means producing a new entity, image of the
        starting one, in order to be put into a new Model, this Model
        being itself the result of a dispatch from an original Model

        According to the cases, dispatch can either
        * just return <entto> as equating <entfrom>
        -> the new model designates the starting entity : it is
        lighter, but the dispatched entity being shared might not be
        modified for dispatch
        * copy <entfrom> to <entto>
        by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1)
        -> the dispatched entity is a COPY, hence it can be modified

        The provided default just duplicates the handle without
        copying, then returns False. Can be redefined

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GeneralModule_Dispatch(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entto) -> Standard_Boolean

        Creates a new void entity <entto> according to a Case Number
        This entity remains to be filled, by reading from a file or
        by copying from another entity of same type (see CopyCase)

        :type CN: int
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GeneralModule_NewVoid(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a CopyTool which provides its working Map.
        Use method Transferred from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _Interface.Interface_GeneralModule_CopyCase(self, *args)


    def NewCopiedCase(self, *args):
        """
        NewCopiedCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Specific operator (create+copy) defaulted to do nothing.
        It can be redefined : When it is not possible to work in two
        steps (NewVoid then CopyCase). This can occur when there is
        no default constructor : hence the result <entto> must be
        created with an effective definition.
        Remark : if NewCopiedCase is defined, CopyCase has nothing to do
        Returns True if it has produced something, false else

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GeneralModule_NewCopiedCase(self, *args)


    def RenewImpliedCase(self, *args):
        """
        RenewImpliedCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _Interface.Interface_GeneralModule_RenewImpliedCase(self, *args)


    def WhenDeleteCase(self, *args):
        """
        WhenDeleteCase(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Standard_Boolean const dispatched)

        Prepares an entity to be deleted. What does it mean :
        Basically, any class of entity may define its own destructor
        By default, it does nothing but calling destructors on fields
        With the Memory Manager, it is useless to call destructor,
        it is done automatically when the Handle is nullified(cleared)
        BUT this is ineffective in looping structures (whatever these
        are "Implied" references or not).

        THUS : if no loop may appear in definitions, a class which
        inherits from TShared is correctly managed by automatic way
        BUT if there can be loops (or simply back pointers), they must
        be broken, for instance by clearing fields of one of the nodes
        The default does nothing, to be redefined if a loop can occur
        (Implied generally requires WhenDelete, but other cases can
        occur)

        Warning : <dispatched> tells if the entity to be deleted has been
        produced by Dispatch or not. Hence WhenDelete must be in
        coherence with Dispatch
        Dispatch can either copy or not.
        If it copies the entity, this one should be deleted
        If it doesnt (i.e. duplicates the handle) nothing to do

        If <dispatch> is False, normal deletion is to be performed

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type dispatched: bool

        """
        return _Interface.Interface_GeneralModule_WhenDeleteCase(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Standard_Integer

        Returns a category number which characterizes an entity
        Category Numbers are managed by the class Category
        <shares> can be used to evaluate this number in the context
        Default returns 0 which means "unspecified"

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_GeneralModule_CategoryNumber(self, *args)


    def Name(self, *args):
        """
        Name(Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Handle_TCollection_HAsciiString

        Determines if an entity brings a Name (or widerly, if a Name
        can be attached to it, through the ShareTool
        By default, returns a Null Handle (no name can be produced)
        Can be redefined

        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_GeneralModule_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_GeneralModule_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_GeneralModule_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_GeneralModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_GeneralModule
Interface_GeneralModule_swigregister = _Interface.Interface_GeneralModule_swigregister
Interface_GeneralModule_swigregister(Interface_GeneralModule)

def Interface_GeneralModule_get_type_name(*args):
    """
    Interface_GeneralModule_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_GeneralModule_get_type_name(*args)

def Interface_GeneralModule_get_type_descriptor(*args):
    """
    Interface_GeneralModule_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_GeneralModule_get_type_descriptor(*args)

class Interface_TypedValue(MoniTool.MoniTool_TypedValue):
    """
    Now strictly equivalent to TypedValue from MoniTool,
    except for ParamType which remains for compatibility reasons

    This class allows to dynamically manage .. typed values, i.e.
    values which have an alphanumeric expression, but with
    controls. Such as "must be an Integer" or "Enumerative Text"
    etc

    Hence, a TypedValue brings a specification (type + constraints
    if any) and a value. Its basic form is a string, it can be
    specified as integer or real or enumerative string, then
    queried as such.
    Its string content, which is a Handle(HAsciiString) can be
    shared by other data structures, hence gives a direct on line
    access to its value.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_TypedValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_TypedValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_TypedValue self, Standard_CString const name, Interface_ParamType const type=Interface_ParamText, Standard_CString const init) -> Interface_TypedValue

        Creates a TypedValue, with a name

        type gives the type of the parameter, default is free text
        Also available : Integer, Real, Enum, Entity (i.e. Object)
        More precise specifications, titles, can be given to the
        TypedValue once created

        init gives an initial value. If it is not given, the
        TypedValue begins as "not set", its value is empty

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Interface.Interface_ParamType
        :type init: OCC.wrapper.Standard.Standard_CString

        """
        this = _Interface.new_Interface_TypedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Type(self, *args):
        """
        Type(Interface_TypedValue self) -> Interface_ParamType

        Returns the type
        I.E. calls ValueType then makes correspondance between
        ParamType from Interface (which remains for compatibility
        reasons) and ValueType from MoniTool

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Interface_TypedValue_Type(self, *args)


    def ParamTypeToValueType(*args):
        """
        ParamTypeToValueType(Interface_ParamType const typ) -> MoniTool_ValueType

        Correspondance ParamType from Interface  to
        ValueType from MoniTool

        :type typ: OCC.wrapper.Interface.Interface_ParamType
        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _Interface.Interface_TypedValue_ParamTypeToValueType(*args)

    ParamTypeToValueType = staticmethod(ParamTypeToValueType)

    def ValueTypeToParamType(*args):
        """
        ValueTypeToParamType(MoniTool_ValueType const typ) -> Interface_ParamType

        Correspondance ParamType from Interface  to
        ValueType from MoniTool

        :type typ: OCC.wrapper.MoniTool.MoniTool_ValueType
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Interface_TypedValue_ValueTypeToParamType(*args)

    ValueTypeToParamType = staticmethod(ValueTypeToParamType)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_TypedValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_TypedValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_TypedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_TypedValue
Interface_TypedValue_swigregister = _Interface.Interface_TypedValue_swigregister
Interface_TypedValue_swigregister(Interface_TypedValue)

def Interface_TypedValue_ParamTypeToValueType(*args):
    """
    Interface_TypedValue_ParamTypeToValueType(Interface_ParamType const typ) -> MoniTool_ValueType

    Correspondance ParamType from Interface  to
    ValueType from MoniTool

    :type typ: OCC.wrapper.Interface.Interface_ParamType
    :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

    """
    return _Interface.Interface_TypedValue_ParamTypeToValueType(*args)

def Interface_TypedValue_ValueTypeToParamType(*args):
    """
    Interface_TypedValue_ValueTypeToParamType(MoniTool_ValueType const typ) -> Interface_ParamType

    Correspondance ParamType from Interface  to
    ValueType from MoniTool

    :type typ: OCC.wrapper.MoniTool.MoniTool_ValueType
    :rtype: OCC.wrapper.Interface.Interface_ParamType

    """
    return _Interface.Interface_TypedValue_ValueTypeToParamType(*args)

def Interface_TypedValue_get_type_name(*args):
    """
    Interface_TypedValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_TypedValue_get_type_name(*args)

def Interface_TypedValue_get_type_descriptor(*args):
    """
    Interface_TypedValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_TypedValue_get_type_descriptor(*args)

class Interface_Protocol(Standard.Standard_Transient):
    """
    General description of Interface Protocols. A Protocol defines
    a set of Entity types. This class provides also the notion of
    Active Protocol, as a working context, defined once then
    exploited by various Tools and Libraries.

    It also gives control of type definitions. By default, types
    are provided by CDL, but specific implementations, or topics
    like multi-typing, may involve another way
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_Protocol
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_Protocol(self) 
            return h


    def Active(*args):
        """
        Active() -> Handle_Interface_Protocol

        Returns the Active Protocol, if defined (else, returns a
        Null Handle, which means "no defined active protocol")

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_Protocol_Active(*args)

    Active = staticmethod(Active)

    def SetActive(*args):
        """
        SetActive(Handle_Interface_Protocol aprotocol)

        Sets a given Protocol to be the Active one (for the users of
        Active, see just above). Applies to every sub-type of Protocol

        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_Protocol_SetActive(*args)

    SetActive = staticmethod(SetActive)

    def ClearActive(*args):
        """
        ClearActive()

        Erases the Active Protocol (hence it becomes undefined)


        """
        return _Interface.Interface_Protocol_ClearActive(*args)

    ClearActive = staticmethod(ClearActive)

    def NbResources(self, *args):
        """
        NbResources(Interface_Protocol self) -> Standard_Integer

        Returns count of Protocol used as Resources (level one)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Protocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(Interface_Protocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given its rank (between 1 and NbResources)

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_Protocol_Resource(self, *args)


    def CaseNumber(self, *args):
        """
        CaseNumber(Interface_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns a unique positive CaseNumber for each Recognized
        Object. By default, recognition is based on Type(1)
        By default, calls the following one which is deferred.

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Protocol_CaseNumber(self, *args)


    def IsDynamicType(self, *args):
        """
        IsDynamicType(Interface_Protocol self, Handle_Standard_Transient obj) -> Standard_Boolean

        Returns True if type of <obj> is that defined from CDL
        This is the default but it may change according implementation

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Protocol_IsDynamicType(self, *args)


    def NbTypes(self, *args):
        """
        NbTypes(Interface_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Each one is candidate to be recognized by
        TypeNumber, <obj> is then processed according it
        By default, returns 1 (the DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Protocol_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Interface_Protocol self, Handle_Standard_Transient obj, Standard_Integer const nt=1) -> Handle_Standard_Type

        Returns a type under which <obj> can be recognized and
        processed, according its rank in its definition list (see
        NbTypes).
        By default, returns DynamicType

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type nt: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_Protocol_Type(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(Interface_Protocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a unique positive CaseNumber for each Recognized Type,
        Returns Zero for "<type> not recognized"

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Protocol_TypeNumber(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(Interface_Protocol self, Interface_Graph G, Handle_Interface_Check ach) -> Standard_Boolean

        Evaluates a Global Check for a model (with its Graph)
        Returns True when done, False if data in model do not apply

        Very specific of each norm, i.e. of each protocol : the
        uppest level Protocol assumes it, it can call GlobalCheck of
        its ressources only if it is necessary

        Default does nothing, can be redefined

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Protocol_GlobalCheck(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Interface_Protocol self) -> Handle_Interface_InterfaceModel

        Creates an empty Model of the considered Norm

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_Protocol_NewModel(self, *args)


    def IsSuitableModel(self, *args):
        """
        IsSuitableModel(Interface_Protocol self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True if <model> is a Model of the considered Norm

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Protocol_IsSuitableModel(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(Interface_Protocol self) -> Handle_Standard_Transient

        Creates a new Unknown Entity for the considered Norm

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_Protocol_UnknownEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Interface_Protocol self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is an Unknown Entity for the Norm, i.e.
        same Type as them created by method UnknownEntity
        (for an Entity out of the Norm, answer can be unpredicable)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Protocol_IsUnknownEntity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_Protocol_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_Protocol_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_Protocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_Protocol
Interface_Protocol_swigregister = _Interface.Interface_Protocol_swigregister
Interface_Protocol_swigregister(Interface_Protocol)

def Interface_Protocol_Active(*args):
    """
    Interface_Protocol_Active() -> Handle_Interface_Protocol

    Returns the Active Protocol, if defined (else, returns a
    Null Handle, which means "no defined active protocol")

    :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

    """
    return _Interface.Interface_Protocol_Active(*args)

def Interface_Protocol_SetActive(*args):
    """
    Interface_Protocol_SetActive(Handle_Interface_Protocol aprotocol)

    Sets a given Protocol to be the Active one (for the users of
    Active, see just above). Applies to every sub-type of Protocol

    :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

    """
    return _Interface.Interface_Protocol_SetActive(*args)

def Interface_Protocol_ClearActive(*args):
    """
    Interface_Protocol_ClearActive()

    Erases the Active Protocol (hence it becomes undefined)


    """
    return _Interface.Interface_Protocol_ClearActive(*args)

def Interface_Protocol_get_type_name(*args):
    """
    Interface_Protocol_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_Protocol_get_type_name(*args)

def Interface_Protocol_get_type_descriptor(*args):
    """
    Interface_Protocol_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_Protocol_get_type_descriptor(*args)

class Interface_ReaderModule(Standard.Standard_Transient):
    """
    Defines unitary operations required to read an Entity from a
    File (see FileReaderData, FileReaderTool), under control of
    a FileReaderTool. The initial creation is performed by a
    GeneralModule (set in GeneralLib). Then, which remains is
    Loading data from the FileReaderData to the Entity

    To work, a GeneralModule has formerly recognized the Type read
    from FileReaderData as a positive Case Number, then the
    ReaderModule reads it according to this Case Number
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_ReaderModule
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_ReaderModule(self) 
            return h


    def CaseNum(self, *args):
        """
        CaseNum(Interface_ReaderModule self, Handle_Interface_FileReaderData data, Standard_Integer const num) -> Standard_Integer

        Translates the type of record <num> in <data> to a positive
        Case Number. If Recognition fails, must return 0

        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ReaderModule_CaseNum(self, *args)


    def Read(self, *args):
        """
        Read(Interface_ReaderModule self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        Performs the effective loading from <data>, record <num>,
        to the Entity <ent> formerly created
        In case of Error or Warning, fills <ach> with messages
        Remark that the Case Number comes from translating a record

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ReaderModule_Read(self, *args)


    def NewRead(self, *args):
        """
        NewRead(Interface_ReaderModule self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific operator (create+read) defaulted to do nothing.
        It can be redefined when it is not possible to work in two
        steps (NewVoid then Read). This occurs when no default
        constructor is defined : hence the result <ent> must be
        created with an effective definition from the reader.
        Remark : if NewRead is defined, Copy has nothing to do.

        Returns True if it has produced something, false else.
        If nothing was produced, <ach> should be filled : it will be
        treated as "Unrecognized case" by reader tool.

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReaderModule_NewRead(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_ReaderModule_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_ReaderModule_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_ReaderModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_ReaderModule
Interface_ReaderModule_swigregister = _Interface.Interface_ReaderModule_swigregister
Interface_ReaderModule_swigregister(Interface_ReaderModule)

def Interface_ReaderModule_get_type_name(*args):
    """
    Interface_ReaderModule_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_ReaderModule_get_type_name(*args)

def Interface_ReaderModule_get_type_descriptor(*args):
    """
    Interface_ReaderModule_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_ReaderModule_get_type_descriptor(*args)

class Handle_Interface_CheckFailure(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_CheckFailure self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_CheckFailure_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_CheckFailure self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_CheckFailure_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_CheckFailure self, Interface_CheckFailure thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_CheckFailure_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_CheckFailure self, Handle_Interface_CheckFailure theHandle) -> Handle_Interface_CheckFailure
        assign(Handle_Interface_CheckFailure self, Interface_CheckFailure thePtr) -> Handle_Interface_CheckFailure
        assign(Handle_Interface_CheckFailure self, Handle_Interface_CheckFailure theHandle) -> Handle_Interface_CheckFailure

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_CheckFailure_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_CheckFailure self) -> Interface_CheckFailure

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_CheckFailure_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_CheckFailure self) -> Interface_CheckFailure

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_CheckFailure___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_CheckFailure self) -> Interface_CheckFailure

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_CheckFailure___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_CheckFailure___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_CheckFailure___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_CheckFailure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_CheckFailure_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_CheckFailure

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Interface_CheckFailure self, Standard_CString const theMessage) -> Handle_Interface_CheckFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_CheckFailure

        """
        return _Interface.Handle_Interface_CheckFailure_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_CheckFailure self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_CheckFailure_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_CheckFailure_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_CheckFailure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Interface_CheckFailure self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Interface.Handle_Interface_CheckFailure_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Interface_CheckFailure self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_CheckFailure_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Interface_CheckFailure self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_CheckFailure_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Interface_CheckFailure self)
        Reraise(Handle_Interface_CheckFailure self, Standard_CString const aMessage)
        Reraise(Handle_Interface_CheckFailure self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Interface.Handle_Interface_CheckFailure_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Interface_CheckFailure self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Interface.Handle_Interface_CheckFailure_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Interface_CheckFailure self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Interface.Handle_Interface_CheckFailure_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_CheckFailure self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_CheckFailure_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_CheckFailure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_CheckFailure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CheckFailure_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_CheckFailure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_CheckFailure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CheckFailure_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_CheckFailure self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_CheckFailure_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_CheckFailure self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_CheckFailure_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_CheckFailure self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_CheckFailure_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_CheckFailure self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_CheckFailure_DecrementRefCounter(self, *args)

Handle_Interface_CheckFailure_swigregister = _Interface.Handle_Interface_CheckFailure_swigregister
Handle_Interface_CheckFailure_swigregister(Handle_Interface_CheckFailure)

def Handle_Interface_CheckFailure_DownCast(thing):
    return _Interface.Handle_Interface_CheckFailure_DownCast(thing)
Handle_Interface_CheckFailure_DownCast = _Interface.Handle_Interface_CheckFailure_DownCast

class Interface_EntityList(object):
    """
    This class defines a list of Entities (Transient Objects),
    it can be used as a field of other Transient classes, with
    these features :
    - oriented to define a little list, that is, slower than an
    Array or a Map of Entities for a big count (about 100 and
    over), but faster than a Sequence
    - allows to work as a Sequence, limited to Clear, Append,
    Remove, Access to an Item identified by its rank in the list
    - space saving, compared to a Sequence, especially for little
    amounts; better than an Array for a very little amount (less
    than 10) but less good for a greater amount

    Works in conjunction with EntityCluster
    An EntityList gives access to a list of Entity Clusters, which
    are chained (in one sense : Single List)
    Remark : a new Item may not be Null, because this is the
    criterium used for "End of List" 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_EntityList self) -> Interface_EntityList

        Creates a List as beeing empty


        """
        this = _Interface.new_Interface_EntityList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(Interface_EntityList self)

        Clears the List


        """
        return _Interface.Interface_EntityList_Clear(self, *args)


    def Append(self, *args):
        """
        Append(Interface_EntityList self, Handle_Standard_Transient ent)

        Appends an Entity, that is to the END of the list
        (keeps order, but works slowerly than Add, see below)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityList_Append(self, *args)


    def Add(self, *args):
        """
        Add(Interface_EntityList self, Handle_Standard_Transient ent)

        Adds an Entity to the list, that is, with NO REGARD about the
        order (faster than Append if count becomes greater than 10)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityList_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Interface_EntityList self, Handle_Standard_Transient ent)
        Remove(Interface_EntityList self, Standard_Integer const num)

        Removes an Entity from the list, given its rank

        :type num: int

        """
        return _Interface.Interface_EntityList_Remove(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Interface_EntityList self) -> Standard_Boolean

        Returns True if the list is empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_EntityList_IsEmpty(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Interface_EntityList self) -> Standard_Integer

        Returns count of recorded Entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_EntityList_NbEntities(self, *args)


    def Value(self, *args):
        """
        Returns an Item given its number. Beware about the way the
        list was filled (see above, Add and Append)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_EntityList_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Interface_EntityList self, Standard_Integer const num, Handle_Standard_Transient ent)

        Returns an Item given its number. Beware about the way the
        list was filled (see above, Add and Append)

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityList_SetValue(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Interface_EntityList self, Interface_EntityIterator iter)

        fills an Iterator with the content of the list
        (normal way to consult a list which has been filled with Add)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_EntityList_FillIterator(self, *args)


    def NbTypedEntities(self, *args):
        """
        NbTypedEntities(Interface_EntityList self, Handle_Standard_Type atype) -> Standard_Integer

        Returns count of Entities of a given Type (0 : none)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_EntityList_NbTypedEntities(self, *args)


    def TypedEntity(self, *args):
        """
        TypedEntity(Interface_EntityList self, Handle_Standard_Type atype, Standard_Integer const num=0) -> Handle_Standard_Transient

        Returns the Entity which is of a given type.
        If num = 0 (D), there must be ONE AND ONLY ONE
        If num > 0, returns the num-th entity of this type

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityList_TypedEntity(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_EntityList
Interface_EntityList_swigregister = _Interface.Interface_EntityList_swigregister
Interface_EntityList_swigregister(Interface_EntityList)

class Interface_HGraph(Standard.Standard_Transient):
    """
    This class allows to store a redefinable Graph, via a Handle
    (usefull for an Object which can work on several successive
    Models, with the same general conditions)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_HGraph
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_HGraph(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_HGraph self, Interface_Graph agraph) -> Interface_HGraph
        __init__(Interface_HGraph self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib, Standard_Boolean const theModeStats) -> Interface_HGraph
        __init__(Interface_HGraph self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol, Standard_Boolean const theModeStats) -> Interface_HGraph
        __init__(Interface_HGraph self, Handle_Interface_InterfaceModel amodel, Handle_Interface_GTool gtool, Standard_Boolean const theModeStats) -> Interface_HGraph
        __init__(Interface_HGraph self, Handle_Interface_InterfaceModel amodel, Standard_Boolean const theModeStats) -> Interface_HGraph

        Same a above, but works with the GTool in the model

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type theModeStats: bool

        """
        this = _Interface.new_Interface_HGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Graph(self, *args):
        """
        Returns the Graph contained in <me>, for Read Only Operations
        Remark that it is returns as "const &"
        Getting it in a new variable instead of a reference would be
        a pitty, because all the graph's content would be duplicated

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _Interface.Interface_HGraph_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CGraph(self, *args):
        """
        CGraph(Interface_HGraph self) -> Interface_Graph

        Same as above, but for Read-Write Operations
        Then, The Graph will be modified in the HGraph itself

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        return _Interface.Interface_HGraph_CGraph(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_HGraph_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_HGraph_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_HGraph_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_HGraph
Interface_HGraph_swigregister = _Interface.Interface_HGraph_swigregister
Interface_HGraph_swigregister(Interface_HGraph)

def Interface_HGraph_get_type_name(*args):
    """
    Interface_HGraph_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_HGraph_get_type_name(*args)

def Interface_HGraph_get_type_descriptor(*args):
    """
    Interface_HGraph_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_HGraph_get_type_descriptor(*args)

class Interface_ShareTool(object):
    """
    Builds the Graph of Dependancies, from the General Service
    "Shared" -> builds for each Entity of a Model, the Shared and
    Sharing Lists, and gives access to them.
    Allows to complete with Implied References (which are not
    regarded as Shared Entities, but are nevertheless Referenced),
    this can be usefull for Reference Checking
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_ShareTool self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib) -> Interface_ShareTool
        __init__(Interface_ShareTool self, Handle_Interface_InterfaceModel amodel, Handle_Interface_GTool gtool) -> Interface_ShareTool
        __init__(Interface_ShareTool self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol) -> Interface_ShareTool
        __init__(Interface_ShareTool self, Handle_Interface_InterfaceModel amodel) -> Interface_ShareTool
        __init__(Interface_ShareTool self, Interface_Graph agraph) -> Interface_ShareTool
        __init__(Interface_ShareTool self, Handle_Interface_HGraph ahgraph) -> Interface_ShareTool

        Completes the Graph by Adding Implied References. Hence, they
        are considered as Sharing References in all the other queries

        :type ahgraph: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        this = _Interface.new_Interface_ShareTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args):
        """
        Model(Interface_ShareTool self) -> Handle_Interface_InterfaceModel

        Returns the Model used for Creation (directly or for Graph)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_ShareTool_Model(self, *args)


    def Graph(self, *args):
        """
        Returns the data used by the ShareTool to work
        Can then be used directly (read only)

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _Interface.Interface_ShareTool_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootEntities(self, *args):
        """
        RootEntities(Interface_ShareTool self) -> Interface_EntityIterator

        Returns the Entities which are not Shared (their Sharing List
        is empty) in the Model

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_RootEntities(self, *args)


    def IsShared(self, *args):
        """
        IsShared(Interface_ShareTool self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is Shared by other Entities in the Model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ShareTool_IsShared(self, *args)


    def Shareds(self, *args):
        """
        Shareds(Interface_ShareTool self, Handle_Standard_Transient ent) -> Interface_EntityIterator

        Returns the List of Entities Shared by a given Entity <ent>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_Shareds(self, *args)


    def Sharings(self, *args):
        """
        Sharings(Interface_ShareTool self, Handle_Standard_Transient ent) -> Interface_EntityIterator

        Returns the List of Entities Sharing a given Entity <ent>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_Sharings(self, *args)


    def NbTypedSharings(self, *args):
        """
        NbTypedSharings(Interface_ShareTool self, Handle_Standard_Transient ent, Handle_Standard_Type atype) -> Standard_Integer

        Returns the count of Sharing Entities of an Entity, which
        are Kind of a given Type

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ShareTool_NbTypedSharings(self, *args)


    def TypedSharing(self, *args):
        """
        TypedSharing(Interface_ShareTool self, Handle_Standard_Transient ent, Handle_Standard_Type atype) -> Handle_Standard_Transient

        Returns the Sharing Entity of an Entity, which is Kind of a
        given Type. Allows to access a Sharing Entity of a given type
        when there is one and only one (current case)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ShareTool_TypedSharing(self, *args)


    def All(self, *args):
        """
        All(Interface_ShareTool self, Handle_Standard_Transient ent, Standard_Boolean const rootlast) -> Interface_EntityIterator

        Returns the complete list of entities shared by <ent> at any
        level, including <ent> itself
        If <ent> is the Model, considers the concatenation of
        AllShared for each root
        If <rootlast> is True (D), the list starts with lower level
        entities and ends by the root. Else, the root is first and
        the lower level entities are at end

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type rootlast: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_All(self, *args)


    def Print(self, *args):
        """
        Print(Interface_ShareTool self, Interface_EntityIterator iter, Handle_Message_Messenger S)

        Utility method which Prints the content of an iterator
        (by their Numbers)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_ShareTool_Print(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_ShareTool
Interface_ShareTool_swigregister = _Interface.Interface_ShareTool_swigregister
Interface_ShareTool_swigregister(Interface_ShareTool)

class Handle_Interface_GTool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_GTool self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_GTool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_GTool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_GTool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_GTool self, Interface_GTool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_GTool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_GTool self, Handle_Interface_GTool theHandle) -> Handle_Interface_GTool
        assign(Handle_Interface_GTool self, Interface_GTool thePtr) -> Handle_Interface_GTool
        assign(Handle_Interface_GTool self, Handle_Interface_GTool theHandle) -> Handle_Interface_GTool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_GTool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_GTool self) -> Interface_GTool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_GTool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_GTool self) -> Interface_GTool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_GTool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_GTool self) -> Interface_GTool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_GTool___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_GTool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_GTool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_GTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_GTool_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_GTool

    def SetSignType(self, *args):
        """
        SetSignType(Handle_Interface_GTool self, Handle_Interface_SignType sign)

        Sets a new SignType

        :type sign: OCC.wrapper.Interface.Handle_Interface_SignType

        """
        return _Interface.Handle_Interface_GTool_SetSignType(self, *args)


    def SignType(self, *args):
        """
        SignType(Handle_Interface_GTool self) -> Handle_Interface_SignType

        Returns the SignType. Can be null

        :rtype: OCC.wrapper.Interface.Handle_Interface_SignType

        """
        return _Interface.Handle_Interface_GTool_SignType(self, *args)


    def SignValue(self, *args):
        """
        SignValue(Handle_Interface_GTool self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient Object in a Model
        It calls SignType to do that
        If SignType is not defined, return ClassName of <ent>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_GTool_SignValue(self, *args)


    def SignName(self, *args):
        """
        SignName(Handle_Interface_GTool self) -> Standard_CString

        Returns the Name of the SignType, or "Class Name"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_GTool_SignName(self, *args)


    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_Interface_GTool self, Handle_Interface_Protocol proto, Standard_Boolean const enforce)

        Sets a new Protocol
        if <enforce> is False and the new Protocol equates the old one
        then nothing is done

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type enforce: bool

        """
        return _Interface.Handle_Interface_GTool_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Protocol(Handle_Interface_GTool self) -> Handle_Interface_Protocol

        Returns the Protocol.  Warning : it can be Null

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_GTool_Protocol(self, *args)


    def Lib(self, *args):
        """
        Lib(Handle_Interface_GTool self) -> Interface_GeneralLib

        Returns the GeneralLib itself

        :rtype: OCC.wrapper.Interface.Interface_GeneralLib

        """
        return _Interface.Handle_Interface_GTool_Lib(self, *args)


    def Reservate(self, *args):
        """
        Reservate(Handle_Interface_GTool self, Standard_Integer const nb, Standard_Boolean const enforce)

        Reservates maps for a count of entities
        <enforce> False : minimum count
        <enforce> True  : clears former reservations
        Does not clear the maps

        :type nb: int
        :type enforce: bool

        """
        return _Interface.Handle_Interface_GTool_Reservate(self, *args)


    def ClearEntities(self, *args):
        """
        ClearEntities(Handle_Interface_GTool self)

        Clears the maps which record, for each already recorded entity
        its Module and Case Number


        """
        return _Interface.Handle_Interface_GTool_ClearEntities(self, *args)


    def Select(self, *args):
        """
        Select(Handle_Interface_GTool self, Handle_Standard_Transient ent, Handle_Interface_GeneralModule gmod, Standard_Boolean const enforce) -> Standard_Boolean

        Selects for an entity, its Module and Case Number
        It is optimised : once done for each entity, the result is
        mapped and the GeneralLib is not longer queried
        <enforce> True overpasses this optimisation

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type gmod: OCC.wrapper.Interface.Handle_Interface_GeneralModule
        :type CN: int
        :type enforce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GTool_Select(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_GTool self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_GTool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GTool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_GTool self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_GTool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_GTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_GTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GTool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_GTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_GTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GTool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_GTool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_GTool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_GTool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GTool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_GTool self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_GTool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_GTool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GTool_DecrementRefCounter(self, *args)

Handle_Interface_GTool_swigregister = _Interface.Handle_Interface_GTool_swigregister
Handle_Interface_GTool_swigregister(Handle_Interface_GTool)

def Handle_Interface_GTool_DownCast(thing):
    return _Interface.Handle_Interface_GTool_DownCast(thing)
Handle_Interface_GTool_DownCast = _Interface.Handle_Interface_GTool_DownCast

class Interface_Graph(object):
    """
    Gives basic data structure for operating and storing
    graph results (usage is normally internal)
    Entities are Mapped according their Number in the Model

    Each Entity from the Model can be known as "Present" or
    not; if it is, it is Mapped with a Status : an Integer
    which can be used according to needs of each algorithm
    In addition, the Graph brings a BitMap which can be used
    by any caller

    Also, it is bound with two lists : a list of Shared
    Entities (in fact, their Numbers in the Model) which is
    filled by a ShareTool, and a list of Sharing Entities,
    computed by deduction from the Shared Lists

    Moreover, it is possible to redefine the list of Entities
    Shared by an Entity (instead of standard answer by general
    service Shareds) : this new list can be empty; it can
    be changed or reset (i.e. to come back to standard answer)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_Graph self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib, Standard_Boolean const theModeStats) -> Interface_Graph
        __init__(Interface_Graph self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol, Standard_Boolean const theModeStats) -> Interface_Graph
        __init__(Interface_Graph self, Handle_Interface_InterfaceModel amodel, Handle_Interface_GTool gtool, Standard_Boolean const theModeStats) -> Interface_Graph
        __init__(Interface_Graph self, Handle_Interface_InterfaceModel amodel, Standard_Boolean const theModeStats) -> Interface_Graph
        __init__(Interface_Graph self, Interface_Graph agraph, Standard_Boolean const copied) -> Interface_Graph

        Creates a Graph from another one, getting all its data
        Remark that status are copied from <agraph>, but the other
        lists (sharing/shared) are copied only if <copied> = True

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type copied: bool

        """
        this = _Interface.new_Interface_Graph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(Interface_Graph self)

        Erases data, making graph ready to rebegin from void
        (also resets Shared lists redefinitions)


        """
        return _Interface.Interface_Graph_Reset(self, *args)


    def ResetStatus(self, *args):
        """
        ResetStatus(Interface_Graph self)

        Erases Status (Values and Flags of Presence), making graph
        ready to rebegin from void. Does not concerns Shared lists


        """
        return _Interface.Interface_Graph_ResetStatus(self, *args)


    def Size(self, *args):
        """
        Size(Interface_Graph self) -> Standard_Integer

        Returns size (max nb of entities, i.e. Model's nb of entities)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Graph_Size(self, *args)


    def NbStatuses(self, *args):
        """
        NbStatuses(Interface_Graph self) -> Standard_Integer

        Returns size of array of statuses

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Graph_NbStatuses(self, *args)


    def EntityNumber(self, *args):
        """
        EntityNumber(Interface_Graph self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the Number of the entity in the Map, computed at
        creation time (Entities loaded from the Model)
        Returns 0 if <ent> not contained by Model used to create <me>
        (that is, <ent> is unknown from <me>)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Graph_EntityNumber(self, *args)


    def IsPresent(self, *args):
        """
        IsPresent(Interface_Graph self, Standard_Integer const num) -> Standard_Boolean
        IsPresent(Interface_Graph self, Handle_Standard_Transient ent) -> Standard_Boolean

        Same as above but directly on an Entity <ent> : if it is not
        contained in the Model, returns False. Else calls
        IsPresent(num)  with <num> given by EntityNumber

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Graph_IsPresent(self, *args)


    def Entity(self, *args):
        """
        Returns mapped Entity given its no (if it is present)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_Graph_Entity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Interface_Graph self, Standard_Integer const num) -> Standard_Integer

        Returns Status associated to a numero (only to read it)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Graph_Status(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Interface_Graph self, Standard_Integer const num, Standard_Integer const stat)

        Modifies Status associated to a numero

        :type num: int
        :type stat: int

        """
        return _Interface.Interface_Graph_SetStatus(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(Interface_Graph self, Standard_Integer const num)

        Clears Entity and sets Status to 0, for a numero

        :type num: int

        """
        return _Interface.Interface_Graph_RemoveItem(self, *args)


    def ChangeStatus(self, *args):
        """
        ChangeStatus(Interface_Graph self, Standard_Integer const oldstat, Standard_Integer const newstat)

        Changes all status which value is oldstat to new value newstat

        :type oldstat: int
        :type newstat: int

        """
        return _Interface.Interface_Graph_ChangeStatus(self, *args)


    def RemoveStatus(self, *args):
        """
        RemoveStatus(Interface_Graph self, Standard_Integer const stat)

        Removes all items of which status has a given value stat

        :type stat: int

        """
        return _Interface.Interface_Graph_RemoveStatus(self, *args)


    def BitMap(self, *args):
        """
        Returns the Bit Map in order to read or edit flag values

        :rtype: OCC.wrapper.Interface.Interface_BitMap

        """
        res = _Interface.Interface_Graph_BitMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CBitMap(self, *args):
        """
        CBitMap(Interface_Graph self) -> Interface_BitMap

        Returns the Bit Map in order to edit it (add new flags)

        :rtype: OCC.wrapper.Interface.Interface_BitMap

        """
        return _Interface.Interface_Graph_CBitMap(self, *args)


    def Model(self, *args):
        """
        Returns the Model with which this Graph was created

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _Interface.Interface_Graph_Model(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFromModel(self, *args):
        """
        GetFromModel(Interface_Graph self)

        Loads Graph with all Entities contained in the Model


        """
        return _Interface.Interface_Graph_GetFromModel(self, *args)


    def GetFromEntity(self, *args):
        """
        GetFromEntity(Interface_Graph self, Handle_Standard_Transient ent, Standard_Boolean const shared, Standard_Integer const newstat=0)
        GetFromEntity(Interface_Graph self, Handle_Standard_Transient ent, Standard_Boolean const shared, Standard_Integer const newstat, Standard_Integer const overlapstat, Standard_Boolean const cumul)

        Gets an Entity, plus its shared ones (at every level) if
        "shared" is True. New items are set to status "newstat".
        Items already present in graph are processed as follows :
        - if they already have status "newstat", they remain unchanged
        - if they have another status, this one is modified :
        if cumul is True,  to former status + overlapstat (cumul)
        if cumul is False, to overlapstat (enforce)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shared: bool
        :type newstat: int
        :type overlapstat: int
        :type cumul: bool

        """
        return _Interface.Interface_Graph_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(Interface_Graph self, Interface_EntityIterator iter, Standard_Integer const newstat)
        GetFromIter(Interface_Graph self, Interface_EntityIterator iter, Standard_Integer const newstat, Standard_Integer const overlapstat, Standard_Boolean const cumul)

        Gets Entities given by an EntityIterator and distinguishes
        those already present in the Graph :
        - new entities added to the Graph with status "newstst"
        - entities already present with status = "newstat" remain
        unchanged
        - entities already present with status different form
        "newstat" have their status modified :
        if cumul is True,  to former status + overlapstat (cumul)
        if cumul is False, to overlapstat (enforce)
        (Note : works as GetEntity, shared = False, for each entity)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type newstat: int
        :type overlapstat: int
        :type cumul: bool

        """
        return _Interface.Interface_Graph_GetFromIter(self, *args)


    def GetFromGraph(self, *args):
        """
        GetFromGraph(Interface_Graph self, Interface_Graph agraph)
        GetFromGraph(Interface_Graph self, Interface_Graph agraph, Standard_Integer const stat)

        Gets items from another graph which have a specific Status

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type stat: int

        """
        return _Interface.Interface_Graph_GetFromGraph(self, *args)


    def HasShareErrors(self, *args):
        """
        HasShareErrors(Interface_Graph self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> or the list of entities shared by <ent>
        (not redefined) contains items unknown from this Graph
        Remark : apart from the status HasShareError, these items
        are ignored

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Graph_HasShareErrors(self, *args)


    def GetShareds(self, *args):
        """
        GetShareds(Interface_Graph self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the sequence of Entities Shared by an Entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Interface.Interface_Graph_GetShareds(self, *args)


    def Shareds(self, *args):
        """
        Shareds(Interface_Graph self, Handle_Standard_Transient ent) -> Interface_EntityIterator

        Returns the list of Entities Shared by an Entity, as recorded
        by the Graph. That is, by default Basic Shared List, else it
        can be redefined by methods SetShare, SetNoShare ... see below

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_Graph_Shareds(self, *args)


    def Sharings(self, *args):
        """
        Sharings(Interface_Graph self, Handle_Standard_Transient ent) -> Interface_EntityIterator

        Returns the list of Entities which Share an Entity, computed
        from the Basic or Redefined Shared Lists

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_Graph_Sharings(self, *args)


    def GetSharings(self, *args):
        """
        GetSharings(Interface_Graph self, Handle_Standard_Transient ent) -> Handle_TColStd_HSequenceOfTransient

        Returns the sequence of Entities Sharings by an Entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Interface.Interface_Graph_GetSharings(self, *args)


    def TypedSharings(self, *args):
        """
        TypedSharings(Interface_Graph self, Handle_Standard_Transient ent, Handle_Standard_Type type) -> Interface_EntityIterator

        Returns the list of sharings entities, AT ANY LEVEL, which are
        kind of a given type. A sharing entity kind of this type
        ends the exploration of its branch

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_Graph_TypedSharings(self, *args)


    def RootEntities(self, *args):
        """
        RootEntities(Interface_Graph self) -> Interface_EntityIterator

        Returns the Entities which are not Shared (their Sharing List
        is empty) in the Model

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_Graph_RootEntities(self, *args)


    def Name(self, *args):
        """
        Name(Interface_Graph self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Determines the name attached to an entity, by using the
        general service Name in GeneralModule
        Returns a null handle if no name could be computed or if
        the entity is not in the model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_Graph_Name(self, *args)


    def SharingTable(self, *args):
        """
        Returns the Table of Sharing lists. Used to Create
        another Graph from <me>

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfListOfInteger

        """
        res = _Interface.Interface_Graph_SharingTable(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModeStat(self, *args):
        """
        ModeStat(Interface_Graph self) -> Standard_Boolean

        Returns mode resposible for computation of statuses;

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Graph_ModeStat(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_Graph
Interface_Graph_swigregister = _Interface.Interface_Graph_swigregister
Interface_Graph_swigregister(Interface_Graph)

class Interface_HSequenceOfCheck(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_HSequenceOfCheck
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_HSequenceOfCheck(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_HSequenceOfCheck self) -> Interface_HSequenceOfCheck
        __init__(Interface_HSequenceOfCheck self, NCollection_Sequence_Handle_Interface_Check theOther) -> Interface_HSequenceOfCheck

        :type theOther: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        this = _Interface.new_Interface_HSequenceOfCheck(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        res = _Interface.Interface_HSequenceOfCheck_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Interface_HSequenceOfCheck self, Handle_Interface_Check theItem)
        Append(Interface_HSequenceOfCheck self, NCollection_Sequence_Handle_Interface_Check theSequence)

        :type theSequence: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        return _Interface.Interface_HSequenceOfCheck_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Interface_HSequenceOfCheck self) -> NCollection_Sequence_Handle_Interface_Check

        :rtype: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        return _Interface.Interface_HSequenceOfCheck_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_HSequenceOfCheck_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_HSequenceOfCheck_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_HSequenceOfCheck_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_HSequenceOfCheck
Interface_HSequenceOfCheck_swigregister = _Interface.Interface_HSequenceOfCheck_swigregister
Interface_HSequenceOfCheck_swigregister(Interface_HSequenceOfCheck)

def Interface_HSequenceOfCheck_get_type_name(*args):
    """
    Interface_HSequenceOfCheck_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_HSequenceOfCheck_get_type_name(*args)

def Interface_HSequenceOfCheck_get_type_descriptor(*args):
    """
    Interface_HSequenceOfCheck_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_HSequenceOfCheck_get_type_descriptor(*args)

class Handle_Interface_ReportEntity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_ReportEntity self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_ReportEntity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_ReportEntity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_ReportEntity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_ReportEntity self, Interface_ReportEntity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_ReportEntity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_ReportEntity self, Handle_Interface_ReportEntity theHandle) -> Handle_Interface_ReportEntity
        assign(Handle_Interface_ReportEntity self, Interface_ReportEntity thePtr) -> Handle_Interface_ReportEntity
        assign(Handle_Interface_ReportEntity self, Handle_Interface_ReportEntity theHandle) -> Handle_Interface_ReportEntity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_ReportEntity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_ReportEntity self) -> Interface_ReportEntity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_ReportEntity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_ReportEntity self) -> Interface_ReportEntity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_ReportEntity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_ReportEntity self) -> Interface_ReportEntity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_ReportEntity___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_ReportEntity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_ReportEntity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_ReportEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_ReportEntity_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_ReportEntity

    def SetContent(self, *args):
        """
        SetContent(Handle_Interface_ReportEntity self, Handle_Standard_Transient content)

        Sets a Content : it brings non interpreted data which belong
        to the Concerned Entity. It can be empty then loaded later.
        Remark that for an Unknown Entity, Content is set by Create.

        :type content: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_ReportEntity_SetContent(self, *args)


    def Check(self, *args):
        """
        Returns the stored Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Handle_Interface_ReportEntity_Check(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CCheck(self, *args):
        """
        CCheck(Handle_Interface_ReportEntity self) -> Handle_Interface_Check

        Returns the stored Check in order to change it

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Handle_Interface_ReportEntity_CCheck(self, *args)


    def Concerned(self, *args):
        """
        Concerned(Handle_Interface_ReportEntity self) -> Handle_Standard_Transient

        Returns the stored Concerned Entity. It equates the Content
        in the case of an Unknown Entity

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_ReportEntity_Concerned(self, *args)


    def HasContent(self, *args):
        """
        HasContent(Handle_Interface_ReportEntity self) -> Standard_Boolean

        Returns True if a Content is stored (it can equate Concerned)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReportEntity_HasContent(self, *args)


    def HasNewContent(self, *args):
        """
        HasNewContent(Handle_Interface_ReportEntity self) -> Standard_Boolean

        Returns True if a Content is stored AND differs from Concerned
        (i.e. redefines content) : used when Concerned could not be
        loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReportEntity_HasNewContent(self, *args)


    def Content(self, *args):
        """
        Content(Handle_Interface_ReportEntity self) -> Handle_Standard_Transient

        Returns the stored Content, or a Null Handle
        Remark that it must be an "Unknown Entity" suitable for
        the norm of the containing Model

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_ReportEntity_Content(self, *args)


    def IsError(self, *args):
        """
        IsError(Handle_Interface_ReportEntity self) -> Standard_Boolean

        Returns True for an Error Entity, i.e. if the Check
        brings at least one Fail message

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReportEntity_IsError(self, *args)


    def IsUnknown(self, *args):
        """
        IsUnknown(Handle_Interface_ReportEntity self) -> Standard_Boolean

        Returns True for an Unknown Entity, i,e. if the Check
        is empty and Concerned equates Content

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReportEntity_IsUnknown(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_ReportEntity self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_ReportEntity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ReportEntity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ReportEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_ReportEntity self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_ReportEntity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_ReportEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_ReportEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReportEntity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_ReportEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_ReportEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReportEntity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_ReportEntity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_ReportEntity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_ReportEntity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ReportEntity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_ReportEntity self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_ReportEntity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_ReportEntity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ReportEntity_DecrementRefCounter(self, *args)

Handle_Interface_ReportEntity_swigregister = _Interface.Handle_Interface_ReportEntity_swigregister
Handle_Interface_ReportEntity_swigregister(Handle_Interface_ReportEntity)

def Handle_Interface_ReportEntity_DownCast(thing):
    return _Interface.Handle_Interface_ReportEntity_DownCast(thing)
Handle_Interface_ReportEntity_DownCast = _Interface.Handle_Interface_ReportEntity_DownCast

class Handle_Interface_SignType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_SignType self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_SignType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_SignType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_SignType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_SignType self, Interface_SignType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_SignType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_SignType self, Handle_Interface_SignType theHandle) -> Handle_Interface_SignType
        assign(Handle_Interface_SignType self, Interface_SignType thePtr) -> Handle_Interface_SignType
        assign(Handle_Interface_SignType self, Handle_Interface_SignType theHandle) -> Handle_Interface_SignType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_SignType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_SignType self) -> Interface_SignType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_SignType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_SignType self) -> Interface_SignType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_SignType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_SignType self) -> Interface_SignType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_SignType___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_SignType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_SignType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_SignType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_SignType_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_SignType

    def Text(self, *args):
        """
        Text(Handle_Interface_SignType self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Handle_Interface_SignType_Text(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Interface_SignType self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_SignType_Value(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_Interface_SignType self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_SignType_ClassName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_SignType self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_SignType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_SignType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_SignType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_Interface_SignType self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_SignType_Name(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_Interface_SignType self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Handle_Interface_SignType_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_SignType self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_SignType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_SignType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_SignType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_SignType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_SignType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_SignType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_SignType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_SignType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_SignType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_SignType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_SignType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_SignType self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_SignType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_SignType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_SignType_DecrementRefCounter(self, *args)

Handle_Interface_SignType_swigregister = _Interface.Handle_Interface_SignType_swigregister
Handle_Interface_SignType_swigregister(Handle_Interface_SignType)

def Handle_Interface_SignType_DownCast(thing):
    return _Interface.Handle_Interface_SignType_DownCast(thing)
Handle_Interface_SignType_DownCast = _Interface.Handle_Interface_SignType_DownCast

class NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Standard_Integer,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Standard_Integer,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Standard_Integer,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Standard_Integer,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _Interface.new_NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _Interface.delete_NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher
NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_swigregister = _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Interface.new_NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper_swigregister = _Interface.NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher_IteratorHelper)


try:
	Interface_DataMapOfTransientInteger = NCollection_DataMap_Handle_Standard_Transient_Standard_Integer_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Interface_FileParameter(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Interface_FileParameter self) -> NCollection_Array1< Interface_FileParameter >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Interface_FileParameter self) -> NCollection_Array1< Interface_FileParameter >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Interface_FileParameter self) -> NCollection_Array1< Interface_FileParameter >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Interface_FileParameter self) -> NCollection_Array1< Interface_FileParameter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Interface.new_NCollection_Array1_Interface_FileParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Interface_FileParameter self, Interface_FileParameter theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Interface_FileParameter self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Interface_FileParameter self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Interface_FileParameter self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Interface_FileParameter self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Interface_FileParameter self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Interface_FileParameter self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Interface_FileParameter self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Interface_FileParameter self, NCollection_Array1_Interface_FileParameter theOther) -> NCollection_Array1_Interface_FileParameter

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Interface_FileParameter self, NCollection_Array1_Interface_FileParameter theOther) -> NCollection_Array1_Interface_FileParameter

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Interface_FileParameter self, NCollection_Array1_Interface_FileParameter theOther) -> NCollection_Array1_Interface_FileParameter
        assign(NCollection_Array1_Interface_FileParameter self, NCollection_Array1_Interface_FileParameter theOther) -> NCollection_Array1_Interface_FileParameter

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Interface_FileParameter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Interface_FileParameter self) -> Interface_FileParameter

        @return first element

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Interface_FileParameter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Interface_FileParameter self) -> Interface_FileParameter

        @return last element

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Interface_FileParameter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Interface_FileParameter self, Standard_Integer const theIndex) -> Interface_FileParameter

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Interface_FileParameter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Interface_FileParameter_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Interface_FileParameter self, Standard_Integer const theIndex, Interface_FileParameter theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Interface_FileParameter self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Interface.NCollection_Array1_Interface_FileParameter_Resize(self, *args)

    __swig_destroy__ = _Interface.delete_NCollection_Array1_Interface_FileParameter
NCollection_Array1_Interface_FileParameter_swigregister = _Interface.NCollection_Array1_Interface_FileParameter_swigregister
NCollection_Array1_Interface_FileParameter_swigregister(NCollection_Array1_Interface_FileParameter)


try:
	Interface_Array1OfFileParameter = NCollection_Array1_Interface_FileParameter
except NameError:
	pass # does not exist, probably ignored

class Handle_Interface_GeneralModule(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_GeneralModule self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_GeneralModule_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_GeneralModule self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_GeneralModule_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_GeneralModule self, Interface_GeneralModule thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_GeneralModule_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_GeneralModule self, Handle_Interface_GeneralModule theHandle) -> Handle_Interface_GeneralModule
        assign(Handle_Interface_GeneralModule self, Interface_GeneralModule thePtr) -> Handle_Interface_GeneralModule
        assign(Handle_Interface_GeneralModule self, Handle_Interface_GeneralModule theHandle) -> Handle_Interface_GeneralModule

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_GeneralModule_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_GeneralModule self) -> Interface_GeneralModule

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_GeneralModule_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_GeneralModule self) -> Interface_GeneralModule

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_GeneralModule___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_GeneralModule self) -> Interface_GeneralModule

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_GeneralModule___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_GeneralModule___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_GeneralModule___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_GeneralModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_GeneralModule_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_GeneralModule

    def FillShared(self, *args):
        """
        FillShared(Handle_Interface_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum), considered in the context of a Model <model>
        Default calls FillSharedCase (i.e., ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_GeneralModule_FillShared(self, *args)


    def FillSharedCase(self, *args):
        """
        FillSharedCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum). Can use the internal utility method Share, below

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_GeneralModule_FillSharedCase(self, *args)


    def Share(self, *args):
        """
        Share(Handle_Interface_GeneralModule self, Interface_EntityIterator iter, Handle_Standard_Transient shared)

        Adds an Entity to a Shared List (uses GetOneItem on <iter>)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type shared: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_GeneralModule_Share(self, *args)


    def ListImplied(self, *args):
        """
        ListImplied(Handle_Interface_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> considered in the context
        of a Model <model> : i.e. the Entities which are Referenced
        while not considered as Shared (not copied if <ent> is,
        references not renewed by CopyCase but by ImpliedCase, only
        if referenced Entities have been Copied too)
        FillShared + ListImplied give the complete list of References
        Default calls ListImpliedCase (i.e. ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_GeneralModule_ListImplied(self, *args)


    def ListImpliedCase(self, *args):
        """
        ListImpliedCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> (see above)
        are Referenced while not considered as Shared (not copied if
        <ent> is, references not renewed by CopyCase but by
        ImpliedCase, only if referenced Entities have been Copied too)
        FillSharedCase + ListImpliedCase give the complete list of
        Referenced Entities
        The provided default method does nothing (Implied References
        are specific of a little amount of Entity Classes).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_GeneralModule_ListImpliedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>
        Can check context queried through a ShareTool, as required

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Handle_Interface_GeneralModule_CheckCase(self, *args)


    def CanCopy(self, *args):
        """
        CanCopy(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific answer to the question "is Copy properly implemented"
        Remark that it should be in phase with the implementation of
        NewVoid+CopyCase/NewCopyCase
        Default returns always False, can be redefined

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GeneralModule_CanCopy(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Dispatches an entity
        Returns True if it works by copy, False if it just duplicates
        the starting Handle

        Dispatching means producing a new entity, image of the
        starting one, in order to be put into a new Model, this Model
        being itself the result of a dispatch from an original Model

        According to the cases, dispatch can either
        * just return <entto> as equating <entfrom>
        -> the new model designates the starting entity : it is
        lighter, but the dispatched entity being shared might not be
        modified for dispatch
        * copy <entfrom> to <entto>
        by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1)
        -> the dispatched entity is a COPY, hence it can be modified

        The provided default just duplicates the handle without
        copying, then returns False. Can be redefined

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GeneralModule_Dispatch(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entto) -> Standard_Boolean

        Creates a new void entity <entto> according to a Case Number
        This entity remains to be filled, by reading from a file or
        by copying from another entity of same type (see CopyCase)

        :type CN: int
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GeneralModule_NewVoid(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a CopyTool which provides its working Map.
        Use method Transferred from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _Interface.Handle_Interface_GeneralModule_CopyCase(self, *args)


    def NewCopiedCase(self, *args):
        """
        NewCopiedCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Specific operator (create+copy) defaulted to do nothing.
        It can be redefined : When it is not possible to work in two
        steps (NewVoid then CopyCase). This can occur when there is
        no default constructor : hence the result <entto> must be
        created with an effective definition.
        Remark : if NewCopiedCase is defined, CopyCase has nothing to do
        Returns True if it has produced something, false else

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GeneralModule_NewCopiedCase(self, *args)


    def RenewImpliedCase(self, *args):
        """
        RenewImpliedCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _Interface.Handle_Interface_GeneralModule_RenewImpliedCase(self, *args)


    def WhenDeleteCase(self, *args):
        """
        WhenDeleteCase(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Standard_Boolean const dispatched)

        Prepares an entity to be deleted. What does it mean :
        Basically, any class of entity may define its own destructor
        By default, it does nothing but calling destructors on fields
        With the Memory Manager, it is useless to call destructor,
        it is done automatically when the Handle is nullified(cleared)
        BUT this is ineffective in looping structures (whatever these
        are "Implied" references or not).

        THUS : if no loop may appear in definitions, a class which
        inherits from TShared is correctly managed by automatic way
        BUT if there can be loops (or simply back pointers), they must
        be broken, for instance by clearing fields of one of the nodes
        The default does nothing, to be redefined if a loop can occur
        (Implied generally requires WhenDelete, but other cases can
        occur)

        Warning : <dispatched> tells if the entity to be deleted has been
        produced by Dispatch or not. Hence WhenDelete must be in
        coherence with Dispatch
        Dispatch can either copy or not.
        If it copies the entity, this one should be deleted
        If it doesnt (i.e. duplicates the handle) nothing to do

        If <dispatch> is False, normal deletion is to be performed

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type dispatched: bool

        """
        return _Interface.Handle_Interface_GeneralModule_WhenDeleteCase(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Standard_Integer

        Returns a category number which characterizes an entity
        Category Numbers are managed by the class Category
        <shares> can be used to evaluate this number in the context
        Default returns 0 which means "unspecified"

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GeneralModule_CategoryNumber(self, *args)


    def Name(self, *args):
        """
        Name(Handle_Interface_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Handle_TCollection_HAsciiString

        Determines if an entity brings a Name (or widerly, if a Name
        can be attached to it, through the ShareTool
        By default, returns a Null Handle (no name can be produced)
        Can be redefined

        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_GeneralModule_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_GeneralModule self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_GeneralModule_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GeneralModule_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GeneralModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_GeneralModule self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_GeneralModule_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_GeneralModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_GeneralModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GeneralModule_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_GeneralModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_GeneralModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GeneralModule_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_GeneralModule self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_GeneralModule_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_GeneralModule self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GeneralModule_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_GeneralModule self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_GeneralModule_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_GeneralModule self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GeneralModule_DecrementRefCounter(self, *args)

Handle_Interface_GeneralModule_swigregister = _Interface.Handle_Interface_GeneralModule_swigregister
Handle_Interface_GeneralModule_swigregister(Handle_Interface_GeneralModule)

def Handle_Interface_GeneralModule_DownCast(thing):
    return _Interface.Handle_Interface_GeneralModule_DownCast(thing)
Handle_Interface_GeneralModule_DownCast = _Interface.Handle_Interface_GeneralModule_DownCast

class Interface_CheckIterator(object):
    """Result of a Check operation (especially from InterfaceModel)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_CheckIterator self) -> Interface_CheckIterator
        __init__(Interface_CheckIterator self, Standard_CString const name) -> Interface_CheckIterator

        Creates a CheckIterator with a name (displayed by Print as a
        title)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        this = _Interface.new_Interface_CheckIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetName(self, *args):
        """
        SetName(Interface_CheckIterator self, Standard_CString const name)

        Sets / Changes the name

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_CheckIterator_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Interface_CheckIterator self) -> Standard_CString

        Returns the recorded name (can be empty)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_CheckIterator_Name(self, *args)


    def SetModel(self, *args):
        """
        SetModel(Interface_CheckIterator self, Handle_Interface_InterfaceModel model)

        Defines a Model, used to locate entities (not required, if it
        is absent, entities are simply less documented)

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_CheckIterator_SetModel(self, *args)


    def Model(self, *args):
        """
        Model(Interface_CheckIterator self) -> Handle_Interface_InterfaceModel

        Returns the stored model (can be a null handle)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_CheckIterator_Model(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_CheckIterator self)

        Clears the list of checks


        """
        return _Interface.Interface_CheckIterator_Clear(self, *args)


    def Merge(self, *args):
        """
        Merge(Interface_CheckIterator self, Interface_CheckIterator other)

        Merges another CheckIterator into <me>, i.e. adds each of its
        Checks. Content of <other> remains unchanged.
        Takes also the Model but not the Name

        :type other: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckIterator_Merge(self, *args)


    def Add(self, *args):
        """
        Add(Interface_CheckIterator self, Handle_Interface_Check ach, Standard_Integer const num=0)

        Adds a Check to the list to be iterated
        This Check is Accompanied by Entity Number in the Model
        (0 for Global Check or Entity unknown in the Model), if 0 and
        Model is recorded in <me>, it is computed

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type num: int

        """
        return _Interface.Interface_CheckIterator_Add(self, *args)


    def Check(self, *args):
        """
        Returns the Check attached to an Entity
        If no Check was recorded for this Entity, returns an empty
        Check.
        Remark : Works apart from the iteration methods (no interference)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Interface_CheckIterator_Check(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CCheck(self, *args):
        """
        CCheck(Interface_CheckIterator self, Standard_Integer const num) -> Handle_Interface_Check
        CCheck(Interface_CheckIterator self, Handle_Standard_Transient ent) -> Handle_Interface_Check

        Returns the Check bound to an Entity, in order to be consulted
        or completed on the spot
        I.e. returns the Check if is already exists, or adds it then
        returns the new empty Check

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_CheckIterator_CCheck(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Interface_CheckIterator self, Standard_Boolean const failsonly) -> Standard_Boolean

        Returns True if : no Fail has been recorded if <failsonly> is
        True, no Check at all if <failsonly> is False

        :type failsonly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CheckIterator_IsEmpty(self, *args)


    def Status(self, *args):
        """
        Status(Interface_CheckIterator self) -> Interface_CheckStatus

        Returns worst status among : OK, Warning, Fail

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Interface.Interface_CheckIterator_Status(self, *args)


    def Complies(self, *args):
        """
        Complies(Interface_CheckIterator self, Interface_CheckStatus const status) -> Standard_Boolean

        Tells if this check list complies with a given status :
        OK (i.e. empty),  Warning (at least one Warning, but no Fail),
        Fail (at least one), Message (not OK), NoFail, Any

        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CheckIterator_Complies(self, *args)


    def Extract(self, *args):
        """
        Extract(Interface_CheckIterator self, Interface_CheckStatus const status) -> Interface_CheckIterator
        Extract(Interface_CheckIterator self, Standard_CString const mess, Standard_Integer const incl, Interface_CheckStatus const status) -> Interface_CheckIterator

        Returns a CheckIterator which contains the check which comply
        with a message, plus some conditions as follows :
        <incl> = 0 : <mess> exactly matches one of the messages
        <incl> < 0 : <mess> is contained by one of the messages
        <incl> > 0 : <mess> contains one of the messages
        For <status> : for CheckWarning and CheckFail, considers only
        resp. Warning or Check messages. for CheckAny, considers all
        other values are ignored (answer will be false)
        Each Check which complies is entirely taken

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type incl: int
        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckIterator_Extract(self, *args)


    def Remove(self, *args):
        """
        Remove(Interface_CheckIterator self, Standard_CString const mess, Standard_Integer const incl, Interface_CheckStatus const status) -> Standard_Boolean

        Removes the messages of all Checks, under these conditions :
        <incl> = 0 : <mess> exactly matches one of the messages
        <incl> < 0 : <mess> is contained by one of the messages
        <incl> > 0 : <mess> contains one of the messages
        For <status> : for CheckWarning and CheckFail, considers only
        resp. Warning or Check messages. for CheckAny, considers all
        other values are ignored (nothing is done)
        Returns True if at least one message has been removed, False else

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type incl: int
        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CheckIterator_Remove(self, *args)


    def Checkeds(self, *args):
        """
        Checkeds(Interface_CheckIterator self, Standard_Boolean const failsonly, Standard_Boolean const arg3) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of entities concerned by a Check
        Only fails if <failsonly> is True, else all non-empty checks
        If <global> is true, adds the model for a global check
        Else, global check is ignored

        :type failsonly: bool
        :type global: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Interface.Interface_CheckIterator_Checkeds(self, *args)


    def Start(self, *args):
        """
        Start(Interface_CheckIterator self)

        Starts Iteration. Thus, it is possible to restart it
        Remark : an iteration may be done with a const Iterator
        While its content is modified (through a pointer), this allows
        to give it as a const argument to a function


        """
        return _Interface.Interface_CheckIterator_Start(self, *args)


    def More(self, *args):
        """
        More(Interface_CheckIterator self) -> Standard_Boolean

        Returns True if there are more Checks to get

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CheckIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Interface_CheckIterator self)

        Sets Iteration to next Item


        """
        return _Interface.Interface_CheckIterator_Next(self, *args)


    def Value(self, *args):
        """
        Returns Check currently Iterated
        It brings all other informations (status, messages, ...)
        The Number of the Entity in the Model is given by Number below

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Interface_CheckIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Number(self, *args):
        """
        Number(Interface_CheckIterator self) -> Standard_Integer

        Returns Number of Entity for the Check currently iterated
        or 0 for GlobalCheck

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_CheckIterator_Number(self, *args)


    def Print(self, *args):
        """
        Print(Interface_CheckIterator self, Handle_Message_Messenger S, Standard_Boolean const failsonly, Standard_Integer const final=0)
        Print(Interface_CheckIterator self, Handle_Message_Messenger S, Handle_Interface_InterfaceModel model, Standard_Boolean const failsonly, Standard_Integer const final=0)

        Works as Print without a model, but for entities which have
        no attached number (Number not positive), tries to compute
        this Number from <model> and displays "original" or "computed"

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type failsonly: bool
        :type final: int

        """
        return _Interface.Interface_CheckIterator_Print(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Interface_CheckIterator self)

        Clears data of iteration


        """
        return _Interface.Interface_CheckIterator_Destroy(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_CheckIterator
Interface_CheckIterator_swigregister = _Interface.Interface_CheckIterator_swigregister
Interface_CheckIterator_swigregister(Interface_CheckIterator)

class Handle_Interface_ParamList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_ParamList self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_ParamList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_ParamList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_ParamList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_ParamList self, Interface_ParamList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_ParamList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_ParamList self, Handle_Interface_ParamList theHandle) -> Handle_Interface_ParamList
        assign(Handle_Interface_ParamList self, Interface_ParamList thePtr) -> Handle_Interface_ParamList
        assign(Handle_Interface_ParamList self, Handle_Interface_ParamList theHandle) -> Handle_Interface_ParamList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_ParamList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_ParamList self) -> Interface_ParamList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_ParamList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_ParamList self) -> Interface_ParamList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_ParamList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_ParamList self) -> Interface_ParamList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_ParamList___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_ParamList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_ParamList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_ParamList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_ParamList_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_ParamList

    def Length(self, *args):
        """
        Length(Handle_Interface_ParamList self) -> Standard_Integer

        Returns the number of elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamList_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_Interface_ParamList self) -> Standard_Integer

        Returns the lower bound.
        Warning

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamList_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_Interface_ParamList self) -> Standard_Integer

        Returns the upper bound.
        Warning

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamList_Upper(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_Interface_ParamList self, Standard_Integer const Index, Interface_FileParameter Value)

        Assigns the value <Value> to the <Index>-th item of this array.

        :type Index: int
        :type Value: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_ParamList_SetValue(self, *args)


    def Value(self, *args):
        """
        Return the value of  the  <Index>th element of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Handle_Interface_ParamList_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Handle_Interface_ParamList___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_Interface_ParamList self, Standard_Integer const Index) -> Interface_FileParameter

        return the value  of the <Index>th element  of the
        array.

        :type Index: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_ParamList_ChangeValue(self, *args)


    def Clear(self, *args):
        """Clear(Handle_Interface_ParamList self)"""
        return _Interface.Handle_Interface_ParamList_Clear(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_ParamList self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_ParamList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ParamList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ParamList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_ParamList self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_ParamList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_ParamList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_ParamList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ParamList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_ParamList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_ParamList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ParamList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_ParamList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_ParamList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_ParamList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_ParamList self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_ParamList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_ParamList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamList_DecrementRefCounter(self, *args)

Handle_Interface_ParamList_swigregister = _Interface.Handle_Interface_ParamList_swigregister
Handle_Interface_ParamList_swigregister(Handle_Interface_ParamList)

def Handle_Interface_ParamList_DownCast(thing):
    return _Interface.Handle_Interface_ParamList_DownCast(thing)
Handle_Interface_ParamList_DownCast = _Interface.Handle_Interface_ParamList_DownCast

class Handle_Interface_GlobalNodeOfGeneralLib(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_GlobalNodeOfGeneralLib self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_GlobalNodeOfGeneralLib self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_GlobalNodeOfGeneralLib self, Interface_GlobalNodeOfGeneralLib thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_GlobalNodeOfGeneralLib self, Handle_Interface_GlobalNodeOfGeneralLib theHandle) -> Handle_Interface_GlobalNodeOfGeneralLib
        assign(Handle_Interface_GlobalNodeOfGeneralLib self, Interface_GlobalNodeOfGeneralLib thePtr) -> Handle_Interface_GlobalNodeOfGeneralLib
        assign(Handle_Interface_GlobalNodeOfGeneralLib self, Handle_Interface_GlobalNodeOfGeneralLib theHandle) -> Handle_Interface_GlobalNodeOfGeneralLib

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_GlobalNodeOfGeneralLib self) -> Interface_GlobalNodeOfGeneralLib

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_GlobalNodeOfGeneralLib self) -> Interface_GlobalNodeOfGeneralLib

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_GlobalNodeOfGeneralLib self) -> Interface_GlobalNodeOfGeneralLib

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_GlobalNodeOfGeneralLib___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_GlobalNodeOfGeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_GlobalNodeOfGeneralLib

    def Add(self, *args):
        """
        Add(Handle_Interface_GlobalNodeOfGeneralLib self, Handle_Interface_GeneralModule amodule, Handle_Interface_Protocol aprotocol)

        Adds a Module bound with a Protocol to the list : does
        nothing if already in the list, THAT IS, Same Type (exact
        match) and Same State (that is, IsEqual is not required)
        Once added, stores its attached Protocol in correspondance

        :type amodule: OCC.wrapper.Interface.Handle_Interface_GeneralModule
        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Add(self, *args)


    def Module(self, *args):
        """
        Returns the Module stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_GeneralModule

        """
        res = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the attached Protocol stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next GlobalNode. If none is defined, returned
        value is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfGeneralLib

        """
        res = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_GlobalNodeOfGeneralLib self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_GlobalNodeOfGeneralLib self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_GlobalNodeOfGeneralLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_GlobalNodeOfGeneralLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_GlobalNodeOfGeneralLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_GlobalNodeOfGeneralLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_GlobalNodeOfGeneralLib self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_GlobalNodeOfGeneralLib self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_GlobalNodeOfGeneralLib self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_GlobalNodeOfGeneralLib self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DecrementRefCounter(self, *args)

Handle_Interface_GlobalNodeOfGeneralLib_swigregister = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_swigregister
Handle_Interface_GlobalNodeOfGeneralLib_swigregister(Handle_Interface_GlobalNodeOfGeneralLib)

def Handle_Interface_GlobalNodeOfGeneralLib_DownCast(thing):
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast(thing)
Handle_Interface_GlobalNodeOfGeneralLib_DownCast = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast

class Interface_EntityIterator(object):
    """
    Defines an Iterator on Entities.
    Allows considering of various criteria
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_EntityIterator self) -> Interface_EntityIterator
        __init__(Interface_EntityIterator self, Handle_TColStd_HSequenceOfTransient list) -> Interface_EntityIterator

        Defines an iterator on a list, directly i.e. without copying it

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        this = _Interface.new_Interface_EntityIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddList(self, *args):
        """
        AddList(Interface_EntityIterator self, Handle_TColStd_HSequenceOfTransient list)

        Gets a list of entities and adds its to the iteration list

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Interface.Interface_EntityIterator_AddList(self, *args)


    def AddItem(self, *args):
        """
        AddItem(Interface_EntityIterator self, Handle_Standard_Transient anentity)

        Adds to the iteration list a defined entity

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityIterator_AddItem(self, *args)


    def GetOneItem(self, *args):
        """
        GetOneItem(Interface_EntityIterator self, Handle_Standard_Transient anentity)

        same as AddItem (kept for compatibility)

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_EntityIterator_GetOneItem(self, *args)


    def SelectType(self, *args):
        """
        SelectType(Interface_EntityIterator self, Handle_Standard_Type atype, Standard_Boolean const keep)

        Selects entities with are Kind of a given type,  keep only
        them (is keep is True) or reject only them (if keep is False)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type keep: bool

        """
        return _Interface.Interface_EntityIterator_SelectType(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Interface_EntityIterator self) -> Standard_Integer

        Returns count of entities which will be iterated on
        Calls Start if not yet done

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_EntityIterator_NbEntities(self, *args)


    def NbTyped(self, *args):
        """
        NbTyped(Interface_EntityIterator self, Handle_Standard_Type type) -> Standard_Integer

        Returns count of entities of a given type (kind of)

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_EntityIterator_NbTyped(self, *args)


    def Typed(self, *args):
        """
        Typed(Interface_EntityIterator self, Handle_Standard_Type type) -> Interface_EntityIterator

        Returns the list of entities of a given type (kind of)

        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_EntityIterator_Typed(self, *args)


    def Start(self, *args):
        """
        Start(Interface_EntityIterator self)

        Allows re-iteration (useless for the first iteration)


        """
        return _Interface.Interface_EntityIterator_Start(self, *args)


    def More(self, *args):
        """
        More(Interface_EntityIterator self) -> Standard_Boolean

        Says if there are other entities (vertices) to iterate
        the first time, calls Start

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_EntityIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Interface_EntityIterator self)

        Sets iteration to the next entity (vertex) to give


        """
        return _Interface.Interface_EntityIterator_Next(self, *args)


    def Value(self, *args):
        """
        Returns the current Entity iterated, to be used by Interface
        tools

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_EntityIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Content(self, *args):
        """
        Content(Interface_EntityIterator self) -> Handle_TColStd_HSequenceOfTransient

        Returns the content of the Iterator, accessed through a Handle
        to be used by a frontal-engine logic
        Returns an empty Sequence if the Iterator is empty
        Calls Start if not yet done

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Interface.Interface_EntityIterator_Content(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Interface_EntityIterator self)

        Clears data of iteration


        """
        return _Interface.Interface_EntityIterator_Destroy(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_EntityIterator
Interface_EntityIterator_swigregister = _Interface.Interface_EntityIterator_swigregister
Interface_EntityIterator_swigregister(Interface_EntityIterator)

class Interface_Check(Standard.Standard_Transient):
    """
    Defines a Check, as a list of Fail or Warning Messages under
    a literal form, which can be empty. A Check can also bring an
    Entity, which is the Entity to which the messages apply
    (this Entity may be any Transient Object).

    Messages can be stored in two forms : the definitive form
    (the only one by default), and another form, the original
    form, which can be different if it contains values to be
    inserted (integers, reals, strings)
    The original form can be more suitable for some operations
    such as counting messages
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_Check
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_Check(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_Check self) -> Interface_Check
        __init__(Interface_Check self, Handle_Standard_Transient anentity) -> Interface_Check

        Defines a Check on an Entity

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _Interface.new_Interface_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SendFail(self, *args):
        """
        SendFail(Interface_Check self, Message_Msg amsg)

        New name for AddFail (Msg)

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Interface_Check_SendFail(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Interface_Check self, Handle_TCollection_HAsciiString amess)
        AddFail(Interface_Check self, Handle_TCollection_HAsciiString amess, Handle_TCollection_HAsciiString orig)
        AddFail(Interface_Check self, Standard_CString const amess, Standard_CString const orig)
        AddFail(Interface_Check self, Message_Msg amsg)

        Records a new Fail from the definition of a Msg (Original+Value)

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Interface_Check_AddFail(self, *args)


    def HasFailed(self, *args):
        """
        HasFailed(Interface_Check self) -> Standard_Boolean

        Returns True if Check brings at least one Fail Message

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Check_HasFailed(self, *args)


    def NbFails(self, *args):
        """
        NbFails(Interface_Check self) -> Standard_Integer

        Returns count of recorded Fails

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Check_NbFails(self, *args)


    def Fail(self, *args):
        """
        Returns Fail Message as a String
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _Interface.Interface_Check_Fail(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CFail(self, *args):
        """
        CFail(Interface_Check self, Standard_Integer const num, Standard_Boolean const final) -> Standard_CString

        Same as above, but returns a CString (to be printed ...)
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Check_CFail(self, *args)


    def Fails(self, *args):
        """
        Fails(Interface_Check self, Standard_Boolean const final) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of Fails, for a frontal-engine logic
        Final forms by default, Original forms if <final> is False
        Can be empty

        :type final: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Interface_Check_Fails(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Interface_Check self, Message_Msg amsg)

        New name for AddWarning

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Interface_Check_SendWarning(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Interface_Check self, Handle_TCollection_HAsciiString amess)
        AddWarning(Interface_Check self, Handle_TCollection_HAsciiString amess, Handle_TCollection_HAsciiString orig)
        AddWarning(Interface_Check self, Standard_CString const amess, Standard_CString const orig)
        AddWarning(Interface_Check self, Message_Msg amsg)

        Records a new Warning from the definition of a Msg (Original+Value)

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Interface_Check_AddWarning(self, *args)


    def HasWarnings(self, *args):
        """
        HasWarnings(Interface_Check self) -> Standard_Boolean

        Returns True if Check brings at least one Warning Message

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Check_HasWarnings(self, *args)


    def NbWarnings(self, *args):
        """
        NbWarnings(Interface_Check self) -> Standard_Integer

        Returns count of recorded Warning messages

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Check_NbWarnings(self, *args)


    def Warning(self, *args):
        """
        Returns Warning message as a String
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _Interface.Interface_Check_Warning(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CWarning(self, *args):
        """
        CWarning(Interface_Check self, Standard_Integer const num, Standard_Boolean const final) -> Standard_CString

        Same as above, but returns a CString (to be printed ...)
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Check_CWarning(self, *args)


    def Warnings(self, *args):
        """
        Warnings(Interface_Check self, Standard_Boolean const final) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of Warnings, for a frontal-engine logic
        Final forms by default, Original forms if <final> is False
        Can be empty

        :type final: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Interface_Check_Warnings(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Interface_Check self, Message_Msg amsg)

        Records an information message
        This does not change the status of the Check

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Interface_Check_SendMsg(self, *args)


    def NbInfoMsgs(self, *args):
        """
        NbInfoMsgs(Interface_Check self) -> Standard_Integer

        Returns the count of recorded information messages

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Check_NbInfoMsgs(self, *args)


    def InfoMsg(self, *args):
        """
        Returns information message as a String

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _Interface.Interface_Check_InfoMsg(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CInfoMsg(self, *args):
        """
        CInfoMsg(Interface_Check self, Standard_Integer const num, Standard_Boolean const final) -> Standard_CString

        Same as above, but returns a CString (to be printed ...)
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Check_CInfoMsg(self, *args)


    def InfoMsgs(self, *args):
        """
        InfoMsgs(Interface_Check self, Standard_Boolean const final) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of Info Msg, for a frontal-engine logic
        Final forms by default, Original forms if <final> is False
        Can be empty

        :type final: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Interface_Check_InfoMsgs(self, *args)


    def Status(self, *args):
        """
        Status(Interface_Check self) -> Interface_CheckStatus

        Returns the Check Status : OK, Warning or Fail

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Interface.Interface_Check_Status(self, *args)


    def Complies(self, *args):
        """
        Complies(Interface_Check self, Interface_CheckStatus const status) -> Standard_Boolean
        Complies(Interface_Check self, Handle_TCollection_HAsciiString mess, Standard_Integer const incl, Interface_CheckStatus const status) -> Standard_Boolean

        Tells if a message is brought by a Check, as follows :
        <incl> = 0 : <mess> exactly matches one of the messages
        <incl> < 0 : <mess> is contained by one of the messages
        <incl> > 0 : <mess> contains one of the messages
        For <status> : for CheckWarning and CheckFail, considers only
        resp. Warning or Check messages. for CheckAny, considers all
        other values are ignored (answer will be false)

        :type mess: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type incl: int
        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Check_Complies(self, *args)


    def HasEntity(self, *args):
        """
        HasEntity(Interface_Check self) -> Standard_Boolean

        Returns True if a Check is devoted to an entity; else, it is
        global (for InterfaceModel's storing of global error messages)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Check_HasEntity(self, *args)


    def Entity(self, *args):
        """
        Returns the entity on which the Check has been defined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_Check_Entity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Interface_Check self)

        Clears a check, in order to receive informations from transfer
        (Messages and Entity)


        """
        return _Interface.Interface_Check_Clear(self, *args)


    def ClearFails(self, *args):
        """
        ClearFails(Interface_Check self)

        Clears the Fail Messages (for instance to keep only Warnings)


        """
        return _Interface.Interface_Check_ClearFails(self, *args)


    def ClearWarnings(self, *args):
        """
        ClearWarnings(Interface_Check self)

        Clears the Warning Messages (for instance to keep only Fails)


        """
        return _Interface.Interface_Check_ClearWarnings(self, *args)


    def ClearInfoMsgs(self, *args):
        """
        ClearInfoMsgs(Interface_Check self)

        Clears the Info Messages


        """
        return _Interface.Interface_Check_ClearInfoMsgs(self, *args)


    def Remove(self, *args):
        """
        Remove(Interface_Check self, Handle_TCollection_HAsciiString mess, Standard_Integer const incl, Interface_CheckStatus const status) -> Standard_Boolean

        Removes the messages which comply with <mess>, as follows :
        <incl> = 0 : <mess> exactly matches one of the messages
        <incl> < 0 : <mess> is contained by one of the messages
        <incl> > 0 : <mess> contains one of the messages
        For <status> : for CheckWarning and CheckFail, considers only
        resp. Warning or Check messages. for CheckAny, considers all
        other values are ignored (nothing is done)
        Returns True if at least one message has been removed, False else

        :type mess: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type incl: int
        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Check_Remove(self, *args)


    def Mend(self, *args):
        """
        Mend(Interface_Check self, Standard_CString const pref, Standard_Integer const num=0) -> Standard_Boolean

        Mends messages, according <pref> and <num>
        According to <num>, works on the whole list of Fails if = 0(D)
        or only one Fail message, given its rank
        If <pref> is empty, converts Fail(s) to Warning(s)
        Else, does the conversion but prefixes the new Warning(s) but
        <pref> followed by a semi-column
        Some reserved values of <pref> are :
        "FM" : standard prefix "Mended" (can be translated)
        "CF" : clears Fail(s)
        "CW" : clears Warning(s) : here, <num> refers to Warning list
        "CA" : clears all messages : here, <num> is ignored

        :type pref: OCC.wrapper.Standard.Standard_CString
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Check_Mend(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(Interface_Check self, Handle_Standard_Transient anentity)

        Receives an entity result of a Transfer

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_Check_SetEntity(self, *args)


    def GetEntity(self, *args):
        """
        GetEntity(Interface_Check self, Handle_Standard_Transient anentity)

        same as SetEntity (old form kept for compatibility)
        Warning : Does nothing if Entity field is not yet clear

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_Check_GetEntity(self, *args)


    def GetMessages(self, *args):
        """
        GetMessages(Interface_Check self, Handle_Interface_Check other)

        Copies messages stored in another Check, cumulating
        Does not regard other's Entity. Used to cumulate messages

        :type other: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_Check_GetMessages(self, *args)


    def GetAsWarning(self, *args):
        """
        GetAsWarning(Interface_Check self, Handle_Interface_Check other, Standard_Boolean const failsonly)

        Copies messages converted into Warning messages
        If failsonly is true, only Fails are taken, and converted
        else, Warnings are taken too. Does not regard Entity
        Used to keep Fail messages as Warning, after a recovery

        :type other: OCC.wrapper.Interface.Handle_Interface_Check
        :type failsonly: bool

        """
        return _Interface.Interface_Check_GetAsWarning(self, *args)


    def Print(self, *args):
        """
        Print(Interface_Check self, Handle_Message_Messenger S, Standard_Integer const level, Standard_Integer const final=1)

        Prints the messages of the check to an Messenger
        <level> = 1 : only fails
        <level> = 2 : fails and warnings
        <level> = 3 : all (fails, warnings, info msg)
        <final> : if positive (D) prints final values of messages
        if negative, prints originals
        if null, prints both forms

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int
        :type final: int

        """
        return _Interface.Interface_Check_Print(self, *args)


    def Trace(self, *args):
        """
        Trace(Interface_Check self, Standard_Integer const level=-1, Standard_Integer const final=1)

        Prints the messages of the check to the default trace file
        By default, according to the default standard level
        Else, according level (see method Print)

        :type level: int
        :type final: int

        """
        return _Interface.Interface_Check_Trace(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_Check_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_Check_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_Check_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_Check
Interface_Check_swigregister = _Interface.Interface_Check_swigregister
Interface_Check_swigregister(Interface_Check)

def Interface_Check_get_type_name(*args):
    """
    Interface_Check_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_Check_get_type_name(*args)

def Interface_Check_get_type_descriptor(*args):
    """
    Interface_Check_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_Check_get_type_descriptor(*args)

class Interface_Category(object):
    """
    This class manages categories
    A category is defined by a name and a number, and can be
    seen as a way of rough classification, i.e. less precise than
    a cdl type.
    Hence, it is possible to dispatch every entity in about
    a dozen of categories, twenty is a reasonable maximum.

    Basically, the system provides the following categories :
    Shape (Geometry, BRep, CSG, Features, etc...)
    Drawing (Drawing, Views, Annotations, Pictures, Scketches ...)
    Structure (Component & Part, Groups & Patterns ...)
    Description (Meta-Data : Relations, Properties, Product ...)
    Auxiliary   (those which do not enter in the above list)
    and some dedicated categories
    FEA , Kinematics , Piping , etc...
    plus Professional  for other dedicated non-classed categories

    In addition, this class provides a way to compute then quickly
    query category numbers for an entire model.
    Values are just recorded as a list of numbers, control must
    then be done in a wider context (which must provide a Graph)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_Category self) -> Interface_Category
        __init__(Interface_Category self, Handle_Interface_Protocol theProtocol) -> Interface_Category
        __init__(Interface_Category self, Handle_Interface_GTool theGTool) -> Interface_Category

        Creates a Category with a given GTool

        :type theGTool: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        this = _Interface.new_Interface_Category(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetProtocol(self, *args):
        """
        SetProtocol(Interface_Category self, Handle_Interface_Protocol theProtocol)

        Sets/Changes Protocol

        :type theProtocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_Category_SetProtocol(self, *args)


    def CatNum(self, *args):
        """
        CatNum(Interface_Category self, Handle_Standard_Transient theEnt, Interface_ShareTool theShares) -> Standard_Integer

        Determines the Category Number for an entity in its context,
        by using general service CategoryNumber

        :type theEnt: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theShares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Category_CatNum(self, *args)


    def ClearNums(self, *args):
        """
        ClearNums(Interface_Category self)

        Clears the recorded list of category numbers for a Model


        """
        return _Interface.Interface_Category_ClearNums(self, *args)


    def Compute(self, *args):
        """
        Compute(Interface_Category self, Handle_Interface_InterfaceModel theModel, Interface_ShareTool theShares)

        Computes the Category Number for each entity and records it,
        in an array (ent.number -> category number)
        Hence, it can be queried by the method Num.
        The Model itself is not recorded, this method is intended to
        be used in a wider context (which detains also a Graph, etc)

        :type theModel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type theShares: OCC.wrapper.Interface.Interface_ShareTool

        """
        return _Interface.Interface_Category_Compute(self, *args)


    def Num(self, *args):
        """
        Num(Interface_Category self, Standard_Integer const theNumEnt) -> Standard_Integer

        Returns the category number recorded for an entity number
        Returns 0 if out of range

        :type theNumEnt: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Category_Num(self, *args)


    def AddCategory(*args):
        """
        AddCategory(Standard_CString const theName) -> Standard_Integer

        Records a new Category defined by its names, produces a number
        New if not yet recorded

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Category_AddCategory(*args)

    AddCategory = staticmethod(AddCategory)

    def NbCategories(*args):
        """
        NbCategories() -> Standard_Integer

        Returns the count of recorded categories

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Category_NbCategories(*args)

    NbCategories = staticmethod(NbCategories)

    def Name(*args):
        """
        Name(Standard_Integer const theNum) -> Standard_CString

        Returns the name of a category, according to its number

        :type theNum: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Category_Name(*args)

    Name = staticmethod(Name)

    def Number(*args):
        """
        Number(Standard_CString const theName) -> Standard_Integer

        Returns the number of a category, according to its name

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Category_Number(*args)

    Number = staticmethod(Number)

    def Init(*args):
        """
        Init()

        Default initialisation
        (protected against several calls : passes only once)


        """
        return _Interface.Interface_Category_Init(*args)

    Init = staticmethod(Init)
    __swig_destroy__ = _Interface.delete_Interface_Category
Interface_Category_swigregister = _Interface.Interface_Category_swigregister
Interface_Category_swigregister(Interface_Category)

def Interface_Category_AddCategory(*args):
    """
    Interface_Category_AddCategory(Standard_CString const theName) -> Standard_Integer

    Records a new Category defined by its names, produces a number
    New if not yet recorded

    :type theName: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_Category_AddCategory(*args)

def Interface_Category_NbCategories(*args):
    """
    Interface_Category_NbCategories() -> Standard_Integer

    Returns the count of recorded categories

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_Category_NbCategories(*args)

def Interface_Category_Name(*args):
    """
    Interface_Category_Name(Standard_Integer const theNum) -> Standard_CString

    Returns the name of a category, according to its number

    :type theNum: int
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_Category_Name(*args)

def Interface_Category_Number(*args):
    """
    Interface_Category_Number(Standard_CString const theName) -> Standard_Integer

    Returns the number of a category, according to its name

    :type theName: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_Category_Number(*args)

def Interface_Category_Init(*args):
    """
    Interface_Category_Init()

    Default initialisation
    (protected against several calls : passes only once)


    """
    return _Interface.Interface_Category_Init(*args)

class NCollection_Sequence_Handle_Interface_Check(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Interface_Check self) -> NCollection_Sequence< opencascade::handle< Interface_Check > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Interface_Check self) -> NCollection_Sequence< opencascade::handle< Interface_Check > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Interface_Check self) -> NCollection_Sequence< opencascade::handle< Interface_Check > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Interface_Check self) -> NCollection_Sequence< opencascade::handle< Interface_Check > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Interface.new_NCollection_Sequence_Handle_Interface_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Interface_Check self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Interface_Check self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Interface_Check self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Interface_Check self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Interface_Check self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Interface_Check self)

        Reverse sequence


        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Interface_Check self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Interface_Check self, NCollection_Sequence_Handle_Interface_Check theOther) -> NCollection_Sequence_Handle_Interface_Check

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Interface_Check self, NCollection_Sequence_Handle_Interface_Check theOther) -> NCollection_Sequence_Handle_Interface_Check

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Interface_Check self, NCollection_Sequence< opencascade::handle< Interface_Check > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Interface_Check self, Handle_Interface_Check theItem)
        Append(NCollection_Sequence_Handle_Interface_Check self, NCollection_Sequence_Handle_Interface_Check theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Interface_Check self, Handle_Interface_Check theItem)
        Prepend(NCollection_Sequence_Handle_Interface_Check self, NCollection_Sequence_Handle_Interface_Check theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex, Handle_Interface_Check theItem)
        InsertBefore(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Interface_Check theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Interface_Check self, NCollection_Sequence< opencascade::handle< Interface_Check > >::Iterator & thePosition, Handle_Interface_Check theItem)
        InsertAfter(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Interface_Check theSeq)
        InsertAfter(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex, Handle_Interface_Check theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Interface_Check theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Sequence_Handle_Interface_Check_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Interface_Check self) -> Handle_Interface_Check

        First item access

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Sequence_Handle_Interface_Check_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Interface_Check self) -> Handle_Interface_Check

        Last item access

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Sequence_Handle_Interface_Check_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex) -> Handle_Interface_Check

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Sequence_Handle_Interface_Check___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Interface_Check self, Standard_Integer const theIndex, Handle_Interface_Check theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Interface.NCollection_Sequence_Handle_Interface_Check_SetValue(self, *args)


    def __iter__(self):
        return _Interface.NCollection_Sequence_Handle_Interface_Check___iter__(self)
    __swig_destroy__ = _Interface.delete_NCollection_Sequence_Handle_Interface_Check
NCollection_Sequence_Handle_Interface_Check_swigregister = _Interface.NCollection_Sequence_Handle_Interface_Check_swigregister
NCollection_Sequence_Handle_Interface_Check_swigregister(NCollection_Sequence_Handle_Interface_Check)

def NCollection_Sequence_Handle_Interface_Check_delNode(*args):
    """
    NCollection_Sequence_Handle_Interface_Check_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Interface.NCollection_Sequence_Handle_Interface_Check_delNode(*args)

class NCollection_Sequence_Handle_Interface_Check_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Interface.new_NCollection_Sequence_Handle_Interface_Check_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_NCollection_Sequence_Handle_Interface_Check_IteratorHelper

    def __next__(self):
        return _Interface.NCollection_Sequence_Handle_Interface_Check_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Interface_Check_IteratorHelper_swigregister = _Interface.NCollection_Sequence_Handle_Interface_Check_IteratorHelper_swigregister
NCollection_Sequence_Handle_Interface_Check_IteratorHelper_swigregister(NCollection_Sequence_Handle_Interface_Check_IteratorHelper)


try:
	Interface_SequenceOfCheck = NCollection_Sequence_Handle_Interface_Check
except NameError:
	pass # does not exist, probably ignored

class Interface_CopyTool(object):
    """
    Performs Deep Copies of sets of Entities
    Allows to perform Copy of Interface Entities from a Model to
    another one. Works by calling general services GetFromAnother
    and GetImplied.
    Uses a CopyMap to bind a unique Result to each Copied Entity

    It is possible to command Copies of Entities (and those they
    reference) by call to the General Service Library, or to
    enforce results for transfer of some Entities (calling Bind)

    A Same CopyTool can be used for several successive Copies from
    the same Model : either by restarting from scratch (e.g. to
    copy different parts of a starting Model to several Targets),
    or incremental : in that case, it is possible to know what is
    the content of the last increment (defined by last call to
    ClearLastFlags  and queried by call to LastCopiedAfter)

    Works in two times : first, create the list of copied Entities
    second, pushes them to a target Model (manages also Model's
    Header) or returns the Result as an Iterator, as desired

    The core action (Copy) works by using ShallowCopy (method
    attached to each class) and Copy from GeneralLib (itself using
    dedicated tools). It can be redefined for specific actions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_CopyTool self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib) -> Interface_CopyTool
        __init__(Interface_CopyTool self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol) -> Interface_CopyTool
        __init__(Interface_CopyTool self, Handle_Interface_InterfaceModel amodel) -> Interface_CopyTool

        Same as above, but works with the Active Protocol

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        this = _Interface.new_Interface_CopyTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args):
        """
        Model(Interface_CopyTool self) -> Handle_Interface_InterfaceModel

        Returns the Model on which the CopyTool works

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_CopyTool_Model(self, *args)


    def SetControl(self, *args):
        """
        SetControl(Interface_CopyTool self, Handle_Interface_CopyControl othermap)

        Changes the Map of Result for another one. This allows to work
        with a more sophisticated Mapping Control than the Standard
        one which is CopyMap (e.g. TransferProcess from Transfer)

        :type othermap: OCC.wrapper.Interface.Handle_Interface_CopyControl

        """
        return _Interface.Interface_CopyTool_SetControl(self, *args)


    def Control(self, *args):
        """
        Control(Interface_CopyTool self) -> Handle_Interface_CopyControl

        Returns the object used for Control

        :rtype: OCC.wrapper.Interface.Handle_Interface_CopyControl

        """
        return _Interface.Interface_CopyTool_Control(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_CopyTool self)

        Clears Transfer List. Gets Ready to begin another Transfer


        """
        return _Interface.Interface_CopyTool_Clear(self, *args)


    def Copy(self, *args):
        """
        Copy(Interface_CopyTool self, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Standard_Boolean const mapped, Standard_Boolean const errstat) -> Standard_Boolean

        Creates the CounterPart of an Entity (by ShallowCopy), Binds
        it, then Copies the content of the former Entity to the other
        one (same Type), by call to the General Service Library
        It may command the Copy of Referenced Entities
        Then, its returns True.

        If <mapped> is True, the Map is used to store the Result
        Else, the Result is simply produced : it can be used to Copy
        internal sub-parts of Entities, which are not intended to be
        shared (Strings, Arrays, etc...)
        If <errstat> is True, this means that the Entity is recorded
        in the Model as Erroneous : in this case, the General Service
        for Deep Copy is not called (this could be dangerous) : hence
        the Counter-Part is produced but empty, it can be referenced.

        This method does nothing and returns False if the Protocol
        does not recognize <ent>.
        It basically makes a Deep Copy without changing the Types.
        It can be redefined for special uses.

        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mapped: bool
        :type errstat: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CopyTool_Copy(self, *args)


    def Transferred(self, *args):
        """
        Transferred(Interface_CopyTool self, Handle_Standard_Transient ent) -> Handle_Standard_Transient

        Transfers one Entity, if not yet bound to a result
        Remark : For an Entity which is reported in the Starting Model,
        the ReportEntity will also be copied with its Content if it
        has one (at least ShallowCopy; Complete Copy if the Protocol
        recognizes the Content : see method Copy)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_CopyTool_Transferred(self, *args)


    def Bind(self, *args):
        """
        Bind(Interface_CopyTool self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Defines a Result for the Transfer of a Starting object.
        Used by method Transferred (which performs a normal Copy),
        but can also be called to enforce a result : in the latter
        case, the enforced result must be compatible with the other
        Transfers which are performed

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_CopyTool_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Interface_CopyTool self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Search for the result of a Starting Object (i.e. an Entity)
        Returns True  if a  Result is Bound (and fills "result")
        Returns False if no result is Bound

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CopyTool_Search(self, *args)


    def ClearLastFlags(self, *args):
        """
        ClearLastFlags(Interface_CopyTool self)

        Clears LastFlags only. This allows to know what Entities are
        copied after its call (see method LastCopiedAfter). It can be
        used when copies are done by increments, which must be
        distinghished. ClearLastFlags is also called by Clear.


        """
        return _Interface.Interface_CopyTool_ClearLastFlags(self, *args)


    def LastCopiedAfter(self, *args):
        """
        LastCopiedAfter(Interface_CopyTool self, Standard_Integer const numfrom, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Integer

        Returns an copied Entity and its Result which were operated
        after last call to ClearLastFlags. It returns the first
        "Last Copied Entity" which Number follows <numfrom>, Zero if
        none. It is used in a loop as follow :
        Integer num = 0;
        while ( (num = CopyTool.LastCopiedAfter(num,ent,res)) ) {
        .. Process Starting <ent> and its Result <res>
        }

        :type numfrom: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_CopyTool_LastCopiedAfter(self, *args)


    def TransferEntity(self, *args):
        """
        TransferEntity(Interface_CopyTool self, Handle_Standard_Transient ent)

        Transfers one Entity and records result into the Transfer List
        Calls method Transferred

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_CopyTool_TransferEntity(self, *args)


    def RenewImpliedRefs(self, *args):
        """
        RenewImpliedRefs(Interface_CopyTool self)

        Renews the Implied References. These References do not involve
        Copying of referenced Entities. For such a Reference, if the
        Entity which defines it AND the referenced Entity are both
        copied, then this Reference is renewed. Else it is deleted in
        the copied Entities.
        Remark : this concerns only some specific references, such as
        "back pointers".


        """
        return _Interface.Interface_CopyTool_RenewImpliedRefs(self, *args)


    def FillModel(self, *args):
        """
        FillModel(Interface_CopyTool self, Handle_Interface_InterfaceModel bmodel)

        Fills a Model with the result of the transfer (TransferList)
        Commands copy of Header too, and calls RenewImpliedRefs

        :type bmodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_CopyTool_FillModel(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Interface_CopyTool self, Standard_Boolean const withreports) -> Interface_EntityIterator

        Returns the complete list of copied Entities
        If <withreports> is given True, the entities which were
        reported in the Starting Model are replaced in the list
        by the copied ReportEntities

        :type withreports: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_CopyTool_CompleteResult(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Interface_CopyTool self, Standard_Boolean const withreports) -> Interface_EntityIterator

        Returns the list of Root copied Entities (those which were
        asked for copy by the user of CopyTool, not by copying
        another Entity)

        :type withreports: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_CopyTool_RootResult(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_CopyTool
Interface_CopyTool_swigregister = _Interface.Interface_CopyTool_swigregister
Interface_CopyTool_swigregister(Interface_CopyTool)

class Handle_Interface_NodeOfReaderLib(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_NodeOfReaderLib self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_NodeOfReaderLib_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_NodeOfReaderLib self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_NodeOfReaderLib self, Interface_NodeOfReaderLib thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_NodeOfReaderLib self, Handle_Interface_NodeOfReaderLib theHandle) -> Handle_Interface_NodeOfReaderLib
        assign(Handle_Interface_NodeOfReaderLib self, Interface_NodeOfReaderLib thePtr) -> Handle_Interface_NodeOfReaderLib
        assign(Handle_Interface_NodeOfReaderLib self, Handle_Interface_NodeOfReaderLib theHandle) -> Handle_Interface_NodeOfReaderLib

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_NodeOfReaderLib self) -> Interface_NodeOfReaderLib

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_NodeOfReaderLib self) -> Interface_NodeOfReaderLib

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_NodeOfReaderLib___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_NodeOfReaderLib self) -> Interface_NodeOfReaderLib

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_NodeOfReaderLib___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_NodeOfReaderLib___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_NodeOfReaderLib___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_NodeOfReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_NodeOfReaderLib_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_NodeOfReaderLib

    def AddNode(self, *args):
        """
        AddNode(Handle_Interface_NodeOfReaderLib self, Handle_Interface_GlobalNodeOfReaderLib anode)

        Adds a couple (Module,Protocol), that is, stores it into
        itself if not yet done, else creates a Next Node to do it

        :type anode: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfReaderLib

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_AddNode(self, *args)


    def Module(self, *args):
        """
        Returns the Module designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_ReaderModule

        """
        res = _Interface.Handle_Interface_NodeOfReaderLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the Protocol designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Handle_Interface_NodeOfReaderLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next Node. If none was defined, returned value
        is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_NodeOfReaderLib

        """
        res = _Interface.Handle_Interface_NodeOfReaderLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_NodeOfReaderLib self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_NodeOfReaderLib_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_NodeOfReaderLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_NodeOfReaderLib self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_NodeOfReaderLib_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_NodeOfReaderLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_NodeOfReaderLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_NodeOfReaderLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_NodeOfReaderLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_NodeOfReaderLib self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_NodeOfReaderLib self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_NodeOfReaderLib self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_NodeOfReaderLib_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_NodeOfReaderLib self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_NodeOfReaderLib_DecrementRefCounter(self, *args)

Handle_Interface_NodeOfReaderLib_swigregister = _Interface.Handle_Interface_NodeOfReaderLib_swigregister
Handle_Interface_NodeOfReaderLib_swigregister(Handle_Interface_NodeOfReaderLib)

def Handle_Interface_NodeOfReaderLib_DownCast(thing):
    return _Interface.Handle_Interface_NodeOfReaderLib_DownCast(thing)
Handle_Interface_NodeOfReaderLib_DownCast = _Interface.Handle_Interface_NodeOfReaderLib_DownCast

class Interface_CopyMap(Interface_CopyControl):
    """
    Manages a Map for the need of single Transfers, such as Copies
    In such transfer, Starting Entities are read from a unique
    Starting Model, and each transferred Entity is bound to one
    and only one Result, which cannot be changed later.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_CopyMap
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_CopyMap(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_CopyMap self, Handle_Interface_InterfaceModel amodel) -> Interface_CopyMap

        Creates a CopyMap adapted to work from a Model

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        this = _Interface.new_Interface_CopyMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(Interface_CopyMap self)

        Clears Transfer List. Gets Ready to begin another Transfer


        """
        return _Interface.Interface_CopyMap_Clear(self, *args)


    def Model(self, *args):
        """
        Model(Interface_CopyMap self) -> Handle_Interface_InterfaceModel

        Returns the InterfaceModel used at Creation time

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_CopyMap_Model(self, *args)


    def Bind(self, *args):
        """
        Bind(Interface_CopyMap self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Binds a Starting Entity identified by its Number <num> in the
        Starting Model, to a Result of Transfer <res>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_CopyMap_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Interface_CopyMap self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Search for the result of a Starting Object (i.e. an Entity,
        identified by its Number <num> in the Starting Model)
        Returns True  if a  Result is Bound (and fills <res>)
        Returns False if no result is Bound (and nullifies <res>)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_CopyMap_Search(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_CopyMap_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_CopyMap_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_CopyMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_CopyMap
Interface_CopyMap_swigregister = _Interface.Interface_CopyMap_swigregister
Interface_CopyMap_swigregister(Interface_CopyMap)

def Interface_CopyMap_get_type_name(*args):
    """
    Interface_CopyMap_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_CopyMap_get_type_name(*args)

def Interface_CopyMap_get_type_descriptor(*args):
    """
    Interface_CopyMap_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_CopyMap_get_type_descriptor(*args)

class Interface_CheckTool(object):
    """
    Performs Checks on Entities, using General Service Library and
    Modules to work. Works on one Entity or on a complete Model
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_CheckTool self, Handle_Interface_InterfaceModel model, Handle_Interface_Protocol protocol) -> Interface_CheckTool
        __init__(Interface_CheckTool self, Handle_Interface_InterfaceModel model) -> Interface_CheckTool
        __init__(Interface_CheckTool self, Interface_Graph graph) -> Interface_CheckTool
        __init__(Interface_CheckTool self, Handle_Interface_HGraph hgraph) -> Interface_CheckTool

        :type hgraph: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        this = _Interface.new_Interface_CheckTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FillCheck(self, *args):
        """
        FillCheck(Interface_CheckTool self, Handle_Standard_Transient ent, Interface_ShareTool sh, Handle_Interface_Check ach)

        Fills as required a Check with the Error and Warning messages
        produced by Checking a given Entity.
        For an Erroneous or Corrected Entity : Check build at Analyse
        time; else, Check computed for Entity (Verify integrity), can
        use a Graph as required to control context

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type sh: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_CheckTool_FillCheck(self, *args)


    def Print(self, *args):
        """
        Print(Interface_CheckTool self, Handle_Interface_Check ach, Handle_Message_Messenger S)
        Print(Interface_CheckTool self, Interface_CheckIterator list, Handle_Message_Messenger S)

        Simply Lists all the Checks and the Content (messages) and the
        Entity, if there is, of each Check
        (if all Checks are OK, nothing is Printed)

        :type list: OCC.wrapper.Interface.Interface_CheckIterator
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_CheckTool_Print(self, *args)


    def Check(self, *args):
        """
        Check(Interface_CheckTool self, Standard_Integer const num) -> Handle_Interface_Check

        Returns the Check associated to an Entity identified by
        its Number in a Model.

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_CheckTool_Check(self, *args)


    def CheckSuccess(self, *args):
        """
        CheckSuccess(Interface_CheckTool self, Standard_Boolean const reset)

        Checks if any Error has been detected (CheckList not empty)
        Returns normally if none, raises exception if some exists.
        It reuses the last computations from other checking methods,
        unless the argument <resest> is given True

        :type reset: bool

        """
        return _Interface.Interface_CheckTool_CheckSuccess(self, *args)


    def CompleteCheckList(self, *args):
        """
        CompleteCheckList(Interface_CheckTool self) -> Interface_CheckIterator

        Returns list of all "remarkable" informations, which include :
        - GlobalCheck, if not empty
        - Error Checks, for all Errors (Verify + Analyse)
        - also Corrected Entities
        - and Unknown Entities : for those, each Unknown Entity is
        associated to an empty Check (it is neither an Error nor a
        Correction, but a remarkable information)

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_CompleteCheckList(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Interface_CheckTool self) -> Interface_CheckIterator

        Returns list of all Errors detected
        Note that presence of Unknown Entities is not an error
        Cumulates : GlobalCheck if error +
        AnalyseCheckList + VerifyCheckList

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_CheckList(self, *args)


    def AnalyseCheckList(self, *args):
        """
        AnalyseCheckList(Interface_CheckTool self) -> Interface_CheckIterator

        Returns list of errors dectected at Analyse time (syntactic)
        (note that GlobalCheck is not in this list)

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_AnalyseCheckList(self, *args)


    def VerifyCheckList(self, *args):
        """
        VerifyCheckList(Interface_CheckTool self) -> Interface_CheckIterator

        Returns list of integrity constraints errors (semantic)
        (note that GlobalCheck is not in this list)

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_VerifyCheckList(self, *args)


    def WarningCheckList(self, *args):
        """
        WarningCheckList(Interface_CheckTool self) -> Interface_CheckIterator

        Returns list of Corrections (includes GlobalCheck if corrected)

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_WarningCheckList(self, *args)


    def UnknownEntities(self, *args):
        """
        UnknownEntities(Interface_CheckTool self) -> Interface_EntityIterator

        Returns list of Unknown Entities
        Note that Error and Erroneous Entities are not considered
        as Unknown

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_CheckTool_UnknownEntities(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_CheckTool
Interface_CheckTool_swigregister = _Interface.Interface_CheckTool_swigregister
Interface_CheckTool_swigregister(Interface_CheckTool)

class Handle_Interface_TypedValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_TypedValue self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_TypedValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_TypedValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_TypedValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_TypedValue self, Interface_TypedValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_TypedValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_TypedValue self, Handle_Interface_TypedValue theHandle) -> Handle_Interface_TypedValue
        assign(Handle_Interface_TypedValue self, Interface_TypedValue thePtr) -> Handle_Interface_TypedValue
        assign(Handle_Interface_TypedValue self, Handle_Interface_TypedValue theHandle) -> Handle_Interface_TypedValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_TypedValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_TypedValue self) -> Interface_TypedValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_TypedValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_TypedValue self) -> Interface_TypedValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_TypedValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_TypedValue self) -> Interface_TypedValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_TypedValue___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_TypedValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_TypedValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_TypedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_TypedValue_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_TypedValue

    def Type(self, *args):
        """
        Type(Handle_Interface_TypedValue self) -> Interface_ParamType

        Returns the type
        I.E. calls ValueType then makes correspondance between
        ParamType from Interface (which remains for compatibility
        reasons) and ValueType from MoniTool

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Handle_Interface_TypedValue_Type(self, *args)


    def ParamTypeToValueType(self, *args):
        """
        ParamTypeToValueType(Handle_Interface_TypedValue self, Interface_ParamType const typ) -> MoniTool_ValueType

        Correspondance ParamType from Interface  to
        ValueType from MoniTool

        :type typ: OCC.wrapper.Interface.Interface_ParamType
        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _Interface.Handle_Interface_TypedValue_ParamTypeToValueType(self, *args)


    def ValueTypeToParamType(self, *args):
        """
        ValueTypeToParamType(Handle_Interface_TypedValue self, MoniTool_ValueType const typ) -> Interface_ParamType

        Correspondance ParamType from Interface  to
        ValueType from MoniTool

        :type typ: OCC.wrapper.MoniTool.MoniTool_ValueType
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Handle_Interface_TypedValue_ValueTypeToParamType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_TypedValue self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_TypedValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_TypedValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_TypedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Internals(self, *args):
        """
        Internals(Handle_Interface_TypedValue self, MoniTool_ValueInterpret & interp, MoniTool_ValueSatisfies & satisf, Standard_CString & satisname, NCollection_DataMap< TCollection_AsciiString,Standard_Integer > & enums)

        Access to internal data which have no other access

        :type interp: OCC.wrapper.MoniTool.MoniTool_ValueInterpret
        :type satisf: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type satisname: OCC.wrapper.Standard.Standard_CString
        :type enums: OCC.wrapper.MoniTool.NCollection_DataMap_TCollection_AsciiString_Standard_Integer

        """
        return _Interface.Handle_Interface_TypedValue_Internals(self, *args)


    def Name(self, *args):
        """
        Name(Handle_Interface_TypedValue self) -> Standard_CString

        Returns the name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_Name(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_Interface_TypedValue self) -> MoniTool_ValueType

        Returns the type of the value

        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _Interface.Handle_Interface_TypedValue_ValueType(self, *args)


    def Definition(self, *args):
        """
        Definition(Handle_Interface_TypedValue self) -> TCollection_AsciiString

        Returns the Definition
        By priority, the enforced one, else an automatic one, computed
        from the specification

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Handle_Interface_TypedValue_Definition(self, *args)


    def SetDefinition(self, *args):
        """
        SetDefinition(Handle_Interface_TypedValue self, Standard_CString const deftext)

        Enforces a Definition

        :type deftext: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_SetDefinition(self, *args)


    def Print(self, *args):
        """
        Print(Handle_Interface_TypedValue self, Handle_Message_Messenger S)

        Prints definition, specification, and actual status and value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_TypedValue_Print(self, *args)


    def PrintValue(self, *args):
        """
        PrintValue(Handle_Interface_TypedValue self, Handle_Message_Messenger S)

        Prints only the Value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_TypedValue_PrintValue(self, *args)


    def AddDef(self, *args):
        """
        AddDef(Handle_Interface_TypedValue self, Standard_CString const initext) -> Standard_Boolean

        Completes the definition of a TypedValue by command <initext>,
        once created with its type
        Returns True if done, False if could not be interpreted
        <initext> may be :
        imin ival : minimum value for an integer
        imax ival : maximum value for an integer
        rmin rval : minimum value for a real
        rmax rval : maximum value for a real
        unit name : name of unit
        ematch i  : enum from integer value i, match required
        enum   i  : enum from integer value i, match not required
        eval text : add an enumerative value (increments max by 1)
        eval ??   : add a non-authorised enum value (to be skipped)
        tmax   l  : maximum length for a text

        :type initext: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_AddDef(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_Interface_TypedValue self, Standard_CString const label)

        Sets a label, which can then be displayed

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_SetLabel(self, *args)


    def Label(self, *args):
        """
        Label(Handle_Interface_TypedValue self) -> Standard_CString

        Returns the label, if set; else returns an empty string

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_Label(self, *args)


    def SetMaxLength(self, *args):
        """
        SetMaxLength(Handle_Interface_TypedValue self, Standard_Integer const max)

        Sets a maximum length for a text (active only for a free text)

        :type max: int

        """
        return _Interface.Handle_Interface_TypedValue_SetMaxLength(self, *args)


    def MaxLength(self, *args):
        """
        MaxLength(Handle_Interface_TypedValue self) -> Standard_Integer

        Returns the maximum length, 0 if not set

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_TypedValue_MaxLength(self, *args)


    def SetIntegerLimit(self, *args):
        """
        SetIntegerLimit(Handle_Interface_TypedValue self, Standard_Boolean const max, Standard_Integer const val)

        Sets an Integer limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: int

        """
        return _Interface.Handle_Interface_TypedValue_SetIntegerLimit(self, *args)


    def IntegerLimit(self, *args):
        """
        IntegerLimit(Handle_Interface_TypedValue self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Integer Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Integer)

        :type max: bool
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_IntegerLimit(self, *args)


    def SetRealLimit(self, *args):
        """
        SetRealLimit(Handle_Interface_TypedValue self, Standard_Boolean const max, Standard_Real const val)

        Sets a Real limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: float

        """
        return _Interface.Handle_Interface_TypedValue_SetRealLimit(self, *args)


    def RealLimit(self, *args):
        """
        RealLimit(Handle_Interface_TypedValue self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Real Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Real)

        :type max: bool
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_RealLimit(self, *args)


    def SetUnitDef(self, *args):
        """
        SetUnitDef(Handle_Interface_TypedValue self, Standard_CString const arg2)

        Sets (Clears if <def> empty) a unit definition, as an equation
        of dimensions. TypedValue just records this definition, does
        not exploit it, to be done as required by user applications

        :type def: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_SetUnitDef(self, *args)


    def UnitDef(self, *args):
        """
        UnitDef(Handle_Interface_TypedValue self) -> Standard_CString

        Returns the recorded unit definition, empty if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_UnitDef(self, *args)


    def StartEnum(self, *args):
        """
        StartEnum(Handle_Interface_TypedValue self, Standard_Integer const start=0, Standard_Boolean const match)

        For an enumeration, precises the starting value (default 0)
        and the match condition : if True (D), the string value must
        match the definition, else it may take another value : in that
        case, the Integer Value will be  Start - 1.
        (empty value remains allowed)

        :type start: int
        :type match: bool

        """
        return _Interface.Handle_Interface_TypedValue_StartEnum(self, *args)


    def AddEnum(self, *args):
        """
        AddEnum(Handle_Interface_TypedValue self, Standard_CString const v1, Standard_CString const v2, Standard_CString const v3, Standard_CString const v4, Standard_CString const v5, Standard_CString const v6, Standard_CString const v7, Standard_CString const v8, Standard_CString const v9, Standard_CString const v10)

        Adds enumerative definitions. For more than 10, several calls

        :type v1: OCC.wrapper.Standard.Standard_CString
        :type v2: OCC.wrapper.Standard.Standard_CString
        :type v3: OCC.wrapper.Standard.Standard_CString
        :type v4: OCC.wrapper.Standard.Standard_CString
        :type v5: OCC.wrapper.Standard.Standard_CString
        :type v6: OCC.wrapper.Standard.Standard_CString
        :type v7: OCC.wrapper.Standard.Standard_CString
        :type v8: OCC.wrapper.Standard.Standard_CString
        :type v9: OCC.wrapper.Standard.Standard_CString
        :type v10: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_AddEnum(self, *args)


    def AddEnumValue(self, *args):
        """
        AddEnumValue(Handle_Interface_TypedValue self, Standard_CString const val, Standard_Integer const num)

        Adds an enumeration definition, by its string and numeric
        values. If it is the first setting for this value, it is
        recorded as main value. Else, it is recognized as alternate
        string for this numeric value

        :type val: OCC.wrapper.Standard.Standard_CString
        :type num: int

        """
        return _Interface.Handle_Interface_TypedValue_AddEnumValue(self, *args)


    def EnumDef(self, *args):
        """
        EnumDef(Handle_Interface_TypedValue self) -> Standard_Boolean

        Gives the Enum definitions : start value, end value, match
        status. Returns True for an Enum, False else.

        :type startcase: int
        :type endcase: int
        :type match: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_EnumDef(self, *args)


    def EnumVal(self, *args):
        """
        EnumVal(Handle_Interface_TypedValue self, Standard_Integer const num) -> Standard_CString

        Returns the value of an enumerative definition, from its rank
        Empty string if out of range or not an Enum

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_EnumVal(self, *args)


    def EnumCase(self, *args):
        """
        EnumCase(Handle_Interface_TypedValue self, Standard_CString const val) -> Standard_Integer

        Returns the case number which cooresponds to a string value
        Works with main and additionnal values
        Returns (StartEnum - 1) if not OK, -1 if not an Enum

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_TypedValue_EnumCase(self, *args)


    def SetObjectType(self, *args):
        """
        SetObjectType(Handle_Interface_TypedValue self, Handle_Standard_Type typ)

        Sets type of which an Object TypedValue must be kind of
        Error for a TypedValue not an Object (Entity)

        :type typ: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Handle_Interface_TypedValue_SetObjectType(self, *args)


    def ObjectType(self, *args):
        """
        ObjectType(Handle_Interface_TypedValue self) -> Handle_Standard_Type

        Returns the type of which an Object TypedValue must be kind of
        Default is Standard_Transient
        Null for a TypedValue not an Object

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Handle_Interface_TypedValue_ObjectType(self, *args)


    def SetInterpret(self, *args):
        """
        SetInterpret(Handle_Interface_TypedValue self, MoniTool_ValueInterpret const func)

        Sets a specific Interpret function

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueInterpret

        """
        return _Interface.Handle_Interface_TypedValue_SetInterpret(self, *args)


    def HasInterpret(self, *args):
        """
        HasInterpret(Handle_Interface_TypedValue self) -> Standard_Boolean

        Tells if a TypedValue has an Interpret

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_HasInterpret(self, *args)


    def SetSatisfies(self, *args):
        """
        SetSatisfies(Handle_Interface_TypedValue self, MoniTool_ValueSatisfies const func, Standard_CString const name)

        Sets a specific Satisfies function : it is added to the
        already defined criteria
        It must match the form :
        statisfies (val : HAsciiString) returns Boolean

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_SetSatisfies(self, *args)


    def SatisfiesName(self, *args):
        """
        SatisfiesName(Handle_Interface_TypedValue self) -> Standard_CString

        Returns name of specific satisfy, empty string if none

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_SatisfiesName(self, *args)


    def IsSetValue(self, *args):
        """
        IsSetValue(Handle_Interface_TypedValue self) -> Standard_Boolean

        Returns True if the value is set (not empty/not null object)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_IsSetValue(self, *args)


    def CStringValue(self, *args):
        """
        CStringValue(Handle_Interface_TypedValue self) -> Standard_CString

        Returns the value, as a cstring. Empty if not set.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_CStringValue(self, *args)


    def HStringValue(self, *args):
        """
        HStringValue(Handle_Interface_TypedValue self) -> Handle_TCollection_HAsciiString

        Returns the value, as a Handle (can then be shared)
        Null if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_TypedValue_HStringValue(self, *args)


    def Interpret(self, *args):
        """
        Interpret(Handle_Interface_TypedValue self, Handle_TCollection_HAsciiString hval, Standard_Boolean const native) -> Handle_TCollection_HAsciiString

        Interprets a value.
        <native> True  : returns a native value
        <native> False : returns a coded  value
        If the Interpret function is set, calls it
        Else, for an Enum, Native returns the Text, Coded returns
        the number
        STANDARD RETURNS : = hval means no specific interpretation
        Null means senseless
        Can also be redefined

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type native: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_TypedValue_Interpret(self, *args)


    def Satisfies(self, *args):
        """
        Satisfies(Handle_Interface_TypedValue self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Returns True if a value statifies the specification
        (remark : does not apply to Entity : see ObjectType, for this
        type, the string is just a comment)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_Satisfies(self, *args)


    def ClearValue(self, *args):
        """
        ClearValue(Handle_Interface_TypedValue self)

        Clears the recorded Value : it is now unset


        """
        return _Interface.Handle_Interface_TypedValue_ClearValue(self, *args)


    def SetCStringValue(self, *args):
        """
        SetCStringValue(Handle_Interface_TypedValue self, Standard_CString const val) -> Standard_Boolean

        Changes the value. The new one must satisfy the specification
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_SetCStringValue(self, *args)


    def SetHStringValue(self, *args):
        """
        SetHStringValue(Handle_Interface_TypedValue self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Forces a new Handle for the Value
        It can be empty, else (if Type is not free Text), it must
        satisfy the specification.
        Not only the value is changed, but also the way it is shared
        Remark : for Type=Object, this value is not controlled, it can
        be set as a comment
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_SetHStringValue(self, *args)


    def IntegerValue(self, *args):
        """
        IntegerValue(Handle_Interface_TypedValue self) -> Standard_Integer

        Returns the value as integer, i.e. :
        For type = Integer, the integer itself; 0 if not set
        For type = Enum, the designated rank (see Enum definition)
        StartEnum - 1 if not set or not in the definition
        Else, returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_TypedValue_IntegerValue(self, *args)


    def SetIntegerValue(self, *args):
        """
        SetIntegerValue(Handle_Interface_TypedValue self, Standard_Integer const ival) -> Standard_Boolean

        Changes the value as an integer, only for Integer or Enum

        :type ival: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_SetIntegerValue(self, *args)


    def RealValue(self, *args):
        """
        RealValue(Handle_Interface_TypedValue self) -> Standard_Real

        Returns the value as real,  for a Real type TypedValue
        Else, returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Handle_Interface_TypedValue_RealValue(self, *args)


    def SetRealValue(self, *args):
        """
        SetRealValue(Handle_Interface_TypedValue self, Standard_Real const rval) -> Standard_Boolean

        Changes the value as a real, only for Real

        :type rval: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_SetRealValue(self, *args)


    def ObjectValue(self, *args):
        """
        ObjectValue(Handle_Interface_TypedValue self) -> Handle_Standard_Transient

        Returns the value as Transient Object, only for Object/Entity
        Remark that the "HString value" is IGNORED here
        Null if not set; remains to be casted

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_TypedValue_ObjectValue(self, *args)


    def GetObjectValue(self, *args):
        """
        GetObjectValue(Handle_Interface_TypedValue self, Handle_Standard_Transient val)

        Same as ObjectValue, but avoids DownCast : the receiving
        variable is directly loaded. It is assumed that it complies
        with the definition of ObjectType ! Otherwise, big trouble

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_TypedValue_GetObjectValue(self, *args)


    def SetObjectValue(self, *args):
        """
        SetObjectValue(Handle_Interface_TypedValue self, Handle_Standard_Transient obj) -> Standard_Boolean

        Changes the value as Transient Object, only for Object/Entity
        Returns False if DynamicType does not satisfy ObjectType
        Can be redefined to be managed (in a subclass)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_SetObjectValue(self, *args)


    def ObjectTypeName(self, *args):
        """
        ObjectTypeName(Handle_Interface_TypedValue self) -> Standard_CString

        Returns the type name of the ObjectValue, or an empty string
        if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_TypedValue_ObjectTypeName(self, *args)


    def AddLib(self, *args):
        """
        AddLib(Handle_Interface_TypedValue self, Handle_MoniTool_TypedValue tv, Standard_CString const arg2) -> Standard_Boolean

        Adds a TypedValue in the library.
        It is recorded then will be accessed by its Name
        Its Definition may be imposed, else it is computed as usual
        By default it will be accessed by its Definition (string)
        Returns True if done, False if tv is Null or brings no
        Definition or <def> not defined

        If a TypedValue was already recorded under this name, it is
        replaced

        :type tv: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue
        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_AddLib(self, *args)


    def Lib(self, *args):
        """
        Lib(Handle_Interface_TypedValue self, Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns the TypedValue bound with a given Name
        Null Handle if none recorded
        Warning : it is the original, not duplicated

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _Interface.Handle_Interface_TypedValue_Lib(self, *args)


    def FromLib(self, *args):
        """
        FromLib(Handle_Interface_TypedValue self, Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns a COPY of the TypedValue bound with a given Name
        Null Handle if none recorded

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _Interface.Handle_Interface_TypedValue_FromLib(self, *args)


    def LibList(self, *args):
        """
        LibList(Handle_Interface_TypedValue self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the list of names of items of the Library of Types
        --    Library of TypedValue as Valued Parameters,    -- --
        accessed by parameter name
        for use by management of Static Parameters

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Interface.Handle_Interface_TypedValue_LibList(self, *args)


    def StaticValue(self, *args):
        """
        StaticValue(Handle_Interface_TypedValue self, Standard_CString const name) -> Handle_MoniTool_TypedValue

        Returns a static value from its name, null if unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _Interface.Handle_Interface_TypedValue_StaticValue(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_TypedValue self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_TypedValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_TypedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_TypedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_TypedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_TypedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_TypedValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_TypedValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_TypedValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_TypedValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_TypedValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_TypedValue self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_TypedValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_TypedValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_TypedValue_DecrementRefCounter(self, *args)

Handle_Interface_TypedValue_swigregister = _Interface.Handle_Interface_TypedValue_swigregister
Handle_Interface_TypedValue_swigregister(Handle_Interface_TypedValue)

def Handle_Interface_TypedValue_DownCast(thing):
    return _Interface.Handle_Interface_TypedValue_DownCast(thing)
Handle_Interface_TypedValue_DownCast = _Interface.Handle_Interface_TypedValue_DownCast

class Handle_Interface_HGraph(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_HGraph self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_HGraph_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_HGraph self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_HGraph_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_HGraph self, Interface_HGraph thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_HGraph_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_HGraph self, Handle_Interface_HGraph theHandle) -> Handle_Interface_HGraph
        assign(Handle_Interface_HGraph self, Interface_HGraph thePtr) -> Handle_Interface_HGraph
        assign(Handle_Interface_HGraph self, Handle_Interface_HGraph theHandle) -> Handle_Interface_HGraph

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_HGraph_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_HGraph self) -> Interface_HGraph

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_HGraph_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_HGraph self) -> Interface_HGraph

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_HGraph___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_HGraph self) -> Interface_HGraph

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_HGraph___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_HGraph___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_HGraph___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_HGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_HGraph_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_HGraph

    def Graph(self, *args):
        """
        Returns the Graph contained in <me>, for Read Only Operations
        Remark that it is returns as "const &"
        Getting it in a new variable instead of a reference would be
        a pitty, because all the graph's content would be duplicated

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _Interface.Handle_Interface_HGraph_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CGraph(self, *args):
        """
        CGraph(Handle_Interface_HGraph self) -> Interface_Graph

        Same as above, but for Read-Write Operations
        Then, The Graph will be modified in the HGraph itself

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        return _Interface.Handle_Interface_HGraph_CGraph(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_HGraph self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_HGraph_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_HGraph_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_HGraph_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_HGraph self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_HGraph_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_HGraph self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_HGraph self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_HGraph_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_HGraph self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_HGraph self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_HGraph_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_HGraph self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_HGraph_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_HGraph self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_HGraph_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_HGraph self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_HGraph_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_HGraph self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_HGraph_DecrementRefCounter(self, *args)

Handle_Interface_HGraph_swigregister = _Interface.Handle_Interface_HGraph_swigregister
Handle_Interface_HGraph_swigregister(Handle_Interface_HGraph)

def Handle_Interface_HGraph_DownCast(thing):
    return _Interface.Handle_Interface_HGraph_DownCast(thing)
Handle_Interface_HGraph_DownCast = _Interface.Handle_Interface_HGraph_DownCast

class Handle_Interface_EntityCluster(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_EntityCluster self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_EntityCluster_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_EntityCluster self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_EntityCluster_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_EntityCluster self, Interface_EntityCluster thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_EntityCluster_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_EntityCluster self, Handle_Interface_EntityCluster theHandle) -> Handle_Interface_EntityCluster
        assign(Handle_Interface_EntityCluster self, Interface_EntityCluster thePtr) -> Handle_Interface_EntityCluster
        assign(Handle_Interface_EntityCluster self, Handle_Interface_EntityCluster theHandle) -> Handle_Interface_EntityCluster

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_EntityCluster_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_EntityCluster self) -> Interface_EntityCluster

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_EntityCluster_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_EntityCluster self) -> Interface_EntityCluster

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_EntityCluster___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_EntityCluster self) -> Interface_EntityCluster

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_EntityCluster___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_EntityCluster___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_EntityCluster___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_EntityCluster(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_EntityCluster_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_EntityCluster

    def Append(self, *args):
        """
        Append(Handle_Interface_EntityCluster self, Handle_Standard_Transient ent)

        Appends an Entity to the Cluster. If it is not full, adds the
        entity directly inside itself. Else, transmits to its Next
        and Creates it if it does not yet exist

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_EntityCluster_Append(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_Interface_EntityCluster self, Handle_Standard_Transient ent) -> Standard_Boolean
        Remove(Handle_Interface_EntityCluster self, Standard_Integer const num) -> Standard_Boolean

        Removes an Entity from the Cluster, given its rank. If <num>
        is greater than NbLocal, calls its Next with (num - NbLocal),
        Returns True if it becomes itself empty, False else

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_EntityCluster_Remove(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Handle_Interface_EntityCluster self) -> Standard_Integer

        Returns total count of Entities (including Next)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_EntityCluster_NbEntities(self, *args)


    def Value(self, *args):
        """
        Returns the Entity identified by its rank in the list
        (including Next)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Handle_Interface_EntityCluster_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(Handle_Interface_EntityCluster self, Standard_Integer const num, Handle_Standard_Transient ent)

        Changes an Entity given its rank.

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_EntityCluster_SetValue(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_Interface_EntityCluster self, Interface_EntityIterator iter)

        Fills an Iterator with designated Entities (includes Next)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_EntityCluster_FillIterator(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_EntityCluster self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_EntityCluster_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_EntityCluster_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_EntityCluster_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_EntityCluster self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_EntityCluster_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_EntityCluster self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_EntityCluster self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_EntityCluster_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_EntityCluster self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_EntityCluster self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_EntityCluster_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_EntityCluster self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_EntityCluster_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_EntityCluster self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_EntityCluster_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_EntityCluster self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_EntityCluster_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_EntityCluster self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_EntityCluster_DecrementRefCounter(self, *args)

Handle_Interface_EntityCluster_swigregister = _Interface.Handle_Interface_EntityCluster_swigregister
Handle_Interface_EntityCluster_swigregister(Handle_Interface_EntityCluster)

def Handle_Interface_EntityCluster_DownCast(thing):
    return _Interface.Handle_Interface_EntityCluster_DownCast(thing)
Handle_Interface_EntityCluster_DownCast = _Interface.Handle_Interface_EntityCluster_DownCast

class Interface_MSG(object):
    """
    This class gives a set of functions to manage and use a list
    of translated messages (messagery)

    Keys are strings, their corresponding (i.e. translated) items
    are strings, managed by a dictionary (a global one).

    If the dictionary is not set, or if a key is not recorded,
    the key is returned as item, and it is possible to :
    - trace or not this fail, record or not it for further trace

    It is also possible to suspend the translation (keys are then
    always returned as items)

    This class also provides a file format for loading :
    It is made of couples of lines, the first one begins by '@'
    the following is the key, the second one is the message
    Lines which are empty or which begin by '@@' are skipped
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_MSG self, Standard_CString const key) -> Interface_MSG
        __init__(Interface_MSG self, Standard_CString const key, Standard_Integer const i1) -> Interface_MSG
        __init__(Interface_MSG self, Standard_CString const key, Standard_Integer const i1, Standard_Integer const i2) -> Interface_MSG
        __init__(Interface_MSG self, Standard_CString const key, Standard_Real const r1, Standard_Integer const intervals=-1) -> Interface_MSG
        __init__(Interface_MSG self, Standard_CString const key, Standard_CString const str) -> Interface_MSG
        __init__(Interface_MSG self, Standard_CString const key, Standard_Integer const ival, Standard_CString const str) -> Interface_MSG

        Translates a message which contains one integer and one
        string variables
        As for one integer, it is just a writing help
        Used for instance to say "Param n0.<ival> i.e. <str> is not.."

        The basic message is intended to be in  C-sprintf  format
        with one %d then one %s forms in it

        :type key: OCC.wrapper.Standard.Standard_CString
        :type ival: int
        :type str: OCC.wrapper.Standard.Standard_CString

        """
        this = _Interface.new_Interface_MSG(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """
        Destroy(Interface_MSG self)

        Optimised destructor (applies for additional forms of Create)


        """
        return _Interface.Interface_MSG_Destroy(self, *args)


    def Value(self, *args):
        """
        Value(Interface_MSG self) -> Standard_CString

        Returns the translated message, in a functional form with
        operator ()
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_MSG_Value(self, *args)


    def Read(*args):
        """
        Read(Standard_IStream & S) -> Standard_Integer
        Read(Standard_CString const file) -> Standard_Integer

        Reads a list of messages from a file defined by its name

        :type file: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_MSG_Read(*args)

    Read = staticmethod(Read)

    def Write(*args):
        """
        Write(Standard_OStream & S, Standard_CString const rootkey) -> Standard_Integer

        Writes the list of messages recorded to be translated, to a
        stream. Writes all the list (Default) or only keys which begin
        by <rootkey>. Returns the count of written messages

        :type S: OCC.wrapper.Standard.Standard_OStream
        :type rootkey: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_MSG_Write(*args)

    Write = staticmethod(Write)

    def IsKey(*args):
        """
        IsKey(Standard_CString const mess) -> Standard_Boolean

        Returns True if a given message is surely a key
        (according to the form adopted for keys)
        (before activating messages, answer is false)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_MSG_IsKey(*args)

    IsKey = staticmethod(IsKey)

    def Translated(*args):
        """
        Translated(Standard_CString const key) -> Standard_CString

        Returns the item recorded for a key.
        Returns the key itself if :
        - it is not recorded (then, the trace system is activated)
        - MSG has been required to be hung on

        :type key: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_MSG_Translated(*args)

    Translated = staticmethod(Translated)

    def Record(*args):
        """
        Record(Standard_CString const key, Standard_CString const item)

        Fills the dictionary with a couple (key-item)
        If a key is already recorded, it is possible to :
        - keep the last definition, and activate the trace system

        :type key: OCC.wrapper.Standard.Standard_CString
        :type item: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_MSG_Record(*args)

    Record = staticmethod(Record)

    def SetTrace(*args):
        """
        SetTrace(Standard_Boolean const toprint, Standard_Boolean const torecord)

        Sets the trace system to work when activated, as follow :
        - if <toprint>  is True, print immediately on standard output
        - if <torecord> is True, record it for further print

        :type toprint: bool
        :type torecord: bool

        """
        return _Interface.Interface_MSG_SetTrace(*args)

    SetTrace = staticmethod(SetTrace)

    def SetMode(*args):
        """
        SetMode(Standard_Boolean const running, Standard_Boolean const raising)

        Sets the main modes for MSG :
        - if <running> is True, translation works normally
        - if <running> is False, translated item equate keys
        - if <raising> is True, errors (from Record or Translate)
        cause MSG to raise an exception
        - if <raising> is False, MSG runs without exception, then
        see also Trace Modes above

        :type running: bool
        :type raising: bool

        """
        return _Interface.Interface_MSG_SetMode(*args)

    SetMode = staticmethod(SetMode)

    def PrintTrace(*args):
        """
        PrintTrace(Standard_OStream & S)

        Prints the recorded errors (without title; can be empty, this
        is the normally expected case)

        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _Interface.Interface_MSG_PrintTrace(*args)

    PrintTrace = staticmethod(PrintTrace)

    def Intervalled(*args):
        """
        Intervalled(Standard_Real const val, Standard_Integer const order=3, Standard_Boolean const upper) -> Standard_Real

        Returns an "intervalled" value from a starting real <val> :
        i.e. a value which is rounded on an interval limit
        Interval limits are defined to be in a coarsely "geometric"
        progression (two successive intervals are inside a limit ratio)

        <order> gives the count of desired intervals in a range <1-10>
        <upper> False, returns the first lower interval (D)
        <upper> True,  returns the first upper interval
        Values of Intervals according <order> :
        0,1 : 1 10 100 ...
        2   : 1 3 10 30 100 ...
        3(D): 1 2 5 10 20 50 100 ...
        4   : 1 2 3 6 10 20 30 60 100 ...
        6   : 1 1.5 2 3 5 7 10 15 20 ...
        10  : 1 1.2 1.5 2 2.5 3 4 5 6 8 10 12 15 20 25 ...

        :type val: float
        :type order: int
        :type upper: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Interface_MSG_Intervalled(*args)

    Intervalled = staticmethod(Intervalled)

    def TDate(*args):
        """
        TDate(Standard_CString const text, Standard_Integer const yy, Standard_Integer const mm, Standard_Integer const dd, Standard_Integer const hh, Standard_Integer const mn, Standard_Integer const ss, Standard_CString const format)

        Codes a date as a text, from its numeric value (-> seconds) :
        YYYY-MM-DD:HH-MN-SS  fixed format, completed by leading zeros
        Another format can be provided, as follows :
        C:%d ...   C like format, preceeded by  C:
        S:...      format to call system (not yet implemented)

        :type text: OCC.wrapper.Standard.Standard_CString
        :type yy: int
        :type mm: int
        :type dd: int
        :type hh: int
        :type mn: int
        :type ss: int
        :type format: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_MSG_TDate(*args)

    TDate = staticmethod(TDate)

    def NDate(*args):
        """
        NDate(Standard_CString const text) -> Standard_Boolean

        Decodes a date to numeric integer values
        Returns True if OK, False if text does not fit with required
        format. Incomplete forms are allowed (for instance, for only
        YYYY-MM-DD, hour is zero)

        :type text: OCC.wrapper.Standard.Standard_CString
        :type yy: int
        :type mm: int
        :type dd: int
        :type hh: int
        :type mn: int
        :type ss: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_MSG_NDate(*args)

    NDate = staticmethod(NDate)

    def CDate(*args):
        """
        CDate(Standard_CString const text1, Standard_CString const text2) -> Standard_Integer

        Returns a value about comparison of two dates
        0 : equal. <0 text1 anterior. >0 text1 posterior

        :type text1: OCC.wrapper.Standard.Standard_CString
        :type text2: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_MSG_CDate(*args)

    CDate = staticmethod(CDate)

    def Blanks(*args):
        """
        Blanks(Standard_Integer const val, Standard_Integer const max) -> Standard_CString
        Blanks(Standard_CString const val, Standard_Integer const max) -> Standard_CString
        Blanks(Standard_Integer const count) -> Standard_CString

        Returns a blank string of <count> blanks (mini 0, maxi 76)

        :type count: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_MSG_Blanks(*args)

    Blanks = staticmethod(Blanks)

    def Print(*args):
        """
        Print(Standard_OStream & S, Standard_CString const val, Standard_Integer const max, Standard_Integer const just=-1)

        Prints a String on an Output Stream, as follows :
        Accompagned with blanks, to give up to <max> charis at all,
        justified according just :
        -1 (D) : left     0 : center    1 : right
        Maximum 76 characters

        :type S: OCC.wrapper.Standard.Standard_OStream
        :type val: OCC.wrapper.Standard.Standard_CString
        :type max: int
        :type just: int

        """
        return _Interface.Interface_MSG_Print(*args)

    Print = staticmethod(Print)
    __swig_destroy__ = _Interface.delete_Interface_MSG
Interface_MSG_swigregister = _Interface.Interface_MSG_swigregister
Interface_MSG_swigregister(Interface_MSG)

def Interface_MSG_Read(*args):
    """
    Read(Standard_IStream & S) -> Standard_Integer
    Interface_MSG_Read(Standard_CString const file) -> Standard_Integer

    Reads a list of messages from a file defined by its name

    :type file: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_MSG_Read(*args)

def Interface_MSG_Write(*args):
    """
    Interface_MSG_Write(Standard_OStream & S, Standard_CString const rootkey) -> Standard_Integer

    Writes the list of messages recorded to be translated, to a
    stream. Writes all the list (Default) or only keys which begin
    by <rootkey>. Returns the count of written messages

    :type S: OCC.wrapper.Standard.Standard_OStream
    :type rootkey: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_MSG_Write(*args)

def Interface_MSG_IsKey(*args):
    """
    Interface_MSG_IsKey(Standard_CString const mess) -> Standard_Boolean

    Returns True if a given message is surely a key
    (according to the form adopted for keys)
    (before activating messages, answer is false)

    :type mess: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_MSG_IsKey(*args)

def Interface_MSG_Translated(*args):
    """
    Interface_MSG_Translated(Standard_CString const key) -> Standard_CString

    Returns the item recorded for a key.
    Returns the key itself if :
    - it is not recorded (then, the trace system is activated)
    - MSG has been required to be hung on

    :type key: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_MSG_Translated(*args)

def Interface_MSG_Record(*args):
    """
    Interface_MSG_Record(Standard_CString const key, Standard_CString const item)

    Fills the dictionary with a couple (key-item)
    If a key is already recorded, it is possible to :
    - keep the last definition, and activate the trace system

    :type key: OCC.wrapper.Standard.Standard_CString
    :type item: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_MSG_Record(*args)

def Interface_MSG_SetTrace(*args):
    """
    Interface_MSG_SetTrace(Standard_Boolean const toprint, Standard_Boolean const torecord)

    Sets the trace system to work when activated, as follow :
    - if <toprint>  is True, print immediately on standard output
    - if <torecord> is True, record it for further print

    :type toprint: bool
    :type torecord: bool

    """
    return _Interface.Interface_MSG_SetTrace(*args)

def Interface_MSG_SetMode(*args):
    """
    Interface_MSG_SetMode(Standard_Boolean const running, Standard_Boolean const raising)

    Sets the main modes for MSG :
    - if <running> is True, translation works normally
    - if <running> is False, translated item equate keys
    - if <raising> is True, errors (from Record or Translate)
    cause MSG to raise an exception
    - if <raising> is False, MSG runs without exception, then
    see also Trace Modes above

    :type running: bool
    :type raising: bool

    """
    return _Interface.Interface_MSG_SetMode(*args)

def Interface_MSG_PrintTrace(*args):
    """
    Interface_MSG_PrintTrace(Standard_OStream & S)

    Prints the recorded errors (without title; can be empty, this
    is the normally expected case)

    :type S: OCC.wrapper.Standard.Standard_OStream

    """
    return _Interface.Interface_MSG_PrintTrace(*args)

def Interface_MSG_Intervalled(*args):
    """
    Interface_MSG_Intervalled(Standard_Real const val, Standard_Integer const order=3, Standard_Boolean const upper) -> Standard_Real

    Returns an "intervalled" value from a starting real <val> :
    i.e. a value which is rounded on an interval limit
    Interval limits are defined to be in a coarsely "geometric"
    progression (two successive intervals are inside a limit ratio)

    <order> gives the count of desired intervals in a range <1-10>
    <upper> False, returns the first lower interval (D)
    <upper> True,  returns the first upper interval
    Values of Intervals according <order> :
    0,1 : 1 10 100 ...
    2   : 1 3 10 30 100 ...
    3(D): 1 2 5 10 20 50 100 ...
    4   : 1 2 3 6 10 20 30 60 100 ...
    6   : 1 1.5 2 3 5 7 10 15 20 ...
    10  : 1 1.2 1.5 2 2.5 3 4 5 6 8 10 12 15 20 25 ...

    :type val: float
    :type order: int
    :type upper: bool
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Interface.Interface_MSG_Intervalled(*args)

def Interface_MSG_TDate(*args):
    """
    Interface_MSG_TDate(Standard_CString const text, Standard_Integer const yy, Standard_Integer const mm, Standard_Integer const dd, Standard_Integer const hh, Standard_Integer const mn, Standard_Integer const ss, Standard_CString const format)

    Codes a date as a text, from its numeric value (-> seconds) :
    YYYY-MM-DD:HH-MN-SS  fixed format, completed by leading zeros
    Another format can be provided, as follows :
    C:%d ...   C like format, preceeded by  C:
    S:...      format to call system (not yet implemented)

    :type text: OCC.wrapper.Standard.Standard_CString
    :type yy: int
    :type mm: int
    :type dd: int
    :type hh: int
    :type mn: int
    :type ss: int
    :type format: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_MSG_TDate(*args)

def Interface_MSG_NDate(*args):
    """
    Interface_MSG_NDate(Standard_CString const text) -> Standard_Boolean

    Decodes a date to numeric integer values
    Returns True if OK, False if text does not fit with required
    format. Incomplete forms are allowed (for instance, for only
    YYYY-MM-DD, hour is zero)

    :type text: OCC.wrapper.Standard.Standard_CString
    :type yy: int
    :type mm: int
    :type dd: int
    :type hh: int
    :type mn: int
    :type ss: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_MSG_NDate(*args)

def Interface_MSG_CDate(*args):
    """
    Interface_MSG_CDate(Standard_CString const text1, Standard_CString const text2) -> Standard_Integer

    Returns a value about comparison of two dates
    0 : equal. <0 text1 anterior. >0 text1 posterior

    :type text1: OCC.wrapper.Standard.Standard_CString
    :type text2: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_MSG_CDate(*args)

def Interface_MSG_Blanks(*args):
    """
    Blanks(Standard_Integer const val, Standard_Integer const max) -> Standard_CString
    Blanks(Standard_CString const val, Standard_Integer const max) -> Standard_CString
    Interface_MSG_Blanks(Standard_Integer const count) -> Standard_CString

    Returns a blank string of <count> blanks (mini 0, maxi 76)

    :type count: int
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_MSG_Blanks(*args)

def Interface_MSG_Print(*args):
    """
    Interface_MSG_Print(Standard_OStream & S, Standard_CString const val, Standard_Integer const max, Standard_Integer const just=-1)

    Prints a String on an Output Stream, as follows :
    Accompagned with blanks, to give up to <max> charis at all,
    justified according just :
    -1 (D) : left     0 : center    1 : right
    Maximum 76 characters

    :type S: OCC.wrapper.Standard.Standard_OStream
    :type val: OCC.wrapper.Standard.Standard_CString
    :type max: int
    :type just: int

    """
    return _Interface.Interface_MSG_Print(*args)

class Interface_STAT(object):
    """
    This class manages statistics to be queried asynchronously.
    Way of use :
    An operator describes a STAT form then fills it according to
    its progression. This produces a state of advancement of the
    process. This state can then be queried asynchronously :
    typically it is summarised as a percentage. There are also
    an identification of the current state, and informations on
    processed volume.

    A STAT form can be described once for all (as static).
    It describes the stream of the process (see later), in terms
    of phases, cycles, steps, with estimated weights. But it
    brings no current data.

    One STAT at a time is active for filling and querying. It is
    used to control phasing, weighting ... Specific data for
    execution are given when running on active STAT : counts of
    items ... Data for query are then recorded and can be accessed
    at any time, asynchronously.

    A STAT is organised as follows :
    - it can be split into PHASES (by default, there is none, and
    all process takes place in one "default" phase)
    - each phase is identified by a name and is attached a weight
    -> the sum of the weights is used to compute relative weights
    - for each phase, or for the unique default phase if none :
    -- the process works on a list of ITEMS
    -- by default, all the items are processed in once
    -- but this list can be split into CYCLES, each one takes
    a sub-list : the weight of each cycle is related to its
    count of items
    -- a cycle can be split into STEPS, by default there are none
    then one "default step" is considered
    -- each step is attached a weight
    -> the sum of the weights of steps is used to compute relative
    weights of the steps in each cycle
    -> all the cycles of a phase have the same organisation

    Hence, when defining the STAT form, the phases have to be
    described. If no weight is precisely known, give 1. for all...
    No phase description will give only one "default" phase
    For each phase, a typical cycle can be described by its steps.
    Here too, for no weight precisely known, give 1. for all...

    For executing, activate a STAT to begin count. Give counts of
    items and cycles for the first phase (for the unique default
    one if no phasing is described)
    Else, give count of items and cycles for each new phase.
    Class methods allow also to set next cycle (given count of
    items), next step in cycle (if more then one), next item in
    step.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_STAT self, Standard_CString const title) -> Interface_STAT
        __init__(Interface_STAT self, Interface_STAT other) -> Interface_STAT

        used when starting

        :type other: OCC.wrapper.Interface.Interface_STAT

        """
        this = _Interface.new_Interface_STAT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Internals(self, *args):
        """
        Internals(Interface_STAT self, Handle_TCollection_HAsciiString tit, Handle_TColStd_HSequenceOfAsciiString phn, Handle_TColStd_HSequenceOfReal phw, Handle_TColStd_HSequenceOfInteger phdeb, Handle_TColStd_HSequenceOfInteger phfin, Handle_TColStd_HSequenceOfReal stw)

        Returns fields in once, without copying them, used for copy
        when starting

        :type tit: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type total: float
        :type phn: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString
        :type phw: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal
        :type phdeb: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger
        :type phfin: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger
        :type stw: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _Interface.Interface_STAT_Internals(self, *args)


    def AddPhase(self, *args):
        """
        AddPhase(Interface_STAT self, Standard_Real const weight, Standard_CString const name)

        Adds a new phase to the description.
        The first one after Create replaces the default unique one

        :type weight: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_STAT_AddPhase(self, *args)


    def AddStep(self, *args):
        """
        AddStep(Interface_STAT self, Standard_Real const weight=1)

        Adds a new step for the last added phase, the default unique
        one if no AddPhase has already been added
        Warning : AddStep before the first AddPhase are cancelled

        :type weight: float

        """
        return _Interface.Interface_STAT_AddStep(self, *args)


    def Description(self, *args):
        """
        Description(Interface_STAT self, Standard_CString & title)

        Returns global description (cumulated weights of all phases,
        count of phases,1 for default, and title)

        :type nbphases: int
        :type total: float
        :type title: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_STAT_Description(self, *args)


    def Phase(self, *args):
        """
        Phase(Interface_STAT self, Standard_Integer const num, Standard_CString & name)

        Returns description of a phase, given its rank
        (n0 for first step, count of steps, default gives one;
        weight, name)

        :type num: int
        :type n0step: int
        :type nbstep: int
        :type weight: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_STAT_Phase(self, *args)


    def Step(self, *args):
        """
        Step(Interface_STAT self, Standard_Integer const num) -> Standard_Real

        Returns weight of a Step, related to the cumul given for the
        phase.
        <num> is given by <n0step> + i, i between 1 and <nbsteps>
        (default gives n0step < 0 then weight is one)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Interface_STAT_Step(self, *args)


    def Start(self, *args):
        """
        Start(Interface_STAT self, Standard_Integer const items, Standard_Integer const cycles=1)

        Starts a STAT on its first phase (or its default one)
        <items> gives the total count of items, <cycles> the count of
        cycles
        If <cycles> is more than one, the first Cycle must then be
        started by NextCycle (NextStep/NextItem are ignored).
        If it is one, NextItem/NextStep can then be called

        :type items: int
        :type cycles: int

        """
        return _Interface.Interface_STAT_Start(self, *args)


    def StartCount(*args):
        """
        StartCount(Standard_Integer const items, Standard_CString const title)

        Starts a default STAT, with no phase, no step, ready to just
        count items.
        <items> gives the total count of items
        Hence, NextItem is available to directly count

        :type items: int
        :type title: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_STAT_StartCount(*args)

    StartCount = staticmethod(StartCount)

    def NextPhase(*args):
        """
        NextPhase(Standard_Integer const items, Standard_Integer const cycles=1)

        Commands to resume the preceeding phase and start a new one
        <items> and <cycles> as for Start, but for this new phase
        Ignored if count of phases is already passed
        If <cycles> is more than one, the first Cycle must then be
        started by NextCycle (NextStep/NextItem are ignored).
        If it is one, NextItem/NextStep can then be called

        :type items: int
        :type cycles: int

        """
        return _Interface.Interface_STAT_NextPhase(*args)

    NextPhase = staticmethod(NextPhase)

    def SetPhase(*args):
        """
        SetPhase(Standard_Integer const items, Standard_Integer const cycles=1)

        Changes the parameters of the phase to start
        To be used before first counting (i.e. just after NextPhase)
        Can be used by an operator which has to reajust counts on run

        :type items: int
        :type cycles: int

        """
        return _Interface.Interface_STAT_SetPhase(*args)

    SetPhase = staticmethod(SetPhase)

    def NextCycle(*args):
        """
        NextCycle(Standard_Integer const items)

        Commands to resume the preceeding cycle and start a new one,
        with a count of items
        Ignored if count of cycles is already passed
        Then, first step is started (or default one)
        NextItem can be called for the first step, or NextStep to pass
        to the next one

        :type items: int

        """
        return _Interface.Interface_STAT_NextCycle(*args)

    NextCycle = staticmethod(NextCycle)

    def NextStep(*args):
        """
        NextStep()

        Commands to resume the preceeding step of the cycle
        Ignored if count of steps is already passed
        NextItem can be called for this step, NextStep passes to next


        """
        return _Interface.Interface_STAT_NextStep(*args)

    NextStep = staticmethod(NextStep)

    def NextItem(*args):
        """
        NextItem(Standard_Integer const nbitems=1)

        Commands to add an item in the current step of the current
        cycle of the current phase
        By default, one item per call, can be overpassed
        Ignored if count of items of this cycle is already passed

        :type nbitems: int

        """
        return _Interface.Interface_STAT_NextItem(*args)

    NextItem = staticmethod(NextItem)

    def End(*args):
        """
        End()

        Commands to declare the process ended (hence, advancement is
        forced to 100 %)


        """
        return _Interface.Interface_STAT_End(*args)

    End = staticmethod(End)

    def Where(*args):
        """
        Where(Standard_Boolean const phase) -> Standard_CString

        Returns an identification of the STAT :
        <phase> True (D) : the name of the current phase
        <phase> False : the title of the current STAT

        :type phase: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_STAT_Where(*args)

    Where = staticmethod(Where)

    def Percent(*args):
        """
        Percent(Standard_Boolean const phase) -> Standard_Integer

        Returns the advancement as a percentage :
        <phase> True : inside the current phase
        <phase> False (D) : relative to the whole process

        :type phase: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_STAT_Percent(*args)

    Percent = staticmethod(Percent)
    __swig_destroy__ = _Interface.delete_Interface_STAT
Interface_STAT_swigregister = _Interface.Interface_STAT_swigregister
Interface_STAT_swigregister(Interface_STAT)

def Interface_STAT_StartCount(*args):
    """
    Interface_STAT_StartCount(Standard_Integer const items, Standard_CString const title)

    Starts a default STAT, with no phase, no step, ready to just
    count items.
    <items> gives the total count of items
    Hence, NextItem is available to directly count

    :type items: int
    :type title: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_STAT_StartCount(*args)

def Interface_STAT_NextPhase(*args):
    """
    Interface_STAT_NextPhase(Standard_Integer const items, Standard_Integer const cycles=1)

    Commands to resume the preceeding phase and start a new one
    <items> and <cycles> as for Start, but for this new phase
    Ignored if count of phases is already passed
    If <cycles> is more than one, the first Cycle must then be
    started by NextCycle (NextStep/NextItem are ignored).
    If it is one, NextItem/NextStep can then be called

    :type items: int
    :type cycles: int

    """
    return _Interface.Interface_STAT_NextPhase(*args)

def Interface_STAT_SetPhase(*args):
    """
    Interface_STAT_SetPhase(Standard_Integer const items, Standard_Integer const cycles=1)

    Changes the parameters of the phase to start
    To be used before first counting (i.e. just after NextPhase)
    Can be used by an operator which has to reajust counts on run

    :type items: int
    :type cycles: int

    """
    return _Interface.Interface_STAT_SetPhase(*args)

def Interface_STAT_NextCycle(*args):
    """
    Interface_STAT_NextCycle(Standard_Integer const items)

    Commands to resume the preceeding cycle and start a new one,
    with a count of items
    Ignored if count of cycles is already passed
    Then, first step is started (or default one)
    NextItem can be called for the first step, or NextStep to pass
    to the next one

    :type items: int

    """
    return _Interface.Interface_STAT_NextCycle(*args)

def Interface_STAT_NextStep(*args):
    """
    Interface_STAT_NextStep()

    Commands to resume the preceeding step of the cycle
    Ignored if count of steps is already passed
    NextItem can be called for this step, NextStep passes to next


    """
    return _Interface.Interface_STAT_NextStep(*args)

def Interface_STAT_NextItem(*args):
    """
    Interface_STAT_NextItem(Standard_Integer const nbitems=1)

    Commands to add an item in the current step of the current
    cycle of the current phase
    By default, one item per call, can be overpassed
    Ignored if count of items of this cycle is already passed

    :type nbitems: int

    """
    return _Interface.Interface_STAT_NextItem(*args)

def Interface_STAT_End(*args):
    """
    Interface_STAT_End()

    Commands to declare the process ended (hence, advancement is
    forced to 100 %)


    """
    return _Interface.Interface_STAT_End(*args)

def Interface_STAT_Where(*args):
    """
    Interface_STAT_Where(Standard_Boolean const phase) -> Standard_CString

    Returns an identification of the STAT :
    <phase> True (D) : the name of the current phase
    <phase> False : the title of the current STAT

    :type phase: bool
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_STAT_Where(*args)

def Interface_STAT_Percent(*args):
    """
    Interface_STAT_Percent(Standard_Boolean const phase) -> Standard_Integer

    Returns the advancement as a percentage :
    <phase> True : inside the current phase
    <phase> False (D) : relative to the whole process

    :type phase: bool
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_STAT_Percent(*args)

class Interface_GlobalNodeOfReaderLib(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_GlobalNodeOfReaderLib
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_GlobalNodeOfReaderLib(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_GlobalNodeOfReaderLib self) -> Interface_GlobalNodeOfReaderLib

        Creates an empty GlobalNode, with no Next


        """
        this = _Interface.new_Interface_GlobalNodeOfReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(Interface_GlobalNodeOfReaderLib self, Handle_Interface_ReaderModule amodule, Handle_Interface_Protocol aprotocol)

        Adds a Module bound with a Protocol to the list : does
        nothing if already in the list, THAT IS, Same Type (exact
        match) and Same State (that is, IsEqual is not required)
        Once added, stores its attached Protocol in correspondance

        :type amodule: OCC.wrapper.Interface.Handle_Interface_ReaderModule
        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Add(self, *args)


    def Module(self, *args):
        """
        Returns the Module stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_ReaderModule

        """
        res = _Interface.Interface_GlobalNodeOfReaderLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the attached Protocol stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Interface_GlobalNodeOfReaderLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next GlobalNode. If none is defined, returned
        value is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfReaderLib

        """
        res = _Interface.Interface_GlobalNodeOfReaderLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_GlobalNodeOfReaderLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_GlobalNodeOfReaderLib
Interface_GlobalNodeOfReaderLib_swigregister = _Interface.Interface_GlobalNodeOfReaderLib_swigregister
Interface_GlobalNodeOfReaderLib_swigregister(Interface_GlobalNodeOfReaderLib)

def Interface_GlobalNodeOfReaderLib_get_type_name(*args):
    """
    Interface_GlobalNodeOfReaderLib_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_GlobalNodeOfReaderLib_get_type_name(*args)

def Interface_GlobalNodeOfReaderLib_get_type_descriptor(*args):
    """
    Interface_GlobalNodeOfReaderLib_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_GlobalNodeOfReaderLib_get_type_descriptor(*args)

class Interface_ReaderLib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetGlobal(*args):
        """
        SetGlobal(Handle_Interface_ReaderModule amodule, Handle_Interface_Protocol aprotocol)

        Adds a couple (Module-Protocol) into the global definition set
        for this class of Library.

        :type amodule: OCC.wrapper.Interface.Handle_Interface_ReaderModule
        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_ReaderLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def __init__(self, *args):
        """
        __init__(Interface_ReaderLib self, Handle_Interface_Protocol aprotocol) -> Interface_ReaderLib
        __init__(Interface_ReaderLib self) -> Interface_ReaderLib

        Creates an empty Library : it will later by filled by method
        AddProtocol


        """
        this = _Interface.new_Interface_ReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddProtocol(self, *args):
        """
        AddProtocol(Interface_ReaderLib self, Handle_Standard_Transient aprotocol)

        Adds a couple (Module-Protocol) to the Library, given the
        class of a Protocol. Takes Resources into account.
        (if <aprotocol> is not of type TheProtocol, it is not added)

        :type aprotocol: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ReaderLib_AddProtocol(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_ReaderLib self)

        Clears the list of Modules of a library (can be used to
        redefine the order of Modules before action : Clear then
        refill the Library by calls to AddProtocol)


        """
        return _Interface.Interface_ReaderLib_Clear(self, *args)


    def SetComplete(self, *args):
        """
        SetComplete(Interface_ReaderLib self)

        Sets a library to be defined with the complete Global list
        (all the couples Protocol/Modules recorded in it)


        """
        return _Interface.Interface_ReaderLib_SetComplete(self, *args)


    def Select(self, *args):
        """
        Select(Interface_ReaderLib self, Handle_Standard_Transient obj, Handle_Interface_ReaderModule module) -> Standard_Boolean

        Selects a Module from the Library, given an Object.
        Returns True if Select has succeeded, False else.
        Also Returns (as arguments) the selected Module and the Case
        Number determined by the associated Protocol.
        If Select has failed, <module> is Null Handle and CN is zero.
        (Select can work on any criterium, such as Object DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type module: OCC.wrapper.Interface.Handle_Interface_ReaderModule
        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReaderLib_Select(self, *args)


    def Start(self, *args):
        """
        Start(Interface_ReaderLib self)

        Starts Iteration on the Modules (sets it on the first one)


        """
        return _Interface.Interface_ReaderLib_Start(self, *args)


    def More(self, *args):
        """
        More(Interface_ReaderLib self) -> Standard_Boolean

        Returns True if there are more Modules to iterate on

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ReaderLib_More(self, *args)


    def Next(self, *args):
        """
        Next(Interface_ReaderLib self)

        Iterates by getting the next Module in the list
        If there is none, the exception will be raised by Value


        """
        return _Interface.Interface_ReaderLib_Next(self, *args)


    def Module(self, *args):
        """
        Returns the current Module in the Iteration

        :rtype: OCC.wrapper.Interface.Handle_Interface_ReaderModule

        """
        res = _Interface.Interface_ReaderLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the current Protocol in the Iteration

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Interface_ReaderLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_ReaderLib
Interface_ReaderLib_swigregister = _Interface.Interface_ReaderLib_swigregister
Interface_ReaderLib_swigregister(Interface_ReaderLib)

def Interface_ReaderLib_SetGlobal(*args):
    """
    Interface_ReaderLib_SetGlobal(Handle_Interface_ReaderModule amodule, Handle_Interface_Protocol aprotocol)

    Adds a couple (Module-Protocol) into the global definition set
    for this class of Library.

    :type amodule: OCC.wrapper.Interface.Handle_Interface_ReaderModule
    :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

    """
    return _Interface.Interface_ReaderLib_SetGlobal(*args)

class Interface_HArray1OfHAsciiString(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_HArray1OfHAsciiString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_HArray1OfHAsciiString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_HArray1OfHAsciiString self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Interface_HArray1OfHAsciiString
        __init__(Interface_HArray1OfHAsciiString self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_TCollection_HAsciiString theValue) -> Interface_HArray1OfHAsciiString
        __init__(Interface_HArray1OfHAsciiString self, NCollection_Array1_Handle_TCollection_HAsciiString theOther) -> Interface_HArray1OfHAsciiString

        :type theOther: OCC.wrapper.Interface.Interface_Array1OfHAsciiString

        """
        this = _Interface.new_Interface_HArray1OfHAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Interface.Interface_Array1OfHAsciiString

        """
        res = _Interface.Interface_HArray1OfHAsciiString_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Interface_HArray1OfHAsciiString self) -> NCollection_Array1_Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.Interface.Interface_Array1OfHAsciiString

        """
        return _Interface.Interface_HArray1OfHAsciiString_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_HArray1OfHAsciiString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_HArray1OfHAsciiString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_HArray1OfHAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_HArray1OfHAsciiString
Interface_HArray1OfHAsciiString_swigregister = _Interface.Interface_HArray1OfHAsciiString_swigregister
Interface_HArray1OfHAsciiString_swigregister(Interface_HArray1OfHAsciiString)

def Interface_HArray1OfHAsciiString_get_type_name(*args):
    """
    Interface_HArray1OfHAsciiString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_HArray1OfHAsciiString_get_type_name(*args)

def Interface_HArray1OfHAsciiString_get_type_descriptor(*args):
    """
    Interface_HArray1OfHAsciiString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_HArray1OfHAsciiString_get_type_descriptor(*args)

class Interface_FloatWriter(object):
    """
    This class converts a floting number (Real) to a string
    It can be used if the standard C-C++ output functions
    (sprintf or cout<<) are not convenient. That is to say :
    - to suppress trailing '0' and 'E+00' (if desired)
    - to control exponant output and floating point output

    Formats are given in the form used by printf-sprintf
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_FloatWriter self, Standard_Integer const chars=0) -> Interface_FloatWriter

        Creates a FloatWriter ready to work, with default options  -
        - zero suppress option is set
        - main format is set to "%E"
        - secondary format is set to "%f" for values between 0.1 and
        1000. in absolute values
        If <chars> is given (and positive), it will produce options
        to produce this count of characters : "%<chars>f","%<chars>%E"

        :type chars: int

        """
        this = _Interface.new_Interface_FloatWriter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFormat(self, *args):
        """
        SetFormat(Interface_FloatWriter self, Standard_CString const form, Standard_Boolean const reset)

        Sets a specific Format for Sending Reals (main format)
        (Default from Creation is "%E")
        If <reset> is given True (default), this call clears effects
        of former calls to SetFormatForRange and SetZeroSuppress

        :type form: OCC.wrapper.Standard.Standard_CString
        :type reset: bool

        """
        return _Interface.Interface_FloatWriter_SetFormat(self, *args)


    def SetFormatForRange(self, *args):
        """
        SetFormatForRange(Interface_FloatWriter self, Standard_CString const form, Standard_Real const R1, Standard_Real const R2)

        Sets a secondary Format for Real, to be applied between R1 and
        R2 (in absolute values). A Call to SetRealForm cancels this
        secondary form if <reset> is True.
        (Default from Creation is "%f" between 0.1 and 1000.)
        Warning : if the condition (0. <= R1 < R2) is not fulfilled, this
        secondary form is canceled.

        :type form: OCC.wrapper.Standard.Standard_CString
        :type R1: float
        :type R2: float

        """
        return _Interface.Interface_FloatWriter_SetFormatForRange(self, *args)


    def SetZeroSuppress(self, *args):
        """
        SetZeroSuppress(Interface_FloatWriter self, Standard_Boolean const mode)

        Sets Sending Real Parameters to suppress trailing Zeros and
        Null Exponant ("E+00"), if <mode> is given True, Resets this
        mode if <mode> is False (in addition to Real Forms)
        A call to SetRealFrom resets this mode to False ig <reset> is
        given True (Default from Creation is True)

        :type mode: bool

        """
        return _Interface.Interface_FloatWriter_SetZeroSuppress(self, *args)


    def SetDefaults(self, *args):
        """
        SetDefaults(Interface_FloatWriter self, Standard_Integer const chars=0)

        Sets again options to the defaults given by Create

        :type chars: int

        """
        return _Interface.Interface_FloatWriter_SetDefaults(self, *args)


    def Options(self, *args):
        """
        Options(Interface_FloatWriter self)

        Returns active options : <zerosup> is the option ZeroSuppress,
        <range> is True if a range is set, False else
        R1,R2 give the range (if it is set)

        :type zerosup: bool
        :type range: bool
        :type R1: float
        :type R2: float

        """
        return _Interface.Interface_FloatWriter_Options(self, *args)


    def MainFormat(self, *args):
        """
        MainFormat(Interface_FloatWriter self) -> Standard_CString

        Returns the main format
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_FloatWriter_MainFormat(self, *args)


    def FormatForRange(self, *args):
        """
        FormatForRange(Interface_FloatWriter self) -> Standard_CString

        Returns the format for range, if set
        Meaningful only if <range> from Options is True
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_FloatWriter_FormatForRange(self, *args)


    def Write(self, *args):
        """
        Write(Interface_FloatWriter self, Standard_Real const val, Standard_CString const text) -> Standard_Integer

        Writes a Real value <val> to a string <text> by using the
        options. Returns the useful Length of produced string.
        It calls the class method Convert.
        Warning : <text> is assumed to be wide enough (20-30 is correct)
        And, even if declared in, its content will be modified

        :type val: float
        :type text: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FloatWriter_Write(self, *args)


    def Convert(*args):
        """
        Convert(Standard_Real const val, Standard_CString const text, Standard_Boolean const zerosup, Standard_Real const Range1, Standard_Real const Range2, Standard_CString const mainform, Standard_CString const rangeform) -> Standard_Integer

        This class method converts a Real Value to a string, given
        options given as arguments. It can be called independantly.
        Warning : even if declared in, content of <text> will be modified

        :type val: float
        :type text: OCC.wrapper.Standard.Standard_CString
        :type zerosup: bool
        :type Range1: float
        :type Range2: float
        :type mainform: OCC.wrapper.Standard.Standard_CString
        :type rangeform: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FloatWriter_Convert(*args)

    Convert = staticmethod(Convert)
    __swig_destroy__ = _Interface.delete_Interface_FloatWriter
Interface_FloatWriter_swigregister = _Interface.Interface_FloatWriter_swigregister
Interface_FloatWriter_swigregister(Interface_FloatWriter)

def Interface_FloatWriter_Convert(*args):
    """
    Interface_FloatWriter_Convert(Standard_Real const val, Standard_CString const text, Standard_Boolean const zerosup, Standard_Real const Range1, Standard_Real const Range2, Standard_CString const mainform, Standard_CString const rangeform) -> Standard_Integer

    This class method converts a Real Value to a string, given
    options given as arguments. It can be called independantly.
    Warning : even if declared in, content of <text> will be modified

    :type val: float
    :type text: OCC.wrapper.Standard.Standard_CString
    :type zerosup: bool
    :type Range1: float
    :type Range2: float
    :type mainform: OCC.wrapper.Standard.Standard_CString
    :type rangeform: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_FloatWriter_Convert(*args)

class Interface_ShareFlags(object):
    """
    This class only says for each Entity of a Model, if it is
    Shared or not by one or more other(s) of this Model
    It uses the General Service "Shared".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_ShareFlags self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib) -> Interface_ShareFlags
        __init__(Interface_ShareFlags self, Handle_Interface_InterfaceModel amodel, Handle_Interface_GTool gtool) -> Interface_ShareFlags
        __init__(Interface_ShareFlags self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol) -> Interface_ShareFlags
        __init__(Interface_ShareFlags self, Handle_Interface_InterfaceModel amodel) -> Interface_ShareFlags
        __init__(Interface_ShareFlags self, Interface_Graph agraph) -> Interface_ShareFlags

        Creates a ShareFlags by querying informations from a Graph
        (remark that Graph also has a method IsShared)

        :type agraph: OCC.wrapper.Interface.Interface_Graph

        """
        this = _Interface.new_Interface_ShareFlags(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args):
        """
        Model(Interface_ShareFlags self) -> Handle_Interface_InterfaceModel

        Returns the Model used for the evaluation

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_ShareFlags_Model(self, *args)


    def IsShared(self, *args):
        """
        IsShared(Interface_ShareFlags self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is Shared by one or more other
        Entity(ies) of the Model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_ShareFlags_IsShared(self, *args)


    def RootEntities(self, *args):
        """
        RootEntities(Interface_ShareFlags self) -> Interface_EntityIterator

        Returns the Entities which are not Shared (see their flags)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_ShareFlags_RootEntities(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Interface_ShareFlags self) -> Standard_Integer

        Returns the count of root entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ShareFlags_NbRoots(self, *args)


    def Root(self, *args):
        """
        Root(Interface_ShareFlags self, Standard_Integer const num=1) -> Handle_Standard_Transient

        Returns a root entity according its rank in the list of roots
        By default, it returns the first one

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_ShareFlags_Root(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_ShareFlags
Interface_ShareFlags_swigregister = _Interface.Interface_ShareFlags_swigregister
Interface_ShareFlags_swigregister(Interface_ShareFlags)

class Handle_Interface_CopyControl(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_CopyControl self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_CopyControl_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_CopyControl self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_CopyControl_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_CopyControl self, Interface_CopyControl thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_CopyControl_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_CopyControl self, Handle_Interface_CopyControl theHandle) -> Handle_Interface_CopyControl
        assign(Handle_Interface_CopyControl self, Interface_CopyControl thePtr) -> Handle_Interface_CopyControl
        assign(Handle_Interface_CopyControl self, Handle_Interface_CopyControl theHandle) -> Handle_Interface_CopyControl

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_CopyControl_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_CopyControl self) -> Interface_CopyControl

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_CopyControl_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_CopyControl self) -> Interface_CopyControl

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_CopyControl___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_CopyControl self) -> Interface_CopyControl

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_CopyControl___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_CopyControl___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_CopyControl___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_CopyControl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_CopyControl_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_CopyControl

    def Clear(self, *args):
        """
        Clear(Handle_Interface_CopyControl self)

        Clears List of Copy Results. Gets Ready to begin another Copy
        Process.


        """
        return _Interface.Handle_Interface_CopyControl_Clear(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Interface_CopyControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Bind a Result to a Starting Entity identified by its Number

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_CopyControl_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Handle_Interface_CopyControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Searches for the Result bound to a Startingf Entity identified
        by its Number.
        If Found, returns True and fills <res>
        Else, returns False and nullifies <res>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CopyControl_Search(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_CopyControl self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_CopyControl_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_CopyControl_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_CopyControl_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_CopyControl self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_CopyControl_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_CopyControl self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_CopyControl self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CopyControl_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_CopyControl self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_CopyControl self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CopyControl_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_CopyControl self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_CopyControl_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_CopyControl self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_CopyControl_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_CopyControl self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_CopyControl_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_CopyControl self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_CopyControl_DecrementRefCounter(self, *args)

Handle_Interface_CopyControl_swigregister = _Interface.Handle_Interface_CopyControl_swigregister
Handle_Interface_CopyControl_swigregister(Handle_Interface_CopyControl)

def Handle_Interface_CopyControl_DownCast(thing):
    return _Interface.Handle_Interface_CopyControl_DownCast(thing)
Handle_Interface_CopyControl_DownCast = _Interface.Handle_Interface_CopyControl_DownCast

class Interface_IntList(object):
    """
    This class detains the data which describe a Graph. A Graph
    has two lists, one for shared refs, one for sharing refs
    (the reverses). Each list comprises, for each Entity of the
    Model of the Graph, a list of Entities (shared or sharing).
    In fact, entities are identified by their numbers in the Model
    or Graph : this gives better performances.

    A simple way to implement this is to instantiate a HArray1
    with a HSequenceOfInteger : each Entity Number designates a
    value, which is a Sequence (if it is null, it is considered as
    empty : this is a little optimisation).

    This class gives a more efficient way to implement this.
    It has two lists (two arrays of integers), one to describe
    list (empty, one value given immediately, or negated index in
    the second list), one to store refs (pointed from the first
    list). This is much more efficient than a list of sequences,
    in terms of speed (especially for read) and of memory

    An IntList can also be set to access data for a given entity
    number, it then acts as a single sequence

    Remark that if an IntList is created from another one, it can
    be read, but if it is created without copying, it may not be
    edited
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_IntList self) -> Interface_IntList
        __init__(Interface_IntList self, Standard_Integer const nbe) -> Interface_IntList
        __init__(Interface_IntList self, Interface_IntList other, Standard_Boolean const copied) -> Interface_IntList

        Creates an IntList from another one.
        if <copied> is True, copies data
        else, data are not copied, only the header object is

        :type other: OCC.wrapper.Interface.Interface_IntList
        :type copied: bool

        """
        this = _Interface.new_Interface_IntList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Interface_IntList self, Standard_Integer const nbe)

        Initialize IntList by number of entities.

        :type nbe: int

        """
        return _Interface.Interface_IntList_Initialize(self, *args)


    def Internals(self, *args):
        """
        Internals(Interface_IntList self, Handle_TColStd_HArray1OfInteger ents, Handle_TColStd_HArray1OfInteger refs)

        Returns internal values, used for copying

        :type nbrefs: int
        :type ents: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
        :type refs: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _Interface.Interface_IntList_Internals(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Interface_IntList self) -> Standard_Integer

        Returns count of entities to be aknowledged

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_IntList_NbEntities(self, *args)


    def SetNbEntities(self, *args):
        """
        SetNbEntities(Interface_IntList self, Standard_Integer const nbe)

        Changes the count of entities (ignored if decreased)

        :type nbe: int

        """
        return _Interface.Interface_IntList_SetNbEntities(self, *args)


    def SetNumber(self, *args):
        """
        SetNumber(Interface_IntList self, Standard_Integer const number)

        Sets an entity number as current (for read and fill)

        :type number: int

        """
        return _Interface.Interface_IntList_SetNumber(self, *args)


    def Number(self, *args):
        """
        Number(Interface_IntList self) -> Standard_Integer

        Returns the current entity number

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_IntList_Number(self, *args)


    def List(self, *args):
        """
        List(Interface_IntList self, Standard_Integer const number, Standard_Boolean const copied) -> Interface_IntList

        Returns an IntList, identical to <me> but set to a specified
        entity Number
        By default, not copied (in order to be read)
        Specified <copied> to produce another list and edit it

        :type number: int
        :type copied: bool
        :rtype: OCC.wrapper.Interface.Interface_IntList

        """
        return _Interface.Interface_IntList_List(self, *args)


    def SetRedefined(self, *args):
        """
        SetRedefined(Interface_IntList self, Standard_Boolean const mode)

        Sets current entity list to be redefined or not
        This is used in a Graph for redefinition list : it can be
        disable (no redefinition, i.e. list is cleared), or enabled
        (starts as empty). The original list has not to be "redefined"

        :type mode: bool

        """
        return _Interface.Interface_IntList_SetRedefined(self, *args)


    def Reservate(self, *args):
        """
        Reservate(Interface_IntList self, Standard_Integer const count)

        Makes a reservation for <count> references to be later
        attached to the current entity. If required, it increases
        the size of array used to store refs. Remark that if count is
        less than two, it does nothing (because immediate storing)

        :type count: int

        """
        return _Interface.Interface_IntList_Reservate(self, *args)


    def Add(self, *args):
        """
        Add(Interface_IntList self, Standard_Integer const ref)

        Adds a reference (as an integer value, an entity number) to
        the current entity number. Zero is ignored

        :type ref: int

        """
        return _Interface.Interface_IntList_Add(self, *args)


    def Length(self, *args):
        """
        Length(Interface_IntList self) -> Standard_Integer

        Returns the count of refs attached to current entity number

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_IntList_Length(self, *args)


    def IsRedefined(self, *args):
        """
        IsRedefined(Interface_IntList self, Standard_Integer const num=0) -> Standard_Boolean

        Returns True if the list for a number (default is taken as
        current) is "redefined"  (usefull for empty list)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_IntList_IsRedefined(self, *args)


    def Value(self, *args):
        """
        Value(Interface_IntList self, Standard_Integer const num) -> Standard_Integer

        Returns a reference number in the list for current number,
        according to its rank

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_IntList_Value(self, *args)


    def Remove(self, *args):
        """
        Remove(Interface_IntList self, Standard_Integer const num) -> Standard_Boolean

        Removes an item in the list for current number, given its rank
        Returns True if done, False else

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_IntList_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_IntList self)

        Clears all data, hence each entity number has an empty list


        """
        return _Interface.Interface_IntList_Clear(self, *args)


    def AdjustSize(self, *args):
        """
        AdjustSize(Interface_IntList self, Standard_Integer const margin=0)

        Resizes lists to exact sizes. For list of refs, a positive
        margin can be added.

        :type margin: int

        """
        return _Interface.Interface_IntList_AdjustSize(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_IntList
Interface_IntList_swigregister = _Interface.Interface_IntList_swigregister
Interface_IntList_swigregister(Interface_IntList)

class Handle_Interface_IntVal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_IntVal self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_IntVal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_IntVal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_IntVal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_IntVal self, Interface_IntVal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_IntVal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_IntVal self, Handle_Interface_IntVal theHandle) -> Handle_Interface_IntVal
        assign(Handle_Interface_IntVal self, Interface_IntVal thePtr) -> Handle_Interface_IntVal
        assign(Handle_Interface_IntVal self, Handle_Interface_IntVal theHandle) -> Handle_Interface_IntVal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_IntVal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_IntVal self) -> Interface_IntVal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_IntVal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_IntVal self) -> Interface_IntVal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_IntVal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_IntVal self) -> Interface_IntVal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_IntVal___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_IntVal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_IntVal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_IntVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_IntVal_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_IntVal

    def Value(self, *args):
        """
        Value(Handle_Interface_IntVal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_IntVal_Value(self, *args)


    def CValue(self, *args):
        """
        CValue(Handle_Interface_IntVal self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_IntVal_CValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_IntVal self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_IntVal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_IntVal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_IntVal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_IntVal self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_IntVal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_IntVal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_IntVal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_IntVal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_IntVal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_IntVal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_IntVal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_IntVal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_IntVal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_IntVal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_IntVal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_IntVal self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_IntVal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_IntVal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_IntVal_DecrementRefCounter(self, *args)

Handle_Interface_IntVal_swigregister = _Interface.Handle_Interface_IntVal_swigregister
Handle_Interface_IntVal_swigregister(Handle_Interface_IntVal)

def Handle_Interface_IntVal_DownCast(thing):
    return _Interface.Handle_Interface_IntVal_DownCast(thing)
Handle_Interface_IntVal_DownCast = _Interface.Handle_Interface_IntVal_DownCast

class NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self) -> NCollection_IndexedMap< TCollection_AsciiString,Interface_MapAsciiStringHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self) -> NCollection_IndexedMap< TCollection_AsciiString,Interface_MapAsciiStringHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Interface.new_NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher theOther) -> NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher theOther) -> NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, TCollection_AsciiString theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, TCollection_AsciiString theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, Standard_Integer const theIndex, TCollection_AsciiString theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self)

        RemoveLast


        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, TCollection_AsciiString theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, TCollection_AsciiString theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_Size(self, *args)


    def __iter__(self):
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher___iter__(self)
    __swig_destroy__ = _Interface.delete_NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher
NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_swigregister = _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_swigregister
NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_swigregister(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher)

class NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Interface.new_NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper

    def __next__(self):
        return _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper_swigregister = _Interface.NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper_swigregister
NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper_swigregister(NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher_IteratorHelper)


try:
	Interface_IndexedMapOfAsciiString = NCollection_IndexedMap_TCollection_AsciiString_Interface_MapAsciiStringHasher
except NameError:
	pass # does not exist, probably ignored

class Interface_NodeOfGeneralLib(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_NodeOfGeneralLib
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_NodeOfGeneralLib(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_NodeOfGeneralLib self) -> Interface_NodeOfGeneralLib

        Creates an empty Node, with no Next


        """
        this = _Interface.new_Interface_NodeOfGeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddNode(self, *args):
        """
        AddNode(Interface_NodeOfGeneralLib self, Handle_Interface_GlobalNodeOfGeneralLib anode)

        Adds a couple (Module,Protocol), that is, stores it into
        itself if not yet done, else creates a Next Node to do it

        :type anode: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfGeneralLib

        """
        return _Interface.Interface_NodeOfGeneralLib_AddNode(self, *args)


    def Module(self, *args):
        """
        Returns the Module designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_GeneralModule

        """
        res = _Interface.Interface_NodeOfGeneralLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the Protocol designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Interface_NodeOfGeneralLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next Node. If none was defined, returned value
        is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_NodeOfGeneralLib

        """
        res = _Interface.Interface_NodeOfGeneralLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_NodeOfGeneralLib_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_NodeOfGeneralLib_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_NodeOfGeneralLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_NodeOfGeneralLib
Interface_NodeOfGeneralLib_swigregister = _Interface.Interface_NodeOfGeneralLib_swigregister
Interface_NodeOfGeneralLib_swigregister(Interface_NodeOfGeneralLib)

def Interface_NodeOfGeneralLib_get_type_name(*args):
    """
    Interface_NodeOfGeneralLib_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_NodeOfGeneralLib_get_type_name(*args)

def Interface_NodeOfGeneralLib_get_type_descriptor(*args):
    """
    Interface_NodeOfGeneralLib_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_NodeOfGeneralLib_get_type_descriptor(*args)

class Handle_Interface_Protocol(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_Protocol self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_Protocol_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_Protocol self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_Protocol_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_Protocol self, Interface_Protocol thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_Protocol_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_Protocol self, Handle_Interface_Protocol theHandle) -> Handle_Interface_Protocol
        assign(Handle_Interface_Protocol self, Interface_Protocol thePtr) -> Handle_Interface_Protocol
        assign(Handle_Interface_Protocol self, Handle_Interface_Protocol theHandle) -> Handle_Interface_Protocol

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_Protocol_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_Protocol self) -> Interface_Protocol

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_Protocol_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_Protocol self) -> Interface_Protocol

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_Protocol___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_Protocol self) -> Interface_Protocol

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_Protocol___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_Protocol___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_Protocol___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_Protocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_Protocol_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_Protocol

    def Active(self, *args):
        """
        Active(Handle_Interface_Protocol self) -> Handle_Interface_Protocol

        Returns the Active Protocol, if defined (else, returns a
        Null Handle, which means "no defined active protocol")

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_Protocol_Active(self, *args)


    def SetActive(self, *args):
        """
        SetActive(Handle_Interface_Protocol self, Handle_Interface_Protocol aprotocol)

        Sets a given Protocol to be the Active one (for the users of
        Active, see just above). Applies to every sub-type of Protocol

        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_Protocol_SetActive(self, *args)


    def ClearActive(self, *args):
        """
        ClearActive(Handle_Interface_Protocol self)

        Erases the Active Protocol (hence it becomes undefined)


        """
        return _Interface.Handle_Interface_Protocol_ClearActive(self, *args)


    def NbResources(self, *args):
        """
        NbResources(Handle_Interface_Protocol self) -> Standard_Integer

        Returns count of Protocol used as Resources (level one)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Protocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(Handle_Interface_Protocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given its rank (between 1 and NbResources)

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_Protocol_Resource(self, *args)


    def CaseNumber(self, *args):
        """
        CaseNumber(Handle_Interface_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns a unique positive CaseNumber for each Recognized
        Object. By default, recognition is based on Type(1)
        By default, calls the following one which is deferred.

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Protocol_CaseNumber(self, *args)


    def IsDynamicType(self, *args):
        """
        IsDynamicType(Handle_Interface_Protocol self, Handle_Standard_Transient obj) -> Standard_Boolean

        Returns True if type of <obj> is that defined from CDL
        This is the default but it may change according implementation

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Protocol_IsDynamicType(self, *args)


    def NbTypes(self, *args):
        """
        NbTypes(Handle_Interface_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Each one is candidate to be recognized by
        TypeNumber, <obj> is then processed according it
        By default, returns 1 (the DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Protocol_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Handle_Interface_Protocol self, Handle_Standard_Transient obj, Standard_Integer const nt=1) -> Handle_Standard_Type

        Returns a type under which <obj> can be recognized and
        processed, according its rank in its definition list (see
        NbTypes).
        By default, returns DynamicType

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type nt: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Handle_Interface_Protocol_Type(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(Handle_Interface_Protocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a unique positive CaseNumber for each Recognized Type,
        Returns Zero for "<type> not recognized"

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Protocol_TypeNumber(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(Handle_Interface_Protocol self, Interface_Graph G, Handle_Interface_Check ach) -> Standard_Boolean

        Evaluates a Global Check for a model (with its Graph)
        Returns True when done, False if data in model do not apply

        Very specific of each norm, i.e. of each protocol : the
        uppest level Protocol assumes it, it can call GlobalCheck of
        its ressources only if it is necessary

        Default does nothing, can be redefined

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Protocol_GlobalCheck(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Handle_Interface_Protocol self) -> Handle_Interface_InterfaceModel

        Creates an empty Model of the considered Norm

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Handle_Interface_Protocol_NewModel(self, *args)


    def IsSuitableModel(self, *args):
        """
        IsSuitableModel(Handle_Interface_Protocol self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True if <model> is a Model of the considered Norm

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Protocol_IsSuitableModel(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(Handle_Interface_Protocol self) -> Handle_Standard_Transient

        Creates a new Unknown Entity for the considered Norm

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_Protocol_UnknownEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Handle_Interface_Protocol self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is an Unknown Entity for the Norm, i.e.
        same Type as them created by method UnknownEntity
        (for an Entity out of the Norm, answer can be unpredicable)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Protocol_IsUnknownEntity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_Protocol self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_Protocol_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_Protocol_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_Protocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_Protocol self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_Protocol_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_Protocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_Protocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Protocol_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_Protocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_Protocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Protocol_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_Protocol self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_Protocol_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_Protocol self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Protocol_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_Protocol self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_Protocol_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_Protocol self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Protocol_DecrementRefCounter(self, *args)

Handle_Interface_Protocol_swigregister = _Interface.Handle_Interface_Protocol_swigregister
Handle_Interface_Protocol_swigregister(Handle_Interface_Protocol)

def Handle_Interface_Protocol_DownCast(thing):
    return _Interface.Handle_Interface_Protocol_DownCast(thing)
Handle_Interface_Protocol_DownCast = _Interface.Handle_Interface_Protocol_DownCast

class Interface_Static(Interface_TypedValue):
    """
    This class gives a way to manage meaningfull static variables,
    used as "global" parameters in various procedures.

    A Static brings a specification (its type, constraints if any)
    and a value. Its basic form is a string, it can be specified
    as integer or real or enumerative string, and queried as such.
    Its string content, which is a Handle(HAsciiString) can be
    shared by other data structures, hence gives a direct on line
    access to its value.

    All this description is inherited from TypedValue

    A Static can be given an initial value, it can be filled from,
    either a set of Resources (an applicative feature which
    accesses and manages parameter files), or environment or
    internal definition : these define families of Static.
    In addition, it supports a status for reinitialisation : an
    initialisation procedure can ask if the value of the Static
    has changed from its last call, in this case does something
    then marks the Status "uptodate", else it does nothing.

    Statics are named and recorded then accessed in an alphabetic
    dictionary
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_Static
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_Static(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_Static self, Standard_CString const family, Standard_CString const name, Interface_ParamType const type=Interface_ParamText, Standard_CString const init) -> Interface_Static
        __init__(Interface_Static self, Standard_CString const family, Standard_CString const name, Handle_Interface_Static other) -> Interface_Static

        Creates a new Static with same definition as another one
        (value is copied, except for Entity : it remains null)

        :type family: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString
        :type other: OCC.wrapper.Interface.Handle_Interface_Static

        """
        this = _Interface.new_Interface_Static(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def PrintStatic(self, *args):
        """
        PrintStatic(Interface_Static self, Handle_Message_Messenger S)

        Writes the properties of a
        parameter in the diagnostic file. These include:
        - Name
        - Family,
        - Wildcard (if it has one)
        - Current status (empty  string if it was updated or
        if it is the original one)
        - Value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_Static_PrintStatic(self, *args)


    def Family(self, *args):
        """
        Family(Interface_Static self) -> Standard_CString

        Returns the family. It can be : a resource name for applis,
        an internal name between : $e (environment variables),
        $l (other, purely local)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Static_Family(self, *args)


    def SetWild(self, *args):
        """
        SetWild(Interface_Static self, Handle_Interface_Static wildcard)

        Sets a "wild-card" static : its value will be considered
        if <me> is not properly set. (reset by set a null one)

        :type wildcard: OCC.wrapper.Interface.Handle_Interface_Static

        """
        return _Interface.Interface_Static_SetWild(self, *args)


    def Wild(self, *args):
        """
        Wild(Interface_Static self) -> Handle_Interface_Static

        Returns the wildcard static, which can be (is most often) null

        :rtype: OCC.wrapper.Interface.Handle_Interface_Static

        """
        return _Interface.Interface_Static_Wild(self, *args)


    def SetUptodate(self, *args):
        """
        SetUptodate(Interface_Static self)

        Records a Static has "uptodate", i.e. its value has been taken
        into account by a reinitialisation procedure
        This flag is reset at each successful SetValue


        """
        return _Interface.Interface_Static_SetUptodate(self, *args)


    def UpdatedStatus(self, *args):
        """
        UpdatedStatus(Interface_Static self) -> Standard_Boolean

        Returns the status "uptodate"

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_UpdatedStatus(self, *args)


    def Init(*args):
        """
        Init(Standard_CString const family, Standard_CString const name, Interface_ParamType const type, Standard_CString const init) -> Standard_Boolean
        Init(Standard_CString const family, Standard_CString const name, Standard_Character const type, Standard_CString const init) -> Standard_Boolean

        As Init with ParamType, but type is given as a character
        This allows a simpler call
        Types : 'i' Integer, 'r' Real, 't' Text, 'e' Enum, 'o' Object
        '=' for same definition as, <init> gives the initial Static
        Returns False if <type> does not match this list

        :type family: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Standard_Character
        :type init: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_Init(*args)

    Init = staticmethod(Init)

    def Static(*args):
        """
        Static(Standard_CString const name) -> Handle_Interface_Static

        Returns a Static from its name. Null Handle if not present

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_Static

        """
        return _Interface.Interface_Static_Static(*args)

    Static = staticmethod(Static)

    def IsPresent(*args):
        """
        IsPresent(Standard_CString const name) -> Standard_Boolean

        Returns True if a Static named <name> is present, False else

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_IsPresent(*args)

    IsPresent = staticmethod(IsPresent)

    def CDef(*args):
        """
        CDef(Standard_CString const name, Standard_CString const part) -> Standard_CString

        Returns a part of the definition of a Static, as a CString
        The part is designated by its name, as a CString
        If the required value is not a string, it is converted to a
        CString then returned
        If <name> is not present, or <part> not defined for <name>,
        this function returns an empty string

        Allowed parts for CDef :
        family : the family
        type  : the type ("integer","real","text","enum")
        label : the label
        satis : satisfy function name if any
        rmin : minimum real value
        rmax : maximum real value
        imin : minimum integer value
        imax : maximum integer value
        enum nn (nn : value of an integer) : enum value for nn
        unit : unit definition for a real

        :type name: OCC.wrapper.Standard.Standard_CString
        :type part: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Static_CDef(*args)

    CDef = staticmethod(CDef)

    def IDef(*args):
        """
        IDef(Standard_CString const name, Standard_CString const part) -> Standard_Integer

        Returns a part of the definition of a Static, as an Integer
        The part is designated by its name, as a CString
        If the required value is not a string, returns zero
        For a Boolean, 0 for false, 1 for true
        If <name> is not present, or <part> not defined for <name>,
        this function returns zero

        Allowed parts for IDef :
        imin, imax : minimum or maximum integer value
        estart : starting number for enum
        ecount : count of enum values (starting from estart)
        ematch : exact match status
        eval val : case determined from a string

        :type name: OCC.wrapper.Standard.Standard_CString
        :type part: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Static_IDef(*args)

    IDef = staticmethod(IDef)

    def IsSet(*args):
        """
        IsSet(Standard_CString const name, Standard_Boolean const proper) -> Standard_Boolean

        Returns True if <name> is present AND set
        <proper> True (D) : considers this item only
        <proper> False    : if not set and attached to a wild-card,
        considers this wild-card

        :type name: OCC.wrapper.Standard.Standard_CString
        :type proper: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_IsSet(*args)

    IsSet = staticmethod(IsSet)

    def CVal(*args):
        """
        CVal(Standard_CString const name) -> Standard_CString

        Returns the value of the
        parameter identified by the string name.
        If the specified parameter does not exist, an empty
        string is returned.
        Example
        Interface_Static::CVal("write.step.schema");
        which could return:
        "AP214"

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_Static_CVal(*args)

    CVal = staticmethod(CVal)

    def IVal(*args):
        """
        IVal(Standard_CString const name) -> Standard_Integer

        Returns the integer value of
        the translation parameter identified by the string name.
        Returns the value 0 if the parameter does not exist.
        Example
        Interface_Static::IVal("write.step.schema");
        which could return: 3

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_Static_IVal(*args)

    IVal = staticmethod(IVal)

    def RVal(*args):
        """
        RVal(Standard_CString const name) -> Standard_Real

        Returns the value of a static
        translation parameter identified by the string name.
        Returns the value 0.0 if the parameter does not exist.

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Interface_Static_RVal(*args)

    RVal = staticmethod(RVal)

    def SetCVal(*args):
        """
        SetCVal(Standard_CString const name, Standard_CString const val) -> Standard_Boolean

        Modifies the value of the
        parameter identified by name. The modification is specified
        by the string val. false is returned if the parameter does not exist.
        Example
        Interface_Static::SetCVal
        ("write.step.schema","AP203")
        This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_SetCVal(*args)

    SetCVal = staticmethod(SetCVal)

    def SetIVal(*args):
        """
        SetIVal(Standard_CString const name, Standard_Integer const val) -> Standard_Boolean

        Modifies the value of the
        parameter identified by name. The modification is specified
        by the integer value val. false is returned if the
        parameter does not exist.
        Example
        Interface_Static::SetIVal
        ("write.step.schema", 3)
        This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.S

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_SetIVal(*args)

    SetIVal = staticmethod(SetIVal)

    def SetRVal(*args):
        """
        SetRVal(Standard_CString const name, Standard_Real const val) -> Standard_Boolean

        Modifies the value of a
        translation parameter. false is returned if the
        parameter does not exist. The modification is specified
        by the real number value val.

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_SetRVal(*args)

    SetRVal = staticmethod(SetRVal)

    def Update(*args):
        """
        Update(Standard_CString const name) -> Standard_Boolean

        Sets a Static to be "uptodate"
        Returns False if <name> is not present
        This status can be used by a reinitialisation procedure to
        rerun if a value has been changed

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_Update(*args)

    Update = staticmethod(Update)

    def IsUpdated(*args):
        """
        IsUpdated(Standard_CString const name) -> Standard_Boolean

        Returns the status "uptodate" from a Static
        Returns False if <name> is not present

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_Static_IsUpdated(*args)

    IsUpdated = staticmethod(IsUpdated)

    def Items(*args):
        """
        Items(Standard_Integer const mode=0, Standard_CString const criter) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns a list of names of statics :
        <mode> = 0 (D) : criter is for family
        <mode> = 1 : criter is regexp on names, takes final items
        (ignore wild cards)
        <mode> = 2 : idem but take only wilded, not final items
        <mode> = 3 : idem, take all items matching criter
        idem + 100 : takes only non-updated items
        idem + 200 : takes only updated items
        criter empty (D) : returns all names
        else returns names which match the given criter
        Remark : families beginning by '$' are not listed by criter ""
        they are listed only by criter "$"

        This allows for instance to set new values after having loaded
        or reloaded a resource, then to update them as required

        :type mode: int
        :type criter: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Interface_Static_Items(*args)

    Items = staticmethod(Items)

    def Standards(*args):
        """
        Standards()

        Initializes all standard static parameters, which can be used
        by every function. statics specific of a norm or a function
        must be defined around it


        """
        return _Interface.Interface_Static_Standards(*args)

    Standards = staticmethod(Standards)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_Static_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_Static_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_Static_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_Static
Interface_Static_swigregister = _Interface.Interface_Static_swigregister
Interface_Static_swigregister(Interface_Static)

def Interface_Static_Init(*args):
    """
    Init(Standard_CString const family, Standard_CString const name, Interface_ParamType const type, Standard_CString const init) -> Standard_Boolean
    Interface_Static_Init(Standard_CString const family, Standard_CString const name, Standard_Character const type, Standard_CString const init) -> Standard_Boolean

    As Init with ParamType, but type is given as a character
    This allows a simpler call
    Types : 'i' Integer, 'r' Real, 't' Text, 'e' Enum, 'o' Object
    '=' for same definition as, <init> gives the initial Static
    Returns False if <type> does not match this list

    :type family: OCC.wrapper.Standard.Standard_CString
    :type name: OCC.wrapper.Standard.Standard_CString
    :type type: OCC.wrapper.Standard.Standard_Character
    :type init: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_Init(*args)

def Interface_Static_Static(*args):
    """
    Interface_Static_Static(Standard_CString const name) -> Handle_Interface_Static

    Returns a Static from its name. Null Handle if not present

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Interface.Handle_Interface_Static

    """
    return _Interface.Interface_Static_Static(*args)

def Interface_Static_IsPresent(*args):
    """
    Interface_Static_IsPresent(Standard_CString const name) -> Standard_Boolean

    Returns True if a Static named <name> is present, False else

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_IsPresent(*args)

def Interface_Static_CDef(*args):
    """
    Interface_Static_CDef(Standard_CString const name, Standard_CString const part) -> Standard_CString

    Returns a part of the definition of a Static, as a CString
    The part is designated by its name, as a CString
    If the required value is not a string, it is converted to a
    CString then returned
    If <name> is not present, or <part> not defined for <name>,
    this function returns an empty string

    Allowed parts for CDef :
    family : the family
    type  : the type ("integer","real","text","enum")
    label : the label
    satis : satisfy function name if any
    rmin : minimum real value
    rmax : maximum real value
    imin : minimum integer value
    imax : maximum integer value
    enum nn (nn : value of an integer) : enum value for nn
    unit : unit definition for a real

    :type name: OCC.wrapper.Standard.Standard_CString
    :type part: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_Static_CDef(*args)

def Interface_Static_IDef(*args):
    """
    Interface_Static_IDef(Standard_CString const name, Standard_CString const part) -> Standard_Integer

    Returns a part of the definition of a Static, as an Integer
    The part is designated by its name, as a CString
    If the required value is not a string, returns zero
    For a Boolean, 0 for false, 1 for true
    If <name> is not present, or <part> not defined for <name>,
    this function returns zero

    Allowed parts for IDef :
    imin, imax : minimum or maximum integer value
    estart : starting number for enum
    ecount : count of enum values (starting from estart)
    ematch : exact match status
    eval val : case determined from a string

    :type name: OCC.wrapper.Standard.Standard_CString
    :type part: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_Static_IDef(*args)

def Interface_Static_IsSet(*args):
    """
    Interface_Static_IsSet(Standard_CString const name, Standard_Boolean const proper) -> Standard_Boolean

    Returns True if <name> is present AND set
    <proper> True (D) : considers this item only
    <proper> False    : if not set and attached to a wild-card,
    considers this wild-card

    :type name: OCC.wrapper.Standard.Standard_CString
    :type proper: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_IsSet(*args)

def Interface_Static_CVal(*args):
    """
    Interface_Static_CVal(Standard_CString const name) -> Standard_CString

    Returns the value of the
    parameter identified by the string name.
    If the specified parameter does not exist, an empty
    string is returned.
    Example
    Interface_Static::CVal("write.step.schema");
    which could return:
    "AP214"

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_Static_CVal(*args)

def Interface_Static_IVal(*args):
    """
    Interface_Static_IVal(Standard_CString const name) -> Standard_Integer

    Returns the integer value of
    the translation parameter identified by the string name.
    Returns the value 0 if the parameter does not exist.
    Example
    Interface_Static::IVal("write.step.schema");
    which could return: 3

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Interface.Interface_Static_IVal(*args)

def Interface_Static_RVal(*args):
    """
    Interface_Static_RVal(Standard_CString const name) -> Standard_Real

    Returns the value of a static
    translation parameter identified by the string name.
    Returns the value 0.0 if the parameter does not exist.

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Interface.Interface_Static_RVal(*args)

def Interface_Static_SetCVal(*args):
    """
    Interface_Static_SetCVal(Standard_CString const name, Standard_CString const val) -> Standard_Boolean

    Modifies the value of the
    parameter identified by name. The modification is specified
    by the string val. false is returned if the parameter does not exist.
    Example
    Interface_Static::SetCVal
    ("write.step.schema","AP203")
    This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.

    :type name: OCC.wrapper.Standard.Standard_CString
    :type val: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_SetCVal(*args)

def Interface_Static_SetIVal(*args):
    """
    Interface_Static_SetIVal(Standard_CString const name, Standard_Integer const val) -> Standard_Boolean

    Modifies the value of the
    parameter identified by name. The modification is specified
    by the integer value val. false is returned if the
    parameter does not exist.
    Example
    Interface_Static::SetIVal
    ("write.step.schema", 3)
    This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.S

    :type name: OCC.wrapper.Standard.Standard_CString
    :type val: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_SetIVal(*args)

def Interface_Static_SetRVal(*args):
    """
    Interface_Static_SetRVal(Standard_CString const name, Standard_Real const val) -> Standard_Boolean

    Modifies the value of a
    translation parameter. false is returned if the
    parameter does not exist. The modification is specified
    by the real number value val.

    :type name: OCC.wrapper.Standard.Standard_CString
    :type val: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_SetRVal(*args)

def Interface_Static_Update(*args):
    """
    Interface_Static_Update(Standard_CString const name) -> Standard_Boolean

    Sets a Static to be "uptodate"
    Returns False if <name> is not present
    This status can be used by a reinitialisation procedure to
    rerun if a value has been changed

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_Update(*args)

def Interface_Static_IsUpdated(*args):
    """
    Interface_Static_IsUpdated(Standard_CString const name) -> Standard_Boolean

    Returns the status "uptodate" from a Static
    Returns False if <name> is not present

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_Static_IsUpdated(*args)

def Interface_Static_Items(*args):
    """
    Interface_Static_Items(Standard_Integer const mode=0, Standard_CString const criter) -> Handle_TColStd_HSequenceOfHAsciiString

    Returns a list of names of statics :
    <mode> = 0 (D) : criter is for family
    <mode> = 1 : criter is regexp on names, takes final items
    (ignore wild cards)
    <mode> = 2 : idem but take only wilded, not final items
    <mode> = 3 : idem, take all items matching criter
    idem + 100 : takes only non-updated items
    idem + 200 : takes only updated items
    criter empty (D) : returns all names
    else returns names which match the given criter
    Remark : families beginning by '$' are not listed by criter ""
    they are listed only by criter "$"

    This allows for instance to set new values after having loaded
    or reloaded a resource, then to update them as required

    :type mode: int
    :type criter: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

    """
    return _Interface.Interface_Static_Items(*args)

def Interface_Static_Standards(*args):
    """
    Interface_Static_Standards()

    Initializes all standard static parameters, which can be used
    by every function. statics specific of a norm or a function
    must be defined around it


    """
    return _Interface.Interface_Static_Standards(*args)

def Interface_Static_get_type_name(*args):
    """
    Interface_Static_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_Static_get_type_name(*args)

def Interface_Static_get_type_descriptor(*args):
    """
    Interface_Static_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_Static_get_type_descriptor(*args)

class NCollection_Vector_Interface_FileParameter(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_Interface_FileParameter self) -> NCollection_Vector< Interface_FileParameter >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_Interface_FileParameter self) -> NCollection_Vector< Interface_FileParameter >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_Interface_FileParameter self) -> NCollection_Vector< Interface_FileParameter >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_Interface_FileParameter self) -> NCollection_Vector< Interface_FileParameter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _Interface.new_NCollection_Vector_Interface_FileParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_Interface_FileParameter self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_Interface_FileParameter self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_Interface_FileParameter self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_Interface_FileParameter self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_Interface_FileParameter self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_Interface_FileParameter self, NCollection_Vector_Interface_FileParameter theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_Interface_FileParameter self, NCollection_Vector_Interface_FileParameter theOther) -> NCollection_Vector_Interface_FileParameter

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_Interface_FileParameter self, Interface_FileParameter theValue) -> Interface_FileParameter

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_Interface_FileParameter self) -> Interface_FileParameter

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Vector_Interface_FileParameter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Vector_Interface_FileParameter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_Interface_FileParameter self) -> Interface_FileParameter

        @return first element

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Vector_Interface_FileParameter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_Interface_FileParameter self) -> Interface_FileParameter

        @return last element

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Vector_Interface_FileParameter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Vector_Interface_FileParameter_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_Interface_FileParameter self, Standard_Integer const theIndex) -> Interface_FileParameter

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_Interface_FileParameter self, Standard_Integer const theIndex, Interface_FileParameter theValue) -> Interface_FileParameter

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _Interface.NCollection_Vector_Interface_FileParameter_SetValue(self, *args)

    __swig_destroy__ = _Interface.delete_NCollection_Vector_Interface_FileParameter
NCollection_Vector_Interface_FileParameter_swigregister = _Interface.NCollection_Vector_Interface_FileParameter_swigregister
NCollection_Vector_Interface_FileParameter_swigregister(NCollection_Vector_Interface_FileParameter)


try:
	Interface_VectorOfFileParameter = NCollection_Vector_Interface_FileParameter
except NameError:
	pass # does not exist, probably ignored

class Handle_Interface_UndefinedContent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_UndefinedContent self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_UndefinedContent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_UndefinedContent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_UndefinedContent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_UndefinedContent self, Interface_UndefinedContent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_UndefinedContent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_UndefinedContent self, Handle_Interface_UndefinedContent theHandle) -> Handle_Interface_UndefinedContent
        assign(Handle_Interface_UndefinedContent self, Interface_UndefinedContent thePtr) -> Handle_Interface_UndefinedContent
        assign(Handle_Interface_UndefinedContent self, Handle_Interface_UndefinedContent theHandle) -> Handle_Interface_UndefinedContent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_UndefinedContent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_UndefinedContent self) -> Interface_UndefinedContent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_UndefinedContent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_UndefinedContent self) -> Interface_UndefinedContent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_UndefinedContent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_UndefinedContent self) -> Interface_UndefinedContent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_UndefinedContent___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_UndefinedContent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_UndefinedContent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_UndefinedContent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_UndefinedContent_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_UndefinedContent

    def NbParams(self, *args):
        """
        NbParams(Handle_Interface_UndefinedContent self) -> Standard_Integer

        Gives count of recorded parameters

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_UndefinedContent_NbParams(self, *args)


    def NbLiterals(self, *args):
        """
        NbLiterals(Handle_Interface_UndefinedContent self) -> Standard_Integer

        Gives count of Literal Parameters

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_UndefinedContent_NbLiterals(self, *args)


    def ParamData(self, *args):
        """
        ParamData(Handle_Interface_UndefinedContent self, Standard_Integer const num, Handle_Standard_Transient ent, Handle_TCollection_HAsciiString val) -> Standard_Boolean

        Returns data of a Parameter : its type, and the entity if it
        designates en entity ("ent") or its literal value else ("str")
        Returned value (Boolean) : True if it is an Entity, False else

        :type num: int
        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_UndefinedContent_ParamData(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_Interface_UndefinedContent self, Standard_Integer const num) -> Interface_ParamType

        Returns the ParamType of a Param, given its rank
        Error if num is not between 1 and NbParams

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Handle_Interface_UndefinedContent_ParamType(self, *args)


    def IsParamEntity(self, *args):
        """
        IsParamEntity(Handle_Interface_UndefinedContent self, Standard_Integer const num) -> Standard_Boolean

        Returns True if a Parameter is recorded as an entity
        Error if num is not between 1 and NbParams

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_UndefinedContent_IsParamEntity(self, *args)


    def ParamEntity(self, *args):
        """
        ParamEntity(Handle_Interface_UndefinedContent self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns Entity corresponding to a Param, given its rank

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_UndefinedContent_ParamEntity(self, *args)


    def ParamValue(self, *args):
        """
        ParamValue(Handle_Interface_UndefinedContent self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns litteral value of a Parameter, given its rank

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_UndefinedContent_ParamValue(self, *args)


    def Reservate(self, *args):
        """
        Reservate(Handle_Interface_UndefinedContent self, Standard_Integer const nb, Standard_Integer const nblit)

        Manages reservation for parameters (internal use)
        (nb : total count of parameters, nblit : count of literals)

        :type nb: int
        :type nblit: int

        """
        return _Interface.Handle_Interface_UndefinedContent_Reservate(self, *args)


    def AddLiteral(self, *args):
        """
        AddLiteral(Handle_Interface_UndefinedContent self, Interface_ParamType const ptype, Handle_TCollection_HAsciiString val)

        Adds a literal Parameter to the list

        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_UndefinedContent_AddLiteral(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Handle_Interface_UndefinedContent self, Interface_ParamType const ptype, Handle_Standard_Transient ent)

        Adds a Parameter which references an Entity

        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_UndefinedContent_AddEntity(self, *args)


    def RemoveParam(self, *args):
        """
        RemoveParam(Handle_Interface_UndefinedContent self, Standard_Integer const num)

        Removes a Parameter given its rank

        :type num: int

        """
        return _Interface.Handle_Interface_UndefinedContent_RemoveParam(self, *args)


    def SetLiteral(self, *args):
        """
        SetLiteral(Handle_Interface_UndefinedContent self, Standard_Integer const num, Interface_ParamType const ptype, Handle_TCollection_HAsciiString val)

        Sets a new value for the Parameter <num>, to a literal value
        (if it referenced formerly an Entity, this Entity is removed)

        :type num: int
        :type ptype: OCC.wrapper.Interface.Interface_ParamType
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_UndefinedContent_SetLiteral(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(Handle_Interface_UndefinedContent self, Standard_Integer const num, Interface_ParamType const ptype, Handle_Standard_Transient ent)
        SetEntity(Handle_Interface_UndefinedContent self, Standard_Integer const num, Handle_Standard_Transient ent)

        Changes the Entity referenced by the Parameter <num>
        (with same ParamType)

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_UndefinedContent_SetEntity(self, *args)


    def EntityList(self, *args):
        """
        EntityList(Handle_Interface_UndefinedContent self) -> Interface_EntityList

        Returns globally the list of param entities. Note that it can
        be used as shared entity list for the UndefinedEntity

        :rtype: OCC.wrapper.Interface.Interface_EntityList

        """
        return _Interface.Handle_Interface_UndefinedContent_EntityList(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(Handle_Interface_UndefinedContent self, Handle_Interface_UndefinedContent other, Interface_CopyTool TC)

        Copies contents of undefined entities; deigned to be called by
        GetFromAnother method from Undefined entity of each Interface
        (the basic operation is the same regardless the norm)

        :type other: OCC.wrapper.Interface.Handle_Interface_UndefinedContent
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _Interface.Handle_Interface_UndefinedContent_GetFromAnother(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_UndefinedContent self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_UndefinedContent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_UndefinedContent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_UndefinedContent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_UndefinedContent self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_UndefinedContent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_UndefinedContent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_UndefinedContent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_UndefinedContent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_UndefinedContent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_UndefinedContent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_UndefinedContent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_UndefinedContent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_UndefinedContent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_UndefinedContent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_UndefinedContent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_UndefinedContent self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_UndefinedContent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_UndefinedContent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_UndefinedContent_DecrementRefCounter(self, *args)

Handle_Interface_UndefinedContent_swigregister = _Interface.Handle_Interface_UndefinedContent_swigregister
Handle_Interface_UndefinedContent_swigregister(Handle_Interface_UndefinedContent)

def Handle_Interface_UndefinedContent_DownCast(thing):
    return _Interface.Handle_Interface_UndefinedContent_DownCast(thing)
Handle_Interface_UndefinedContent_DownCast = _Interface.Handle_Interface_UndefinedContent_DownCast

class Interface_GraphContent(Interface_EntityIterator):
    """
    Defines general form for classes of graph algorithms on
    Interfaces, this form is that of EntityIterator
    Each sub-class fills it according to its own algorithm
    This also allows to combine any graph result to others,
    all being given under one unique form
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_GraphContent self) -> Interface_GraphContent
        __init__(Interface_GraphContent self, Interface_Graph agraph) -> Interface_GraphContent
        __init__(Interface_GraphContent self, Interface_Graph agraph, Standard_Integer const stat) -> Interface_GraphContent
        __init__(Interface_GraphContent self, Interface_Graph agraph, Handle_Standard_Transient ent) -> Interface_GraphContent

        Creates an Iterator with Shared entities of an entity
        (equivalente to EntityIterator but with a Graph)

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _Interface.new_Interface_GraphContent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromGraph(self, *args):
        """
        GetFromGraph(Interface_GraphContent self, Interface_Graph agraph)
        GetFromGraph(Interface_GraphContent self, Interface_Graph agraph, Standard_Integer const stat)

        Gets entities from a graph which have a specific Status value
        (one created), adds them to those already recorded

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type stat: int

        """
        return _Interface.Interface_GraphContent_GetFromGraph(self, *args)


    def Result(self, *args):
        """
        Result(Interface_GraphContent self) -> Interface_EntityIterator

        Returns Result under the exact form of an EntityIterator :
        Can be used when EntityIterator itself is required (as a
        returned value for instance), whitout way for a sub-class

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_GraphContent_Result(self, *args)


    def Begin(self, *args):
        """
        Begin(Interface_GraphContent self)

        Does the Evaluation before starting the iteration itself
        (in out)


        """
        return _Interface.Interface_GraphContent_Begin(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Interface_GraphContent self)

        Evaluates list of Entities to be iterated. Called by Start
        Default is set to doing nothing : intended to be redefined
        by each sub-class


        """
        return _Interface.Interface_GraphContent_Evaluate(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_GraphContent
Interface_GraphContent_swigregister = _Interface.Interface_GraphContent_swigregister
Interface_GraphContent_swigregister(Interface_GraphContent)

class Handle_Interface_HArray1OfHAsciiString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_HArray1OfHAsciiString self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_HArray1OfHAsciiString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_HArray1OfHAsciiString self, Interface_HArray1OfHAsciiString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_HArray1OfHAsciiString self, Handle_Interface_HArray1OfHAsciiString theHandle) -> Handle_Interface_HArray1OfHAsciiString
        assign(Handle_Interface_HArray1OfHAsciiString self, Interface_HArray1OfHAsciiString thePtr) -> Handle_Interface_HArray1OfHAsciiString
        assign(Handle_Interface_HArray1OfHAsciiString self, Handle_Interface_HArray1OfHAsciiString theHandle) -> Handle_Interface_HArray1OfHAsciiString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_HArray1OfHAsciiString self) -> Interface_HArray1OfHAsciiString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_HArray1OfHAsciiString self) -> Interface_HArray1OfHAsciiString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_HArray1OfHAsciiString self) -> Interface_HArray1OfHAsciiString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_HArray1OfHAsciiString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_HArray1OfHAsciiString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_HArray1OfHAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_HArray1OfHAsciiString_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_HArray1OfHAsciiString

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Interface.Interface_Array1OfHAsciiString

        """
        res = _Interface.Handle_Interface_HArray1OfHAsciiString_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Interface_HArray1OfHAsciiString self) -> NCollection_Array1_Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.Interface.Interface_Array1OfHAsciiString

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_HArray1OfHAsciiString self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_HArray1OfHAsciiString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_HArray1OfHAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_HArray1OfHAsciiString self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_HArray1OfHAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_HArray1OfHAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_HArray1OfHAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_HArray1OfHAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_HArray1OfHAsciiString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_HArray1OfHAsciiString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_HArray1OfHAsciiString self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_HArray1OfHAsciiString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_HArray1OfHAsciiString_DecrementRefCounter(self, *args)

Handle_Interface_HArray1OfHAsciiString_swigregister = _Interface.Handle_Interface_HArray1OfHAsciiString_swigregister
Handle_Interface_HArray1OfHAsciiString_swigregister(Handle_Interface_HArray1OfHAsciiString)

def Handle_Interface_HArray1OfHAsciiString_DownCast(thing):
    return _Interface.Handle_Interface_HArray1OfHAsciiString_DownCast(thing)
Handle_Interface_HArray1OfHAsciiString_DownCast = _Interface.Handle_Interface_HArray1OfHAsciiString_DownCast

class Interface_InterfaceModel(Standard.Standard_Transient):
    """
    Defines an (Indexed) Set of data corresponding to a complete
    Transfer by a File Interface, i.e. File Header and Transient
    Entities (Objects) contained in a File. Contained Entities are
    identified in the Model by unique and consecutive Numbers.

    In addition, a Model can attach to each entity, a specific
    Label according to the norm (e.g. Name for VDA, #ident for
    Step ...), intended to be output on a string or a stream
    (remark : labels are not obliged to be unique)

    InterfaceModel itself is not Transient, it is intended to
    work on a set of Transient Data. The services offered are
    basic Listing and Identification operations on Transient
    Entities, storage of Error Reports, Copying.

    Moreovere, it is possible to define and use templates. These
    are empty Models, from which copies can be obtained in order
    to be filled with effective data. This allows to record
    standard definitions for headers, avoiding to recreate them
    for each sendings, and assuring customisation of produced
    files for a given site.
    A template is attached to a name. It is possible to define a
    template from another one (get it, edit it then record it
    under another name).

    See also Graph, ShareTool, CheckTool for more
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_InterfaceModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_InterfaceModel(self) 
            return h


    def Destroy(self, *args):
        """
        Destroy(Interface_InterfaceModel self)

        Clears the list of entities (service WhenDelete)


        """
        return _Interface.Interface_InterfaceModel_Destroy(self, *args)


    def SetProtocol(self, *args):
        """
        SetProtocol(Interface_InterfaceModel self, Handle_Interface_Protocol proto)

        Sets a Protocol for this Model
        It is also set by a call to AddWithRefs with Protocol
        It is used for : DumpHeader (as required), ClearEntities ...

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_InterfaceModel_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Protocol(Interface_InterfaceModel self) -> Handle_Interface_Protocol

        Returns the Protocol which has been set by SetProtocol, or
        AddWithRefs with Protocol

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_InterfaceModel_Protocol(self, *args)


    def SetGTool(self, *args):
        """
        SetGTool(Interface_InterfaceModel self, Handle_Interface_GTool gtool)

        Sets a GTool for this model, which already defines a Protocol

        :type gtool: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        return _Interface.Interface_InterfaceModel_SetGTool(self, *args)


    def GTool(self, *args):
        """
        GTool(Interface_InterfaceModel self) -> Handle_Interface_GTool

        Returns the GTool, set by SetProtocol or by SetGTool

        :rtype: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        return _Interface.Interface_InterfaceModel_GTool(self, *args)


    def DispatchStatus(self, *args):
        """
        DispatchStatus(Interface_InterfaceModel self) -> Standard_Boolean &

        Returns the Dispatch Status, either for get or set
        A Model which is produced from Dispatch may share entities
        with the original (according to the Protocol), hence these
        non-copied entities should not be deleted

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_DispatchStatus(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_InterfaceModel self)

        Erases contained data; used when a Model is copied to others :
        the new copied ones begin from clear
        Clear calls specific method ClearHeader (see below)


        """
        return _Interface.Interface_InterfaceModel_Clear(self, *args)


    def ClearEntities(self, *args):
        """
        ClearEntities(Interface_InterfaceModel self)

        Clears the entities; uses the general service WhenDelete, in
        addition to the standard Memory Manager; can be redefined


        """
        return _Interface.Interface_InterfaceModel_ClearEntities(self, *args)


    def ClearLabels(self, *args):
        """
        ClearLabels(Interface_InterfaceModel self)

        Erases informations about labels, if any : specific to each
        norm


        """
        return _Interface.Interface_InterfaceModel_ClearLabels(self, *args)


    def ClearHeader(self, *args):
        """
        ClearHeader(Interface_InterfaceModel self)

        Clears Model's header : specific to each norm


        """
        return _Interface.Interface_InterfaceModel_ClearHeader(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Interface_InterfaceModel self) -> Standard_Integer

        Returns count of contained Entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_InterfaceModel_NbEntities(self, *args)


    def Contains(self, *args):
        """
        Contains(Interface_InterfaceModel self, Handle_Standard_Transient anentity) -> Standard_Boolean

        Returns True if a Model contains an Entity (for a ReportEntity,
        looks for the ReportEntity itself AND its Concerned Entity)

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_Contains(self, *args)


    def Number(self, *args):
        """
        Number(Interface_InterfaceModel self, Handle_Standard_Transient anentity) -> Standard_Integer

        Returns the Number of an Entity in the Model if it contains it.
        Else returns 0. For a ReportEntity, looks at Concerned Entity.
        Returns the Directory entry   Number of  an Entity in
        the  Model if it contains it.   Else returns  0.  For a
        ReportEntity, looks at Concerned Entity.

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_InterfaceModel_Number(self, *args)


    def Value(self, *args):
        """
        Returns an Entity identified by its number in the Model
        Each sub-class of InterfaceModel can define its own method
        Entity to return its specific class of Entity (e.g. for VDA,
        VDAModel returns a VDAEntity), working by calling Value
        Remark : For a Reported Entity, (Erroneous, Corrected, Unknown), this
        method returns this Reported Entity.
        See ReportEntity for other questions.

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_InterfaceModel_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbTypes(self, *args):
        """
        NbTypes(Interface_InterfaceModel self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Defined by the Protocol, which gives default as
        1 (dynamic Type).

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_InterfaceModel_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Interface_InterfaceModel self, Handle_Standard_Transient ent, Standard_Integer const num=1) -> Handle_Standard_Type

        Returns a type, given its rank : defined by the Protocol
        (by default, the first one)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_InterfaceModel_Type(self, *args)


    def TypeName(self, *args):
        """
        TypeName(Interface_InterfaceModel self, Handle_Standard_Transient ent, Standard_Boolean const complete) -> Standard_CString

        Returns the type name of an entity, from the list of types
        (one or more ...)
        <complete> True (D) gives the complete type, else packages are
        removed
        WARNING : buffered, to be immediately copied or printed

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type complete: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_InterfaceModel_TypeName(self, *args)


    def ClassName(*args):
        """
        ClassName(Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_InterfaceModel_ClassName(*args)

    ClassName = staticmethod(ClassName)

    def EntityState(self, *args):
        """
        EntityState(Interface_InterfaceModel self, Standard_Integer const num) -> Interface_DataState

        Returns the State of an entity, given its number

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_DataState

        """
        return _Interface.Interface_InterfaceModel_EntityState(self, *args)


    def IsReportEntity(self, *args):
        """
        IsReportEntity(Interface_InterfaceModel self, Standard_Integer const num, Standard_Boolean const semantic) -> Standard_Boolean

        Returns True if <num> identifies a ReportEntity in the Model
        Hence, ReportEntity can be called.

        By default, queries main report, if <semantic> is True, it
        queries report for semantic check

        Remember that a Report Entity can be defined for an Unknown
        Entity, or a Corrected or Erroneous (at read time) Entity.
        The ReportEntity is defined before call to method AddEntity.

        :type num: int
        :type semantic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_IsReportEntity(self, *args)


    def ReportEntity(self, *args):
        """
        ReportEntity(Interface_InterfaceModel self, Standard_Integer const num, Standard_Boolean const semantic) -> Handle_Interface_ReportEntity

        Returns a ReportEntity identified by its number in the Model,
        or a Null Handle If <num> does not identify a ReportEntity.

        By default, queries main report, if <semantic> is True, it
        queries report for semantic check

        :type num: int
        :type semantic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_ReportEntity

        """
        return _Interface.Interface_InterfaceModel_ReportEntity(self, *args)


    def IsErrorEntity(self, *args):
        """
        IsErrorEntity(Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Error Entity : in this
        case, a ReportEntity brings Fail Messages and possibly an
        "undefined" Content, see IsRedefinedEntity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_IsErrorEntity(self, *args)


    def IsRedefinedContent(self, *args):
        """
        IsRedefinedContent(Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Entity which content is
        redefined through a ReportEntity (i.e. with literal data only)
        This happens when an entity is syntactically erroneous in the
        way that its basic content remains empty.
        For more details (such as content itself), see ReportEntity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_IsRedefinedContent(self, *args)


    def ClearReportEntity(self, *args):
        """
        ClearReportEntity(Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Removes the ReportEntity attached to Entity <num>. Returns
        True if done, False if no ReportEntity was attached to <num>.
        Warning : the caller must assume that this clearing is meaningfull

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_ClearReportEntity(self, *args)


    def SetReportEntity(self, *args):
        """
        SetReportEntity(Interface_InterfaceModel self, Standard_Integer const num, Handle_Interface_ReportEntity rep) -> Standard_Boolean

        Sets or Replaces a ReportEntity for the Entity <num>. Returns
        True if Report is replaced, False if it has been replaced
        Warning : the caller must assume that this setting is meaningfull

        :type num: int
        :type rep: OCC.wrapper.Interface.Handle_Interface_ReportEntity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_SetReportEntity(self, *args)


    def AddReportEntity(self, *args):
        """
        AddReportEntity(Interface_InterfaceModel self, Handle_Interface_ReportEntity rep, Standard_Boolean const semantic) -> Standard_Boolean

        Adds a ReportEntity as such. Returns False if the concerned
        entity is not recorded in the Model
        Else, adds it into, either the main report list or the
        list for semantic checks, then returns True

        :type rep: OCC.wrapper.Interface.Handle_Interface_ReportEntity
        :type semantic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_AddReportEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Unknown Entity : in this
        case, a ReportEntity with no Check Messages designates it.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_IsUnknownEntity(self, *args)


    def FillSemanticChecks(self, *args):
        """
        FillSemanticChecks(Interface_InterfaceModel self, Interface_CheckIterator checks, Standard_Boolean const clear)

        Fills the list of semantic checks.
        This list is computed (by CheckTool). Hence, it can be stored
        in the model for later queries
        <clear> True (D) : new list replaces
        <clear> False    : new list is cumulated

        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type clear: bool

        """
        return _Interface.Interface_InterfaceModel_FillSemanticChecks(self, *args)


    def HasSemanticChecks(self, *args):
        """
        HasSemanticChecks(Interface_InterfaceModel self) -> Standard_Boolean

        Returns True if semantic checks have been filled

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_HasSemanticChecks(self, *args)


    def Check(self, *args):
        """
        Returns the check attached to an entity, designated by its
        Number. 0 for global check
        <semantic> True  : recorded semantic check
        <semantic> False : recorded syntactic check (see ReportEntity)
        If no check is recorded for <num>, returns an empty Check

        :type num: int
        :type syntactic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Interface_InterfaceModel_Check(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reservate(self, *args):
        """
        Reservate(Interface_InterfaceModel self, Standard_Integer const nbent)

        Does a reservation for the List of Entities (for optimized
        storage management). If it is not called, storage management
        can be less efficient. <nbent> is the expected count of
        Entities to store

        :type nbent: int

        """
        return _Interface.Interface_InterfaceModel_Reservate(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Interface_InterfaceModel self, Handle_Standard_Transient anentity)

        Internal method for adding an Entity. Used by file reading
        (defined by each Interface) and Transfer tools. It adds the
        entity required to be added, not its refs : see AddWithRefs.
        If <anentity> is a ReportEntity, it is added to the list of
        Reports, its Concerned Entity (Erroneous or Corrected, else
        Unknown) is added to the list of Entities.
        That is, the ReportEntity must be created before Adding

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_InterfaceModel_AddEntity(self, *args)


    def AddWithRefs(self, *args):
        """
        AddWithRefs(Interface_InterfaceModel self, Handle_Standard_Transient anent, Handle_Interface_Protocol proto, Standard_Integer const level=0, Standard_Boolean const listall)
        AddWithRefs(Interface_InterfaceModel self, Handle_Standard_Transient anent, Standard_Integer const level=0, Standard_Boolean const listall)
        AddWithRefs(Interface_InterfaceModel self, Handle_Standard_Transient anent, Interface_GeneralLib lib, Standard_Integer const level=0, Standard_Boolean const listall)

        Same as above, but works with an already created GeneralLib

        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type lib: OCC.wrapper.Interface.Interface_GeneralLib
        :type level: int
        :type listall: bool

        """
        return _Interface.Interface_InterfaceModel_AddWithRefs(self, *args)


    def ReplaceEntity(self, *args):
        """
        ReplaceEntity(Interface_InterfaceModel self, Standard_Integer const nument, Handle_Standard_Transient anent)

        Replace Entity with Number=nument on other entity - "anent"

        :type nument: int
        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_InterfaceModel_ReplaceEntity(self, *args)


    def ReverseOrders(self, *args):
        """
        ReverseOrders(Interface_InterfaceModel self, Standard_Integer const after=0)

        Reverses the Numbers of the Entities, between <after> and the
        total count of Entities. Thus, the entities :
        1,2 ... after, after+1 ... nb-1, nb  become numbered as :
        1,2 ... after, nb, nb-1 ... after+1
        By default (after = 0) the whole list of Entities is reversed

        :type after: int

        """
        return _Interface.Interface_InterfaceModel_ReverseOrders(self, *args)


    def ChangeOrder(self, *args):
        """
        ChangeOrder(Interface_InterfaceModel self, Standard_Integer const oldnum, Standard_Integer const newnum, Standard_Integer const count=1)

        Changes the Numbers of some Entities : <oldnum> is moved to
        <newnum>, same for <count> entities. Thus :
        1,2 ... newnum-1 newnum ... oldnum .. oldnum+count oldnum+count+1 .. gives
        1,2 ... newnum-1 oldnum .. oldnum+count newnum ... oldnum+count+1
        (can be seen as a circular permutation)

        :type oldnum: int
        :type newnum: int
        :type count: int

        """
        return _Interface.Interface_InterfaceModel_ChangeOrder(self, *args)


    def GetFromTransfer(self, *args):
        """
        GetFromTransfer(Interface_InterfaceModel self, Interface_EntityIterator aniter)

        Gets contents from an EntityIterator, prepared by a
        Transfer tool (e.g TransferCopy). Starts from clear

        :type aniter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_GetFromTransfer(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(Interface_InterfaceModel self, Handle_Interface_InterfaceModel other)

        Gets header (data specific of a defined Interface) from
        another InterfaceModel; called from TransferCopy

        :type other: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_InterfaceModel_GetFromAnother(self, *args)


    def NewEmptyModel(self, *args):
        """
        NewEmptyModel(Interface_InterfaceModel self) -> Handle_Interface_InterfaceModel

        Returns a New Empty Model, same type as <me> (whatever its
        Type); called to Copy parts a Model into other ones, then
        followed by a call to GetFromAnother (Header) then filling
        with specified Entities, themselves copied

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_InterfaceModel_NewEmptyModel(self, *args)


    def SetCategoryNumber(self, *args):
        """
        SetCategoryNumber(Interface_InterfaceModel self, Standard_Integer const num, Standard_Integer const val) -> Standard_Boolean

        Records a category number for an entity number
        Returns True when done, False if <num> is out of range

        :type num: int
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_SetCategoryNumber(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Integer

        Returns the recorded category number for a given entity number
        0 if none was defined for this entity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_InterfaceModel_CategoryNumber(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Interface_InterfaceModel self, Interface_EntityIterator iter)

        Allows an EntityIterator to get a list of Entities

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_FillIterator(self, *args)


    def Entities(self, *args):
        """
        Entities(Interface_InterfaceModel self) -> Interface_EntityIterator

        Returns the list of all Entities, as an Iterator on Entities
        (the Entities themselves, not the Reports)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_Entities(self, *args)


    def Reports(self, *args):
        """
        Reports(Interface_InterfaceModel self, Standard_Boolean const semantic) -> Interface_EntityIterator

        Returns the list of all ReportEntities, i.e. data about
        Entities read with Error or Warning informations
        (each item has to be casted to Report Entity then it can be
        queried for Concerned Entity, Content, Check ...)
        By default, returns the main reports, is <semantic> is True it
        returns the list for sematic checks

        :type semantic: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_Reports(self, *args)


    def Redefineds(self, *args):
        """
        Redefineds(Interface_InterfaceModel self) -> Interface_EntityIterator

        Returns the list of ReportEntities which redefine data
        (generally, if concerned entity is "Error", a literal content
        is added to it : this is a "redefined entity"

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_Redefineds(self, *args)


    def GlobalCheck(self, *args):
        """
        Returns the GlobalCheck, which memorizes messages global to
        the file (not specific to an Entity), especially Header

        :type syntactic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Interface_InterfaceModel_GlobalCheck(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetGlobalCheck(self, *args):
        """
        SetGlobalCheck(Interface_InterfaceModel self, Handle_Interface_Check ach)

        Allows to modify GlobalCheck, after getting then completing it
        Remark : it is SYNTACTIC check. Semantics, see FillChecks

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_InterfaceModel_SetGlobalCheck(self, *args)


    def VerifyCheck(self, *args):
        """
        VerifyCheck(Interface_InterfaceModel self, Handle_Interface_Check ach)

        Minimum Semantic Global Check on data in model (header)
        Can only check basic Data. See also GlobalCheck from Protocol
        for a check which takes the Graph into account
        Default does nothing, can be redefined

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Interface_InterfaceModel_VerifyCheck(self, *args)


    def DumpHeader(self, *args):
        """
        DumpHeader(Interface_InterfaceModel self, Handle_Message_Messenger S, Standard_Integer const level=0)

        Dumps Header in a short, easy to read, form, onto a Stream
        <level> allows to print more or less parts of the header,
        if necessary. 0 for basic print

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int

        """
        return _Interface.Interface_InterfaceModel_DumpHeader(self, *args)


    def Print(self, *args):
        """
        Print(Interface_InterfaceModel self, Handle_Standard_Transient ent, Handle_Message_Messenger s, Standard_Integer const mode=0)

        Prints identification of a given entity in <me>, in order to
        be printed in a list or phrase
        <mode> < 0 : prints only its number
        <mode> = 1 : just calls PrintLabel
        <mode> = 0 (D) : prints its number plus '/' plus PrintLabel
        If <ent> == <me>, simply prints "Global"
        If <ent> is unknown, prints "??/its type"

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type s: OCC.wrapper.Message.Handle_Message_Messenger
        :type mode: int

        """
        return _Interface.Interface_InterfaceModel_Print(self, *args)


    def PrintLabel(self, *args):
        """
        PrintLabel(Interface_InterfaceModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to each norm, for a given entity.
        Must only print label itself, in order to be included in a
        phrase. Can call the result of StringLabel, but not obliged.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_InterfaceModel_PrintLabel(self, *args)


    def PrintToLog(self, *args):
        """
        PrintToLog(Interface_InterfaceModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to each norm in log format, for
        a given entity.
        By default, just calls PrintLabel, can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_InterfaceModel_PrintToLog(self, *args)


    def StringLabel(self, *args):
        """
        StringLabel(Interface_InterfaceModel self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns a string with the label attached to a given entity.
        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_InterfaceModel_StringLabel(self, *args)


    def NextNumberForLabel(self, *args):
        """
        NextNumberForLabel(Interface_InterfaceModel self, Standard_CString const label, Standard_Integer const lastnum=0, Standard_Boolean const exact) -> Standard_Integer

        Searches a label which matches with one entity.
        Begins from <lastnum>+1 (default:1) and scans the entities
        until <NbEntities>. For the first which matches <label>,
        this method returns its Number. Returns 0 if nothing found
        Can be called recursively (labels are not specified as unique)
        <exact> : if True (default), exact match is required
        else, checks the END of entity label

        This method is virtual, hence it can be redefined for a more
        efficient search (if exact is true).

        :type label: OCC.wrapper.Standard.Standard_CString
        :type lastnum: int
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_InterfaceModel_NextNumberForLabel(self, *args)


    def HasTemplate(*args):
        """
        HasTemplate(Standard_CString const name) -> Standard_Boolean

        Returns true if a template is attached to a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_HasTemplate(*args)

    HasTemplate = staticmethod(HasTemplate)

    def Template(*args):
        """
        Template(Standard_CString const name) -> Handle_Interface_InterfaceModel

        Returns the template model attached to a name, or a Null Handle

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_InterfaceModel_Template(*args)

    Template = staticmethod(Template)

    def SetTemplate(*args):
        """
        SetTemplate(Standard_CString const name, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Records a new template model with a name. If the name was
        already recorded, the corresponding template is replaced by
        the new one. Then, WARNING : test HasTemplate to avoid
        surprises

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_InterfaceModel_SetTemplate(*args)

    SetTemplate = staticmethod(SetTemplate)

    def ListTemplates(*args):
        """
        ListTemplates() -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the complete list of names attached to template models

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Interface_InterfaceModel_ListTemplates(*args)

    ListTemplates = staticmethod(ListTemplates)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_InterfaceModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_InterfaceModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_InterfaceModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_InterfaceModel
Interface_InterfaceModel_swigregister = _Interface.Interface_InterfaceModel_swigregister
Interface_InterfaceModel_swigregister(Interface_InterfaceModel)

def Interface_InterfaceModel_ClassName(*args):
    """
    Interface_InterfaceModel_ClassName(Standard_CString const typnam) -> Standard_CString

    From a CDL Type Name, returns the Class part (package dropped)
    WARNING : buffered, to be immediately copied or printed

    :type typnam: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Interface.Interface_InterfaceModel_ClassName(*args)

def Interface_InterfaceModel_HasTemplate(*args):
    """
    Interface_InterfaceModel_HasTemplate(Standard_CString const name) -> Standard_Boolean

    Returns true if a template is attached to a given name

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_InterfaceModel_HasTemplate(*args)

def Interface_InterfaceModel_Template(*args):
    """
    Interface_InterfaceModel_Template(Standard_CString const name) -> Handle_Interface_InterfaceModel

    Returns the template model attached to a name, or a Null Handle

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

    """
    return _Interface.Interface_InterfaceModel_Template(*args)

def Interface_InterfaceModel_SetTemplate(*args):
    """
    Interface_InterfaceModel_SetTemplate(Standard_CString const name, Handle_Interface_InterfaceModel model) -> Standard_Boolean

    Records a new template model with a name. If the name was
    already recorded, the corresponding template is replaced by
    the new one. Then, WARNING : test HasTemplate to avoid
    surprises

    :type name: OCC.wrapper.Standard.Standard_CString
    :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Interface.Interface_InterfaceModel_SetTemplate(*args)

def Interface_InterfaceModel_ListTemplates(*args):
    """
    Interface_InterfaceModel_ListTemplates() -> Handle_TColStd_HSequenceOfHAsciiString

    Returns the complete list of names attached to template models

    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

    """
    return _Interface.Interface_InterfaceModel_ListTemplates(*args)

def Interface_InterfaceModel_get_type_name(*args):
    """
    Interface_InterfaceModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_InterfaceModel_get_type_name(*args)

def Interface_InterfaceModel_get_type_descriptor(*args):
    """
    Interface_InterfaceModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_InterfaceModel_get_type_descriptor(*args)

class Handle_Interface_Check(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_Check self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_Check_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_Check self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_Check_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_Check self, Interface_Check thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_Check_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_Check self, Handle_Interface_Check theHandle) -> Handle_Interface_Check
        assign(Handle_Interface_Check self, Interface_Check thePtr) -> Handle_Interface_Check
        assign(Handle_Interface_Check self, Handle_Interface_Check theHandle) -> Handle_Interface_Check

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_Check_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_Check self) -> Interface_Check

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_Check_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_Check self) -> Interface_Check

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_Check___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_Check self) -> Interface_Check

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_Check___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_Check___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_Check___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_Check_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_Check

    def SendFail(self, *args):
        """
        SendFail(Handle_Interface_Check self, Message_Msg amsg)

        New name for AddFail (Msg)

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Handle_Interface_Check_SendFail(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Interface_Check self, Handle_TCollection_HAsciiString amess)
        AddFail(Handle_Interface_Check self, Handle_TCollection_HAsciiString amess, Handle_TCollection_HAsciiString orig)
        AddFail(Handle_Interface_Check self, Standard_CString const amess, Standard_CString const orig)
        AddFail(Handle_Interface_Check self, Message_Msg amsg)

        Records a new Fail from the definition of a Msg (Original+Value)

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Handle_Interface_Check_AddFail(self, *args)


    def HasFailed(self, *args):
        """
        HasFailed(Handle_Interface_Check self) -> Standard_Boolean

        Returns True if Check brings at least one Fail Message

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_HasFailed(self, *args)


    def NbFails(self, *args):
        """
        NbFails(Handle_Interface_Check self) -> Standard_Integer

        Returns count of recorded Fails

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Check_NbFails(self, *args)


    def Fail(self, *args):
        """
        Returns Fail Message as a String
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _Interface.Handle_Interface_Check_Fail(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CFail(self, *args):
        """
        CFail(Handle_Interface_Check self, Standard_Integer const num, Standard_Boolean const final) -> Standard_CString

        Same as above, but returns a CString (to be printed ...)
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Check_CFail(self, *args)


    def Fails(self, *args):
        """
        Fails(Handle_Interface_Check self, Standard_Boolean const final) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of Fails, for a frontal-engine logic
        Final forms by default, Original forms if <final> is False
        Can be empty

        :type final: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Handle_Interface_Check_Fails(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_Interface_Check self, Message_Msg amsg)

        New name for AddWarning

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Handle_Interface_Check_SendWarning(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Interface_Check self, Handle_TCollection_HAsciiString amess)
        AddWarning(Handle_Interface_Check self, Handle_TCollection_HAsciiString amess, Handle_TCollection_HAsciiString orig)
        AddWarning(Handle_Interface_Check self, Standard_CString const amess, Standard_CString const orig)
        AddWarning(Handle_Interface_Check self, Message_Msg amsg)

        Records a new Warning from the definition of a Msg (Original+Value)

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Handle_Interface_Check_AddWarning(self, *args)


    def HasWarnings(self, *args):
        """
        HasWarnings(Handle_Interface_Check self) -> Standard_Boolean

        Returns True if Check brings at least one Warning Message

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_HasWarnings(self, *args)


    def NbWarnings(self, *args):
        """
        NbWarnings(Handle_Interface_Check self) -> Standard_Integer

        Returns count of recorded Warning messages

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Check_NbWarnings(self, *args)


    def Warning(self, *args):
        """
        Returns Warning message as a String
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _Interface.Handle_Interface_Check_Warning(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CWarning(self, *args):
        """
        CWarning(Handle_Interface_Check self, Standard_Integer const num, Standard_Boolean const final) -> Standard_CString

        Same as above, but returns a CString (to be printed ...)
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Check_CWarning(self, *args)


    def Warnings(self, *args):
        """
        Warnings(Handle_Interface_Check self, Standard_Boolean const final) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of Warnings, for a frontal-engine logic
        Final forms by default, Original forms if <final> is False
        Can be empty

        :type final: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Handle_Interface_Check_Warnings(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_Interface_Check self, Message_Msg amsg)

        Records an information message
        This does not change the status of the Check

        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Interface.Handle_Interface_Check_SendMsg(self, *args)


    def NbInfoMsgs(self, *args):
        """
        NbInfoMsgs(Handle_Interface_Check self) -> Standard_Integer

        Returns the count of recorded information messages

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Check_NbInfoMsgs(self, *args)


    def InfoMsg(self, *args):
        """
        Returns information message as a String

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        res = _Interface.Handle_Interface_Check_InfoMsg(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CInfoMsg(self, *args):
        """
        CInfoMsg(Handle_Interface_Check self, Standard_Integer const num, Standard_Boolean const final) -> Standard_CString

        Same as above, but returns a CString (to be printed ...)
        Final form by default, Original form if <final> is False

        :type num: int
        :type final: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Check_CInfoMsg(self, *args)


    def InfoMsgs(self, *args):
        """
        InfoMsgs(Handle_Interface_Check self, Standard_Boolean const final) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the list of Info Msg, for a frontal-engine logic
        Final forms by default, Original forms if <final> is False
        Can be empty

        :type final: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Handle_Interface_Check_InfoMsgs(self, *args)


    def Status(self, *args):
        """
        Status(Handle_Interface_Check self) -> Interface_CheckStatus

        Returns the Check Status : OK, Warning or Fail

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Interface.Handle_Interface_Check_Status(self, *args)


    def Complies(self, *args):
        """
        Complies(Handle_Interface_Check self, Interface_CheckStatus const status) -> Standard_Boolean
        Complies(Handle_Interface_Check self, Handle_TCollection_HAsciiString mess, Standard_Integer const incl, Interface_CheckStatus const status) -> Standard_Boolean

        Tells if a message is brought by a Check, as follows :
        <incl> = 0 : <mess> exactly matches one of the messages
        <incl> < 0 : <mess> is contained by one of the messages
        <incl> > 0 : <mess> contains one of the messages
        For <status> : for CheckWarning and CheckFail, considers only
        resp. Warning or Check messages. for CheckAny, considers all
        other values are ignored (answer will be false)

        :type mess: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type incl: int
        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_Complies(self, *args)


    def HasEntity(self, *args):
        """
        HasEntity(Handle_Interface_Check self) -> Standard_Boolean

        Returns True if a Check is devoted to an entity; else, it is
        global (for InterfaceModel's storing of global error messages)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_HasEntity(self, *args)


    def Entity(self, *args):
        """
        Returns the entity on which the Check has been defined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Handle_Interface_Check_Entity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_Interface_Check self)

        Clears a check, in order to receive informations from transfer
        (Messages and Entity)


        """
        return _Interface.Handle_Interface_Check_Clear(self, *args)


    def ClearFails(self, *args):
        """
        ClearFails(Handle_Interface_Check self)

        Clears the Fail Messages (for instance to keep only Warnings)


        """
        return _Interface.Handle_Interface_Check_ClearFails(self, *args)


    def ClearWarnings(self, *args):
        """
        ClearWarnings(Handle_Interface_Check self)

        Clears the Warning Messages (for instance to keep only Fails)


        """
        return _Interface.Handle_Interface_Check_ClearWarnings(self, *args)


    def ClearInfoMsgs(self, *args):
        """
        ClearInfoMsgs(Handle_Interface_Check self)

        Clears the Info Messages


        """
        return _Interface.Handle_Interface_Check_ClearInfoMsgs(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_Interface_Check self, Handle_TCollection_HAsciiString mess, Standard_Integer const incl, Interface_CheckStatus const status) -> Standard_Boolean

        Removes the messages which comply with <mess>, as follows :
        <incl> = 0 : <mess> exactly matches one of the messages
        <incl> < 0 : <mess> is contained by one of the messages
        <incl> > 0 : <mess> contains one of the messages
        For <status> : for CheckWarning and CheckFail, considers only
        resp. Warning or Check messages. for CheckAny, considers all
        other values are ignored (nothing is done)
        Returns True if at least one message has been removed, False else

        :type mess: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type incl: int
        :type status: OCC.wrapper.Interface.Interface_CheckStatus
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_Remove(self, *args)


    def Mend(self, *args):
        """
        Mend(Handle_Interface_Check self, Standard_CString const pref, Standard_Integer const num=0) -> Standard_Boolean

        Mends messages, according <pref> and <num>
        According to <num>, works on the whole list of Fails if = 0(D)
        or only one Fail message, given its rank
        If <pref> is empty, converts Fail(s) to Warning(s)
        Else, does the conversion but prefixes the new Warning(s) but
        <pref> followed by a semi-column
        Some reserved values of <pref> are :
        "FM" : standard prefix "Mended" (can be translated)
        "CF" : clears Fail(s)
        "CW" : clears Warning(s) : here, <num> refers to Warning list
        "CA" : clears all messages : here, <num> is ignored

        :type pref: OCC.wrapper.Standard.Standard_CString
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_Mend(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(Handle_Interface_Check self, Handle_Standard_Transient anentity)

        Receives an entity result of a Transfer

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_Check_SetEntity(self, *args)


    def GetEntity(self, *args):
        """
        GetEntity(Handle_Interface_Check self, Handle_Standard_Transient anentity)

        same as SetEntity (old form kept for compatibility)
        Warning : Does nothing if Entity field is not yet clear

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_Check_GetEntity(self, *args)


    def GetMessages(self, *args):
        """
        GetMessages(Handle_Interface_Check self, Handle_Interface_Check other)

        Copies messages stored in another Check, cumulating
        Does not regard other's Entity. Used to cumulate messages

        :type other: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Handle_Interface_Check_GetMessages(self, *args)


    def GetAsWarning(self, *args):
        """
        GetAsWarning(Handle_Interface_Check self, Handle_Interface_Check other, Standard_Boolean const failsonly)

        Copies messages converted into Warning messages
        If failsonly is true, only Fails are taken, and converted
        else, Warnings are taken too. Does not regard Entity
        Used to keep Fail messages as Warning, after a recovery

        :type other: OCC.wrapper.Interface.Handle_Interface_Check
        :type failsonly: bool

        """
        return _Interface.Handle_Interface_Check_GetAsWarning(self, *args)


    def Print(self, *args):
        """
        Print(Handle_Interface_Check self, Handle_Message_Messenger S, Standard_Integer const level, Standard_Integer const final=1)

        Prints the messages of the check to an Messenger
        <level> = 1 : only fails
        <level> = 2 : fails and warnings
        <level> = 3 : all (fails, warnings, info msg)
        <final> : if positive (D) prints final values of messages
        if negative, prints originals
        if null, prints both forms

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int
        :type final: int

        """
        return _Interface.Handle_Interface_Check_Print(self, *args)


    def Trace(self, *args):
        """
        Trace(Handle_Interface_Check self, Standard_Integer const level=-1, Standard_Integer const final=1)

        Prints the messages of the check to the default trace file
        By default, according to the default standard level
        Else, according level (see method Print)

        :type level: int
        :type final: int

        """
        return _Interface.Handle_Interface_Check_Trace(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_Check self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_Check_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_Check_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_Check_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_Check self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_Check_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_Check self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_Check self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_Check self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_Check self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Check_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_Check self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_Check_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_Check self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Check_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_Check self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_Check_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_Check self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Check_DecrementRefCounter(self, *args)

Handle_Interface_Check_swigregister = _Interface.Handle_Interface_Check_swigregister
Handle_Interface_Check_swigregister(Handle_Interface_Check)

def Handle_Interface_Check_DownCast(thing):
    return _Interface.Handle_Interface_Check_DownCast(thing)
Handle_Interface_Check_DownCast = _Interface.Handle_Interface_Check_DownCast


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class Interface_GeneralLib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetGlobal(*args):
        """
        SetGlobal(Handle_Interface_GeneralModule amodule, Handle_Interface_Protocol aprotocol)

        Adds a couple (Module-Protocol) into the global definition set
        for this class of Library.

        :type amodule: OCC.wrapper.Interface.Handle_Interface_GeneralModule
        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_GeneralLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def __init__(self, *args):
        """
        __init__(Interface_GeneralLib self, Handle_Interface_Protocol aprotocol) -> Interface_GeneralLib
        __init__(Interface_GeneralLib self) -> Interface_GeneralLib

        Creates an empty Library : it will later by filled by method
        AddProtocol


        """
        this = _Interface.new_Interface_GeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddProtocol(self, *args):
        """
        AddProtocol(Interface_GeneralLib self, Handle_Standard_Transient aprotocol)

        Adds a couple (Module-Protocol) to the Library, given the
        class of a Protocol. Takes Resources into account.
        (if <aprotocol> is not of type TheProtocol, it is not added)

        :type aprotocol: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_GeneralLib_AddProtocol(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_GeneralLib self)

        Clears the list of Modules of a library (can be used to
        redefine the order of Modules before action : Clear then
        refill the Library by calls to AddProtocol)


        """
        return _Interface.Interface_GeneralLib_Clear(self, *args)


    def SetComplete(self, *args):
        """
        SetComplete(Interface_GeneralLib self)

        Sets a library to be defined with the complete Global list
        (all the couples Protocol/Modules recorded in it)


        """
        return _Interface.Interface_GeneralLib_SetComplete(self, *args)


    def Select(self, *args):
        """
        Select(Interface_GeneralLib self, Handle_Standard_Transient obj, Handle_Interface_GeneralModule module) -> Standard_Boolean

        Selects a Module from the Library, given an Object.
        Returns True if Select has succeeded, False else.
        Also Returns (as arguments) the selected Module and the Case
        Number determined by the associated Protocol.
        If Select has failed, <module> is Null Handle and CN is zero.
        (Select can work on any criterium, such as Object DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type module: OCC.wrapper.Interface.Handle_Interface_GeneralModule
        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GeneralLib_Select(self, *args)


    def Start(self, *args):
        """
        Start(Interface_GeneralLib self)

        Starts Iteration on the Modules (sets it on the first one)


        """
        return _Interface.Interface_GeneralLib_Start(self, *args)


    def More(self, *args):
        """
        More(Interface_GeneralLib self) -> Standard_Boolean

        Returns True if there are more Modules to iterate on

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_GeneralLib_More(self, *args)


    def Next(self, *args):
        """
        Next(Interface_GeneralLib self)

        Iterates by getting the next Module in the list
        If there is none, the exception will be raised by Value


        """
        return _Interface.Interface_GeneralLib_Next(self, *args)


    def Module(self, *args):
        """
        Returns the current Module in the Iteration

        :rtype: OCC.wrapper.Interface.Handle_Interface_GeneralModule

        """
        res = _Interface.Interface_GeneralLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the current Protocol in the Iteration

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Interface_GeneralLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_GeneralLib
Interface_GeneralLib_swigregister = _Interface.Interface_GeneralLib_swigregister
Interface_GeneralLib_swigregister(Interface_GeneralLib)

def Interface_GeneralLib_SetGlobal(*args):
    """
    Interface_GeneralLib_SetGlobal(Handle_Interface_GeneralModule amodule, Handle_Interface_Protocol aprotocol)

    Adds a couple (Module-Protocol) into the global definition set
    for this class of Library.

    :type amodule: OCC.wrapper.Interface.Handle_Interface_GeneralModule
    :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

    """
    return _Interface.Interface_GeneralLib_SetGlobal(*args)

class Interface_ParamSet(Standard.Standard_Transient):
    """
    Defines an ordered set of FileParameters, in a way to be
    efficient as in memory requirement or in speed
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_ParamSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_ParamSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_ParamSet self, Standard_Integer const nres, Standard_Integer const nst=1) -> Interface_ParamSet

        Creates an empty ParamSet, beginning at number "nst" and of
        initial reservation "nres" : the "nres" first parameters
        which follow "ndeb" (included) will be put in an Array
        (a ParamList). The remainders are set in Next(s) ParamSet(s)

        :type nres: int
        :type nst: int

        """
        this = _Interface.new_Interface_ParamSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Append(self, *args):
        """
        Append(Interface_ParamSet self, Standard_CString const val, Standard_Integer const lnval, Interface_ParamType const typ, Standard_Integer const nument) -> Standard_Integer
        Append(Interface_ParamSet self, Interface_FileParameter FP) -> Standard_Integer

        Adds a parameter at the end of the ParamSet (transparent
        about reservation and "Next")
        Returns new count of recorded Parameters

        :type FP: OCC.wrapper.Interface.Interface_FileParameter
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ParamSet_Append(self, *args)


    def NbParams(self, *args):
        """
        NbParams(Interface_ParamSet self) -> Standard_Integer

        Returns the total count of parameters (including nexts)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_ParamSet_NbParams(self, *args)


    def Param(self, *args):
        """
        Returns a parameter identified by its number

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Interface_ParamSet_Param(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParam(self, *args):
        """
        ChangeParam(Interface_ParamSet self, Standard_Integer const num) -> Interface_FileParameter

        Same as above, but in order to be modified on place

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_ParamSet_ChangeParam(self, *args)


    def SetParam(self, *args):
        """
        SetParam(Interface_ParamSet self, Standard_Integer const num, Interface_FileParameter FP)

        Changes a parameter identified by its number

        :type num: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_ParamSet_SetParam(self, *args)


    def Params(self, *args):
        """
        Params(Interface_ParamSet self, Standard_Integer const num, Standard_Integer const nb) -> Handle_Interface_ParamList

        Builds and returns the sub-list correspinding to parameters,
        from "num" included, with count "nb"
        If <num> and <nb> are zero, returns the whole list

        :type num: int
        :type nb: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_ParamList

        """
        return _Interface.Interface_ParamSet_Params(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Interface_ParamSet self)

        Destructor (waiting for transparent memory management)


        """
        return _Interface.Interface_ParamSet_Destroy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_ParamSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_ParamSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_ParamSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_ParamSet
Interface_ParamSet_swigregister = _Interface.Interface_ParamSet_swigregister
Interface_ParamSet_swigregister(Interface_ParamSet)

def Interface_ParamSet_get_type_name(*args):
    """
    Interface_ParamSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_ParamSet_get_type_name(*args)

def Interface_ParamSet_get_type_descriptor(*args):
    """
    Interface_ParamSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_ParamSet_get_type_descriptor(*args)

class Interface_LineBuffer(object):
    """
    Simple Management of a Line Buffer, to be used by Interface
    File Writers.
    While a String is suitable to do that, this class ensures an
    optimised Memory Management, because this is a hard point of
    File Writing.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_LineBuffer self, Standard_Integer const size=10) -> Interface_LineBuffer

        Creates a LineBuffer with an absolute maximum size
        (Default value is only to satisfy compiler requirement)

        :type size: int

        """
        this = _Interface.new_Interface_LineBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetMax(self, *args):
        """
        SetMax(Interface_LineBuffer self, Standard_Integer const max)

        Changes Maximum allowed size of Buffer.
        If <max> is Zero, Maximum size is set to the initial size.

        :type max: int

        """
        return _Interface.Interface_LineBuffer_SetMax(self, *args)


    def SetInitial(self, *args):
        """
        SetInitial(Interface_LineBuffer self, Standard_Integer const initial)

        Sets an Initial reservation for Blank characters
        (this reservation is counted in the size of the current Line)

        :type initial: int

        """
        return _Interface.Interface_LineBuffer_SetInitial(self, *args)


    def SetKeep(self, *args):
        """
        SetKeep(Interface_LineBuffer self)

        Sets a Keep Status at current Length. It means that at next
        Move, the new line will begin by characters between Keep + 1
        and current Length


        """
        return _Interface.Interface_LineBuffer_SetKeep(self, *args)


    def CanGet(self, *args):
        """
        CanGet(Interface_LineBuffer self, Standard_Integer const more) -> Standard_Boolean

        Returns True if there is room enough to add <more> characters
        Else, it is required to Dump the Buffer before refilling it
        <more> is recorded to manage SetKeep status

        :type more: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_LineBuffer_CanGet(self, *args)


    def Content(self, *args):
        """
        Content(Interface_LineBuffer self) -> Standard_CString

        Returns the Content of the LineBuffer

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_LineBuffer_Content(self, *args)


    def Length(self, *args):
        """
        Length(Interface_LineBuffer self) -> Standard_Integer

        Returns the Length of the LineBuffer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_LineBuffer_Length(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_LineBuffer self)

        Clears completely the LineBuffer


        """
        return _Interface.Interface_LineBuffer_Clear(self, *args)


    def FreezeInitial(self, *args):
        """
        FreezeInitial(Interface_LineBuffer self)

        Inhibits effect of SetInitial until the next Move (i.e. Keep)
        Then Prepare will not insert initial blanks, but further ones
        will. This allows to cancel initial blanks on an internal Split
        A call to SetInitial has no effect on this until Move


        """
        return _Interface.Interface_LineBuffer_FreezeInitial(self, *args)


    def Move(self, *args):
        """
        Move(Interface_LineBuffer self, TCollection_AsciiString str)
        Move(Interface_LineBuffer self, Handle_TCollection_HAsciiString str)

        Same as above, but <str> is known through a Handle

        :type str: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_LineBuffer_Move(self, *args)


    def Moved(self, *args):
        """
        Moved(Interface_LineBuffer self) -> Handle_TCollection_HAsciiString

        Same as above, but generates the HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Interface_LineBuffer_Moved(self, *args)


    def Add(self, *args):
        """
        Add(Interface_LineBuffer self, Standard_CString const text)
        Add(Interface_LineBuffer self, Standard_CString const text, Standard_Integer const lntext)
        Add(Interface_LineBuffer self, TCollection_AsciiString text)
        Add(Interface_LineBuffer self, Standard_Character const text)

        Adds a text made of only ONE Character

        :type text: OCC.wrapper.Standard.Standard_Character

        """
        return _Interface.Interface_LineBuffer_Add(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_LineBuffer
Interface_LineBuffer_swigregister = _Interface.Interface_LineBuffer_swigregister
Interface_LineBuffer_swigregister(Interface_LineBuffer)

class Handle_Interface_NodeOfGeneralLib(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_NodeOfGeneralLib self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_NodeOfGeneralLib self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_NodeOfGeneralLib self, Interface_NodeOfGeneralLib thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_NodeOfGeneralLib self, Handle_Interface_NodeOfGeneralLib theHandle) -> Handle_Interface_NodeOfGeneralLib
        assign(Handle_Interface_NodeOfGeneralLib self, Interface_NodeOfGeneralLib thePtr) -> Handle_Interface_NodeOfGeneralLib
        assign(Handle_Interface_NodeOfGeneralLib self, Handle_Interface_NodeOfGeneralLib theHandle) -> Handle_Interface_NodeOfGeneralLib

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_NodeOfGeneralLib self) -> Interface_NodeOfGeneralLib

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_NodeOfGeneralLib self) -> Interface_NodeOfGeneralLib

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_NodeOfGeneralLib self) -> Interface_NodeOfGeneralLib

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_NodeOfGeneralLib___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_NodeOfGeneralLib___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_NodeOfGeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_NodeOfGeneralLib_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_NodeOfGeneralLib

    def AddNode(self, *args):
        """
        AddNode(Handle_Interface_NodeOfGeneralLib self, Handle_Interface_GlobalNodeOfGeneralLib anode)

        Adds a couple (Module,Protocol), that is, stores it into
        itself if not yet done, else creates a Next Node to do it

        :type anode: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfGeneralLib

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_AddNode(self, *args)


    def Module(self, *args):
        """
        Returns the Module designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_GeneralModule

        """
        res = _Interface.Handle_Interface_NodeOfGeneralLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the Protocol designated by a precise Node

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Handle_Interface_NodeOfGeneralLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next Node. If none was defined, returned value
        is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_NodeOfGeneralLib

        """
        res = _Interface.Handle_Interface_NodeOfGeneralLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_NodeOfGeneralLib self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_NodeOfGeneralLib_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_NodeOfGeneralLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_NodeOfGeneralLib self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_NodeOfGeneralLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_NodeOfGeneralLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_NodeOfGeneralLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_NodeOfGeneralLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_NodeOfGeneralLib self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_NodeOfGeneralLib self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_NodeOfGeneralLib self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_NodeOfGeneralLib self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_NodeOfGeneralLib_DecrementRefCounter(self, *args)

Handle_Interface_NodeOfGeneralLib_swigregister = _Interface.Handle_Interface_NodeOfGeneralLib_swigregister
Handle_Interface_NodeOfGeneralLib_swigregister(Handle_Interface_NodeOfGeneralLib)

def Handle_Interface_NodeOfGeneralLib_DownCast(thing):
    return _Interface.Handle_Interface_NodeOfGeneralLib_DownCast(thing)
Handle_Interface_NodeOfGeneralLib_DownCast = _Interface.Handle_Interface_NodeOfGeneralLib_DownCast

class Interface_FileReaderTool(object):
    """
    Defines services which are required to load an InterfaceModel
    from a File. Typically, it may firstly transform a system
    file into a FileReaderData object, then work on it, not longer
    considering file contents, to load an Interface Model.
    It may also work on a FileReaderData already loaded.

    FileReaderTool provides, on one hand, some general services
    which are common to all read operations but can be redefined,
    plus general actions to be performed specifically for each
    Norm, as deferred methods to define.

    In particular, FileReaderTool defines the Interface's Unknown
    and Error entities
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetData(self, *args):
        """
        SetData(Interface_FileReaderTool self, Handle_Interface_FileReaderData reader, Handle_Interface_Protocol protocol)

        Sets Data to a FileReaderData. Works with a Protocol

        :type reader: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_FileReaderTool_SetData(self, *args)


    def Protocol(self, *args):
        """
        Protocol(Interface_FileReaderTool self) -> Handle_Interface_Protocol

        Returns the Protocol given at creation time

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Interface_FileReaderTool_Protocol(self, *args)


    def Data(self, *args):
        """
        Data(Interface_FileReaderTool self) -> Handle_Interface_FileReaderData

        Returns the FileReaderData which is used to work

        :rtype: OCC.wrapper.Interface.Handle_Interface_FileReaderData

        """
        return _Interface.Interface_FileReaderTool_Data(self, *args)


    def SetModel(self, *args):
        """
        SetModel(Interface_FileReaderTool self, Handle_Interface_InterfaceModel amodel)

        Stores a Model. Used when the Model has been loaded

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_FileReaderTool_SetModel(self, *args)


    def Model(self, *args):
        """
        Model(Interface_FileReaderTool self) -> Handle_Interface_InterfaceModel

        Returns the stored Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_FileReaderTool_Model(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Interface_FileReaderTool self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_FileReaderTool_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Interface_FileReaderTool self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Interface_FileReaderTool_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Interface_FileReaderTool self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages
        - 0: no trace at all
        - 1: errors
        - 2: errors and warnings
        - 3: all messages
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Interface.Interface_FileReaderTool_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Interface_FileReaderTool self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderTool_TraceLevel(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Interface_FileReaderTool self, Standard_Boolean const err)

        Allows controlling whether exception raisings are handled
        If err is False, they are not (hence, dbx can take control)
        If err is True, they are, and they are traced
        (by putting on messenger Entity's Number and file record num)
        Default given at Model's creation time is True

        :type err: bool

        """
        return _Interface.Interface_FileReaderTool_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Interface_FileReaderTool self) -> Standard_Boolean

        Returns ErrorHandle flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderTool_ErrorHandle(self, *args)


    def SetEntities(self, *args):
        """
        SetEntities(Interface_FileReaderTool self)

        Fills records with empty entities; once done, each entity can
        ask the FileReaderTool for any entity referenced through an
        identifier. Calls Recognize which is specific to each specific
        type of FileReaderTool


        """
        return _Interface.Interface_FileReaderTool_SetEntities(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Interface_FileReaderTool self, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Recognizes a record, given its number. Specific to each
        Interface; called by SetEntities. It can call the basic method
        RecognizeByLib.
        Returns False if recognition has failed, True else.
        <ach> has not to be filled if simply Recognition has failed :
        it must record true error messages : RecognizeByLib can
        generate error messages if NewRead is called

        Note that it works thru a Recognizer (method Evaluate) which
        has to be memorized before starting

        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderTool_Recognize(self, *args)


    def RecognizeByLib(self, *args):
        """
        RecognizeByLib(Interface_FileReaderTool self, Standard_Integer const num, Interface_GeneralLib glib, Interface_ReaderLib rlib, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Recognizes a record with the help of Libraries. Can be used
        to implement the method Recognize.
        <rlib> is used to find Protocol and CaseNumber to apply
        <glib> performs the creation (by service NewVoid, or NewRead
        if NewVoid gave no result)
        <ach> is a check, which is transmitted to NewRead if it is
        called, gives a result but which is false
        <ent> is the result
        Returns False if recognition has failed, True else

        :type num: int
        :type glib: OCC.wrapper.Interface.Interface_GeneralLib
        :type rlib: OCC.wrapper.Interface.Interface_ReaderLib
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderTool_RecognizeByLib(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(Interface_FileReaderTool self) -> Handle_Standard_Transient

        Provides an unknown entity, specific to the Interface
        called by SetEntities when Recognize has failed (Unknown alone)
        or by LoadModel when an Entity has caused a Fail on reading
        (to keep at least its literal description)
        Uses Protocol to do it

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_FileReaderTool_UnknownEntity(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Interface_FileReaderTool self) -> Handle_Interface_InterfaceModel

        Creates an empty Model of the norm. Uses Protocol to do it

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_FileReaderTool_NewModel(self, *args)


    def LoadModel(self, *args):
        """
        LoadModel(Interface_FileReaderTool self, Handle_Interface_InterfaceModel amodel)

        Reads and fills Entities from the FileReaderData set by
        SetData to an InterfaceModel.
        It enchains required operations, the specific ones correspond
        to deferred methods (below) to be defined for each Norm.
        It manages also error recovery and trace.
        Remark : it calls SetModel.
        It Can raise any error which can occur during a load
        operation, unless Error Handling is set.
        This method can also be redefined if judged necessary.

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_FileReaderTool_LoadModel(self, *args)


    def LoadedEntity(self, *args):
        """
        LoadedEntity(Interface_FileReaderTool self, Standard_Integer const num) -> Handle_Standard_Transient

        Reads, Fills and Returns one Entity read from a Record of the
        FileReaderData. This Method manages also case of Fail or
        Warning, by producing a ReportEntyty plus , for a Fail, a
        literal Content (as an UnknownEntity). Performs also Trace

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_FileReaderTool_LoadedEntity(self, *args)


    def BeginRead(self, *args):
        """
        BeginRead(Interface_FileReaderTool self, Handle_Interface_InterfaceModel amodel)

        Fills model's header; each Interface defines for its Model its
        own file header; this method fills it from FileReaderTool.+
        It is called by AnalyseFile from InterfaceModel

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_FileReaderTool_BeginRead(self, *args)


    def AnalyseRecord(self, *args):
        """
        AnalyseRecord(Interface_FileReaderTool self, Standard_Integer const num, Handle_Standard_Transient anent, Handle_Interface_Check acheck) -> Standard_Boolean

        Fills an Entity, given record no; specific to each Interface,
        called by AnalyseFile from InterfaceModel (which manages its
        calling arguments)
        To work, each Interface can define a method in its proper
        Transient class, like this (given as an example) :
        AnalyseRecord (me  : mutable; FR     : in out FileReaderTool;
        num : Integer; acheck : in out Check)
        returns Boolean;
        and call it from AnalyseRecord

        Returned Value : True if the entity could be loaded, False
        else (in case of syntactic fail)

        :type num: int
        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type acheck: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderTool_AnalyseRecord(self, *args)


    def EndRead(self, *args):
        """
        EndRead(Interface_FileReaderTool self, Handle_Interface_InterfaceModel amodel)

        Ends file reading after reading all the entities
        default is doing nothing; redefinable as necessary

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Interface_FileReaderTool_EndRead(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_FileReaderTool self)

        Clear filelds


        """
        return _Interface.Interface_FileReaderTool_Clear(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_FileReaderTool
Interface_FileReaderTool_swigregister = _Interface.Interface_FileReaderTool_swigregister
Interface_FileReaderTool_swigregister(Interface_FileReaderTool)

class Handle_Interface_SignLabel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_SignLabel self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_SignLabel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_SignLabel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_SignLabel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_SignLabel self, Interface_SignLabel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_SignLabel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_SignLabel self, Handle_Interface_SignLabel theHandle) -> Handle_Interface_SignLabel
        assign(Handle_Interface_SignLabel self, Interface_SignLabel thePtr) -> Handle_Interface_SignLabel
        assign(Handle_Interface_SignLabel self, Handle_Interface_SignLabel theHandle) -> Handle_Interface_SignLabel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_SignLabel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_SignLabel self) -> Interface_SignLabel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_SignLabel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_SignLabel self) -> Interface_SignLabel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_SignLabel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_SignLabel self) -> Interface_SignLabel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_SignLabel___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_SignLabel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_SignLabel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_SignLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_SignLabel_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_SignLabel

    def Name(self, *args):
        """
        Name(Handle_Interface_SignLabel self) -> Standard_CString

        Returns "Entity Label"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_SignLabel_Name(self, *args)


    def Text(self, *args):
        """
        Text(Handle_Interface_SignLabel self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Considers context as an InterfaceModel and returns the Label
        computed by it

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Handle_Interface_SignLabel_Text(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_SignLabel self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_SignLabel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_SignLabel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_SignLabel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextAlone(self, *args):
        """
        TextAlone(Handle_Interface_SignLabel self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Handle_Interface_SignLabel_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_SignLabel self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_SignLabel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_SignLabel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_SignLabel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_SignLabel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_SignLabel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_SignLabel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_SignLabel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_SignLabel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_SignLabel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_SignLabel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_SignLabel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_SignLabel self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_SignLabel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_SignLabel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_SignLabel_DecrementRefCounter(self, *args)

Handle_Interface_SignLabel_swigregister = _Interface.Handle_Interface_SignLabel_swigregister
Handle_Interface_SignLabel_swigregister(Handle_Interface_SignLabel)

def Handle_Interface_SignLabel_DownCast(thing):
    return _Interface.Handle_Interface_SignLabel_DownCast(thing)
Handle_Interface_SignLabel_DownCast = _Interface.Handle_Interface_SignLabel_DownCast

class Interface_FileReaderData(Standard.Standard_Transient):
    """
    This class defines services which permit to access Data issued
    from a File, in a form which does not depend of physical
    format : thus, each Record has an attached ParamList (to be
    managed) and resulting Entity.

    Each Interface defines its own FileReaderData : on one hand by
    defining deferred methods given here, on the other hand by
    describing literal data and their accesses, with the help of
    basic classes such as String, Array1OfString, etc...

    FileReaderData is used by a FileReaderTool, which is also
    specific of each Norm, to read an InterfaceModel of the Norm
    FileReaderData inherits TShared to be accessed by Handle :
    this allows FileReaderTool to define more easily the specific
    methods, and improves memory management.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_FileReaderData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_FileReaderData(self) 
            return h


    def NbRecords(self, *args):
        """
        NbRecords(Interface_FileReaderData self) -> Standard_Integer

        Returns the count of registered records
        That is, value given for Initialization (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderData_NbRecords(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Interface_FileReaderData self) -> Standard_Integer

        Returns the count of entities. Depending of each norm, records
        can be Entities or SubParts (SubList in STEP, SubGroup in SET
        ...). NbEntities counts only Entities, not Subs
        Used for memory reservation in InterfaceModel
        Default implementation uses FindNextRecord
        Can be redefined into a more performant way

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderData_NbEntities(self, *args)


    def FindNextRecord(self, *args):
        """
        FindNextRecord(Interface_FileReaderData self, Standard_Integer const num) -> Standard_Integer

        Determines the record number defining an Entity following a
        given record number. Specific to each sub-class of
        FileReaderData. Returning zero means no record found

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderData_FindNextRecord(self, *args)


    def InitParams(self, *args):
        """
        InitParams(Interface_FileReaderData self, Standard_Integer const num)

        attaches an empty ParamList to a Record

        :type num: int

        """
        return _Interface.Interface_FileReaderData_InitParams(self, *args)


    def AddParam(self, *args):
        """
        AddParam(Interface_FileReaderData self, Standard_Integer const num, Standard_CString const aval, Interface_ParamType const atype, Standard_Integer const nument=0)
        AddParam(Interface_FileReaderData self, Standard_Integer const num, TCollection_AsciiString aval, Interface_ParamType const atype, Standard_Integer const nument=0)
        AddParam(Interface_FileReaderData self, Standard_Integer const num, Interface_FileParameter FP)

        Same as above, but gets a complete FileParameter
        Warning : Content of <FP> is NOT copied : its original address and space
        in memory are assumed to be managed elsewhere (see ParamSet)

        :type num: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_FileReaderData_AddParam(self, *args)


    def SetParam(self, *args):
        """
        SetParam(Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump, Interface_FileParameter FP)

        Sets a new value for a parameter of a record, given by :
        num : record number; nump : parameter number in the record

        :type num: int
        :type nump: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_FileReaderData_SetParam(self, *args)


    def NbParams(self, *args):
        """
        NbParams(Interface_FileReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns count of parameters attached to record "num"
        If <num> = 0, returns the total recorded count of parameters

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderData_NbParams(self, *args)


    def Params(self, *args):
        """
        Params(Interface_FileReaderData self, Standard_Integer const num) -> Handle_Interface_ParamList

        Returns the complete ParamList of a record (read only)
        num = 0 to return the whole param list for the file

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_ParamList

        """
        return _Interface.Interface_FileReaderData_Params(self, *args)


    def Param(self, *args):
        """
        Returns parameter "nump" of record "num", as a complete
        FileParameter

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Interface_FileReaderData_Param(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParam(self, *args):
        """
        ChangeParam(Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Interface_FileParameter

        Same as above, but in order to be modified on place

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Interface_FileReaderData_ChangeParam(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Interface_ParamType

        Returns type of parameter "nump" of record "num"
        Returns literal value of parameter "nump" of record "num"
        was C++ : return const &

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Interface_FileReaderData_ParamType(self, *args)


    def ParamCValue(self, *args):
        """
        ParamCValue(Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_CString

        Same as above, but as a CString
        was C++ : return const

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_FileReaderData_ParamCValue(self, *args)


    def IsParamDefined(self, *args):
        """
        IsParamDefined(Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_Boolean

        Returns True if parameter "nump" of record "num" is defined
        (it is not if its type is ParamVoid)

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderData_IsParamDefined(self, *args)


    def ParamNumber(self, *args):
        """
        ParamNumber(Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_Integer

        Returns record number of an entity referenced by a parameter
        of type Ident; 0 if no EntityNumber has been determined
        Note that it is used to reference Entities but also Sublists
        (sublists are not objects, but internal descriptions)

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderData_ParamNumber(self, *args)


    def ParamEntity(self, *args):
        """
        Returns the StepEntity referenced by a parameter
        Error if none

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_FileReaderData_ParamEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamFirstRank(self, *args):
        """
        ParamFirstRank(Interface_FileReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns the absolute rank of the beginning of a record
        (its lsit is from ParamFirstRank+1 to ParamFirstRank+NbParams)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_FileReaderData_ParamFirstRank(self, *args)


    def BoundEntity(self, *args):
        """
        Returns the entity bound to a record, set by SetEntities

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Interface_FileReaderData_BoundEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindEntity(self, *args):
        """
        BindEntity(Interface_FileReaderData self, Standard_Integer const num, Handle_Standard_Transient ent)

        Binds an entity to a record

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Interface_FileReaderData_BindEntity(self, *args)


    def SetErrorLoad(self, *args):
        """
        SetErrorLoad(Interface_FileReaderData self, Standard_Boolean const val)

        Sets the status "Error Load" on, to overside check fails
        <val> True  : declares unloaded
        <val> False : declares loaded
        If not called before loading (see FileReaderTool), check fails
        give the status
        IsErrorLoad says if SetErrorLoad has been called by user
        ResetErrorLoad resets it (called by FileReaderTool)
        This allows to specify that the currently loaded entity
        remains unloaded (because of syntactic fail)

        :type val: bool

        """
        return _Interface.Interface_FileReaderData_SetErrorLoad(self, *args)


    def IsErrorLoad(self, *args):
        """
        IsErrorLoad(Interface_FileReaderData self) -> Standard_Boolean

        Returns True if the status "Error Load" has been set (to True
        or False)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderData_IsErrorLoad(self, *args)


    def ResetErrorLoad(self, *args):
        """
        ResetErrorLoad(Interface_FileReaderData self) -> Standard_Boolean

        Returns the former value of status "Error Load" then resets it
        Used to read the status then ensure it is reset

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_FileReaderData_ResetErrorLoad(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Interface_FileReaderData self)

        Destructor (waiting for memory management)


        """
        return _Interface.Interface_FileReaderData_Destroy(self, *args)


    def Fastof(*args):
        """
        Fastof(Standard_CString const str) -> Standard_Real

        Same spec.s as standard <atof> but 5 times faster

        :type str: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Interface_FileReaderData_Fastof(*args)

    Fastof = staticmethod(Fastof)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_FileReaderData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_FileReaderData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_FileReaderData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_FileReaderData
Interface_FileReaderData_swigregister = _Interface.Interface_FileReaderData_swigregister
Interface_FileReaderData_swigregister(Interface_FileReaderData)

def Interface_FileReaderData_Fastof(*args):
    """
    Interface_FileReaderData_Fastof(Standard_CString const str) -> Standard_Real

    Same spec.s as standard <atof> but 5 times faster

    :type str: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Interface.Interface_FileReaderData_Fastof(*args)

def Interface_FileReaderData_get_type_name(*args):
    """
    Interface_FileReaderData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_FileReaderData_get_type_name(*args)

def Interface_FileReaderData_get_type_descriptor(*args):
    """
    Interface_FileReaderData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_FileReaderData_get_type_descriptor(*args)

class Handle_Interface_GlobalNodeOfReaderLib(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_GlobalNodeOfReaderLib self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_GlobalNodeOfReaderLib self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_GlobalNodeOfReaderLib self, Interface_GlobalNodeOfReaderLib thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_GlobalNodeOfReaderLib self, Handle_Interface_GlobalNodeOfReaderLib theHandle) -> Handle_Interface_GlobalNodeOfReaderLib
        assign(Handle_Interface_GlobalNodeOfReaderLib self, Interface_GlobalNodeOfReaderLib thePtr) -> Handle_Interface_GlobalNodeOfReaderLib
        assign(Handle_Interface_GlobalNodeOfReaderLib self, Handle_Interface_GlobalNodeOfReaderLib theHandle) -> Handle_Interface_GlobalNodeOfReaderLib

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_GlobalNodeOfReaderLib self) -> Interface_GlobalNodeOfReaderLib

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_GlobalNodeOfReaderLib self) -> Interface_GlobalNodeOfReaderLib

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_GlobalNodeOfReaderLib self) -> Interface_GlobalNodeOfReaderLib

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_GlobalNodeOfReaderLib___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_GlobalNodeOfReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_GlobalNodeOfReaderLib

    def Add(self, *args):
        """
        Add(Handle_Interface_GlobalNodeOfReaderLib self, Handle_Interface_ReaderModule amodule, Handle_Interface_Protocol aprotocol)

        Adds a Module bound with a Protocol to the list : does
        nothing if already in the list, THAT IS, Same Type (exact
        match) and Same State (that is, IsEqual is not required)
        Once added, stores its attached Protocol in correspondance

        :type amodule: OCC.wrapper.Interface.Handle_Interface_ReaderModule
        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_Add(self, *args)


    def Module(self, *args):
        """
        Returns the Module stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_ReaderModule

        """
        res = _Interface.Handle_Interface_GlobalNodeOfReaderLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the attached Protocol stored in a given GlobalNode

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _Interface.Handle_Interface_GlobalNodeOfReaderLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next GlobalNode. If none is defined, returned
        value is a Null Handle

        :rtype: OCC.wrapper.Interface.Handle_Interface_GlobalNodeOfReaderLib

        """
        res = _Interface.Handle_Interface_GlobalNodeOfReaderLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_GlobalNodeOfReaderLib self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GlobalNodeOfReaderLib_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_GlobalNodeOfReaderLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_GlobalNodeOfReaderLib self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_GlobalNodeOfReaderLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_GlobalNodeOfReaderLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_GlobalNodeOfReaderLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_GlobalNodeOfReaderLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_GlobalNodeOfReaderLib self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_GlobalNodeOfReaderLib self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_GlobalNodeOfReaderLib self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_GlobalNodeOfReaderLib self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_GlobalNodeOfReaderLib_DecrementRefCounter(self, *args)

Handle_Interface_GlobalNodeOfReaderLib_swigregister = _Interface.Handle_Interface_GlobalNodeOfReaderLib_swigregister
Handle_Interface_GlobalNodeOfReaderLib_swigregister(Handle_Interface_GlobalNodeOfReaderLib)

def Handle_Interface_GlobalNodeOfReaderLib_DownCast(thing):
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast(thing)
Handle_Interface_GlobalNodeOfReaderLib_DownCast = _Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast

class Handle_Interface_FileReaderData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_FileReaderData self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_FileReaderData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_FileReaderData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_FileReaderData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_FileReaderData self, Interface_FileReaderData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_FileReaderData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_FileReaderData self, Handle_Interface_FileReaderData theHandle) -> Handle_Interface_FileReaderData
        assign(Handle_Interface_FileReaderData self, Interface_FileReaderData thePtr) -> Handle_Interface_FileReaderData
        assign(Handle_Interface_FileReaderData self, Handle_Interface_FileReaderData theHandle) -> Handle_Interface_FileReaderData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_FileReaderData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_FileReaderData self) -> Interface_FileReaderData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_FileReaderData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_FileReaderData self) -> Interface_FileReaderData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_FileReaderData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_FileReaderData self) -> Interface_FileReaderData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_FileReaderData___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_FileReaderData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_FileReaderData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_FileReaderData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_FileReaderData_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_FileReaderData

    def NbRecords(self, *args):
        """
        NbRecords(Handle_Interface_FileReaderData self) -> Standard_Integer

        Returns the count of registered records
        That is, value given for Initialization (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_NbRecords(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Handle_Interface_FileReaderData self) -> Standard_Integer

        Returns the count of entities. Depending of each norm, records
        can be Entities or SubParts (SubList in STEP, SubGroup in SET
        ...). NbEntities counts only Entities, not Subs
        Used for memory reservation in InterfaceModel
        Default implementation uses FindNextRecord
        Can be redefined into a more performant way

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_NbEntities(self, *args)


    def FindNextRecord(self, *args):
        """
        FindNextRecord(Handle_Interface_FileReaderData self, Standard_Integer const num) -> Standard_Integer

        Determines the record number defining an Entity following a
        given record number. Specific to each sub-class of
        FileReaderData. Returning zero means no record found

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_FindNextRecord(self, *args)


    def InitParams(self, *args):
        """
        InitParams(Handle_Interface_FileReaderData self, Standard_Integer const num)

        attaches an empty ParamList to a Record

        :type num: int

        """
        return _Interface.Handle_Interface_FileReaderData_InitParams(self, *args)


    def AddParam(self, *args):
        """
        AddParam(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_CString const aval, Interface_ParamType const atype, Standard_Integer const nument=0)
        AddParam(Handle_Interface_FileReaderData self, Standard_Integer const num, TCollection_AsciiString aval, Interface_ParamType const atype, Standard_Integer const nument=0)
        AddParam(Handle_Interface_FileReaderData self, Standard_Integer const num, Interface_FileParameter FP)

        Same as above, but gets a complete FileParameter
        Warning : Content of <FP> is NOT copied : its original address and space
        in memory are assumed to be managed elsewhere (see ParamSet)

        :type num: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_FileReaderData_AddParam(self, *args)


    def SetParam(self, *args):
        """
        SetParam(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump, Interface_FileParameter FP)

        Sets a new value for a parameter of a record, given by :
        num : record number; nump : parameter number in the record

        :type num: int
        :type nump: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_FileReaderData_SetParam(self, *args)


    def NbParams(self, *args):
        """
        NbParams(Handle_Interface_FileReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns count of parameters attached to record "num"
        If <num> = 0, returns the total recorded count of parameters

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_NbParams(self, *args)


    def Params(self, *args):
        """
        Params(Handle_Interface_FileReaderData self, Standard_Integer const num) -> Handle_Interface_ParamList

        Returns the complete ParamList of a record (read only)
        num = 0 to return the whole param list for the file

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_ParamList

        """
        return _Interface.Handle_Interface_FileReaderData_Params(self, *args)


    def Param(self, *args):
        """
        Returns parameter "nump" of record "num", as a complete
        FileParameter

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Handle_Interface_FileReaderData_Param(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParam(self, *args):
        """
        ChangeParam(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Interface_FileParameter

        Same as above, but in order to be modified on place

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_FileReaderData_ChangeParam(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Interface_ParamType

        Returns type of parameter "nump" of record "num"
        Returns literal value of parameter "nump" of record "num"
        was C++ : return const &

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Handle_Interface_FileReaderData_ParamType(self, *args)


    def ParamCValue(self, *args):
        """
        ParamCValue(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_CString

        Same as above, but as a CString
        was C++ : return const

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_FileReaderData_ParamCValue(self, *args)


    def IsParamDefined(self, *args):
        """
        IsParamDefined(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_Boolean

        Returns True if parameter "nump" of record "num" is defined
        (it is not if its type is ParamVoid)

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_FileReaderData_IsParamDefined(self, *args)


    def ParamNumber(self, *args):
        """
        ParamNumber(Handle_Interface_FileReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_Integer

        Returns record number of an entity referenced by a parameter
        of type Ident; 0 if no EntityNumber has been determined
        Note that it is used to reference Entities but also Sublists
        (sublists are not objects, but internal descriptions)

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_ParamNumber(self, *args)


    def ParamEntity(self, *args):
        """
        Returns the StepEntity referenced by a parameter
        Error if none

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Handle_Interface_FileReaderData_ParamEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamFirstRank(self, *args):
        """
        ParamFirstRank(Handle_Interface_FileReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns the absolute rank of the beginning of a record
        (its lsit is from ParamFirstRank+1 to ParamFirstRank+NbParams)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_ParamFirstRank(self, *args)


    def BoundEntity(self, *args):
        """
        Returns the entity bound to a record, set by SetEntities

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Handle_Interface_FileReaderData_BoundEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindEntity(self, *args):
        """
        BindEntity(Handle_Interface_FileReaderData self, Standard_Integer const num, Handle_Standard_Transient ent)

        Binds an entity to a record

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_FileReaderData_BindEntity(self, *args)


    def SetErrorLoad(self, *args):
        """
        SetErrorLoad(Handle_Interface_FileReaderData self, Standard_Boolean const val)

        Sets the status "Error Load" on, to overside check fails
        <val> True  : declares unloaded
        <val> False : declares loaded
        If not called before loading (see FileReaderTool), check fails
        give the status
        IsErrorLoad says if SetErrorLoad has been called by user
        ResetErrorLoad resets it (called by FileReaderTool)
        This allows to specify that the currently loaded entity
        remains unloaded (because of syntactic fail)

        :type val: bool

        """
        return _Interface.Handle_Interface_FileReaderData_SetErrorLoad(self, *args)


    def IsErrorLoad(self, *args):
        """
        IsErrorLoad(Handle_Interface_FileReaderData self) -> Standard_Boolean

        Returns True if the status "Error Load" has been set (to True
        or False)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_FileReaderData_IsErrorLoad(self, *args)


    def ResetErrorLoad(self, *args):
        """
        ResetErrorLoad(Handle_Interface_FileReaderData self) -> Standard_Boolean

        Returns the former value of status "Error Load" then resets it
        Used to read the status then ensure it is reset

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_FileReaderData_ResetErrorLoad(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Handle_Interface_FileReaderData self)

        Destructor (waiting for memory management)


        """
        return _Interface.Handle_Interface_FileReaderData_Destroy(self, *args)


    def Fastof(self, *args):
        """
        Fastof(Handle_Interface_FileReaderData self, Standard_CString const str) -> Standard_Real

        Same spec.s as standard <atof> but 5 times faster

        :type str: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Handle_Interface_FileReaderData_Fastof(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_FileReaderData self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_FileReaderData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_FileReaderData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_FileReaderData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_FileReaderData self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_FileReaderData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_FileReaderData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_FileReaderData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_FileReaderData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_FileReaderData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_FileReaderData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_FileReaderData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_FileReaderData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_FileReaderData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_FileReaderData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_FileReaderData self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_FileReaderData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_FileReaderData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_FileReaderData_DecrementRefCounter(self, *args)

Handle_Interface_FileReaderData_swigregister = _Interface.Handle_Interface_FileReaderData_swigregister
Handle_Interface_FileReaderData_swigregister(Handle_Interface_FileReaderData)

def Handle_Interface_FileReaderData_DownCast(thing):
    return _Interface.Handle_Interface_FileReaderData_DownCast(thing)
Handle_Interface_FileReaderData_DownCast = _Interface.Handle_Interface_FileReaderData_DownCast

class Handle_Interface_ReaderModule(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_ReaderModule self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_ReaderModule_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_ReaderModule self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_ReaderModule_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_ReaderModule self, Interface_ReaderModule thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_ReaderModule_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_ReaderModule self, Handle_Interface_ReaderModule theHandle) -> Handle_Interface_ReaderModule
        assign(Handle_Interface_ReaderModule self, Interface_ReaderModule thePtr) -> Handle_Interface_ReaderModule
        assign(Handle_Interface_ReaderModule self, Handle_Interface_ReaderModule theHandle) -> Handle_Interface_ReaderModule

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_ReaderModule_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_ReaderModule self) -> Interface_ReaderModule

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_ReaderModule_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_ReaderModule self) -> Interface_ReaderModule

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_ReaderModule___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_ReaderModule self) -> Interface_ReaderModule

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_ReaderModule___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_ReaderModule___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_ReaderModule___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_ReaderModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_ReaderModule_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_ReaderModule

    def CaseNum(self, *args):
        """
        CaseNum(Handle_Interface_ReaderModule self, Handle_Interface_FileReaderData data, Standard_Integer const num) -> Standard_Integer

        Translates the type of record <num> in <data> to a positive
        Case Number. If Recognition fails, must return 0

        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ReaderModule_CaseNum(self, *args)


    def Read(self, *args):
        """
        Read(Handle_Interface_ReaderModule self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        Performs the effective loading from <data>, record <num>,
        to the Entity <ent> formerly created
        In case of Error or Warning, fills <ach> with messages
        Remark that the Case Number comes from translating a record

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_ReaderModule_Read(self, *args)


    def NewRead(self, *args):
        """
        NewRead(Handle_Interface_ReaderModule self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific operator (create+read) defaulted to do nothing.
        It can be redefined when it is not possible to work in two
        steps (NewVoid then Read). This occurs when no default
        constructor is defined : hence the result <ent> must be
        created with an effective definition from the reader.
        Remark : if NewRead is defined, Copy has nothing to do.

        Returns True if it has produced something, false else.
        If nothing was produced, <ach> should be filled : it will be
        treated as "Unrecognized case" by reader tool.

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReaderModule_NewRead(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_ReaderModule self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_ReaderModule_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ReaderModule_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ReaderModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_ReaderModule self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_ReaderModule_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_ReaderModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_ReaderModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReaderModule_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_ReaderModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_ReaderModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ReaderModule_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_ReaderModule self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_ReaderModule_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_ReaderModule self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ReaderModule_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_ReaderModule self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_ReaderModule_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_ReaderModule self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ReaderModule_DecrementRefCounter(self, *args)

Handle_Interface_ReaderModule_swigregister = _Interface.Handle_Interface_ReaderModule_swigregister
Handle_Interface_ReaderModule_swigregister(Handle_Interface_ReaderModule)

def Handle_Interface_ReaderModule_DownCast(thing):
    return _Interface.Handle_Interface_ReaderModule_DownCast(thing)
Handle_Interface_ReaderModule_DownCast = _Interface.Handle_Interface_ReaderModule_DownCast

class Handle_Interface_InterfaceError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_InterfaceError self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_InterfaceError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_InterfaceError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_InterfaceError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_InterfaceError self, Interface_InterfaceError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_InterfaceError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_InterfaceError self, Handle_Interface_InterfaceError theHandle) -> Handle_Interface_InterfaceError
        assign(Handle_Interface_InterfaceError self, Interface_InterfaceError thePtr) -> Handle_Interface_InterfaceError
        assign(Handle_Interface_InterfaceError self, Handle_Interface_InterfaceError theHandle) -> Handle_Interface_InterfaceError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_InterfaceError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_InterfaceError self) -> Interface_InterfaceError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_InterfaceError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_InterfaceError self) -> Interface_InterfaceError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_InterfaceError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_InterfaceError self) -> Interface_InterfaceError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_InterfaceError___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_InterfaceError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_InterfaceError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_InterfaceError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_InterfaceError_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_InterfaceError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Interface_InterfaceError self, Standard_CString const theMessage) -> Handle_Interface_InterfaceError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceError

        """
        return _Interface.Handle_Interface_InterfaceError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_InterfaceError self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_InterfaceError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_InterfaceError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_InterfaceError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Interface_InterfaceError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Interface.Handle_Interface_InterfaceError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Interface_InterfaceError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_InterfaceError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Interface_InterfaceError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_InterfaceError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Interface_InterfaceError self)
        Reraise(Handle_Interface_InterfaceError self, Standard_CString const aMessage)
        Reraise(Handle_Interface_InterfaceError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Interface.Handle_Interface_InterfaceError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Interface_InterfaceError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Interface.Handle_Interface_InterfaceError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Interface_InterfaceError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Interface.Handle_Interface_InterfaceError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_InterfaceError self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_InterfaceError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_InterfaceError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_InterfaceError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_InterfaceError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_InterfaceError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_InterfaceError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_InterfaceError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_InterfaceError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_InterfaceError self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_InterfaceError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_InterfaceError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceError_DecrementRefCounter(self, *args)

Handle_Interface_InterfaceError_swigregister = _Interface.Handle_Interface_InterfaceError_swigregister
Handle_Interface_InterfaceError_swigregister(Handle_Interface_InterfaceError)

def Handle_Interface_InterfaceError_DownCast(thing):
    return _Interface.Handle_Interface_InterfaceError_DownCast(thing)
Handle_Interface_InterfaceError_DownCast = _Interface.Handle_Interface_InterfaceError_DownCast

class Handle_Interface_InterfaceModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_InterfaceModel self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_InterfaceModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_InterfaceModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_InterfaceModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_InterfaceModel self, Interface_InterfaceModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_InterfaceModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_InterfaceModel self, Handle_Interface_InterfaceModel theHandle) -> Handle_Interface_InterfaceModel
        assign(Handle_Interface_InterfaceModel self, Interface_InterfaceModel thePtr) -> Handle_Interface_InterfaceModel
        assign(Handle_Interface_InterfaceModel self, Handle_Interface_InterfaceModel theHandle) -> Handle_Interface_InterfaceModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_InterfaceModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_InterfaceModel self) -> Interface_InterfaceModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_InterfaceModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_InterfaceModel self) -> Interface_InterfaceModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_InterfaceModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_InterfaceModel self) -> Interface_InterfaceModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_InterfaceModel___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_InterfaceModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_InterfaceModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_InterfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_InterfaceModel_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_InterfaceModel

    def Destroy(self, *args):
        """
        Destroy(Handle_Interface_InterfaceModel self)

        Clears the list of entities (service WhenDelete)


        """
        return _Interface.Handle_Interface_InterfaceModel_Destroy(self, *args)


    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_Interface_InterfaceModel self, Handle_Interface_Protocol proto)

        Sets a Protocol for this Model
        It is also set by a call to AddWithRefs with Protocol
        It is used for : DumpHeader (as required), ClearEntities ...

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_InterfaceModel_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Protocol(Handle_Interface_InterfaceModel self) -> Handle_Interface_Protocol

        Returns the Protocol which has been set by SetProtocol, or
        AddWithRefs with Protocol

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _Interface.Handle_Interface_InterfaceModel_Protocol(self, *args)


    def SetGTool(self, *args):
        """
        SetGTool(Handle_Interface_InterfaceModel self, Handle_Interface_GTool gtool)

        Sets a GTool for this model, which already defines a Protocol

        :type gtool: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        return _Interface.Handle_Interface_InterfaceModel_SetGTool(self, *args)


    def GTool(self, *args):
        """
        GTool(Handle_Interface_InterfaceModel self) -> Handle_Interface_GTool

        Returns the GTool, set by SetProtocol or by SetGTool

        :rtype: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        return _Interface.Handle_Interface_InterfaceModel_GTool(self, *args)


    def DispatchStatus(self, *args):
        """
        DispatchStatus(Handle_Interface_InterfaceModel self) -> Standard_Boolean &

        Returns the Dispatch Status, either for get or set
        A Model which is produced from Dispatch may share entities
        with the original (according to the Protocol), hence these
        non-copied entities should not be deleted

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_DispatchStatus(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_Interface_InterfaceModel self)

        Erases contained data; used when a Model is copied to others :
        the new copied ones begin from clear
        Clear calls specific method ClearHeader (see below)


        """
        return _Interface.Handle_Interface_InterfaceModel_Clear(self, *args)


    def ClearEntities(self, *args):
        """
        ClearEntities(Handle_Interface_InterfaceModel self)

        Clears the entities; uses the general service WhenDelete, in
        addition to the standard Memory Manager; can be redefined


        """
        return _Interface.Handle_Interface_InterfaceModel_ClearEntities(self, *args)


    def ClearLabels(self, *args):
        """
        ClearLabels(Handle_Interface_InterfaceModel self)

        Erases informations about labels, if any : specific to each
        norm


        """
        return _Interface.Handle_Interface_InterfaceModel_ClearLabels(self, *args)


    def ClearHeader(self, *args):
        """
        ClearHeader(Handle_Interface_InterfaceModel self)

        Clears Model's header : specific to each norm


        """
        return _Interface.Handle_Interface_InterfaceModel_ClearHeader(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Handle_Interface_InterfaceModel self) -> Standard_Integer

        Returns count of contained Entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_NbEntities(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Interface_InterfaceModel self, Handle_Standard_Transient anentity) -> Standard_Boolean

        Returns True if a Model contains an Entity (for a ReportEntity,
        looks for the ReportEntity itself AND its Concerned Entity)

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_Contains(self, *args)


    def Number(self, *args):
        """
        Number(Handle_Interface_InterfaceModel self, Handle_Standard_Transient anentity) -> Standard_Integer

        Returns the Number of an Entity in the Model if it contains it.
        Else returns 0. For a ReportEntity, looks at Concerned Entity.
        Returns the Directory entry   Number of  an Entity in
        the  Model if it contains it.   Else returns  0.  For a
        ReportEntity, looks at Concerned Entity.

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_Number(self, *args)


    def Value(self, *args):
        """
        Returns an Entity identified by its number in the Model
        Each sub-class of InterfaceModel can define its own method
        Entity to return its specific class of Entity (e.g. for VDA,
        VDAModel returns a VDAEntity), working by calling Value
        Remark : For a Reported Entity, (Erroneous, Corrected, Unknown), this
        method returns this Reported Entity.
        See ReportEntity for other questions.

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Interface.Handle_Interface_InterfaceModel_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbTypes(self, *args):
        """
        NbTypes(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Defined by the Protocol, which gives default as
        1 (dynamic Type).

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent, Standard_Integer const num=1) -> Handle_Standard_Type

        Returns a type, given its rank : defined by the Protocol
        (by default, the first one)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Handle_Interface_InterfaceModel_Type(self, *args)


    def TypeName(self, *args):
        """
        TypeName(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent, Standard_Boolean const complete) -> Standard_CString

        Returns the type name of an entity, from the list of types
        (one or more ...)
        <complete> True (D) gives the complete type, else packages are
        removed
        WARNING : buffered, to be immediately copied or printed

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type complete: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_InterfaceModel_TypeName(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_Interface_InterfaceModel self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_InterfaceModel_ClassName(self, *args)


    def EntityState(self, *args):
        """
        EntityState(Handle_Interface_InterfaceModel self, Standard_Integer const num) -> Interface_DataState

        Returns the State of an entity, given its number

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_DataState

        """
        return _Interface.Handle_Interface_InterfaceModel_EntityState(self, *args)


    def IsReportEntity(self, *args):
        """
        IsReportEntity(Handle_Interface_InterfaceModel self, Standard_Integer const num, Standard_Boolean const semantic) -> Standard_Boolean

        Returns True if <num> identifies a ReportEntity in the Model
        Hence, ReportEntity can be called.

        By default, queries main report, if <semantic> is True, it
        queries report for semantic check

        Remember that a Report Entity can be defined for an Unknown
        Entity, or a Corrected or Erroneous (at read time) Entity.
        The ReportEntity is defined before call to method AddEntity.

        :type num: int
        :type semantic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_IsReportEntity(self, *args)


    def ReportEntity(self, *args):
        """
        ReportEntity(Handle_Interface_InterfaceModel self, Standard_Integer const num, Standard_Boolean const semantic) -> Handle_Interface_ReportEntity

        Returns a ReportEntity identified by its number in the Model,
        or a Null Handle If <num> does not identify a ReportEntity.

        By default, queries main report, if <semantic> is True, it
        queries report for semantic check

        :type num: int
        :type semantic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_ReportEntity

        """
        return _Interface.Handle_Interface_InterfaceModel_ReportEntity(self, *args)


    def IsErrorEntity(self, *args):
        """
        IsErrorEntity(Handle_Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Error Entity : in this
        case, a ReportEntity brings Fail Messages and possibly an
        "undefined" Content, see IsRedefinedEntity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_IsErrorEntity(self, *args)


    def IsRedefinedContent(self, *args):
        """
        IsRedefinedContent(Handle_Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Entity which content is
        redefined through a ReportEntity (i.e. with literal data only)
        This happens when an entity is syntactically erroneous in the
        way that its basic content remains empty.
        For more details (such as content itself), see ReportEntity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_IsRedefinedContent(self, *args)


    def ClearReportEntity(self, *args):
        """
        ClearReportEntity(Handle_Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Removes the ReportEntity attached to Entity <num>. Returns
        True if done, False if no ReportEntity was attached to <num>.
        Warning : the caller must assume that this clearing is meaningfull

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_ClearReportEntity(self, *args)


    def SetReportEntity(self, *args):
        """
        SetReportEntity(Handle_Interface_InterfaceModel self, Standard_Integer const num, Handle_Interface_ReportEntity rep) -> Standard_Boolean

        Sets or Replaces a ReportEntity for the Entity <num>. Returns
        True if Report is replaced, False if it has been replaced
        Warning : the caller must assume that this setting is meaningfull

        :type num: int
        :type rep: OCC.wrapper.Interface.Handle_Interface_ReportEntity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_SetReportEntity(self, *args)


    def AddReportEntity(self, *args):
        """
        AddReportEntity(Handle_Interface_InterfaceModel self, Handle_Interface_ReportEntity rep, Standard_Boolean const semantic) -> Standard_Boolean

        Adds a ReportEntity as such. Returns False if the concerned
        entity is not recorded in the Model
        Else, adds it into, either the main report list or the
        list for semantic checks, then returns True

        :type rep: OCC.wrapper.Interface.Handle_Interface_ReportEntity
        :type semantic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_AddReportEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Handle_Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Unknown Entity : in this
        case, a ReportEntity with no Check Messages designates it.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_IsUnknownEntity(self, *args)


    def FillSemanticChecks(self, *args):
        """
        FillSemanticChecks(Handle_Interface_InterfaceModel self, Interface_CheckIterator checks, Standard_Boolean const clear)

        Fills the list of semantic checks.
        This list is computed (by CheckTool). Hence, it can be stored
        in the model for later queries
        <clear> True (D) : new list replaces
        <clear> False    : new list is cumulated

        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type clear: bool

        """
        return _Interface.Handle_Interface_InterfaceModel_FillSemanticChecks(self, *args)


    def HasSemanticChecks(self, *args):
        """
        HasSemanticChecks(Handle_Interface_InterfaceModel self) -> Standard_Boolean

        Returns True if semantic checks have been filled

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_HasSemanticChecks(self, *args)


    def Check(self, *args):
        """
        Returns the check attached to an entity, designated by its
        Number. 0 for global check
        <semantic> True  : recorded semantic check
        <semantic> False : recorded syntactic check (see ReportEntity)
        If no check is recorded for <num>, returns an empty Check

        :type num: int
        :type syntactic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Handle_Interface_InterfaceModel_Check(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reservate(self, *args):
        """
        Reservate(Handle_Interface_InterfaceModel self, Standard_Integer const nbent)

        Does a reservation for the List of Entities (for optimized
        storage management). If it is not called, storage management
        can be less efficient. <nbent> is the expected count of
        Entities to store

        :type nbent: int

        """
        return _Interface.Handle_Interface_InterfaceModel_Reservate(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Handle_Interface_InterfaceModel self, Handle_Standard_Transient anentity)

        Internal method for adding an Entity. Used by file reading
        (defined by each Interface) and Transfer tools. It adds the
        entity required to be added, not its refs : see AddWithRefs.
        If <anentity> is a ReportEntity, it is added to the list of
        Reports, its Concerned Entity (Erroneous or Corrected, else
        Unknown) is added to the list of Entities.
        That is, the ReportEntity must be created before Adding

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_InterfaceModel_AddEntity(self, *args)


    def AddWithRefs(self, *args):
        """
        AddWithRefs(Handle_Interface_InterfaceModel self, Handle_Standard_Transient anent, Handle_Interface_Protocol proto, Standard_Integer const level=0, Standard_Boolean const listall)
        AddWithRefs(Handle_Interface_InterfaceModel self, Handle_Standard_Transient anent, Standard_Integer const level=0, Standard_Boolean const listall)
        AddWithRefs(Handle_Interface_InterfaceModel self, Handle_Standard_Transient anent, Interface_GeneralLib lib, Standard_Integer const level=0, Standard_Boolean const listall)

        Same as above, but works with an already created GeneralLib

        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type lib: OCC.wrapper.Interface.Interface_GeneralLib
        :type level: int
        :type listall: bool

        """
        return _Interface.Handle_Interface_InterfaceModel_AddWithRefs(self, *args)


    def ReplaceEntity(self, *args):
        """
        ReplaceEntity(Handle_Interface_InterfaceModel self, Standard_Integer const nument, Handle_Standard_Transient anent)

        Replace Entity with Number=nument on other entity - "anent"

        :type nument: int
        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_InterfaceModel_ReplaceEntity(self, *args)


    def ReverseOrders(self, *args):
        """
        ReverseOrders(Handle_Interface_InterfaceModel self, Standard_Integer const after=0)

        Reverses the Numbers of the Entities, between <after> and the
        total count of Entities. Thus, the entities :
        1,2 ... after, after+1 ... nb-1, nb  become numbered as :
        1,2 ... after, nb, nb-1 ... after+1
        By default (after = 0) the whole list of Entities is reversed

        :type after: int

        """
        return _Interface.Handle_Interface_InterfaceModel_ReverseOrders(self, *args)


    def ChangeOrder(self, *args):
        """
        ChangeOrder(Handle_Interface_InterfaceModel self, Standard_Integer const oldnum, Standard_Integer const newnum, Standard_Integer const count=1)

        Changes the Numbers of some Entities : <oldnum> is moved to
        <newnum>, same for <count> entities. Thus :
        1,2 ... newnum-1 newnum ... oldnum .. oldnum+count oldnum+count+1 .. gives
        1,2 ... newnum-1 oldnum .. oldnum+count newnum ... oldnum+count+1
        (can be seen as a circular permutation)

        :type oldnum: int
        :type newnum: int
        :type count: int

        """
        return _Interface.Handle_Interface_InterfaceModel_ChangeOrder(self, *args)


    def GetFromTransfer(self, *args):
        """
        GetFromTransfer(Handle_Interface_InterfaceModel self, Interface_EntityIterator aniter)

        Gets contents from an EntityIterator, prepared by a
        Transfer tool (e.g TransferCopy). Starts from clear

        :type aniter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_InterfaceModel_GetFromTransfer(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(Handle_Interface_InterfaceModel self, Handle_Interface_InterfaceModel other)

        Gets header (data specific of a defined Interface) from
        another InterfaceModel; called from TransferCopy

        :type other: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Handle_Interface_InterfaceModel_GetFromAnother(self, *args)


    def NewEmptyModel(self, *args):
        """
        NewEmptyModel(Handle_Interface_InterfaceModel self) -> Handle_Interface_InterfaceModel

        Returns a New Empty Model, same type as <me> (whatever its
        Type); called to Copy parts a Model into other ones, then
        followed by a call to GetFromAnother (Header) then filling
        with specified Entities, themselves copied

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Handle_Interface_InterfaceModel_NewEmptyModel(self, *args)


    def SetCategoryNumber(self, *args):
        """
        SetCategoryNumber(Handle_Interface_InterfaceModel self, Standard_Integer const num, Standard_Integer const val) -> Standard_Boolean

        Records a category number for an entity number
        Returns True when done, False if <num> is out of range

        :type num: int
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_SetCategoryNumber(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_Interface_InterfaceModel self, Standard_Integer const num) -> Standard_Integer

        Returns the recorded category number for a given entity number
        0 if none was defined for this entity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_CategoryNumber(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_Interface_InterfaceModel self, Interface_EntityIterator iter)

        Allows an EntityIterator to get a list of Entities

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_InterfaceModel_FillIterator(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_Interface_InterfaceModel self) -> Interface_EntityIterator

        Returns the list of all Entities, as an Iterator on Entities
        (the Entities themselves, not the Reports)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_InterfaceModel_Entities(self, *args)


    def Reports(self, *args):
        """
        Reports(Handle_Interface_InterfaceModel self, Standard_Boolean const semantic) -> Interface_EntityIterator

        Returns the list of all ReportEntities, i.e. data about
        Entities read with Error or Warning informations
        (each item has to be casted to Report Entity then it can be
        queried for Concerned Entity, Content, Check ...)
        By default, returns the main reports, is <semantic> is True it
        returns the list for sematic checks

        :type semantic: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_InterfaceModel_Reports(self, *args)


    def Redefineds(self, *args):
        """
        Redefineds(Handle_Interface_InterfaceModel self) -> Interface_EntityIterator

        Returns the list of ReportEntities which redefine data
        (generally, if concerned entity is "Error", a literal content
        is added to it : this is a "redefined entity"

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Interface.Handle_Interface_InterfaceModel_Redefineds(self, *args)


    def GlobalCheck(self, *args):
        """
        Returns the GlobalCheck, which memorizes messages global to
        the file (not specific to an Entity), especially Header

        :type syntactic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _Interface.Handle_Interface_InterfaceModel_GlobalCheck(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetGlobalCheck(self, *args):
        """
        SetGlobalCheck(Handle_Interface_InterfaceModel self, Handle_Interface_Check ach)

        Allows to modify GlobalCheck, after getting then completing it
        Remark : it is SYNTACTIC check. Semantics, see FillChecks

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Handle_Interface_InterfaceModel_SetGlobalCheck(self, *args)


    def VerifyCheck(self, *args):
        """
        VerifyCheck(Handle_Interface_InterfaceModel self, Handle_Interface_Check ach)

        Minimum Semantic Global Check on data in model (header)
        Can only check basic Data. See also GlobalCheck from Protocol
        for a check which takes the Graph into account
        Default does nothing, can be redefined

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Interface.Handle_Interface_InterfaceModel_VerifyCheck(self, *args)


    def DumpHeader(self, *args):
        """
        DumpHeader(Handle_Interface_InterfaceModel self, Handle_Message_Messenger S, Standard_Integer const level=0)

        Dumps Header in a short, easy to read, form, onto a Stream
        <level> allows to print more or less parts of the header,
        if necessary. 0 for basic print

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int

        """
        return _Interface.Handle_Interface_InterfaceModel_DumpHeader(self, *args)


    def Print(self, *args):
        """
        Print(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent, Handle_Message_Messenger s, Standard_Integer const mode=0)

        Prints identification of a given entity in <me>, in order to
        be printed in a list or phrase
        <mode> < 0 : prints only its number
        <mode> = 1 : just calls PrintLabel
        <mode> = 0 (D) : prints its number plus '/' plus PrintLabel
        If <ent> == <me>, simply prints "Global"
        If <ent> is unknown, prints "??/its type"

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type s: OCC.wrapper.Message.Handle_Message_Messenger
        :type mode: int

        """
        return _Interface.Handle_Interface_InterfaceModel_Print(self, *args)


    def PrintLabel(self, *args):
        """
        PrintLabel(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to each norm, for a given entity.
        Must only print label itself, in order to be included in a
        phrase. Can call the result of StringLabel, but not obliged.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_InterfaceModel_PrintLabel(self, *args)


    def PrintToLog(self, *args):
        """
        PrintToLog(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to each norm in log format, for
        a given entity.
        By default, just calls PrintLabel, can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_InterfaceModel_PrintToLog(self, *args)


    def StringLabel(self, *args):
        """
        StringLabel(Handle_Interface_InterfaceModel self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns a string with the label attached to a given entity.
        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_InterfaceModel_StringLabel(self, *args)


    def NextNumberForLabel(self, *args):
        """
        NextNumberForLabel(Handle_Interface_InterfaceModel self, Standard_CString const label, Standard_Integer const lastnum=0, Standard_Boolean const exact) -> Standard_Integer

        Searches a label which matches with one entity.
        Begins from <lastnum>+1 (default:1) and scans the entities
        until <NbEntities>. For the first which matches <label>,
        this method returns its Number. Returns 0 if nothing found
        Can be called recursively (labels are not specified as unique)
        <exact> : if True (default), exact match is required
        else, checks the END of entity label

        This method is virtual, hence it can be redefined for a more
        efficient search (if exact is true).

        :type label: OCC.wrapper.Standard.Standard_CString
        :type lastnum: int
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_NextNumberForLabel(self, *args)


    def HasTemplate(self, *args):
        """
        HasTemplate(Handle_Interface_InterfaceModel self, Standard_CString const name) -> Standard_Boolean

        Returns true if a template is attached to a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_HasTemplate(self, *args)


    def Template(self, *args):
        """
        Template(Handle_Interface_InterfaceModel self, Standard_CString const name) -> Handle_Interface_InterfaceModel

        Returns the template model attached to a name, or a Null Handle

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Handle_Interface_InterfaceModel_Template(self, *args)


    def SetTemplate(self, *args):
        """
        SetTemplate(Handle_Interface_InterfaceModel self, Standard_CString const name, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Records a new template model with a name. If the name was
        already recorded, the corresponding template is replaced by
        the new one. Then, WARNING : test HasTemplate to avoid
        surprises

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_SetTemplate(self, *args)


    def ListTemplates(self, *args):
        """
        ListTemplates(Handle_Interface_InterfaceModel self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the complete list of names attached to template models

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Handle_Interface_InterfaceModel_ListTemplates(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_InterfaceModel self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_InterfaceModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_InterfaceModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_InterfaceModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_InterfaceModel self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_InterfaceModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_InterfaceModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_InterfaceModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_InterfaceModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_InterfaceModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_InterfaceModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_InterfaceModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_InterfaceModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_InterfaceModel self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_InterfaceModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_InterfaceModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceModel_DecrementRefCounter(self, *args)

Handle_Interface_InterfaceModel_swigregister = _Interface.Handle_Interface_InterfaceModel_swigregister
Handle_Interface_InterfaceModel_swigregister(Handle_Interface_InterfaceModel)

def Handle_Interface_InterfaceModel_DownCast(thing):
    return _Interface.Handle_Interface_InterfaceModel_DownCast(thing)
Handle_Interface_InterfaceModel_DownCast = _Interface.Handle_Interface_InterfaceModel_DownCast

class Interface_BitMap(object):
    """
    A bit map simply allows to associate a boolean flag to each
    item of a list, such as a list of entities, etc... numbered
    between 1 and a positive count nbitems

    The BitMap class allows to associate several binary flags,
    each of one is identified by a number from 0 to a count
    which can remain at zero or be positive : nbflags

    Flags lists over than numflag=0 are added after creation
    Each of one can be named, hence the user can identify it
    either by its flag number or by a name which gives a flag n0
    (flag n0 0 has no name)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Interface_BitMap self) -> Interface_BitMap
        __init__(Interface_BitMap self, Standard_Integer const nbitems, Standard_Integer const resflags=0) -> Interface_BitMap
        __init__(Interface_BitMap self, Interface_BitMap other, Standard_Boolean const copied) -> Interface_BitMap

        Creates a BitMap from another one
        if <copied> is True, copies data
        else, data are not copied, only the header object is

        :type other: OCC.wrapper.Interface.Interface_BitMap
        :type copied: bool

        """
        this = _Interface.new_Interface_BitMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Interface_BitMap self, Standard_Integer const nbitems, Standard_Integer const resflags=0)
        Initialize(Interface_BitMap self, Interface_BitMap other, Standard_Boolean const copied)

        Initialize a BitMap from another one

        :type other: OCC.wrapper.Interface.Interface_BitMap
        :type copied: bool

        """
        return _Interface.Interface_BitMap_Initialize(self, *args)


    def Internals(self, *args):
        """
        Internals(Interface_BitMap self, Handle_TColStd_HArray1OfInteger flags, Handle_TColStd_HSequenceOfAsciiString names)

        Returns internal values, used for copying
        Flags values start at false

        :type nbitems: int
        :type nbwords: int
        :type nbflags: int
        :type flags: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
        :type names: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Interface.Interface_BitMap_Internals(self, *args)


    def Reservate(self, *args):
        """
        Reservate(Interface_BitMap self, Standard_Integer const moreflags)

        Reservates for a count of more flags

        :type moreflags: int

        """
        return _Interface.Interface_BitMap_Reservate(self, *args)


    def SetLength(self, *args):
        """
        SetLength(Interface_BitMap self, Standard_Integer const nbitems)

        Sets for a new count of items, which can be either less or
        greater than the former one
        For new items, their flags start at false

        :type nbitems: int

        """
        return _Interface.Interface_BitMap_SetLength(self, *args)


    def AddFlag(self, *args):
        """
        AddFlag(Interface_BitMap self, Standard_CString const name) -> Standard_Integer

        Adds a flag, a name can be attached to it
        Returns its flag number
        Makes required reservation

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_BitMap_AddFlag(self, *args)


    def AddSomeFlags(self, *args):
        """
        AddSomeFlags(Interface_BitMap self, Standard_Integer const more) -> Standard_Integer

        Adds several flags (<more>) with no name
        Returns the number of last added flag

        :type more: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_BitMap_AddSomeFlags(self, *args)


    def RemoveFlag(self, *args):
        """
        RemoveFlag(Interface_BitMap self, Standard_Integer const num) -> Standard_Boolean

        Removes a flag given its number.
        Returns True if done, false if num is out of range

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_BitMap_RemoveFlag(self, *args)


    def SetFlagName(self, *args):
        """
        SetFlagName(Interface_BitMap self, Standard_Integer const num, Standard_CString const name) -> Standard_Boolean

        Sets a name for a flag, given its number
        name can be empty (to erase the name of a flag)
        Returns True if done, false if : num is out of range, or
        name non-empty already set to another flag

        :type num: int
        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_BitMap_SetFlagName(self, *args)


    def NbFlags(self, *args):
        """
        NbFlags(Interface_BitMap self) -> Standard_Integer

        Returns the count of flags (flag 0 not included)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_BitMap_NbFlags(self, *args)


    def Length(self, *args):
        """
        Length(Interface_BitMap self) -> Standard_Integer

        Returns the count of items (i.e. the length of the bitmap)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_BitMap_Length(self, *args)


    def FlagName(self, *args):
        """
        FlagName(Interface_BitMap self, Standard_Integer const num) -> Standard_CString

        Returns the name recorded for a flag, or an empty string

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Interface_BitMap_FlagName(self, *args)


    def FlagNumber(self, *args):
        """
        FlagNumber(Interface_BitMap self, Standard_CString const name) -> Standard_Integer

        Returns the number or a flag given its name, or zero

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Interface_BitMap_FlagNumber(self, *args)


    def Value(self, *args):
        """
        Value(Interface_BitMap self, Standard_Integer const item, Standard_Integer const flag=0) -> Standard_Boolean

        Returns the value (true/false) of a flag, from :
        - the number of the item
        - the flag number, by default 0

        :type item: int
        :type flag: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_BitMap_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Interface_BitMap self, Standard_Integer const item, Standard_Boolean const val, Standard_Integer const flag=0)

        Sets a new value for a flag

        :type item: int
        :type val: bool
        :type flag: int

        """
        return _Interface.Interface_BitMap_SetValue(self, *args)


    def SetTrue(self, *args):
        """
        SetTrue(Interface_BitMap self, Standard_Integer const item, Standard_Integer const flag=0)

        Sets a flag to True

        :type item: int
        :type flag: int

        """
        return _Interface.Interface_BitMap_SetTrue(self, *args)


    def SetFalse(self, *args):
        """
        SetFalse(Interface_BitMap self, Standard_Integer const item, Standard_Integer const flag=0)

        Sets a flag to False

        :type item: int
        :type flag: int

        """
        return _Interface.Interface_BitMap_SetFalse(self, *args)


    def CTrue(self, *args):
        """
        CTrue(Interface_BitMap self, Standard_Integer const item, Standard_Integer const flag=0) -> Standard_Boolean

        Returns the former value for a flag and sets it to True
        (before : value returned; after : True)

        :type item: int
        :type flag: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_BitMap_CTrue(self, *args)


    def CFalse(self, *args):
        """
        CFalse(Interface_BitMap self, Standard_Integer const item, Standard_Integer const flag=0) -> Standard_Boolean

        Returns the former value for a flag and sets it to False
        (before : value returned; after : False)

        :type item: int
        :type flag: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Interface_BitMap_CFalse(self, *args)


    def Init(self, *args):
        """
        Init(Interface_BitMap self, Standard_Boolean const val, Standard_Integer const flag=0)

        Initialises all the values of Flag Number <flag> to a given
        value <val>

        :type val: bool
        :type flag: int

        """
        return _Interface.Interface_BitMap_Init(self, *args)


    def Clear(self, *args):
        """
        Clear(Interface_BitMap self)

        Clear all field of bit map


        """
        return _Interface.Interface_BitMap_Clear(self, *args)

    __swig_destroy__ = _Interface.delete_Interface_BitMap
Interface_BitMap_swigregister = _Interface.Interface_BitMap_swigregister
Interface_BitMap_swigregister(Interface_BitMap)

class Handle_Interface_CopyMap(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_CopyMap self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_CopyMap_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_CopyMap self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_CopyMap_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_CopyMap self, Interface_CopyMap thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_CopyMap_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_CopyMap self, Handle_Interface_CopyMap theHandle) -> Handle_Interface_CopyMap
        assign(Handle_Interface_CopyMap self, Interface_CopyMap thePtr) -> Handle_Interface_CopyMap
        assign(Handle_Interface_CopyMap self, Handle_Interface_CopyMap theHandle) -> Handle_Interface_CopyMap

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_CopyMap_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_CopyMap self) -> Interface_CopyMap

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_CopyMap_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_CopyMap self) -> Interface_CopyMap

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_CopyMap___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_CopyMap self) -> Interface_CopyMap

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_CopyMap___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_CopyMap___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_CopyMap___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_CopyMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_CopyMap_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_CopyMap

    def Clear(self, *args):
        """
        Clear(Handle_Interface_CopyMap self)

        Clears Transfer List. Gets Ready to begin another Transfer


        """
        return _Interface.Handle_Interface_CopyMap_Clear(self, *args)


    def Model(self, *args):
        """
        Model(Handle_Interface_CopyMap self) -> Handle_Interface_InterfaceModel

        Returns the InterfaceModel used at Creation time

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Interface.Handle_Interface_CopyMap_Model(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Interface_CopyMap self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Binds a Starting Entity identified by its Number <num> in the
        Starting Model, to a Result of Transfer <res>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_CopyMap_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Handle_Interface_CopyMap self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Search for the result of a Starting Object (i.e. an Entity,
        identified by its Number <num> in the Starting Model)
        Returns True  if a  Result is Bound (and fills <res>)
        Returns False if no result is Bound (and nullifies <res>)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CopyMap_Search(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_CopyMap self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_CopyMap_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_CopyMap_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_CopyMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_CopyMap self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_CopyMap_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_CopyMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_CopyMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CopyMap_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_CopyMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_CopyMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_CopyMap_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_CopyMap self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_CopyMap_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_CopyMap self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_CopyMap_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_CopyMap self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_CopyMap_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_CopyMap self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_CopyMap_DecrementRefCounter(self, *args)

Handle_Interface_CopyMap_swigregister = _Interface.Handle_Interface_CopyMap_swigregister
Handle_Interface_CopyMap_swigregister(Handle_Interface_CopyMap)

def Handle_Interface_CopyMap_DownCast(thing):
    return _Interface.Handle_Interface_CopyMap_DownCast(thing)
Handle_Interface_CopyMap_DownCast = _Interface.Handle_Interface_CopyMap_DownCast

class Handle_Interface_Static(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_Static self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_Static_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_Static self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_Static_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_Static self, Interface_Static thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_Static_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_Static self, Handle_Interface_Static theHandle) -> Handle_Interface_Static
        assign(Handle_Interface_Static self, Interface_Static thePtr) -> Handle_Interface_Static
        assign(Handle_Interface_Static self, Handle_Interface_Static theHandle) -> Handle_Interface_Static

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_Static_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_Static self) -> Interface_Static

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_Static_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_Static self) -> Interface_Static

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_Static___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_Static self) -> Interface_Static

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_Static___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_Static___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_Static___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_Static(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_Static_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_Static

    def PrintStatic(self, *args):
        """
        PrintStatic(Handle_Interface_Static self, Handle_Message_Messenger S)

        Writes the properties of a
        parameter in the diagnostic file. These include:
        - Name
        - Family,
        - Wildcard (if it has one)
        - Current status (empty  string if it was updated or
        if it is the original one)
        - Value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_Static_PrintStatic(self, *args)


    def Family(self, *args):
        """
        Family(Handle_Interface_Static self) -> Standard_CString

        Returns the family. It can be : a resource name for applis,
        an internal name between : $e (environment variables),
        $l (other, purely local)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_Family(self, *args)


    def SetWild(self, *args):
        """
        SetWild(Handle_Interface_Static self, Handle_Interface_Static wildcard)

        Sets a "wild-card" static : its value will be considered
        if <me> is not properly set. (reset by set a null one)

        :type wildcard: OCC.wrapper.Interface.Handle_Interface_Static

        """
        return _Interface.Handle_Interface_Static_SetWild(self, *args)


    def Wild(self, *args):
        """
        Wild(Handle_Interface_Static self) -> Handle_Interface_Static

        Returns the wildcard static, which can be (is most often) null

        :rtype: OCC.wrapper.Interface.Handle_Interface_Static

        """
        return _Interface.Handle_Interface_Static_Wild(self, *args)


    def SetUptodate(self, *args):
        """
        SetUptodate(Handle_Interface_Static self)

        Records a Static has "uptodate", i.e. its value has been taken
        into account by a reinitialisation procedure
        This flag is reset at each successful SetValue


        """
        return _Interface.Handle_Interface_Static_SetUptodate(self, *args)


    def UpdatedStatus(self, *args):
        """
        UpdatedStatus(Handle_Interface_Static self) -> Standard_Boolean

        Returns the status "uptodate"

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_UpdatedStatus(self, *args)


    def Init(self, *args):
        """
        Init(Handle_Interface_Static self, Standard_CString const family, Standard_CString const name, Interface_ParamType const type, Standard_CString const init) -> Standard_Boolean
        Init(Handle_Interface_Static self, Standard_CString const family, Standard_CString const name, Standard_Character const type, Standard_CString const init) -> Standard_Boolean

        As Init with ParamType, but type is given as a character
        This allows a simpler call
        Types : 'i' Integer, 'r' Real, 't' Text, 'e' Enum, 'o' Object
        '=' for same definition as, <init> gives the initial Static
        Returns False if <type> does not match this list

        :type family: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Standard_Character
        :type init: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_Init(self, *args)


    def Static(self, *args):
        """
        Static(Handle_Interface_Static self, Standard_CString const name) -> Handle_Interface_Static

        Returns a Static from its name. Null Handle if not present

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_Static

        """
        return _Interface.Handle_Interface_Static_Static(self, *args)


    def IsPresent(self, *args):
        """
        IsPresent(Handle_Interface_Static self, Standard_CString const name) -> Standard_Boolean

        Returns True if a Static named <name> is present, False else

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IsPresent(self, *args)


    def CDef(self, *args):
        """
        CDef(Handle_Interface_Static self, Standard_CString const name, Standard_CString const part) -> Standard_CString

        Returns a part of the definition of a Static, as a CString
        The part is designated by its name, as a CString
        If the required value is not a string, it is converted to a
        CString then returned
        If <name> is not present, or <part> not defined for <name>,
        this function returns an empty string

        Allowed parts for CDef :
        family : the family
        type  : the type ("integer","real","text","enum")
        label : the label
        satis : satisfy function name if any
        rmin : minimum real value
        rmax : maximum real value
        imin : minimum integer value
        imax : maximum integer value
        enum nn (nn : value of an integer) : enum value for nn
        unit : unit definition for a real

        :type name: OCC.wrapper.Standard.Standard_CString
        :type part: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_CDef(self, *args)


    def IDef(self, *args):
        """
        IDef(Handle_Interface_Static self, Standard_CString const name, Standard_CString const part) -> Standard_Integer

        Returns a part of the definition of a Static, as an Integer
        The part is designated by its name, as a CString
        If the required value is not a string, returns zero
        For a Boolean, 0 for false, 1 for true
        If <name> is not present, or <part> not defined for <name>,
        this function returns zero

        Allowed parts for IDef :
        imin, imax : minimum or maximum integer value
        estart : starting number for enum
        ecount : count of enum values (starting from estart)
        ematch : exact match status
        eval val : case determined from a string

        :type name: OCC.wrapper.Standard.Standard_CString
        :type part: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_IDef(self, *args)


    def IsSet(self, *args):
        """
        IsSet(Handle_Interface_Static self, Standard_CString const name, Standard_Boolean const proper) -> Standard_Boolean

        Returns True if <name> is present AND set
        <proper> True (D) : considers this item only
        <proper> False    : if not set and attached to a wild-card,
        considers this wild-card

        :type name: OCC.wrapper.Standard.Standard_CString
        :type proper: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IsSet(self, *args)


    def CVal(self, *args):
        """
        CVal(Handle_Interface_Static self, Standard_CString const name) -> Standard_CString

        Returns the value of the
        parameter identified by the string name.
        If the specified parameter does not exist, an empty
        string is returned.
        Example
        Interface_Static::CVal("write.step.schema");
        which could return:
        "AP214"

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_CVal(self, *args)


    def IVal(self, *args):
        """
        IVal(Handle_Interface_Static self, Standard_CString const name) -> Standard_Integer

        Returns the integer value of
        the translation parameter identified by the string name.
        Returns the value 0 if the parameter does not exist.
        Example
        Interface_Static::IVal("write.step.schema");
        which could return: 3

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_IVal(self, *args)


    def RVal(self, *args):
        """
        RVal(Handle_Interface_Static self, Standard_CString const name) -> Standard_Real

        Returns the value of a static
        translation parameter identified by the string name.
        Returns the value 0.0 if the parameter does not exist.

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Handle_Interface_Static_RVal(self, *args)


    def SetCVal(self, *args):
        """
        SetCVal(Handle_Interface_Static self, Standard_CString const name, Standard_CString const val) -> Standard_Boolean

        Modifies the value of the
        parameter identified by name. The modification is specified
        by the string val. false is returned if the parameter does not exist.
        Example
        Interface_Static::SetCVal
        ("write.step.schema","AP203")
        This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetCVal(self, *args)


    def SetIVal(self, *args):
        """
        SetIVal(Handle_Interface_Static self, Standard_CString const name, Standard_Integer const val) -> Standard_Boolean

        Modifies the value of the
        parameter identified by name. The modification is specified
        by the integer value val. false is returned if the
        parameter does not exist.
        Example
        Interface_Static::SetIVal
        ("write.step.schema", 3)
        This syntax specifies a switch from the default STEP 214 mode to STEP 203 mode.S

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetIVal(self, *args)


    def SetRVal(self, *args):
        """
        SetRVal(Handle_Interface_Static self, Standard_CString const name, Standard_Real const val) -> Standard_Boolean

        Modifies the value of a
        translation parameter. false is returned if the
        parameter does not exist. The modification is specified
        by the real number value val.

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetRVal(self, *args)


    def Update(self, *args):
        """
        Update(Handle_Interface_Static self, Standard_CString const name) -> Standard_Boolean

        Sets a Static to be "uptodate"
        Returns False if <name> is not present
        This status can be used by a reinitialisation procedure to
        rerun if a value has been changed

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_Update(self, *args)


    def IsUpdated(self, *args):
        """
        IsUpdated(Handle_Interface_Static self, Standard_CString const name) -> Standard_Boolean

        Returns the status "uptodate" from a Static
        Returns False if <name> is not present

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IsUpdated(self, *args)


    def Items(self, *args):
        """
        Items(Handle_Interface_Static self, Standard_Integer const mode=0, Standard_CString const criter) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns a list of names of statics :
        <mode> = 0 (D) : criter is for family
        <mode> = 1 : criter is regexp on names, takes final items
        (ignore wild cards)
        <mode> = 2 : idem but take only wilded, not final items
        <mode> = 3 : idem, take all items matching criter
        idem + 100 : takes only non-updated items
        idem + 200 : takes only updated items
        criter empty (D) : returns all names
        else returns names which match the given criter
        Remark : families beginning by '$' are not listed by criter ""
        they are listed only by criter "$"

        This allows for instance to set new values after having loaded
        or reloaded a resource, then to update them as required

        :type mode: int
        :type criter: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Interface.Handle_Interface_Static_Items(self, *args)


    def Standards(self, *args):
        """
        Standards(Handle_Interface_Static self)

        Initializes all standard static parameters, which can be used
        by every function. statics specific of a norm or a function
        must be defined around it


        """
        return _Interface.Handle_Interface_Static_Standards(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_Static self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_Static_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_Static_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_Static_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_Interface_Static self) -> Interface_ParamType

        Returns the type
        I.E. calls ValueType then makes correspondance between
        ParamType from Interface (which remains for compatibility
        reasons) and ValueType from MoniTool

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Handle_Interface_Static_Type(self, *args)


    def ParamTypeToValueType(self, *args):
        """
        ParamTypeToValueType(Handle_Interface_Static self, Interface_ParamType const typ) -> MoniTool_ValueType

        Correspondance ParamType from Interface  to
        ValueType from MoniTool

        :type typ: OCC.wrapper.Interface.Interface_ParamType
        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _Interface.Handle_Interface_Static_ParamTypeToValueType(self, *args)


    def ValueTypeToParamType(self, *args):
        """
        ValueTypeToParamType(Handle_Interface_Static self, MoniTool_ValueType const typ) -> Interface_ParamType

        Correspondance ParamType from Interface  to
        ValueType from MoniTool

        :type typ: OCC.wrapper.MoniTool.MoniTool_ValueType
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Interface.Handle_Interface_Static_ValueTypeToParamType(self, *args)


    def Internals(self, *args):
        """
        Internals(Handle_Interface_Static self, MoniTool_ValueInterpret & interp, MoniTool_ValueSatisfies & satisf, Standard_CString & satisname, NCollection_DataMap< TCollection_AsciiString,Standard_Integer > & enums)

        Access to internal data which have no other access

        :type interp: OCC.wrapper.MoniTool.MoniTool_ValueInterpret
        :type satisf: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type satisname: OCC.wrapper.Standard.Standard_CString
        :type enums: OCC.wrapper.MoniTool.NCollection_DataMap_TCollection_AsciiString_Standard_Integer

        """
        return _Interface.Handle_Interface_Static_Internals(self, *args)


    def Name(self, *args):
        """
        Name(Handle_Interface_Static self) -> Standard_CString

        Returns the name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_Name(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_Interface_Static self) -> MoniTool_ValueType

        Returns the type of the value

        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _Interface.Handle_Interface_Static_ValueType(self, *args)


    def Definition(self, *args):
        """
        Definition(Handle_Interface_Static self) -> TCollection_AsciiString

        Returns the Definition
        By priority, the enforced one, else an automatic one, computed
        from the specification

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Interface.Handle_Interface_Static_Definition(self, *args)


    def SetDefinition(self, *args):
        """
        SetDefinition(Handle_Interface_Static self, Standard_CString const deftext)

        Enforces a Definition

        :type deftext: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_SetDefinition(self, *args)


    def Print(self, *args):
        """
        Print(Handle_Interface_Static self, Handle_Message_Messenger S)

        Prints definition, specification, and actual status and value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_Static_Print(self, *args)


    def PrintValue(self, *args):
        """
        PrintValue(Handle_Interface_Static self, Handle_Message_Messenger S)

        Prints only the Value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Interface.Handle_Interface_Static_PrintValue(self, *args)


    def AddDef(self, *args):
        """
        AddDef(Handle_Interface_Static self, Standard_CString const initext) -> Standard_Boolean

        Completes the definition of a TypedValue by command <initext>,
        once created with its type
        Returns True if done, False if could not be interpreted
        <initext> may be :
        imin ival : minimum value for an integer
        imax ival : maximum value for an integer
        rmin rval : minimum value for a real
        rmax rval : maximum value for a real
        unit name : name of unit
        ematch i  : enum from integer value i, match required
        enum   i  : enum from integer value i, match not required
        eval text : add an enumerative value (increments max by 1)
        eval ??   : add a non-authorised enum value (to be skipped)
        tmax   l  : maximum length for a text

        :type initext: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_AddDef(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_Interface_Static self, Standard_CString const label)

        Sets a label, which can then be displayed

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_SetLabel(self, *args)


    def Label(self, *args):
        """
        Label(Handle_Interface_Static self) -> Standard_CString

        Returns the label, if set; else returns an empty string

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_Label(self, *args)


    def SetMaxLength(self, *args):
        """
        SetMaxLength(Handle_Interface_Static self, Standard_Integer const max)

        Sets a maximum length for a text (active only for a free text)

        :type max: int

        """
        return _Interface.Handle_Interface_Static_SetMaxLength(self, *args)


    def MaxLength(self, *args):
        """
        MaxLength(Handle_Interface_Static self) -> Standard_Integer

        Returns the maximum length, 0 if not set

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_MaxLength(self, *args)


    def SetIntegerLimit(self, *args):
        """
        SetIntegerLimit(Handle_Interface_Static self, Standard_Boolean const max, Standard_Integer const val)

        Sets an Integer limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: int

        """
        return _Interface.Handle_Interface_Static_SetIntegerLimit(self, *args)


    def IntegerLimit(self, *args):
        """
        IntegerLimit(Handle_Interface_Static self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Integer Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Integer)

        :type max: bool
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IntegerLimit(self, *args)


    def SetRealLimit(self, *args):
        """
        SetRealLimit(Handle_Interface_Static self, Standard_Boolean const max, Standard_Real const val)

        Sets a Real limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: float

        """
        return _Interface.Handle_Interface_Static_SetRealLimit(self, *args)


    def RealLimit(self, *args):
        """
        RealLimit(Handle_Interface_Static self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Real Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Real)

        :type max: bool
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_RealLimit(self, *args)


    def SetUnitDef(self, *args):
        """
        SetUnitDef(Handle_Interface_Static self, Standard_CString const arg2)

        Sets (Clears if <def> empty) a unit definition, as an equation
        of dimensions. TypedValue just records this definition, does
        not exploit it, to be done as required by user applications

        :type def: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_SetUnitDef(self, *args)


    def UnitDef(self, *args):
        """
        UnitDef(Handle_Interface_Static self) -> Standard_CString

        Returns the recorded unit definition, empty if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_UnitDef(self, *args)


    def StartEnum(self, *args):
        """
        StartEnum(Handle_Interface_Static self, Standard_Integer const start=0, Standard_Boolean const match)

        For an enumeration, precises the starting value (default 0)
        and the match condition : if True (D), the string value must
        match the definition, else it may take another value : in that
        case, the Integer Value will be  Start - 1.
        (empty value remains allowed)

        :type start: int
        :type match: bool

        """
        return _Interface.Handle_Interface_Static_StartEnum(self, *args)


    def AddEnum(self, *args):
        """
        AddEnum(Handle_Interface_Static self, Standard_CString const v1, Standard_CString const v2, Standard_CString const v3, Standard_CString const v4, Standard_CString const v5, Standard_CString const v6, Standard_CString const v7, Standard_CString const v8, Standard_CString const v9, Standard_CString const v10)

        Adds enumerative definitions. For more than 10, several calls

        :type v1: OCC.wrapper.Standard.Standard_CString
        :type v2: OCC.wrapper.Standard.Standard_CString
        :type v3: OCC.wrapper.Standard.Standard_CString
        :type v4: OCC.wrapper.Standard.Standard_CString
        :type v5: OCC.wrapper.Standard.Standard_CString
        :type v6: OCC.wrapper.Standard.Standard_CString
        :type v7: OCC.wrapper.Standard.Standard_CString
        :type v8: OCC.wrapper.Standard.Standard_CString
        :type v9: OCC.wrapper.Standard.Standard_CString
        :type v10: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_AddEnum(self, *args)


    def AddEnumValue(self, *args):
        """
        AddEnumValue(Handle_Interface_Static self, Standard_CString const val, Standard_Integer const num)

        Adds an enumeration definition, by its string and numeric
        values. If it is the first setting for this value, it is
        recorded as main value. Else, it is recognized as alternate
        string for this numeric value

        :type val: OCC.wrapper.Standard.Standard_CString
        :type num: int

        """
        return _Interface.Handle_Interface_Static_AddEnumValue(self, *args)


    def EnumDef(self, *args):
        """
        EnumDef(Handle_Interface_Static self) -> Standard_Boolean

        Gives the Enum definitions : start value, end value, match
        status. Returns True for an Enum, False else.

        :type startcase: int
        :type endcase: int
        :type match: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_EnumDef(self, *args)


    def EnumVal(self, *args):
        """
        EnumVal(Handle_Interface_Static self, Standard_Integer const num) -> Standard_CString

        Returns the value of an enumerative definition, from its rank
        Empty string if out of range or not an Enum

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_EnumVal(self, *args)


    def EnumCase(self, *args):
        """
        EnumCase(Handle_Interface_Static self, Standard_CString const val) -> Standard_Integer

        Returns the case number which cooresponds to a string value
        Works with main and additionnal values
        Returns (StartEnum - 1) if not OK, -1 if not an Enum

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_EnumCase(self, *args)


    def SetObjectType(self, *args):
        """
        SetObjectType(Handle_Interface_Static self, Handle_Standard_Type typ)

        Sets type of which an Object TypedValue must be kind of
        Error for a TypedValue not an Object (Entity)

        :type typ: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Handle_Interface_Static_SetObjectType(self, *args)


    def ObjectType(self, *args):
        """
        ObjectType(Handle_Interface_Static self) -> Handle_Standard_Type

        Returns the type of which an Object TypedValue must be kind of
        Default is Standard_Transient
        Null for a TypedValue not an Object

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Handle_Interface_Static_ObjectType(self, *args)


    def SetInterpret(self, *args):
        """
        SetInterpret(Handle_Interface_Static self, MoniTool_ValueInterpret const func)

        Sets a specific Interpret function

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueInterpret

        """
        return _Interface.Handle_Interface_Static_SetInterpret(self, *args)


    def HasInterpret(self, *args):
        """
        HasInterpret(Handle_Interface_Static self) -> Standard_Boolean

        Tells if a TypedValue has an Interpret

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_HasInterpret(self, *args)


    def SetSatisfies(self, *args):
        """
        SetSatisfies(Handle_Interface_Static self, MoniTool_ValueSatisfies const func, Standard_CString const name)

        Sets a specific Satisfies function : it is added to the
        already defined criteria
        It must match the form :
        statisfies (val : HAsciiString) returns Boolean

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_SetSatisfies(self, *args)


    def SatisfiesName(self, *args):
        """
        SatisfiesName(Handle_Interface_Static self) -> Standard_CString

        Returns name of specific satisfy, empty string if none

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_SatisfiesName(self, *args)


    def IsSetValue(self, *args):
        """
        IsSetValue(Handle_Interface_Static self) -> Standard_Boolean

        Returns True if the value is set (not empty/not null object)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IsSetValue(self, *args)


    def CStringValue(self, *args):
        """
        CStringValue(Handle_Interface_Static self) -> Standard_CString

        Returns the value, as a cstring. Empty if not set.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_CStringValue(self, *args)


    def HStringValue(self, *args):
        """
        HStringValue(Handle_Interface_Static self) -> Handle_TCollection_HAsciiString

        Returns the value, as a Handle (can then be shared)
        Null if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_Static_HStringValue(self, *args)


    def Interpret(self, *args):
        """
        Interpret(Handle_Interface_Static self, Handle_TCollection_HAsciiString hval, Standard_Boolean const native) -> Handle_TCollection_HAsciiString

        Interprets a value.
        <native> True  : returns a native value
        <native> False : returns a coded  value
        If the Interpret function is set, calls it
        Else, for an Enum, Native returns the Text, Coded returns
        the number
        STANDARD RETURNS : = hval means no specific interpretation
        Null means senseless
        Can also be redefined

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type native: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _Interface.Handle_Interface_Static_Interpret(self, *args)


    def Satisfies(self, *args):
        """
        Satisfies(Handle_Interface_Static self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Returns True if a value statifies the specification
        (remark : does not apply to Entity : see ObjectType, for this
        type, the string is just a comment)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_Satisfies(self, *args)


    def ClearValue(self, *args):
        """
        ClearValue(Handle_Interface_Static self)

        Clears the recorded Value : it is now unset


        """
        return _Interface.Handle_Interface_Static_ClearValue(self, *args)


    def SetCStringValue(self, *args):
        """
        SetCStringValue(Handle_Interface_Static self, Standard_CString const val) -> Standard_Boolean

        Changes the value. The new one must satisfy the specification
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetCStringValue(self, *args)


    def SetHStringValue(self, *args):
        """
        SetHStringValue(Handle_Interface_Static self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Forces a new Handle for the Value
        It can be empty, else (if Type is not free Text), it must
        satisfy the specification.
        Not only the value is changed, but also the way it is shared
        Remark : for Type=Object, this value is not controlled, it can
        be set as a comment
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetHStringValue(self, *args)


    def IntegerValue(self, *args):
        """
        IntegerValue(Handle_Interface_Static self) -> Standard_Integer

        Returns the value as integer, i.e. :
        For type = Integer, the integer itself; 0 if not set
        For type = Enum, the designated rank (see Enum definition)
        StartEnum - 1 if not set or not in the definition
        Else, returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_IntegerValue(self, *args)


    def SetIntegerValue(self, *args):
        """
        SetIntegerValue(Handle_Interface_Static self, Standard_Integer const ival) -> Standard_Boolean

        Changes the value as an integer, only for Integer or Enum

        :type ival: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetIntegerValue(self, *args)


    def RealValue(self, *args):
        """
        RealValue(Handle_Interface_Static self) -> Standard_Real

        Returns the value as real,  for a Real type TypedValue
        Else, returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Interface.Handle_Interface_Static_RealValue(self, *args)


    def SetRealValue(self, *args):
        """
        SetRealValue(Handle_Interface_Static self, Standard_Real const rval) -> Standard_Boolean

        Changes the value as a real, only for Real

        :type rval: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetRealValue(self, *args)


    def ObjectValue(self, *args):
        """
        ObjectValue(Handle_Interface_Static self) -> Handle_Standard_Transient

        Returns the value as Transient Object, only for Object/Entity
        Remark that the "HString value" is IGNORED here
        Null if not set; remains to be casted

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_Static_ObjectValue(self, *args)


    def GetObjectValue(self, *args):
        """
        GetObjectValue(Handle_Interface_Static self, Handle_Standard_Transient val)

        Same as ObjectValue, but avoids DownCast : the receiving
        variable is directly loaded. It is assumed that it complies
        with the definition of ObjectType ! Otherwise, big trouble

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Interface.Handle_Interface_Static_GetObjectValue(self, *args)


    def SetObjectValue(self, *args):
        """
        SetObjectValue(Handle_Interface_Static self, Handle_Standard_Transient obj) -> Standard_Boolean

        Changes the value as Transient Object, only for Object/Entity
        Returns False if DynamicType does not satisfy ObjectType
        Can be redefined to be managed (in a subclass)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_SetObjectValue(self, *args)


    def ObjectTypeName(self, *args):
        """
        ObjectTypeName(Handle_Interface_Static self) -> Standard_CString

        Returns the type name of the ObjectValue, or an empty string
        if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_Static_ObjectTypeName(self, *args)


    def AddLib(self, *args):
        """
        AddLib(Handle_Interface_Static self, Handle_MoniTool_TypedValue tv, Standard_CString const arg2) -> Standard_Boolean

        Adds a TypedValue in the library.
        It is recorded then will be accessed by its Name
        Its Definition may be imposed, else it is computed as usual
        By default it will be accessed by its Definition (string)
        Returns True if done, False if tv is Null or brings no
        Definition or <def> not defined

        If a TypedValue was already recorded under this name, it is
        replaced

        :type tv: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue
        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_AddLib(self, *args)


    def Lib(self, *args):
        """
        Lib(Handle_Interface_Static self, Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns the TypedValue bound with a given Name
        Null Handle if none recorded
        Warning : it is the original, not duplicated

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _Interface.Handle_Interface_Static_Lib(self, *args)


    def FromLib(self, *args):
        """
        FromLib(Handle_Interface_Static self, Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns a COPY of the TypedValue bound with a given Name
        Null Handle if none recorded

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _Interface.Handle_Interface_Static_FromLib(self, *args)


    def LibList(self, *args):
        """
        LibList(Handle_Interface_Static self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the list of names of items of the Library of Types
        --    Library of TypedValue as Valued Parameters,    -- --
        accessed by parameter name
        for use by management of Static Parameters

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Interface.Handle_Interface_Static_LibList(self, *args)


    def StaticValue(self, *args):
        """
        StaticValue(Handle_Interface_Static self, Standard_CString const name) -> Handle_MoniTool_TypedValue

        Returns a static value from its name, null if unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _Interface.Handle_Interface_Static_StaticValue(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_Static self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_Static_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_Static self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_Static self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_Static self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_Static self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_Static_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_Static self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_Static_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_Static self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_Static self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_Static_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_Static self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_Static_DecrementRefCounter(self, *args)

Handle_Interface_Static_swigregister = _Interface.Handle_Interface_Static_swigregister
Handle_Interface_Static_swigregister(Handle_Interface_Static)

def Handle_Interface_Static_DownCast(thing):
    return _Interface.Handle_Interface_Static_DownCast(thing)
Handle_Interface_Static_DownCast = _Interface.Handle_Interface_Static_DownCast

class NCollection_Array1_Handle_TCollection_HAsciiString(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_TCollection_HAsciiString self) -> NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_TCollection_HAsciiString self) -> NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_TCollection_HAsciiString self) -> NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_TCollection_HAsciiString self) -> NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Interface.new_NCollection_Array1_Handle_TCollection_HAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_TCollection_HAsciiString self, Handle_TCollection_HAsciiString theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_TCollection_HAsciiString self, NCollection_Array1_Handle_TCollection_HAsciiString theOther) -> NCollection_Array1_Handle_TCollection_HAsciiString

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_TCollection_HAsciiString self, NCollection_Array1_Handle_TCollection_HAsciiString theOther) -> NCollection_Array1_Handle_TCollection_HAsciiString

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_TCollection_HAsciiString self, NCollection_Array1_Handle_TCollection_HAsciiString theOther) -> NCollection_Array1_Handle_TCollection_HAsciiString
        assign(NCollection_Array1_Handle_TCollection_HAsciiString self, NCollection_Array1_Handle_TCollection_HAsciiString theOther) -> NCollection_Array1_Handle_TCollection_HAsciiString

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Handle_TCollection_HAsciiString

        @return first element

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_TCollection_HAsciiString self) -> Handle_TCollection_HAsciiString

        @return last element

        :rtype: TheItemType &

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex) -> Handle_TCollection_HAsciiString

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Handle_TCollection_HAsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, Handle_TCollection_HAsciiString theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_TCollection_HAsciiString self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_Resize(self, *args)

    __swig_destroy__ = _Interface.delete_NCollection_Array1_Handle_TCollection_HAsciiString
NCollection_Array1_Handle_TCollection_HAsciiString_swigregister = _Interface.NCollection_Array1_Handle_TCollection_HAsciiString_swigregister
NCollection_Array1_Handle_TCollection_HAsciiString_swigregister(NCollection_Array1_Handle_TCollection_HAsciiString)


try:
	Interface_Array1OfHAsciiString = NCollection_Array1_Handle_TCollection_HAsciiString
except NameError:
	pass # does not exist, probably ignored

class Interface_InterfaceMismatch(Interface_InterfaceError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Interface_InterfaceMismatch
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Interface_InterfaceMismatch(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Interface_InterfaceMismatch self) -> Interface_InterfaceMismatch
        __init__(Interface_InterfaceMismatch self, Standard_CString const theMessage) -> Interface_InterfaceMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Interface.new_Interface_InterfaceMismatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Interface_InterfaceMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceMismatch

        """
        return _Interface.Interface_InterfaceMismatch_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Interface.Interface_InterfaceMismatch_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Interface.Interface_InterfaceMismatch_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Interface_InterfaceMismatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Interface.delete_Interface_InterfaceMismatch
Interface_InterfaceMismatch_swigregister = _Interface.Interface_InterfaceMismatch_swigregister
Interface_InterfaceMismatch_swigregister(Interface_InterfaceMismatch)

def Interface_InterfaceMismatch_NewInstance(*args):
    """
    Interface_InterfaceMismatch_NewInstance(Standard_CString const theMessage) -> Handle_Interface_InterfaceMismatch

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceMismatch

    """
    return _Interface.Interface_InterfaceMismatch_NewInstance(*args)

def Interface_InterfaceMismatch_get_type_name(*args):
    """
    Interface_InterfaceMismatch_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Interface.Interface_InterfaceMismatch_get_type_name(*args)

def Interface_InterfaceMismatch_get_type_descriptor(*args):
    """
    Interface_InterfaceMismatch_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Interface.Interface_InterfaceMismatch_get_type_descriptor(*args)

class Handle_Interface_InterfaceMismatch(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_InterfaceMismatch self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_InterfaceMismatch_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_InterfaceMismatch self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_InterfaceMismatch_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_InterfaceMismatch self, Interface_InterfaceMismatch thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_InterfaceMismatch_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_InterfaceMismatch self, Handle_Interface_InterfaceMismatch theHandle) -> Handle_Interface_InterfaceMismatch
        assign(Handle_Interface_InterfaceMismatch self, Interface_InterfaceMismatch thePtr) -> Handle_Interface_InterfaceMismatch
        assign(Handle_Interface_InterfaceMismatch self, Handle_Interface_InterfaceMismatch theHandle) -> Handle_Interface_InterfaceMismatch

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_InterfaceMismatch_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_InterfaceMismatch self) -> Interface_InterfaceMismatch

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_InterfaceMismatch_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_InterfaceMismatch self) -> Interface_InterfaceMismatch

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_InterfaceMismatch___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_InterfaceMismatch self) -> Interface_InterfaceMismatch

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_InterfaceMismatch___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_InterfaceMismatch___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_InterfaceMismatch___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_InterfaceMismatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_InterfaceMismatch_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_InterfaceMismatch

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Interface_InterfaceMismatch self, Standard_CString const theMessage) -> Handle_Interface_InterfaceMismatch

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceMismatch

        """
        return _Interface.Handle_Interface_InterfaceMismatch_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_InterfaceMismatch self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_InterfaceMismatch_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_InterfaceMismatch_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_InterfaceMismatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Interface_InterfaceMismatch self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Interface.Handle_Interface_InterfaceMismatch_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Interface_InterfaceMismatch self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_InterfaceMismatch_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Interface_InterfaceMismatch self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Interface.Handle_Interface_InterfaceMismatch_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Interface_InterfaceMismatch self)
        Reraise(Handle_Interface_InterfaceMismatch self, Standard_CString const aMessage)
        Reraise(Handle_Interface_InterfaceMismatch self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Interface.Handle_Interface_InterfaceMismatch_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Interface_InterfaceMismatch self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Interface.Handle_Interface_InterfaceMismatch_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Interface_InterfaceMismatch self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Interface.Handle_Interface_InterfaceMismatch_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Interface_InterfaceMismatch self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_InterfaceMismatch_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_InterfaceMismatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_InterfaceMismatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceMismatch_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_InterfaceMismatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_InterfaceMismatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_InterfaceMismatch_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_InterfaceMismatch self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_InterfaceMismatch_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_InterfaceMismatch self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceMismatch_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_InterfaceMismatch self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_InterfaceMismatch_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_InterfaceMismatch self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_InterfaceMismatch_DecrementRefCounter(self, *args)

Handle_Interface_InterfaceMismatch_swigregister = _Interface.Handle_Interface_InterfaceMismatch_swigregister
Handle_Interface_InterfaceMismatch_swigregister(Handle_Interface_InterfaceMismatch)

def Handle_Interface_InterfaceMismatch_DownCast(thing):
    return _Interface.Handle_Interface_InterfaceMismatch_DownCast(thing)
Handle_Interface_InterfaceMismatch_DownCast = _Interface.Handle_Interface_InterfaceMismatch_DownCast

class Handle_Interface_HSequenceOfCheck(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_HSequenceOfCheck self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_HSequenceOfCheck_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_HSequenceOfCheck self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_HSequenceOfCheck self, Interface_HSequenceOfCheck thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_HSequenceOfCheck self, Handle_Interface_HSequenceOfCheck theHandle) -> Handle_Interface_HSequenceOfCheck
        assign(Handle_Interface_HSequenceOfCheck self, Interface_HSequenceOfCheck thePtr) -> Handle_Interface_HSequenceOfCheck
        assign(Handle_Interface_HSequenceOfCheck self, Handle_Interface_HSequenceOfCheck theHandle) -> Handle_Interface_HSequenceOfCheck

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_HSequenceOfCheck self) -> Interface_HSequenceOfCheck

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_HSequenceOfCheck self) -> Interface_HSequenceOfCheck

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_HSequenceOfCheck___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_HSequenceOfCheck self) -> Interface_HSequenceOfCheck

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_HSequenceOfCheck___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_HSequenceOfCheck___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_HSequenceOfCheck___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_HSequenceOfCheck(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_HSequenceOfCheck_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_HSequenceOfCheck

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        res = _Interface.Handle_Interface_HSequenceOfCheck_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Interface_HSequenceOfCheck self, Handle_Interface_Check theItem)
        Append(Handle_Interface_HSequenceOfCheck self, NCollection_Sequence_Handle_Interface_Check theSequence)

        :type theSequence: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Interface_HSequenceOfCheck self) -> NCollection_Sequence_Handle_Interface_Check

        :rtype: OCC.wrapper.Interface.Interface_SequenceOfCheck

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_HSequenceOfCheck self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_HSequenceOfCheck_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_HSequenceOfCheck_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_HSequenceOfCheck self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_HSequenceOfCheck_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_HSequenceOfCheck self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_HSequenceOfCheck self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_HSequenceOfCheck self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_HSequenceOfCheck self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_HSequenceOfCheck self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_HSequenceOfCheck self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_HSequenceOfCheck self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_HSequenceOfCheck_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_HSequenceOfCheck self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_HSequenceOfCheck_DecrementRefCounter(self, *args)

Handle_Interface_HSequenceOfCheck_swigregister = _Interface.Handle_Interface_HSequenceOfCheck_swigregister
Handle_Interface_HSequenceOfCheck_swigregister(Handle_Interface_HSequenceOfCheck)

def Handle_Interface_HSequenceOfCheck_DownCast(thing):
    return _Interface.Handle_Interface_HSequenceOfCheck_DownCast(thing)
Handle_Interface_HSequenceOfCheck_DownCast = _Interface.Handle_Interface_HSequenceOfCheck_DownCast

class Handle_Interface_ParamSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Interface_ParamSet self)

        Nullify the handle


        """
        return _Interface.Handle_Interface_ParamSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Interface_ParamSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Interface.Handle_Interface_ParamSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Interface_ParamSet self, Interface_ParamSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Interface.Handle_Interface_ParamSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Interface_ParamSet self, Handle_Interface_ParamSet theHandle) -> Handle_Interface_ParamSet
        assign(Handle_Interface_ParamSet self, Interface_ParamSet thePtr) -> Handle_Interface_ParamSet
        assign(Handle_Interface_ParamSet self, Handle_Interface_ParamSet theHandle) -> Handle_Interface_ParamSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Interface.Handle_Interface_ParamSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Interface_ParamSet self) -> Interface_ParamSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Interface.Handle_Interface_ParamSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Interface_ParamSet self) -> Interface_ParamSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Interface.Handle_Interface_ParamSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Interface_ParamSet self) -> Interface_ParamSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Interface.Handle_Interface_ParamSet___ref__(self, *args)


    def __hash__(self):
        return _Interface.Handle_Interface_ParamSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Interface.Handle_Interface_ParamSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Interface.new_Handle_Interface_ParamSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Interface.Handle_Interface_ParamSet_DownCast)
    __swig_destroy__ = _Interface.delete_Handle_Interface_ParamSet

    def Append(self, *args):
        """
        Append(Handle_Interface_ParamSet self, Standard_CString const val, Standard_Integer const lnval, Interface_ParamType const typ, Standard_Integer const nument) -> Standard_Integer
        Append(Handle_Interface_ParamSet self, Interface_FileParameter FP) -> Standard_Integer

        Adds a parameter at the end of the ParamSet (transparent
        about reservation and "Next")
        Returns new count of recorded Parameters

        :type FP: OCC.wrapper.Interface.Interface_FileParameter
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamSet_Append(self, *args)


    def NbParams(self, *args):
        """
        NbParams(Handle_Interface_ParamSet self) -> Standard_Integer

        Returns the total count of parameters (including nexts)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamSet_NbParams(self, *args)


    def Param(self, *args):
        """
        Returns a parameter identified by its number

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _Interface.Handle_Interface_ParamSet_Param(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParam(self, *args):
        """
        ChangeParam(Handle_Interface_ParamSet self, Standard_Integer const num) -> Interface_FileParameter

        Same as above, but in order to be modified on place

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_ParamSet_ChangeParam(self, *args)


    def SetParam(self, *args):
        """
        SetParam(Handle_Interface_ParamSet self, Standard_Integer const num, Interface_FileParameter FP)

        Changes a parameter identified by its number

        :type num: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _Interface.Handle_Interface_ParamSet_SetParam(self, *args)


    def Params(self, *args):
        """
        Params(Handle_Interface_ParamSet self, Standard_Integer const num, Standard_Integer const nb) -> Handle_Interface_ParamList

        Builds and returns the sub-list correspinding to parameters,
        from "num" included, with count "nb"
        If <num> and <nb> are zero, returns the whole list

        :type num: int
        :type nb: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_ParamList

        """
        return _Interface.Handle_Interface_ParamSet_Params(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Handle_Interface_ParamSet self)

        Destructor (waiting for transparent memory management)


        """
        return _Interface.Handle_Interface_ParamSet_Destroy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Interface_ParamSet self) -> char const *

        :rtype: const char *

        """
        return _Interface.Handle_Interface_ParamSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ParamSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Interface.Handle_Interface_ParamSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Interface_ParamSet self)

        Memory deallocator for transient classes


        """
        return _Interface.Handle_Interface_ParamSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Interface_ParamSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Interface_ParamSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ParamSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Interface_ParamSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Interface_ParamSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Interface.Handle_Interface_ParamSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Interface_ParamSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Interface.Handle_Interface_ParamSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Interface_ParamSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Interface_ParamSet self)

        Increments the reference counter of this object


        """
        return _Interface.Handle_Interface_ParamSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Interface_ParamSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Interface.Handle_Interface_ParamSet_DecrementRefCounter(self, *args)

Handle_Interface_ParamSet_swigregister = _Interface.Handle_Interface_ParamSet_swigregister
Handle_Interface_ParamSet_swigregister(Handle_Interface_ParamSet)

def Handle_Interface_ParamSet_DownCast(thing):
    return _Interface.Handle_Interface_ParamSet_DownCast(thing)
Handle_Interface_ParamSet_DownCast = _Interface.Handle_Interface_ParamSet_DownCast




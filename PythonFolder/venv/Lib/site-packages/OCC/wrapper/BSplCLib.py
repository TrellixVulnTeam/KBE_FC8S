# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BSplCLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BSplCLib')
    _BSplCLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BSplCLib', [dirname(__file__)])
        except ImportError:
            import _BSplCLib
            return _BSplCLib
        try:
            _mod = imp.load_module('_BSplCLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BSplCLib = swig_import_helper()
    del swig_import_helper
else:
    import _BSplCLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BSplCLib.delete_SwigPyIterator

    def value(self):
        return _BSplCLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BSplCLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BSplCLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BSplCLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BSplCLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BSplCLib.SwigPyIterator_copy(self)

    def next(self):
        return _BSplCLib.SwigPyIterator_next(self)

    def __next__(self):
        return _BSplCLib.SwigPyIterator___next__(self)

    def previous(self):
        return _BSplCLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BSplCLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BSplCLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BSplCLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BSplCLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BSplCLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BSplCLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BSplCLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BSplCLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BSplCLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BSplCLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BSplCLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BSplCLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BSplCLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BSplCLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BSplCLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BSplCLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BSplCLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BSplCLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BSplCLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BSplCLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BSplCLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BSplCLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BSplCLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BSplCLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BSplCLib.ptr_to_number(item)
ptr_to_number = _BSplCLib.ptr_to_number

def HashCode(*args):
    return _BSplCLib.HashCode(*args)
HashCode = _BSplCLib.HashCode

def ptr_equal(a, b):
    return _BSplCLib.ptr_equal(a, b)
ptr_equal = _BSplCLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
BSplCLib_NonUniform = _BSplCLib.BSplCLib_NonUniform
BSplCLib_Uniform = _BSplCLib.BSplCLib_Uniform
BSplCLib_NonConstant = _BSplCLib.BSplCLib_NonConstant
BSplCLib_Constant = _BSplCLib.BSplCLib_Constant
BSplCLib_QuasiConstant = _BSplCLib.BSplCLib_QuasiConstant
class BSplCLib_(object):
    """
    BSplCLib   B-spline curve Library.

    The BSplCLib package is  a basic library  for BSplines. It
    provides three categories of functions.

    * Management methods to  process knots and multiplicities.

    * Multi-Dimensions  spline methods.  BSpline methods where
    poles have an arbitrary number of dimensions. They divides
    in two groups :

    - Global methods modifying the  whole set of  poles. The
    poles are    described   by an array   of   Reals and  a
    Dimension. Example : Inserting knots.

    - Local methods  computing  points and derivatives.  The
    poles  are described by a pointer  on  a local array  of
    Reals and a Dimension. The local array is modified.

    *  2D  and 3D spline   curves  methods.

    Methods  for 2d and 3d BSplines  curves  rational or not
    rational.

    Those methods have the following structure :

    - They extract the pole informations in a working array.

    -  They      process the  working   array    with   the
    multi-dimension  methods. (for example  a  3d  rational
    curve is processed as a 4 dimension curve).

    - They get back the result in the original dimension.

    Note that the  bspline   surface methods found   in the
    package BSplSLib  uses  the same  structure and rely on
    BSplCLib.

    In the following list  of methods the  2d and 3d  curve
    methods   will be  described   with  the  corresponding
    multi-dimension method.

    The 3d or 2d B-spline curve is defined with :

    . its control points : TColgp_Array1OfPnt(2d)        Poles
    . its weights        : TColStd_Array1OfReal          Weights
    . its knots          : TColStd_Array1OfReal          Knots
    . its multiplicities : TColStd_Array1OfInteger       Mults
    . its degree         : Standard_Integer              Degree
    . its periodicity    : Standard_Boolean              Periodic

    Warnings :
    The bounds of Poles and Weights should be the same.
    The bounds of Knots and Mults   should be the same.

    Note: weight and multiplicity arrays can be passed by pointer for
    some functions so that NULL pointer is valid.
    That means no weights/no multiplicities passed.

    No weights (BSplCLib::NoWeights()) means the curve is non rational.
    No mults (BSplCLib::NoMults()) means the knots are "flat" knots.

    KeyWords :
    B-spline curve, Functions, Library

    References :
    . A survey of curves and surfaces methods in CADG Wolfgang
    BOHM CAGD 1 (1984)
    . On de Boor-like algorithms and blossoming Wolfgang BOEHM
    cagd 5 (1988)
    . Blossoming and knot insertion algorithms for B-spline curves
    Ronald N. GOLDMAN
    . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
    . Curves and Surfaces for Computer Aided Geometric Design,
    a practical guide Gerald Farin
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Hunt(*args):
        """
        Hunt(NCollection_Array1_Standard_Real XX, Standard_Real const X)

        This routine searches the position of the real
        value X in  the ordered set of  real  values XX.

        The  elements   in   the  table    XX  are   either
        monotonically    increasing     or    monotonically
        decreasing.

        The input   value Iloc is    used to initialize the
        algorithm  :  if  Iloc  is outside  of   the bounds
        [XX.Lower(), -- XX.Upper()] the bisection algorithm
        is used else  the routine searches from  a previous
        known position  by increasing steps  then converges
        by bisection.

        This  routine is used to  locate a  knot value in a
        set of knots.

        :type XX: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type X: float
        :type Iloc: int

        """
        return _BSplCLib.BSplCLib__Hunt(*args)

    Hunt = staticmethod(Hunt)

    def FirstUKnotIndex(*args):
        """
        FirstUKnotIndex(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

        Computes the index of the knots value which gives
        the start point of the curve.

        :type Degree: int
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__FirstUKnotIndex(*args)

    FirstUKnotIndex = staticmethod(FirstUKnotIndex)

    def LastUKnotIndex(*args):
        """
        LastUKnotIndex(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

        Computes the index of the knots value which gives
        the end point of the curve.

        :type Degree: int
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__LastUKnotIndex(*args)

    LastUKnotIndex = staticmethod(LastUKnotIndex)

    def FlatIndex(*args):
        """
        FlatIndex(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_Standard_Integer Mults, Standard_Boolean const Periodic) -> Standard_Integer

        Computes the index  of  the  flats knots  sequence
        corresponding  to  <Index> in  the  knots sequence
        which multiplicities are <Mults>.

        :type Degree: int
        :type Index: int
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Periodic: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__FlatIndex(*args)

    FlatIndex = staticmethod(FlatIndex)

    def LocateParameter(*args):
        """
        LocateParameter(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const U, Standard_Boolean const IsPeriodic, Standard_Integer const FromK1, Standard_Integer const ToK2)
        LocateParameter(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, Standard_Real const U, Standard_Boolean const IsPeriodic, Standard_Integer const FromK1, Standard_Integer const ToK2)
        LocateParameter(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const U, Standard_Boolean const Periodic)

        :type Degree: int
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type U: float
        :type Periodic: bool
        :type Index: int
        :type NewU: float

        """
        return _BSplCLib.BSplCLib__LocateParameter(*args)

    LocateParameter = staticmethod(LocateParameter)

    def MaxKnotMult(*args):
        """
        MaxKnotMult(NCollection_Array1_Standard_Integer Mults, Standard_Integer const K1, Standard_Integer const K2) -> Standard_Integer

        Finds the greatest multiplicity in a set of knots
        between  K1  and K2.   Mults  is  the  multiplicity
        associated with each knot value.

        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type K1: int
        :type K2: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__MaxKnotMult(*args)

    MaxKnotMult = staticmethod(MaxKnotMult)

    def MinKnotMult(*args):
        """
        MinKnotMult(NCollection_Array1_Standard_Integer Mults, Standard_Integer const K1, Standard_Integer const K2) -> Standard_Integer

        Finds the lowest multiplicity in  a  set of knots
        between   K1  and K2.   Mults is  the  multiplicity
        associated with each knot value.

        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type K1: int
        :type K2: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__MinKnotMult(*args)

    MinKnotMult = staticmethod(MinKnotMult)

    def NbPoles(*args):
        """
        NbPoles(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

        Returns the number of poles of the curve. Returns 0 if
        one of the multiplicities is incorrect.

        * Non positive.

        * Greater than Degree,  or  Degree+1  at the first and
        last knot of a non periodic curve.

        *  The  last periodicity  on  a periodic  curve is not
        equal to the first.

        :type Degree: int
        :type Periodic: bool
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__NbPoles(*args)

    NbPoles = staticmethod(NbPoles)

    def KnotSequenceLength(*args):
        """
        KnotSequenceLength(NCollection_Array1_Standard_Integer Mults, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Standard_Integer

        Returns the length  of the sequence  of knots with
        repetition.

        Periodic :

        Sum(Mults(i), i = Mults.Lower(); i <= Mults.Upper());

        Non Periodic :

        Sum(Mults(i); i = Mults.Lower(); i < Mults.Upper())
        + 2 * Degree

        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type Periodic: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__KnotSequenceLength(*args)

    KnotSequenceLength = staticmethod(KnotSequenceLength)

    def KnotSequence(*args):
        """
        KnotSequence(NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real KnotSeq, Standard_Boolean const Periodic)
        KnotSequence(NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real KnotSeq)

        Computes  the  sequence   of knots KnotSeq  with
        repetition  of the  knots  of multiplicity  greater
        than 1.

        Length of KnotSeq must be KnotSequenceLength(Mults,Degree,Periodic)

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type Periodic: bool
        :type KnotSeq: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__KnotSequence(*args)

    KnotSequence = staticmethod(KnotSequence)

    def KnotsLength(*args):
        """
        KnotsLength(NCollection_Array1_Standard_Real KnotSeq, Standard_Boolean const Periodic) -> Standard_Integer

        Returns the  length  of the   sequence of  knots  (and
        Mults)  without repetition.

        :type KnotSeq: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Periodic: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__KnotsLength(*args)

    KnotsLength = staticmethod(KnotsLength)

    def Knots(*args):
        """
        Knots(NCollection_Array1_Standard_Real KnotSeq, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Boolean const Periodic)

        Computes  the  sequence   of knots Knots  without
        repetition  of the  knots  of multiplicity  greater
        than 1.

        Length  of <Knots> and  <Mults> must be
        KnotsLength(KnotSequence,Periodic)

        :type KnotSeq: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Periodic: bool

        """
        return _BSplCLib.BSplCLib__Knots(*args)

    Knots = staticmethod(Knots)

    def KnotForm(*args):
        """
        KnotForm(NCollection_Array1_Standard_Real Knots, Standard_Integer const FromK1, Standard_Integer const ToK2) -> BSplCLib_KnotDistribution

        Analyses if the  knots distribution is "Uniform"
        or  "NonUniform" between  the  knot  FromK1 and the
        knot ToK2.  There is  no repetition of  knot in the
        knots'sequence <Knots>.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.BSplCLib.BSplCLib_KnotDistribution

        """
        return _BSplCLib.BSplCLib__KnotForm(*args)

    KnotForm = staticmethod(KnotForm)

    def MultForm(*args):
        """
        MultForm(NCollection_Array1_Standard_Integer Mults, Standard_Integer const FromK1, Standard_Integer const ToK2) -> BSplCLib_MultDistribution

        Analyses the distribution of multiplicities between
        the knot FromK1 and the Knot ToK2.

        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.BSplCLib.BSplCLib_MultDistribution

        """
        return _BSplCLib.BSplCLib__MultForm(*args)

    MultForm = staticmethod(MultForm)

    def KnotAnalysis(*args):
        """
        KnotAnalysis(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real CKnots, NCollection_Array1_Standard_Integer CMults)

        Analyzes the array of knots.
        Returns the form and the maximum knot multiplicity.

        :type Degree: int
        :type Periodic: bool
        :type CKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type CMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type KnotForm: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution
        :type MaxKnotMult: int

        """
        return _BSplCLib.BSplCLib__KnotAnalysis(*args)

    KnotAnalysis = staticmethod(KnotAnalysis)

    def Reparametrize(*args):
        """
        Reparametrize(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real Knots)

        Reparametrizes a B-spline curve to [U1, U2].
        The knot values are recomputed such that Knots (Lower) = U1
        and Knots (Upper) = U2   but the knot form is not modified.
        Warnings :
        In the array Knots the values must be in ascending order.
        U1 must not be equal to U2 to avoid division by zero.

        :type U1: float
        :type U2: float
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__Reparametrize(*args)

    Reparametrize = staticmethod(Reparametrize)

    def Reverse(*args):
        """
        Reverse(NCollection_Array1_Standard_Real Knots)
        Reverse(NCollection_Array1_Standard_Integer Mults)
        Reverse(NCollection_Array1_gp_Pnt Poles, Standard_Integer const Last)
        Reverse(NCollection_Array1_gp_Pnt2d Poles, Standard_Integer const Last)
        Reverse(NCollection_Array1_Standard_Real Weights, Standard_Integer const Last)

        Reverses the array of poles.

        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Last: int

        """
        return _BSplCLib.BSplCLib__Reverse(*args)

    Reverse = staticmethod(Reverse)

    def IsRational(*args):
        """
        IsRational(NCollection_Array1_Standard_Real Weights, Standard_Integer const I1, Standard_Integer const I2, Standard_Real const Epsilon=0.0) -> Standard_Boolean

        Returns False if all the weights  of the  array <Weights>
        between   I1 an I2   are  identic.   Epsilon  is used for
        comparing  weights. If Epsilon  is 0. the  Epsilon of the
        first weight is used.

        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type I1: int
        :type I2: int
        :type Epsilon: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.BSplCLib__IsRational(*args)

    IsRational = staticmethod(IsRational)

    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        returns the degree maxima for a BSplineCurve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def BoorScheme(*args):
        """
        BoorScheme(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const Depth, Standard_Integer const Length)

        Performs the  Boor Algorithm  at  parameter <U> with
        the given <Degree> and the  array of <Knots> on  the
        poles <Poles> of dimension  <Dimension>.  The schema
        is  computed  until  level  <Depth>  on a   basis of
        <Length+1> poles.

        * Knots is an array of reals of length :

        <Length> + <Degree>

        * Poles is an array of reals of length :

        (2 * <Length> + 1) * <Dimension>

        The poles values  must be  set  in the array at the
        positions.

        0..Dimension,

        2 * Dimension ..
        3 * Dimension

        4  * Dimension ..
        5  * Dimension

        ...

        The results are found in the array poles depending
        on the Depth. (See the method GetPole).

        :type U: float
        :type Degree: int
        :type Knots: float
        :type Dimension: int
        :type Poles: float
        :type Depth: int
        :type Length: int

        """
        return _BSplCLib.BSplCLib__BoorScheme(*args)

    BoorScheme = staticmethod(BoorScheme)

    def AntiBoorScheme(*args):
        """
        AntiBoorScheme(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const Depth, Standard_Integer const Length, Standard_Real const Tolerance) -> Standard_Boolean

        Compute  the content of  Pole before the BoorScheme.
        This method is used to remove poles.

        U is the poles to  remove, Knots should contains the
        knots of the curve after knot removal.

        The first  and last poles  do not  change, the other
        poles are computed by averaging two possible values.
        The distance between  the  two   possible  poles  is
        computed, if it  is higher than <Tolerance> False is
        returned.

        :type U: float
        :type Degree: int
        :type Knots: float
        :type Dimension: int
        :type Poles: float
        :type Depth: int
        :type Length: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.BSplCLib__AntiBoorScheme(*args)

    AntiBoorScheme = staticmethod(AntiBoorScheme)

    def Derivative(*args):
        """
        Derivative(Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const Length, Standard_Integer const Order)

        Computes   the   poles of  the    BSpline  giving the
        derivatives of order <Order>.

        The formula for the first order is

        Pole(i) = Degree * (Pole(i+1) - Pole(i)) /
        (Knots(i+Degree+1) - Knots(i+1))

        This formula  is repeated  (Degree  is decremented at
        each step).

        :type Degree: int
        :type Knots: float
        :type Dimension: int
        :type Length: int
        :type Order: int
        :type Poles: float

        """
        return _BSplCLib.BSplCLib__Derivative(*args)

    Derivative = staticmethod(Derivative)

    def Bohm(*args):
        """
        Bohm(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const N, Standard_Integer const Dimension)

        Performs the Bohm  Algorithm at  parameter <U>. This
        algorithm computes the value and all the derivatives
        up to order N (N <= Degree).

        <Poles> is the original array of poles.

        The   result in  <Poles>  is    the value and    the
        derivatives.  Poles[0] is  the value,  Poles[Degree]
        is the last  derivative.

        :type U: float
        :type Degree: int
        :type N: int
        :type Knots: float
        :type Dimension: int
        :type Poles: float

        """
        return _BSplCLib.BSplCLib__Bohm(*args)

    Bohm = staticmethod(Bohm)

    def NoWeights(*args):
        """
        NoWeights() -> NCollection_Array1_Standard_Real

        Used as argument for a non rational curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def NoMults(*args):
        """
        NoMults() -> NCollection_Array1_Standard_Integer

        Used as argument for a flatknots evaluation.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BSplCLib.BSplCLib__NoMults(*args)

    NoMults = staticmethod(NoMults)

    def BuildKnots(*args):
        """
        BuildKnots(Standard_Integer const Degree, Standard_Integer const Index, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        Stores in LK  the usefull knots  for the BoorSchem
        on the span Knots(Index) - Knots(Index+1)

        :type Degree: int
        :type Index: int
        :type Periodic: bool
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type LK: float

        """
        return _BSplCLib.BSplCLib__BuildKnots(*args)

    BuildKnots = staticmethod(BuildKnots)

    def PoleIndex(*args):
        """
        PoleIndex(Standard_Integer const Degree, Standard_Integer const Index, Standard_Boolean const Periodic, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

        Return the index of the  first Pole to  use on the
        span  Mults(Index)  - Mults(Index+1).  This  index
        must be added to Poles.Lower().

        :type Degree: int
        :type Index: int
        :type Periodic: bool
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__PoleIndex(*args)

    PoleIndex = staticmethod(PoleIndex)

    def BuildEval(*args):
        """
        BuildEval(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights)
        BuildEval(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
        BuildEval(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights)

        Copy in <LP>  the poles and  weights for  the Eval
        scheme. starting from  Poles(Poles.Lower()+Index)

        :type Degree: int
        :type Index: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type LP: float

        """
        return _BSplCLib.BSplCLib__BuildEval(*args)

    BuildEval = staticmethod(BuildEval)

    def BuildBoor(*args):
        """
        BuildBoor(Standard_Integer const Index, Standard_Integer const Length, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles)

        Copy in <LP>  poles for <Dimension>  Boor  scheme.
        Starting  from    <Index>     *  <Dimension>, copy
        <Length+1> poles.

        :type Index: int
        :type Length: int
        :type Dimension: int
        :type Poles: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type LP: float

        """
        return _BSplCLib.BSplCLib__BuildBoor(*args)

    BuildBoor = staticmethod(BuildBoor)

    def BoorIndex(*args):
        """
        BoorIndex(Standard_Integer const Index, Standard_Integer const Length, Standard_Integer const Depth) -> Standard_Integer

        Returns the index in  the Boor result array of the
        poles <Index>. If  the Boor  algorithm was perform
        with <Length> and <Depth>.

        :type Index: int
        :type Length: int
        :type Depth: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__BoorIndex(*args)

    BoorIndex = staticmethod(BoorIndex)

    def GetPole(*args):
        """
        GetPole(Standard_Integer const Index, Standard_Integer const Length, Standard_Integer const Depth, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Pole)

        Copy  the  pole at  position  <Index>  in  the Boor
        scheme of   dimension <Dimension> to  <Position> in
        the array <Pole>. <Position> is updated.

        :type Index: int
        :type Length: int
        :type Depth: int
        :type Dimension: int
        :type LocPoles: float
        :type Position: int
        :type Pole: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__GetPole(*args)

    GetPole = staticmethod(GetPole)

    def PrepareInsertKnots(*args):
        """
        PrepareInsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, Standard_Real const Epsilon, Standard_Boolean const Add) -> Standard_Boolean

        Returns in <NbPoles, NbKnots> the  new number of poles
        and  knots    if  the  sequence   of  knots <AddKnots,
        AddMults> is inserted in the sequence <Knots, Mults>.

        Epsilon is used to compare knots for equality.

        If Add is True  the multiplicities on  equal knots are
        added.

        If Add is False the max value of the multiplicities is
        kept.

        Return False if :
        The knew knots are knot increasing.
        The new knots are not in the range.

        :type Degree: int
        :type Periodic: bool
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type AddKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type AddMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbPoles: int
        :type NbKnots: int
        :type Epsilon: float
        :type Add: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.BSplCLib__PrepareInsertKnots(*args)

    PrepareInsertKnots = staticmethod(PrepareInsertKnots)

    def InsertKnots(*args):
        """
        InsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array1_Standard_Real NewPoles, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)
        InsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)
        InsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)

        Insert   a  sequence  of  knots <AddKnots> with
        multiplicities   <AddMults>. <AddKnots>   must  be a   non
        decreasing sequence and verifies :

        Knots(Knots.Lower()) <= AddKnots(AddKnots.Lower())
        Knots(Knots.Upper()) >= AddKnots(AddKnots.Upper())

        The NewPoles and NewWeights arrays must have a length :
        Poles.Length() + Sum(AddMults())

        When a knot  to insert is identic  to an existing knot the
        multiplicities   are added.

        Epsilon is used to test knots for equality.

        When AddMult is negative or null the knot is not inserted.
        No multiplicity will becomes higher than the degree.

        The new Knots and Multiplicities  are copied in <NewKnots>
        and  <NewMults>.

        All the New arrays should be correctly dimensioned.

        When all  the new knots  are existing knots, i.e. only the
        multiplicities  will  change it is   safe to  use the same
        arrays as input and output.

        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type AddKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type AddMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Epsilon: float
        :type Add: bool

        """
        return _BSplCLib.BSplCLib__InsertKnots(*args)

    InsertKnots = staticmethod(InsertKnots)

    def InsertKnot(*args):
        """
        InsertKnot(Standard_Integer const UIndex, Standard_Real const U, Standard_Integer const UMult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
        InsertKnot(Standard_Integer const UIndex, Standard_Real const U, Standard_Integer const UMult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

        Insert a new knot U of multiplicity UMult in the
        knot sequence.

        The  location of the new Knot  should be given as an input
        data.  UIndex locates the new knot U  in the knot sequence
        and Knots (UIndex) < U < Knots (UIndex + 1).

        The new control points corresponding to this insertion are
        returned. Knots and Mults are not updated.

        :type UIndex: int
        :type U: float
        :type UMult: int
        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__InsertKnot(*args)

    InsertKnot = staticmethod(InsertKnot)

    def RaiseMultiplicity(*args):
        """
        RaiseMultiplicity(Standard_Integer const KnotIndex, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
        RaiseMultiplicity(Standard_Integer const KnotIndex, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

        Raise the multiplicity of knot to <UMult>.

        The new control points  are  returned. Knots and Mults are
        not updated.

        :type KnotIndex: int
        :type Mult: int
        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__RaiseMultiplicity(*args)

    RaiseMultiplicity = staticmethod(RaiseMultiplicity)

    def RemoveKnot(*args):
        """
        RemoveKnot(Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real NewPoles, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean
        RemoveKnot(Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean
        RemoveKnot(Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean

        Decrement the  multiplicity  of <Knots(Index)>
        to <Mult>. If <Mult>   is  null the   knot  is
        removed.

        As there are two ways to compute the new poles
        the midlle   will  be used  as  long    as the
        distance is lower than Tolerance.

        If a  distance is  bigger  than  tolerance the
        methods returns False  and  the new arrays are
        not modified.

        A low  tolerance can be  used  to test  if the
        knot  can be  removed  without  modifying  the
        curve.

        A high tolerance  can be used  to "smooth" the
        curve.

        :type Index: int
        :type Mult: int
        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.BSplCLib__RemoveKnot(*args)

    RemoveKnot = staticmethod(RemoveKnot)

    def IncreaseDegreeCountKnots(*args):
        """
        IncreaseDegreeCountKnots(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

        Returns the   number   of  knots   of  a  curve   with
        multiplicities <Mults> after elevating the degree from
        <Degree> to <NewDegree>. See the IncreaseDegree method
        for more comments.

        :type Degree: int
        :type NewDegree: int
        :type Periodic: bool
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__IncreaseDegreeCountKnots(*args)

    IncreaseDegreeCountKnots = staticmethod(IncreaseDegreeCountKnots)

    def IncreaseDegree(*args):
        """
        IncreaseDegree(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real NewPoles, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)
        IncreaseDegree(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)
        IncreaseDegree(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)
        IncreaseDegree(Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
        IncreaseDegree(Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

        Increase the degree of a bspline (or bezier) curve
        of   dimension  <Dimension>  form <Degree>      to
        <NewDegree>.

        The number of poles in the new curve is :

        Poles.Length() + (NewDegree - Degree) * Number of spans

        Where the number of spans is :

        LastUKnotIndex(Mults) - FirstUKnotIndex(Mults) + 1

        for a non-periodic curve

        And Knots.Length() - 1 for a periodic curve.

        The multiplicities of all  knots  are increased by
        the degree elevation.

        The new knots are usually  the same knots with the
        exception of  a non-periodic curve with  the first
        and last multiplicity not  equal to Degree+1 where
        knots are removed  form the start  and the  bottom
        untils the sum of the  multiplicities is  equal to
        NewDegree+1  at the  knots   corresponding  to the
        first and last parameters of the curve.

        Example  :  Suppose a  curve  of degree 3 starting
        with following knots and multiplicities :

        knot : 0.  1.  2.
        mult : 1   2   1

        The  FirstUKnot is  2.     because the   sum    of
        multiplicities is Degree+1 : 1 + 2 + 1 = 4 = 3 + 1

        i.e. the first parameter  of the  curve is  2. and
        will still be   2.  after degree  elevation.   Let
        raises this curve to degree 4.  The multiplicities
        are increased by 2.

        They   become 2 3  2.   But     we need a   sum of
        multiplicities  of 5 at knot  2. So the first knot
        is removed and the new knots are :

        knot : 1.  2.
        mult : 3   2

        The multipicity   of the first  knot may   also be
        reduced if the sum is still to big.

        In the  most common situations (periodic  curve or
        curve with first and last multiplicities equals to
        Degree+1) the knots are knot changes.

        The method IncreaseDegreeCountKnots can be used to
        compute the new number of knots.

        :type NewDegree: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__IncreaseDegree(*args)

    IncreaseDegree = staticmethod(IncreaseDegree)

    def PrepareUnperiodize(*args):
        """
        PrepareUnperiodize(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults)

        Set in <NbKnots> and <NbPolesToAdd> the number of Knots and
        Poles   of  the NotPeriodic  Curve   identical  at the
        periodic     curve with    a  degree    <Degree>  ,  a
        knots-distribution with Multiplicities <Mults>.

        :type Degree: int
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbKnots: int
        :type NbPoles: int

        """
        return _BSplCLib.BSplCLib__PrepareUnperiodize(*args)

    PrepareUnperiodize = staticmethod(PrepareUnperiodize)

    def Unperiodize(*args):
        """
        Unperiodize(Standard_Integer const Degree, Standard_Integer const Dimension, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Real NewPoles)
        Unperiodize(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
        Unperiodize(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

        :type Degree: int
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__Unperiodize(*args)

    Unperiodize = staticmethod(Unperiodize)

    def PrepareTrimming(*args):
        """
        PrepareTrimming(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const U1, Standard_Real const U2)

        Set in <NbKnots> and <NbPoles> the number of Knots and
        Poles of the  curve resulting  of  the trimming of the
        BSplinecurve definded with <degree>, <knots>, <mults>

        :type Degree: int
        :type Periodic: bool
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type U1: float
        :type U2: float
        :type NbKnots: int
        :type NbPoles: int

        """
        return _BSplCLib.BSplCLib__PrepareTrimming(*args)

    PrepareTrimming = staticmethod(PrepareTrimming)

    def Trimming(*args):
        """
        Trimming(Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Poles, Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewPoles)
        Trimming(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
        Trimming(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

        :type Degree: int
        :type Periodic: bool
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type U1: float
        :type U2: float
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__Trimming(*args)

    Trimming = staticmethod(Trimming)

    def D0(*args):
        """
        D0(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
        D0(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P)
        D0(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P)
        D0(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P)
        D0(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P)

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BSplCLib.BSplCLib__D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
        D1(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P, gp_Vec V)
        D1(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P, gp_Vec2d V)
        D1(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P, gp_Vec V)
        D1(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
        D2(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        D2(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
        D2(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P, gp_Vec V1, gp_Vec V2)
        D2(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
        D3(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        D3(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)
        D3(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
        D3(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Standard_Real const U, Standard_Integer const N, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
        DN(Standard_Real const U, Standard_Integer const N, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Vec VN)
        DN(Standard_Real const U, Standard_Integer const N, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Vec2d V)

        :type U: float
        :type N: int
        :type UIndex: int
        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__DN(*args)

    DN = staticmethod(DN)

    def EvalBsplineBasis(*args):
        """
        EvalBsplineBasis(Standard_Integer const DerivativeOrder, Standard_Integer const Order, NCollection_Array1_Standard_Real FlatKnots, Standard_Real const Parameter, math_Matrix BsplineBasis, Standard_Boolean const isPeriodic) -> Standard_Integer

        This  evaluates  the Bspline  Basis  at  a
        given  parameter  Parameter   up   to  the
        requested   DerivativeOrder  and store the
        result  in the  array BsplineBasis  in the
        following   fashion
        BSplineBasis(1,1)   =
        value of first non vanishing
        Bspline function which has Index FirstNonZeroBsplineIndex
        BsplineBasis(1,2)   =
        value of second non vanishing
        Bspline   function which  has   Index
        FirstNonZeroBsplineIndex + 1
        BsplineBasis(1,n)   =
        value of second non vanishing non vanishing
        Bspline   function which  has   Index
        FirstNonZeroBsplineIndex + n (n <= Order)
        BSplineBasis(2,1)   =
        value of derivative of first non vanishing
        Bspline function which has Index FirstNonZeroBsplineIndex
        BSplineBasis(N,1)   =
        value of Nth derivative of first non vanishing
        Bspline function which has Index FirstNonZeroBsplineIndex
        if N <= DerivativeOrder + 1

        :type DerivativeOrder: int
        :type Order: int
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Parameter: float
        :type FirstNonZeroBsplineIndex: int
        :type BsplineBasis: OCC.wrapper.math.math_Matrix
        :type isPeriodic: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__EvalBsplineBasis(*args)

    EvalBsplineBasis = staticmethod(EvalBsplineBasis)

    def BuildBSpMatrix(*args):
        """
        BuildBSpMatrix(NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer OrderArray, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, math_Matrix Matrix) -> Standard_Integer

        This Builds   a fully  blown   Matrix of
        (ni)
        Bi    (tj)

        with i  and j within 1..Order + NumPoles
        The  integer ni is   the ith slot of the
        array OrderArray, tj is the jth slot of
        the array Parameters

        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type OrderArray: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Degree: int
        :type Matrix: OCC.wrapper.math.math_Matrix
        :type UpperBandWidth: int
        :type LowerBandWidth: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__BuildBSpMatrix(*args)

    BuildBSpMatrix = staticmethod(BuildBSpMatrix)

    def FactorBandedMatrix(*args):
        """
        FactorBandedMatrix(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth) -> Standard_Integer

        this  factors  the Banded Matrix in
        the LU form with a Banded storage of
        components of the L matrix
        WARNING : do not use if the Matrix is
        totally positive (It is the case for
        Bspline matrices build as above with
        parameters being the Schoenberg points

        :type Matrix: OCC.wrapper.math.math_Matrix
        :type UpperBandWidth: int
        :type LowerBandWidth: int
        :type PivotIndexProblem: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__FactorBandedMatrix(*args)

    FactorBandedMatrix = staticmethod(FactorBandedMatrix)

    def SolveBandedSystem(*args):
        """
        SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Integer const ArrayDimension) -> Standard_Integer
        SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, NCollection_Array1_gp_Pnt2d Array) -> Standard_Integer
        SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, NCollection_Array1_gp_Pnt Array) -> Standard_Integer
        SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Boolean const HomogenousFlag, Standard_Integer const ArrayDimension) -> Standard_Integer
        SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Boolean const HomogenousFlag, NCollection_Array1_gp_Pnt2d Array, NCollection_Array1_Standard_Real Weights) -> Standard_Integer
        SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Boolean const HomogeneousFlag, NCollection_Array1_gp_Pnt Array, NCollection_Array1_Standard_Real Weights) -> Standard_Integer

        This solves  the system Matrix.X =  B
        with when Matrix is factored in LU form
        The  Array   is    an   seen   as    an
        Array[1..N][1..ArrayDimension] with N =
        the  rank  of the  matrix  Matrix.  The
        result is stored   in Array  when  each
        coordinate is  solved that is  B is the
        array whose values are
        B[i] = Array[i][p] for each p in 1..ArrayDimension
        If  HomogeneousFlag ==
        0  the  Poles  are  multiplied by   the
        Weights   uppon   Entry   and      once
        interpolation   is    carried  over the
        result of the  poles are divided by the
        result of   the   interpolation of  the
        weights. Otherwise if HomogenousFlag == 1
        the Poles and Weigths are treated homogenously
        that is that those are interpolated as they
        are and result is returned without division
        by the interpolated weigths.

        :type Matrix: OCC.wrapper.math.math_Matrix
        :type UpperBandWidth: int
        :type LowerBandWidth: int
        :type HomogeneousFlag: bool
        :type Array: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.BSplCLib__SolveBandedSystem(*args)

    SolveBandedSystem = staticmethod(SolveBandedSystem)

    def MergeBSplineKnots(*args):
        """
        MergeBSplineKnots(Standard_Real const Tolerance, Standard_Real const StartValue, Standard_Real const EndValue, Standard_Integer const Degree1, NCollection_Array1_Standard_Real Knots1, NCollection_Array1_Standard_Integer Mults1, Standard_Integer const Degree2, NCollection_Array1_Standard_Real Knots2, NCollection_Array1_Standard_Integer Mults2, Handle_TColStd_HArray1OfReal NewKnots, Handle_TColStd_HArray1OfInteger NewMults)

        Merges  two knot vector by   setting the starting and
        ending values to StartValue and EndValue

        :type Tolerance: float
        :type StartValue: float
        :type EndValue: float
        :type Degree1: int
        :type Knots1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults1: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree2: int
        :type Knots2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults2: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NumPoles: int
        :type NewKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type NewMults: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _BSplCLib.BSplCLib__MergeBSplineKnots(*args)

    MergeBSplineKnots = staticmethod(MergeBSplineKnots)

    def FunctionReparameterise(*args):
        """
        FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, Standard_Integer const PolesDimension, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree)
        FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_Standard_Real NewPoles)
        FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt NewPoles)
        FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt2d NewPoles)

        this will compose  a given Vectorial BSpline F(t)
        defined  by its  BSplineDegree and BSplineFlatKnotsl,
        its Poles  array which are coded as  an array of Real
        of  the  form  [1..NumPoles][1..PolesDimension] with  a
        function     a(t) which is   assumed to   satisfy the
        following  : 1. F(a(t))  is a polynomial BSpline
        that can be expressed  exactly as a BSpline of degree
        NewDegree on the knots FlatKnots
        2. a(t) defines a differentiable
        isomorphism between the range of FlatKnots to the range
        of BSplineFlatKnots which is the
        same as the  range of F(t)
        Warning: it is
        the caller's responsability to insure that conditions
        1. and  2. above are  satisfied : no check whatsoever
        is made in this method
        theStatus will return 0 if OK else it will return the pivot index
        of the matrix that was inverted to compute the multiplied
        BSpline : the method used is interpolation at Schoenenberg
        points of F(a(t))

        :type Function: OCC.wrapper.BSplCLib.BSplCLib_EvaluatorFunction
        :type BSplineDegree: int
        :type BSplineFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewDegree: int
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type theStatus: int

        """
        return _BSplCLib.BSplCLib__FunctionReparameterise(*args)

    FunctionReparameterise = staticmethod(FunctionReparameterise)

    def FunctionMultiply(*args):
        """
        FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, Standard_Integer const PolesDimension, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree)
        FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_Standard_Real NewPoles)
        FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt2d NewPoles)
        FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt NewPoles)

        this will  multiply a given Vectorial BSpline F(t)
        defined  by its  BSplineDegree and BSplineFlatKnotsl,
        its Poles  array which are coded as  an array of Real
        of  the  form  [1..NumPoles][1..PolesDimension] by  a
        function     a(t) which is   assumed to   satisfy the
        following  : 1. a(t)  * F(t)  is a polynomial BSpline
        that can be expressed  exactly as a BSpline of degree
        NewDegree on the knots FlatKnots 2. the range of a(t)
        is the same as the  range of F(t)
        Warning: it is
        the caller's responsability to insure that conditions
        1. and  2. above are  satisfied : no check whatsoever
        is made in this method
        theStatus will return 0 if OK else it will return the pivot index
        of the matrix that was inverted to compute the multiplied
        BSpline : the method used is interpolation at Schoenenberg
        points of a(t)*F(t)

        :type Function: OCC.wrapper.BSplCLib.BSplCLib_EvaluatorFunction
        :type BSplineDegree: int
        :type BSplineFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewDegree: int
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theStatus: int

        """
        return _BSplCLib.BSplCLib__FunctionMultiply(*args)

    FunctionMultiply = staticmethod(FunctionMultiply)

    def Eval(*args):
        """
        Eval(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension)
        Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Integer const DerivativeRequest, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const ArrayDimension)
        Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Integer const DerivativeRequest, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const ArrayDimension)
        Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Boolean const HomogeneousFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point)
        Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Boolean const HomogeneousFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point)

        Perform the evaluation of the Bspline Basis
        and then multiplies by the weights
        this just evaluates the current point

        :type U: float
        :type PeriodicFlag: bool
        :type HomogeneousFlag: bool
        :type ExtrapMode: int
        :type Degree: int
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Weight: float

        """
        return _BSplCLib.BSplCLib__Eval(*args)

    Eval = staticmethod(Eval)

    def TangExtendToConstraint(*args):
        """
        TangExtendToConstraint(NCollection_Array1_Standard_Real FlatKnots, Standard_Real const C1Coefficient, Standard_Integer const NumPoles, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real ConstraintPoint, Standard_Integer const Continuity, Standard_Boolean const After)

        Extend a BSpline nD using the tangency map
        <C1Coefficient> is the coefficient of reparametrisation
        <Continuity> must be equal to 1, 2 or 3.
        <Degree> must be greater or equal than <Continuity> + 1.

        Warning:   <KnotsResult> and <PolesResult>  must be   dimensionned
        properly.

        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type C1Coefficient: float
        :type NumPoles: int
        :type Poles: float
        :type Dimension: int
        :type Degree: int
        :type ConstraintPoint: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Continuity: int
        :type After: bool
        :type NbPolesResult: int
        :type NbKnotsRsult: int
        :type KnotsResult: float
        :type PolesResult: float

        """
        return _BSplCLib.BSplCLib__TangExtendToConstraint(*args)

    TangExtendToConstraint = staticmethod(TangExtendToConstraint)

    def CacheD0(*args):
        """
        CacheD0(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point)
        CacheD0(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point)

        Perform the evaluation of the Bspline Basis
        and then multiplies by the weights
        this just evaluates the current point
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        ththe CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effectsis just evaluates the current point

        :type U: float
        :type Degree: int
        :type CacheParameter: float
        :type SpanLenght: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BSplCLib.BSplCLib__CacheD0(*args)

    CacheD0 = staticmethod(CacheD0)

    def CoefsD0(*args):
        """
        CoefsD0(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point)
        CoefsD0(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point)

        Calls CacheD0 for Bezier  Curves Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for Beziercurves ONLY!!!

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BSplCLib.BSplCLib__CoefsD0(*args)

    CoefsD0 = staticmethod(CoefsD0)

    def CacheD1(*args):
        """
        CacheD1(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec)
        CacheD1(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec)

        Perform the evaluation of the Bspline Basis
        and then multiplies by the weights
        this just evaluates the current point
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        ththe CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effectsis just evaluates the current point

        :type U: float
        :type Degree: int
        :type CacheParameter: float
        :type SpanLenght: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Vec: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__CacheD1(*args)

    CacheD1 = staticmethod(CacheD1)

    def CoefsD1(*args):
        """
        CoefsD1(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec)
        CoefsD1(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec)

        Calls CacheD1 for Bezier  Curves Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for Beziercurves ONLY!!!

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Vec: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__CoefsD1(*args)

    CoefsD1 = staticmethod(CoefsD1)

    def CacheD2(*args):
        """
        CacheD2(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2)
        CacheD2(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2)

        Perform the evaluation of the Bspline Basis
        and then multiplies by the weights
        this just evaluates the current point
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        ththe CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effectsis just evaluates the current point

        :type U: float
        :type Degree: int
        :type CacheParameter: float
        :type SpanLenght: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Vec1: OCC.wrapper.gp.gp_Vec2d
        :type Vec2: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__CacheD2(*args)

    CacheD2 = staticmethod(CacheD2)

    def CoefsD2(*args):
        """
        CoefsD2(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2)
        CoefsD2(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2)

        Calls CacheD1 for Bezier  Curves Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for Beziercurves ONLY!!!

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Vec1: OCC.wrapper.gp.gp_Vec2d
        :type Vec2: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__CoefsD2(*args)

    CoefsD2 = staticmethod(CoefsD2)

    def CacheD3(*args):
        """
        CacheD3(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2, gp_Vec Vec3)
        CacheD3(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2, gp_Vec2d Vec3)

        Perform the evaluation of the Bspline Basis
        and then multiplies by the weights
        this just evaluates the current point
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        ththe CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effectsis just evaluates the current point

        :type U: float
        :type Degree: int
        :type CacheParameter: float
        :type SpanLenght: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Vec1: OCC.wrapper.gp.gp_Vec2d
        :type Vec2: OCC.wrapper.gp.gp_Vec2d
        :type Vec3: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__CacheD3(*args)

    CacheD3 = staticmethod(CacheD3)

    def CoefsD3(*args):
        """
        CoefsD3(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2, gp_Vec Vec3)
        CoefsD3(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2, gp_Vec2d Vec3)

        Calls CacheD1 for Bezier  Curves Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for Beziercurves ONLY!!!

        :type U: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Vec1: OCC.wrapper.gp.gp_Vec2d
        :type Vec2: OCC.wrapper.gp.gp_Vec2d
        :type Vec3: OCC.wrapper.gp.gp_Vec2d

        """
        return _BSplCLib.BSplCLib__CoefsD3(*args)

    CoefsD3 = staticmethod(CoefsD3)

    def BuildCache(*args):
        """
        BuildCache(Standard_Real const U, Standard_Real const InverseOfSpanDomain, Standard_Boolean const PeriodicFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt CachePoles, NCollection_Array1_Standard_Real CacheWeights)
        BuildCache(Standard_Real const U, Standard_Real const InverseOfSpanDomain, Standard_Boolean const PeriodicFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt2d CachePoles, NCollection_Array1_Standard_Real CacheWeights)
        BuildCache(Standard_Real const theParameter, Standard_Real const theSpanDomain, Standard_Boolean const thePeriodicFlag, Standard_Integer const theDegree, Standard_Integer const theSpanIndex, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt thePoles, NCollection_Array1_Standard_Real theWeights, NCollection_Array2_Standard_Real theCacheArray)
        BuildCache(Standard_Real const theParameter, Standard_Real const theSpanDomain, Standard_Boolean const thePeriodicFlag, Standard_Integer const theDegree, Standard_Integer const theSpanIndex, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt2d thePoles, NCollection_Array1_Standard_Real theWeights, NCollection_Array2_Standard_Real theCacheArray)

        Perform the evaluation of the Taylor expansion
        of the Bspline normalized between 0 and 1.
        Structure of result optimized for BSplCLib_Cache.

        :type theParameter: float
        :type theSpanDomain: float
        :type thePeriodicFlag: bool
        :type theDegree: int
        :type theSpanIndex: int
        :type theFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theCacheArray: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplCLib.BSplCLib__BuildCache(*args)

    BuildCache = staticmethod(BuildCache)

    def PolesCoefficients(*args):
        """
        PolesCoefficients(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_gp_Pnt2d CachePoles)
        PolesCoefficients(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt2d CachePoles, NCollection_Array1_Standard_Real CacheWeights)
        PolesCoefficients(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt CachePoles)
        PolesCoefficients(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt CachePoles, NCollection_Array1_Standard_Real CacheWeights)

        Encapsulation   of  BuildCache    to   perform   the
        evaluation  of the Taylor expansion for beziercurves
        at parameter 0.
        Warning: To be used for Beziercurves ONLY!!!

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type CachePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CacheWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__PolesCoefficients(*args)

    PolesCoefficients = staticmethod(PolesCoefficients)

    def FlatBezierKnots(*args):
        """
        FlatBezierKnots(Standard_Integer const Degree) -> Standard_Real const &

        Returns pointer to statically allocated array representing
        flat knots for bezier curve of the specified degree.
        Raises OutOfRange if Degree > MaxDegree()

        :type Degree: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BSplCLib.BSplCLib__FlatBezierKnots(*args)

    FlatBezierKnots = staticmethod(FlatBezierKnots)

    def BuildSchoenbergPoints(*args):
        """
        BuildSchoenbergPoints(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters)

        builds the Schoenberg points from the flat knot
        used to interpolate a BSpline since the
        BSpline matrix is invertible.

        :type Degree: int
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib__BuildSchoenbergPoints(*args)

    BuildSchoenbergPoints = staticmethod(BuildSchoenbergPoints)

    def Interpolate(*args):
        """
        Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt Poles)
        Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt2d Poles)
        Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
        Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights)
        Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, Standard_Integer const ArrayDimension)
        Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, Standard_Integer const ArrayDimension)

        :type Degree: int
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type ContactOrderArray: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ArrayDimension: int
        :type Poles: float
        :type Weights: float
        :type InversionProblem: int

        """
        return _BSplCLib.BSplCLib__Interpolate(*args)

    Interpolate = staticmethod(Interpolate)

    def MovePoint(*args):
        """
        MovePoint(Standard_Real const U, gp_Vec2d Displ, Standard_Integer const Index1, Standard_Integer const Index2, Standard_Integer const Degree, Standard_Boolean const Rational, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d NewPoles)
        MovePoint(Standard_Real const U, gp_Vec Displ, Standard_Integer const Index1, Standard_Integer const Index2, Standard_Integer const Degree, Standard_Boolean const Rational, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt NewPoles)

        Find the new poles which allows  an old point (with a
        given  u as parameter) to reach a new position
        Index1 and Index2 indicate the range of poles we can move
        (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side
        don't enter (1,NbPoles) -> error: rigid move
        (2, NbPoles-1) -> the ends are enforced
        (3, NbPoles-2) -> the ends and the tangency are enforced
        if Problem in BSplineBasis calculation, no change for the curve
        and FirstIndex, LastIndex = 0

        :type U: float
        :type Displ: OCC.wrapper.gp.gp_Vec
        :type Index1: int
        :type Index2: int
        :type Degree: int
        :type Rational: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type FirstIndex: int
        :type LastIndex: int
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _BSplCLib.BSplCLib__MovePoint(*args)

    MovePoint = staticmethod(MovePoint)

    def MovePointAndTangent(*args):
        """
        MovePointAndTangent(Standard_Real const U, Standard_Integer const ArrayDimension, Standard_Real const Tolerance, Standard_Integer const Degree, Standard_Boolean const Rational, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots)
        MovePointAndTangent(Standard_Real const U, gp_Vec Delta, gp_Vec DeltaDerivative, Standard_Real const Tolerance, Standard_Integer const Degree, Standard_Boolean const Rational, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt NewPoles)
        MovePointAndTangent(Standard_Real const U, gp_Vec2d Delta, gp_Vec2d DeltaDerivative, Standard_Real const Tolerance, Standard_Integer const Degree, Standard_Boolean const Rational, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d NewPoles)

        This is the dimension free version of the utility
        U is the parameter  must be within the  first FlatKnots and the
        last FlatKnots  Delta is the amount the  curve has  to be moved
        DeltaDerivative is the  amount the derivative  has to be moved.
        Delta  and   DeltaDerivative   must be    array   of  dimension
        ArrayDimension  Degree  is the degree  of   the BSpline and the
        FlatKnots are the knots of the BSpline  Starting Condition if =
        -1 means the starting point of the curve can move
        = 0 means the
        starting  point  of the cuve  cannot  move but  tangen  starting
        point of the curve cannot move
        = 1 means the starting point and tangents cannot move
        = 2 means the starting point tangent and curvature cannot move
        = ...
        Same holds for EndingCondition
        Poles are the poles of the curve
        Weights are the weights of the curve if Rational = Standard_True
        NewPoles are the poles of the deformed curve
        ErrorStatus will be 0 if no error happened
        1 if there are not enough knots/poles
        the imposed conditions
        The way to solve this problem is to add knots to the BSpline
        If StartCondition = 1 and EndCondition = 1 then you need at least
        4 + 2 = 6 poles so for example to have a C1 cubic you will need
        have at least 2 internal knots.

        :type U: float
        :type Delta: OCC.wrapper.gp.gp_Vec2d
        :type DeltaDerivative: OCC.wrapper.gp.gp_Vec2d
        :type Tolerance: float
        :type Degree: int
        :type Rational: bool
        :type StartingCondition: int
        :type EndingCondition: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type ErrorStatus: int

        """
        return _BSplCLib.BSplCLib__MovePointAndTangent(*args)

    MovePointAndTangent = staticmethod(MovePointAndTangent)

    def Resolution(*args):
        """
        Resolution(Standard_Integer const ArrayDimension, Standard_Integer const NumPoles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, Standard_Real const Tolerance3D)
        Resolution(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, Standard_Integer const NumPoles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, Standard_Real const Tolerance3D)
        Resolution(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, Standard_Integer const NumPoles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, Standard_Real const Tolerance3D)

        given a tolerance in 3D space returns a
        tolerance    in U parameter space such that
        all u1 and u0 in the domain of the curve f(u)
        | u1 - u0 | < UTolerance and
        we have |f (u1) - f (u0)| < Tolerance3D

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NumPoles: int
        :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Degree: int
        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _BSplCLib.BSplCLib__Resolution(*args)

    Resolution = staticmethod(Resolution)

    def __init__(self):
        """
        BSplCLib   B-spline curve Library.

        The BSplCLib package is  a basic library  for BSplines. It
        provides three categories of functions.

        * Management methods to  process knots and multiplicities.

        * Multi-Dimensions  spline methods.  BSpline methods where
        poles have an arbitrary number of dimensions. They divides
        in two groups :

        - Global methods modifying the  whole set of  poles. The
        poles are    described   by an array   of   Reals and  a
        Dimension. Example : Inserting knots.

        - Local methods  computing  points and derivatives.  The
        poles  are described by a pointer  on  a local array  of
        Reals and a Dimension. The local array is modified.

        *  2D  and 3D spline   curves  methods.

        Methods  for 2d and 3d BSplines  curves  rational or not
        rational.

        Those methods have the following structure :

        - They extract the pole informations in a working array.

        -  They      process the  working   array    with   the
        multi-dimension  methods. (for example  a  3d  rational
        curve is processed as a 4 dimension curve).

        - They get back the result in the original dimension.

        Note that the  bspline   surface methods found   in the
        package BSplSLib  uses  the same  structure and rely on
        BSplCLib.

        In the following list  of methods the  2d and 3d  curve
        methods   will be  described   with  the  corresponding
        multi-dimension method.

        The 3d or 2d B-spline curve is defined with :

        . its control points : TColgp_Array1OfPnt(2d)        Poles
        . its weights        : TColStd_Array1OfReal          Weights
        . its knots          : TColStd_Array1OfReal          Knots
        . its multiplicities : TColStd_Array1OfInteger       Mults
        . its degree         : Standard_Integer              Degree
        . its periodicity    : Standard_Boolean              Periodic

        Warnings :
        The bounds of Poles and Weights should be the same.
        The bounds of Knots and Mults   should be the same.

        Note: weight and multiplicity arrays can be passed by pointer for
        some functions so that NULL pointer is valid.
        That means no weights/no multiplicities passed.

        No weights (BSplCLib::NoWeights()) means the curve is non rational.
        No mults (BSplCLib::NoMults()) means the knots are "flat" knots.

        KeyWords :
        B-spline curve, Functions, Library

        References :
        . A survey of curves and surfaces methods in CADG Wolfgang
        BOHM CAGD 1 (1984)
        . On de Boor-like algorithms and blossoming Wolfgang BOEHM
        cagd 5 (1988)
        . Blossoming and knot insertion algorithms for B-spline curves
        Ronald N. GOLDMAN
        . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
        . Curves and Surfaces for Computer Aided Geometric Design,
        a practical guide Gerald Farin
        """
        this = _BSplCLib.new_BSplCLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BSplCLib.delete_BSplCLib_
BSplCLib__swigregister = _BSplCLib.BSplCLib__swigregister
BSplCLib__swigregister(BSplCLib_)

def BSplCLib__Hunt(*args):
    """
    BSplCLib__Hunt(NCollection_Array1_Standard_Real XX, Standard_Real const X)

    This routine searches the position of the real
    value X in  the ordered set of  real  values XX.

    The  elements   in   the  table    XX  are   either
    monotonically    increasing     or    monotonically
    decreasing.

    The input   value Iloc is    used to initialize the
    algorithm  :  if  Iloc  is outside  of   the bounds
    [XX.Lower(), -- XX.Upper()] the bisection algorithm
    is used else  the routine searches from  a previous
    known position  by increasing steps  then converges
    by bisection.

    This  routine is used to  locate a  knot value in a
    set of knots.

    :type XX: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type X: float
    :type Iloc: int

    """
    return _BSplCLib.BSplCLib__Hunt(*args)

def BSplCLib__FirstUKnotIndex(*args):
    """
    BSplCLib__FirstUKnotIndex(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

    Computes the index of the knots value which gives
    the start point of the curve.

    :type Degree: int
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__FirstUKnotIndex(*args)

def BSplCLib__LastUKnotIndex(*args):
    """
    BSplCLib__LastUKnotIndex(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

    Computes the index of the knots value which gives
    the end point of the curve.

    :type Degree: int
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__LastUKnotIndex(*args)

def BSplCLib__FlatIndex(*args):
    """
    BSplCLib__FlatIndex(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_Standard_Integer Mults, Standard_Boolean const Periodic) -> Standard_Integer

    Computes the index  of  the  flats knots  sequence
    corresponding  to  <Index> in  the  knots sequence
    which multiplicities are <Mults>.

    :type Degree: int
    :type Index: int
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Periodic: bool
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__FlatIndex(*args)

def BSplCLib__LocateParameter(*args):
    """
    LocateParameter(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const U, Standard_Boolean const IsPeriodic, Standard_Integer const FromK1, Standard_Integer const ToK2)
    LocateParameter(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, Standard_Real const U, Standard_Boolean const IsPeriodic, Standard_Integer const FromK1, Standard_Integer const ToK2)
    BSplCLib__LocateParameter(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const U, Standard_Boolean const Periodic)

    :type Degree: int
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type U: float
    :type Periodic: bool
    :type Index: int
    :type NewU: float

    """
    return _BSplCLib.BSplCLib__LocateParameter(*args)

def BSplCLib__MaxKnotMult(*args):
    """
    BSplCLib__MaxKnotMult(NCollection_Array1_Standard_Integer Mults, Standard_Integer const K1, Standard_Integer const K2) -> Standard_Integer

    Finds the greatest multiplicity in a set of knots
    between  K1  and K2.   Mults  is  the  multiplicity
    associated with each knot value.

    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type K1: int
    :type K2: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__MaxKnotMult(*args)

def BSplCLib__MinKnotMult(*args):
    """
    BSplCLib__MinKnotMult(NCollection_Array1_Standard_Integer Mults, Standard_Integer const K1, Standard_Integer const K2) -> Standard_Integer

    Finds the lowest multiplicity in  a  set of knots
    between   K1  and K2.   Mults is  the  multiplicity
    associated with each knot value.

    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type K1: int
    :type K2: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__MinKnotMult(*args)

def BSplCLib__NbPoles(*args):
    """
    BSplCLib__NbPoles(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

    Returns the number of poles of the curve. Returns 0 if
    one of the multiplicities is incorrect.

    * Non positive.

    * Greater than Degree,  or  Degree+1  at the first and
    last knot of a non periodic curve.

    *  The  last periodicity  on  a periodic  curve is not
    equal to the first.

    :type Degree: int
    :type Periodic: bool
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__NbPoles(*args)

def BSplCLib__KnotSequenceLength(*args):
    """
    BSplCLib__KnotSequenceLength(NCollection_Array1_Standard_Integer Mults, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Standard_Integer

    Returns the length  of the sequence  of knots with
    repetition.

    Periodic :

    Sum(Mults(i), i = Mults.Lower(); i <= Mults.Upper());

    Non Periodic :

    Sum(Mults(i); i = Mults.Lower(); i < Mults.Upper())
    + 2 * Degree

    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Degree: int
    :type Periodic: bool
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__KnotSequenceLength(*args)

def BSplCLib__KnotSequence(*args):
    """
    KnotSequence(NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real KnotSeq, Standard_Boolean const Periodic)
    BSplCLib__KnotSequence(NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real KnotSeq)

    Computes  the  sequence   of knots KnotSeq  with
    repetition  of the  knots  of multiplicity  greater
    than 1.

    Length of KnotSeq must be KnotSequenceLength(Mults,Degree,Periodic)

    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Degree: int
    :type Periodic: bool
    :type KnotSeq: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__KnotSequence(*args)

def BSplCLib__KnotsLength(*args):
    """
    BSplCLib__KnotsLength(NCollection_Array1_Standard_Real KnotSeq, Standard_Boolean const Periodic) -> Standard_Integer

    Returns the  length  of the   sequence of  knots  (and
    Mults)  without repetition.

    :type KnotSeq: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Periodic: bool
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__KnotsLength(*args)

def BSplCLib__Knots(*args):
    """
    BSplCLib__Knots(NCollection_Array1_Standard_Real KnotSeq, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Boolean const Periodic)

    Computes  the  sequence   of knots Knots  without
    repetition  of the  knots  of multiplicity  greater
    than 1.

    Length  of <Knots> and  <Mults> must be
    KnotsLength(KnotSequence,Periodic)

    :type KnotSeq: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Periodic: bool

    """
    return _BSplCLib.BSplCLib__Knots(*args)

def BSplCLib__KnotForm(*args):
    """
    BSplCLib__KnotForm(NCollection_Array1_Standard_Real Knots, Standard_Integer const FromK1, Standard_Integer const ToK2) -> BSplCLib_KnotDistribution

    Analyses if the  knots distribution is "Uniform"
    or  "NonUniform" between  the  knot  FromK1 and the
    knot ToK2.  There is  no repetition of  knot in the
    knots'sequence <Knots>.

    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type FromK1: int
    :type ToK2: int
    :rtype: OCC.wrapper.BSplCLib.BSplCLib_KnotDistribution

    """
    return _BSplCLib.BSplCLib__KnotForm(*args)

def BSplCLib__MultForm(*args):
    """
    BSplCLib__MultForm(NCollection_Array1_Standard_Integer Mults, Standard_Integer const FromK1, Standard_Integer const ToK2) -> BSplCLib_MultDistribution

    Analyses the distribution of multiplicities between
    the knot FromK1 and the Knot ToK2.

    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type FromK1: int
    :type ToK2: int
    :rtype: OCC.wrapper.BSplCLib.BSplCLib_MultDistribution

    """
    return _BSplCLib.BSplCLib__MultForm(*args)

def BSplCLib__KnotAnalysis(*args):
    """
    BSplCLib__KnotAnalysis(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real CKnots, NCollection_Array1_Standard_Integer CMults)

    Analyzes the array of knots.
    Returns the form and the maximum knot multiplicity.

    :type Degree: int
    :type Periodic: bool
    :type CKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type CMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type KnotForm: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution
    :type MaxKnotMult: int

    """
    return _BSplCLib.BSplCLib__KnotAnalysis(*args)

def BSplCLib__Reparametrize(*args):
    """
    BSplCLib__Reparametrize(Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real Knots)

    Reparametrizes a B-spline curve to [U1, U2].
    The knot values are recomputed such that Knots (Lower) = U1
    and Knots (Upper) = U2   but the knot form is not modified.
    Warnings :
    In the array Knots the values must be in ascending order.
    U1 must not be equal to U2 to avoid division by zero.

    :type U1: float
    :type U2: float
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__Reparametrize(*args)

def BSplCLib__Reverse(*args):
    """
    Reverse(NCollection_Array1_Standard_Real Knots)
    Reverse(NCollection_Array1_Standard_Integer Mults)
    Reverse(NCollection_Array1_gp_Pnt Poles, Standard_Integer const Last)
    Reverse(NCollection_Array1_gp_Pnt2d Poles, Standard_Integer const Last)
    BSplCLib__Reverse(NCollection_Array1_Standard_Real Weights, Standard_Integer const Last)

    Reverses the array of poles.

    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Last: int

    """
    return _BSplCLib.BSplCLib__Reverse(*args)

def BSplCLib__IsRational(*args):
    """
    BSplCLib__IsRational(NCollection_Array1_Standard_Real Weights, Standard_Integer const I1, Standard_Integer const I2, Standard_Real const Epsilon=0.0) -> Standard_Boolean

    Returns False if all the weights  of the  array <Weights>
    between   I1 an I2   are  identic.   Epsilon  is used for
    comparing  weights. If Epsilon  is 0. the  Epsilon of the
    first weight is used.

    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type I1: int
    :type I2: int
    :type Epsilon: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BSplCLib.BSplCLib__IsRational(*args)

def BSplCLib__MaxDegree(*args):
    """
    BSplCLib__MaxDegree() -> Standard_Integer

    returns the degree maxima for a BSplineCurve.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__MaxDegree(*args)

def BSplCLib__BoorScheme(*args):
    """
    BSplCLib__BoorScheme(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const Depth, Standard_Integer const Length)

    Performs the  Boor Algorithm  at  parameter <U> with
    the given <Degree> and the  array of <Knots> on  the
    poles <Poles> of dimension  <Dimension>.  The schema
    is  computed  until  level  <Depth>  on a   basis of
    <Length+1> poles.

    * Knots is an array of reals of length :

    <Length> + <Degree>

    * Poles is an array of reals of length :

    (2 * <Length> + 1) * <Dimension>

    The poles values  must be  set  in the array at the
    positions.

    0..Dimension,

    2 * Dimension ..
    3 * Dimension

    4  * Dimension ..
    5  * Dimension

    ...

    The results are found in the array poles depending
    on the Depth. (See the method GetPole).

    :type U: float
    :type Degree: int
    :type Knots: float
    :type Dimension: int
    :type Poles: float
    :type Depth: int
    :type Length: int

    """
    return _BSplCLib.BSplCLib__BoorScheme(*args)

def BSplCLib__AntiBoorScheme(*args):
    """
    BSplCLib__AntiBoorScheme(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const Depth, Standard_Integer const Length, Standard_Real const Tolerance) -> Standard_Boolean

    Compute  the content of  Pole before the BoorScheme.
    This method is used to remove poles.

    U is the poles to  remove, Knots should contains the
    knots of the curve after knot removal.

    The first  and last poles  do not  change, the other
    poles are computed by averaging two possible values.
    The distance between  the  two   possible  poles  is
    computed, if it  is higher than <Tolerance> False is
    returned.

    :type U: float
    :type Degree: int
    :type Knots: float
    :type Dimension: int
    :type Poles: float
    :type Depth: int
    :type Length: int
    :type Tolerance: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BSplCLib.BSplCLib__AntiBoorScheme(*args)

def BSplCLib__Derivative(*args):
    """
    BSplCLib__Derivative(Standard_Integer const Degree, Standard_Integer const Dimension, Standard_Integer const Length, Standard_Integer const Order)

    Computes   the   poles of  the    BSpline  giving the
    derivatives of order <Order>.

    The formula for the first order is

    Pole(i) = Degree * (Pole(i+1) - Pole(i)) /
    (Knots(i+Degree+1) - Knots(i+1))

    This formula  is repeated  (Degree  is decremented at
    each step).

    :type Degree: int
    :type Knots: float
    :type Dimension: int
    :type Length: int
    :type Order: int
    :type Poles: float

    """
    return _BSplCLib.BSplCLib__Derivative(*args)

def BSplCLib__Bohm(*args):
    """
    BSplCLib__Bohm(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const N, Standard_Integer const Dimension)

    Performs the Bohm  Algorithm at  parameter <U>. This
    algorithm computes the value and all the derivatives
    up to order N (N <= Degree).

    <Poles> is the original array of poles.

    The   result in  <Poles>  is    the value and    the
    derivatives.  Poles[0] is  the value,  Poles[Degree]
    is the last  derivative.

    :type U: float
    :type Degree: int
    :type N: int
    :type Knots: float
    :type Dimension: int
    :type Poles: float

    """
    return _BSplCLib.BSplCLib__Bohm(*args)

def BSplCLib__NoWeights(*args):
    """
    BSplCLib__NoWeights() -> NCollection_Array1_Standard_Real

    Used as argument for a non rational curve.

    :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__NoWeights(*args)

def BSplCLib__NoMults(*args):
    """
    BSplCLib__NoMults() -> NCollection_Array1_Standard_Integer

    Used as argument for a flatknots evaluation.

    :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

    """
    return _BSplCLib.BSplCLib__NoMults(*args)

def BSplCLib__BuildKnots(*args):
    """
    BSplCLib__BuildKnots(Standard_Integer const Degree, Standard_Integer const Index, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

    Stores in LK  the usefull knots  for the BoorSchem
    on the span Knots(Index) - Knots(Index+1)

    :type Degree: int
    :type Index: int
    :type Periodic: bool
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type LK: float

    """
    return _BSplCLib.BSplCLib__BuildKnots(*args)

def BSplCLib__PoleIndex(*args):
    """
    BSplCLib__PoleIndex(Standard_Integer const Degree, Standard_Integer const Index, Standard_Boolean const Periodic, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

    Return the index of the  first Pole to  use on the
    span  Mults(Index)  - Mults(Index+1).  This  index
    must be added to Poles.Lower().

    :type Degree: int
    :type Index: int
    :type Periodic: bool
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__PoleIndex(*args)

def BSplCLib__BuildEval(*args):
    """
    BuildEval(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights)
    BuildEval(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
    BSplCLib__BuildEval(Standard_Integer const Degree, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights)

    Copy in <LP>  the poles and  weights for  the Eval
    scheme. starting from  Poles(Poles.Lower()+Index)

    :type Degree: int
    :type Index: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type LP: float

    """
    return _BSplCLib.BSplCLib__BuildEval(*args)

def BSplCLib__BuildBoor(*args):
    """
    BSplCLib__BuildBoor(Standard_Integer const Index, Standard_Integer const Length, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles)

    Copy in <LP>  poles for <Dimension>  Boor  scheme.
    Starting  from    <Index>     *  <Dimension>, copy
    <Length+1> poles.

    :type Index: int
    :type Length: int
    :type Dimension: int
    :type Poles: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type LP: float

    """
    return _BSplCLib.BSplCLib__BuildBoor(*args)

def BSplCLib__BoorIndex(*args):
    """
    BSplCLib__BoorIndex(Standard_Integer const Index, Standard_Integer const Length, Standard_Integer const Depth) -> Standard_Integer

    Returns the index in  the Boor result array of the
    poles <Index>. If  the Boor  algorithm was perform
    with <Length> and <Depth>.

    :type Index: int
    :type Length: int
    :type Depth: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__BoorIndex(*args)

def BSplCLib__GetPole(*args):
    """
    BSplCLib__GetPole(Standard_Integer const Index, Standard_Integer const Length, Standard_Integer const Depth, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Pole)

    Copy  the  pole at  position  <Index>  in  the Boor
    scheme of   dimension <Dimension> to  <Position> in
    the array <Pole>. <Position> is updated.

    :type Index: int
    :type Length: int
    :type Depth: int
    :type Dimension: int
    :type LocPoles: float
    :type Position: int
    :type Pole: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__GetPole(*args)

def BSplCLib__PrepareInsertKnots(*args):
    """
    BSplCLib__PrepareInsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, Standard_Real const Epsilon, Standard_Boolean const Add) -> Standard_Boolean

    Returns in <NbPoles, NbKnots> the  new number of poles
    and  knots    if  the  sequence   of  knots <AddKnots,
    AddMults> is inserted in the sequence <Knots, Mults>.

    Epsilon is used to compare knots for equality.

    If Add is True  the multiplicities on  equal knots are
    added.

    If Add is False the max value of the multiplicities is
    kept.

    Return False if :
    The knew knots are knot increasing.
    The new knots are not in the range.

    :type Degree: int
    :type Periodic: bool
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type AddKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type AddMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NbPoles: int
    :type NbKnots: int
    :type Epsilon: float
    :type Add: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BSplCLib.BSplCLib__PrepareInsertKnots(*args)

def BSplCLib__InsertKnots(*args):
    """
    InsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array1_Standard_Real NewPoles, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)
    InsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)
    BSplCLib__InsertKnots(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)

    Insert   a  sequence  of  knots <AddKnots> with
    multiplicities   <AddMults>. <AddKnots>   must  be a   non
    decreasing sequence and verifies :

    Knots(Knots.Lower()) <= AddKnots(AddKnots.Lower())
    Knots(Knots.Upper()) >= AddKnots(AddKnots.Upper())

    The NewPoles and NewWeights arrays must have a length :
    Poles.Length() + Sum(AddMults())

    When a knot  to insert is identic  to an existing knot the
    multiplicities   are added.

    Epsilon is used to test knots for equality.

    When AddMult is negative or null the knot is not inserted.
    No multiplicity will becomes higher than the degree.

    The new Knots and Multiplicities  are copied in <NewKnots>
    and  <NewMults>.

    All the New arrays should be correctly dimensioned.

    When all  the new knots  are existing knots, i.e. only the
    multiplicities  will  change it is   safe to  use the same
    arrays as input and output.

    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type AddKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type AddMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Epsilon: float
    :type Add: bool

    """
    return _BSplCLib.BSplCLib__InsertKnots(*args)

def BSplCLib__InsertKnot(*args):
    """
    InsertKnot(Standard_Integer const UIndex, Standard_Real const U, Standard_Integer const UMult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
    BSplCLib__InsertKnot(Standard_Integer const UIndex, Standard_Real const U, Standard_Integer const UMult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

    Insert a new knot U of multiplicity UMult in the
    knot sequence.

    The  location of the new Knot  should be given as an input
    data.  UIndex locates the new knot U  in the knot sequence
    and Knots (UIndex) < U < Knots (UIndex + 1).

    The new control points corresponding to this insertion are
    returned. Knots and Mults are not updated.

    :type UIndex: int
    :type U: float
    :type UMult: int
    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__InsertKnot(*args)

def BSplCLib__RaiseMultiplicity(*args):
    """
    RaiseMultiplicity(Standard_Integer const KnotIndex, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
    BSplCLib__RaiseMultiplicity(Standard_Integer const KnotIndex, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

    Raise the multiplicity of knot to <UMult>.

    The new control points  are  returned. Knots and Mults are
    not updated.

    :type KnotIndex: int
    :type Mult: int
    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__RaiseMultiplicity(*args)

def BSplCLib__RemoveKnot(*args):
    """
    RemoveKnot(Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real NewPoles, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean
    RemoveKnot(Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean
    BSplCLib__RemoveKnot(Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean

    Decrement the  multiplicity  of <Knots(Index)>
    to <Mult>. If <Mult>   is  null the   knot  is
    removed.

    As there are two ways to compute the new poles
    the midlle   will  be used  as  long    as the
    distance is lower than Tolerance.

    If a  distance is  bigger  than  tolerance the
    methods returns False  and  the new arrays are
    not modified.

    A low  tolerance can be  used  to test  if the
    knot  can be  removed  without  modifying  the
    curve.

    A high tolerance  can be used  to "smooth" the
    curve.

    :type Index: int
    :type Mult: int
    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Tolerance: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BSplCLib.BSplCLib__RemoveKnot(*args)

def BSplCLib__IncreaseDegreeCountKnots(*args):
    """
    BSplCLib__IncreaseDegreeCountKnots(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Integer Mults) -> Standard_Integer

    Returns the   number   of  knots   of  a  curve   with
    multiplicities <Mults> after elevating the degree from
    <Degree> to <NewDegree>. See the IncreaseDegree method
    for more comments.

    :type Degree: int
    :type NewDegree: int
    :type Periodic: bool
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__IncreaseDegreeCountKnots(*args)

def BSplCLib__IncreaseDegree(*args):
    """
    IncreaseDegree(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real NewPoles, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)
    IncreaseDegree(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)
    IncreaseDegree(Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)
    IncreaseDegree(Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
    BSplCLib__IncreaseDegree(Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

    Increase the degree of a bspline (or bezier) curve
    of   dimension  <Dimension>  form <Degree>      to
    <NewDegree>.

    The number of poles in the new curve is :

    Poles.Length() + (NewDegree - Degree) * Number of spans

    Where the number of spans is :

    LastUKnotIndex(Mults) - FirstUKnotIndex(Mults) + 1

    for a non-periodic curve

    And Knots.Length() - 1 for a periodic curve.

    The multiplicities of all  knots  are increased by
    the degree elevation.

    The new knots are usually  the same knots with the
    exception of  a non-periodic curve with  the first
    and last multiplicity not  equal to Degree+1 where
    knots are removed  form the start  and the  bottom
    untils the sum of the  multiplicities is  equal to
    NewDegree+1  at the  knots   corresponding  to the
    first and last parameters of the curve.

    Example  :  Suppose a  curve  of degree 3 starting
    with following knots and multiplicities :

    knot : 0.  1.  2.
    mult : 1   2   1

    The  FirstUKnot is  2.     because the   sum    of
    multiplicities is Degree+1 : 1 + 2 + 1 = 4 = 3 + 1

    i.e. the first parameter  of the  curve is  2. and
    will still be   2.  after degree  elevation.   Let
    raises this curve to degree 4.  The multiplicities
    are increased by 2.

    They   become 2 3  2.   But     we need a   sum of
    multiplicities  of 5 at knot  2. So the first knot
    is removed and the new knots are :

    knot : 1.  2.
    mult : 3   2

    The multipicity   of the first  knot may   also be
    reduced if the sum is still to big.

    In the  most common situations (periodic  curve or
    curve with first and last multiplicities equals to
    Degree+1) the knots are knot changes.

    The method IncreaseDegreeCountKnots can be used to
    compute the new number of knots.

    :type NewDegree: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__IncreaseDegree(*args)

def BSplCLib__PrepareUnperiodize(*args):
    """
    BSplCLib__PrepareUnperiodize(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults)

    Set in <NbKnots> and <NbPolesToAdd> the number of Knots and
    Poles   of  the NotPeriodic  Curve   identical  at the
    periodic     curve with    a  degree    <Degree>  ,  a
    knots-distribution with Multiplicities <Mults>.

    :type Degree: int
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NbKnots: int
    :type NbPoles: int

    """
    return _BSplCLib.BSplCLib__PrepareUnperiodize(*args)

def BSplCLib__Unperiodize(*args):
    """
    Unperiodize(Standard_Integer const Degree, Standard_Integer const Dimension, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Real NewPoles)
    Unperiodize(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
    BSplCLib__Unperiodize(Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

    :type Degree: int
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__Unperiodize(*args)

def BSplCLib__PrepareTrimming(*args):
    """
    BSplCLib__PrepareTrimming(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const U1, Standard_Real const U2)

    Set in <NbKnots> and <NbPoles> the number of Knots and
    Poles of the  curve resulting  of  the trimming of the
    BSplinecurve definded with <degree>, <knots>, <mults>

    :type Degree: int
    :type Periodic: bool
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type U1: float
    :type U2: float
    :type NbKnots: int
    :type NbPoles: int

    """
    return _BSplCLib.BSplCLib__PrepareTrimming(*args)

def BSplCLib__Trimming(*args):
    """
    Trimming(Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Integer const Dimension, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Poles, Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewPoles)
    Trimming(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_gp_Pnt NewPoles, NCollection_Array1_Standard_Real NewWeights)
    BSplCLib__Trimming(Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, Standard_Real const U1, Standard_Real const U2, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_gp_Pnt2d NewPoles, NCollection_Array1_Standard_Real NewWeights)

    :type Degree: int
    :type Periodic: bool
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type U1: float
    :type U2: float
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__Trimming(*args)

def BSplCLib__D0(*args):
    """
    D0(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
    D0(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P)
    D0(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P)
    D0(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P)
    BSplCLib__D0(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P)

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BSplCLib.BSplCLib__D0(*args)

def BSplCLib__D1(*args):
    """
    D1(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
    D1(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P, gp_Vec V)
    D1(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P, gp_Vec2d V)
    D1(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P, gp_Vec V)
    BSplCLib__D1(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P, gp_Vec2d V)

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__D1(*args)

def BSplCLib__D2(*args):
    """
    D2(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
    D2(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    D2(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)
    D2(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P, gp_Vec V1, gp_Vec V2)
    BSplCLib__D2(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__D2(*args)

def BSplCLib__D3(*args):
    """
    D3(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
    D3(Standard_Real const U, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    D3(Standard_Real const U, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)
    D3(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)
    BSplCLib__D3(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__D3(*args)

def BSplCLib__DN(*args):
    """
    DN(Standard_Real const U, Standard_Integer const N, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)
    DN(Standard_Real const U, Standard_Integer const N, Standard_Integer const Index, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Vec VN)
    BSplCLib__DN(Standard_Real const U, Standard_Integer const N, Standard_Integer const UIndex, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, gp_Vec2d V)

    :type U: float
    :type N: int
    :type UIndex: int
    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__DN(*args)

def BSplCLib__EvalBsplineBasis(*args):
    """
    BSplCLib__EvalBsplineBasis(Standard_Integer const DerivativeOrder, Standard_Integer const Order, NCollection_Array1_Standard_Real FlatKnots, Standard_Real const Parameter, math_Matrix BsplineBasis, Standard_Boolean const isPeriodic) -> Standard_Integer

    This  evaluates  the Bspline  Basis  at  a
    given  parameter  Parameter   up   to  the
    requested   DerivativeOrder  and store the
    result  in the  array BsplineBasis  in the
    following   fashion
    BSplineBasis(1,1)   =
    value of first non vanishing
    Bspline function which has Index FirstNonZeroBsplineIndex
    BsplineBasis(1,2)   =
    value of second non vanishing
    Bspline   function which  has   Index
    FirstNonZeroBsplineIndex + 1
    BsplineBasis(1,n)   =
    value of second non vanishing non vanishing
    Bspline   function which  has   Index
    FirstNonZeroBsplineIndex + n (n <= Order)
    BSplineBasis(2,1)   =
    value of derivative of first non vanishing
    Bspline function which has Index FirstNonZeroBsplineIndex
    BSplineBasis(N,1)   =
    value of Nth derivative of first non vanishing
    Bspline function which has Index FirstNonZeroBsplineIndex
    if N <= DerivativeOrder + 1

    :type DerivativeOrder: int
    :type Order: int
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Parameter: float
    :type FirstNonZeroBsplineIndex: int
    :type BsplineBasis: OCC.wrapper.math.math_Matrix
    :type isPeriodic: bool
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__EvalBsplineBasis(*args)

def BSplCLib__BuildBSpMatrix(*args):
    """
    BSplCLib__BuildBSpMatrix(NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer OrderArray, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, math_Matrix Matrix) -> Standard_Integer

    This Builds   a fully  blown   Matrix of
    (ni)
    Bi    (tj)

    with i  and j within 1..Order + NumPoles
    The  integer ni is   the ith slot of the
    array OrderArray, tj is the jth slot of
    the array Parameters

    :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type OrderArray: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Degree: int
    :type Matrix: OCC.wrapper.math.math_Matrix
    :type UpperBandWidth: int
    :type LowerBandWidth: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__BuildBSpMatrix(*args)

def BSplCLib__FactorBandedMatrix(*args):
    """
    BSplCLib__FactorBandedMatrix(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth) -> Standard_Integer

    this  factors  the Banded Matrix in
    the LU form with a Banded storage of
    components of the L matrix
    WARNING : do not use if the Matrix is
    totally positive (It is the case for
    Bspline matrices build as above with
    parameters being the Schoenberg points

    :type Matrix: OCC.wrapper.math.math_Matrix
    :type UpperBandWidth: int
    :type LowerBandWidth: int
    :type PivotIndexProblem: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__FactorBandedMatrix(*args)

def BSplCLib__SolveBandedSystem(*args):
    """
    SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Integer const ArrayDimension) -> Standard_Integer
    SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, NCollection_Array1_gp_Pnt2d Array) -> Standard_Integer
    SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, NCollection_Array1_gp_Pnt Array) -> Standard_Integer
    SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Boolean const HomogenousFlag, Standard_Integer const ArrayDimension) -> Standard_Integer
    SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Boolean const HomogenousFlag, NCollection_Array1_gp_Pnt2d Array, NCollection_Array1_Standard_Real Weights) -> Standard_Integer
    BSplCLib__SolveBandedSystem(math_Matrix Matrix, Standard_Integer const UpperBandWidth, Standard_Integer const LowerBandWidth, Standard_Boolean const HomogeneousFlag, NCollection_Array1_gp_Pnt Array, NCollection_Array1_Standard_Real Weights) -> Standard_Integer

    This solves  the system Matrix.X =  B
    with when Matrix is factored in LU form
    The  Array   is    an   seen   as    an
    Array[1..N][1..ArrayDimension] with N =
    the  rank  of the  matrix  Matrix.  The
    result is stored   in Array  when  each
    coordinate is  solved that is  B is the
    array whose values are
    B[i] = Array[i][p] for each p in 1..ArrayDimension
    If  HomogeneousFlag ==
    0  the  Poles  are  multiplied by   the
    Weights   uppon   Entry   and      once
    interpolation   is    carried  over the
    result of the  poles are divided by the
    result of   the   interpolation of  the
    weights. Otherwise if HomogenousFlag == 1
    the Poles and Weigths are treated homogenously
    that is that those are interpolated as they
    are and result is returned without division
    by the interpolated weigths.

    :type Matrix: OCC.wrapper.math.math_Matrix
    :type UpperBandWidth: int
    :type LowerBandWidth: int
    :type HomogeneousFlag: bool
    :type Array: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BSplCLib.BSplCLib__SolveBandedSystem(*args)

def BSplCLib__MergeBSplineKnots(*args):
    """
    BSplCLib__MergeBSplineKnots(Standard_Real const Tolerance, Standard_Real const StartValue, Standard_Real const EndValue, Standard_Integer const Degree1, NCollection_Array1_Standard_Real Knots1, NCollection_Array1_Standard_Integer Mults1, Standard_Integer const Degree2, NCollection_Array1_Standard_Real Knots2, NCollection_Array1_Standard_Integer Mults2, Handle_TColStd_HArray1OfReal NewKnots, Handle_TColStd_HArray1OfInteger NewMults)

    Merges  two knot vector by   setting the starting and
    ending values to StartValue and EndValue

    :type Tolerance: float
    :type StartValue: float
    :type EndValue: float
    :type Degree1: int
    :type Knots1: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults1: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Degree2: int
    :type Knots2: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults2: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NumPoles: int
    :type NewKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
    :type NewMults: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

    """
    return _BSplCLib.BSplCLib__MergeBSplineKnots(*args)

def BSplCLib__FunctionReparameterise(*args):
    """
    FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, Standard_Integer const PolesDimension, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree)
    FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_Standard_Real NewPoles)
    FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt NewPoles)
    BSplCLib__FunctionReparameterise(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt2d NewPoles)

    this will compose  a given Vectorial BSpline F(t)
    defined  by its  BSplineDegree and BSplineFlatKnotsl,
    its Poles  array which are coded as  an array of Real
    of  the  form  [1..NumPoles][1..PolesDimension] with  a
    function     a(t) which is   assumed to   satisfy the
    following  : 1. F(a(t))  is a polynomial BSpline
    that can be expressed  exactly as a BSpline of degree
    NewDegree on the knots FlatKnots
    2. a(t) defines a differentiable
    isomorphism between the range of FlatKnots to the range
    of BSplineFlatKnots which is the
    same as the  range of F(t)
    Warning: it is
    the caller's responsability to insure that conditions
    1. and  2. above are  satisfied : no check whatsoever
    is made in this method
    theStatus will return 0 if OK else it will return the pivot index
    of the matrix that was inverted to compute the multiplied
    BSpline : the method used is interpolation at Schoenenberg
    points of F(a(t))

    :type Function: OCC.wrapper.BSplCLib.BSplCLib_EvaluatorFunction
    :type BSplineDegree: int
    :type BSplineFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewDegree: int
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type theStatus: int

    """
    return _BSplCLib.BSplCLib__FunctionReparameterise(*args)

def BSplCLib__FunctionMultiply(*args):
    """
    FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, Standard_Integer const PolesDimension, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree)
    FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_Standard_Real NewPoles)
    FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt2d NewPoles)
    BSplCLib__FunctionMultiply(BSplCLib_EvaluatorFunction Function, Standard_Integer const BSplineDegree, NCollection_Array1_Standard_Real BSplineFlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const NewDegree, NCollection_Array1_gp_Pnt NewPoles)

    this will  multiply a given Vectorial BSpline F(t)
    defined  by its  BSplineDegree and BSplineFlatKnotsl,
    its Poles  array which are coded as  an array of Real
    of  the  form  [1..NumPoles][1..PolesDimension] by  a
    function     a(t) which is   assumed to   satisfy the
    following  : 1. a(t)  * F(t)  is a polynomial BSpline
    that can be expressed  exactly as a BSpline of degree
    NewDegree on the knots FlatKnots 2. the range of a(t)
    is the same as the  range of F(t)
    Warning: it is
    the caller's responsability to insure that conditions
    1. and  2. above are  satisfied : no check whatsoever
    is made in this method
    theStatus will return 0 if OK else it will return the pivot index
    of the matrix that was inverted to compute the multiplied
    BSpline : the method used is interpolation at Schoenenberg
    points of a(t)*F(t)

    :type Function: OCC.wrapper.BSplCLib.BSplCLib_EvaluatorFunction
    :type BSplineDegree: int
    :type BSplineFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewDegree: int
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type theStatus: int

    """
    return _BSplCLib.BSplCLib__FunctionMultiply(*args)

def BSplCLib__Eval(*args):
    """
    Eval(Standard_Real const U, Standard_Integer const Degree, Standard_Integer const Dimension)
    Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Integer const DerivativeRequest, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const ArrayDimension)
    Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Integer const DerivativeRequest, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const ArrayDimension)
    Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Boolean const HomogeneousFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point)
    BSplCLib__Eval(Standard_Real const U, Standard_Boolean const PeriodicFlag, Standard_Boolean const HomogeneousFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point)

    Perform the evaluation of the Bspline Basis
    and then multiplies by the weights
    this just evaluates the current point

    :type U: float
    :type PeriodicFlag: bool
    :type HomogeneousFlag: bool
    :type ExtrapMode: int
    :type Degree: int
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Weight: float

    """
    return _BSplCLib.BSplCLib__Eval(*args)

def BSplCLib__TangExtendToConstraint(*args):
    """
    BSplCLib__TangExtendToConstraint(NCollection_Array1_Standard_Real FlatKnots, Standard_Real const C1Coefficient, Standard_Integer const NumPoles, Standard_Integer const Dimension, Standard_Integer const Degree, NCollection_Array1_Standard_Real ConstraintPoint, Standard_Integer const Continuity, Standard_Boolean const After)

    Extend a BSpline nD using the tangency map
    <C1Coefficient> is the coefficient of reparametrisation
    <Continuity> must be equal to 1, 2 or 3.
    <Degree> must be greater or equal than <Continuity> + 1.

    Warning:   <KnotsResult> and <PolesResult>  must be   dimensionned
    properly.

    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type C1Coefficient: float
    :type NumPoles: int
    :type Poles: float
    :type Dimension: int
    :type Degree: int
    :type ConstraintPoint: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Continuity: int
    :type After: bool
    :type NbPolesResult: int
    :type NbKnotsRsult: int
    :type KnotsResult: float
    :type PolesResult: float

    """
    return _BSplCLib.BSplCLib__TangExtendToConstraint(*args)

def BSplCLib__CacheD0(*args):
    """
    CacheD0(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point)
    BSplCLib__CacheD0(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point)

    Perform the evaluation of the Bspline Basis
    and then multiplies by the weights
    this just evaluates the current point
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    ththe CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effectsis just evaluates the current point

    :type U: float
    :type Degree: int
    :type CacheParameter: float
    :type SpanLenght: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BSplCLib.BSplCLib__CacheD0(*args)

def BSplCLib__CoefsD0(*args):
    """
    CoefsD0(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point)
    BSplCLib__CoefsD0(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point)

    Calls CacheD0 for Bezier  Curves Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for Beziercurves ONLY!!!

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d

    """
    return _BSplCLib.BSplCLib__CoefsD0(*args)

def BSplCLib__CacheD1(*args):
    """
    CacheD1(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec)
    BSplCLib__CacheD1(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec)

    Perform the evaluation of the Bspline Basis
    and then multiplies by the weights
    this just evaluates the current point
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    ththe CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effectsis just evaluates the current point

    :type U: float
    :type Degree: int
    :type CacheParameter: float
    :type SpanLenght: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Vec: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__CacheD1(*args)

def BSplCLib__CoefsD1(*args):
    """
    CoefsD1(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec)
    BSplCLib__CoefsD1(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec)

    Calls CacheD1 for Bezier  Curves Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for Beziercurves ONLY!!!

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Vec: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__CoefsD1(*args)

def BSplCLib__CacheD2(*args):
    """
    CacheD2(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2)
    BSplCLib__CacheD2(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2)

    Perform the evaluation of the Bspline Basis
    and then multiplies by the weights
    this just evaluates the current point
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    ththe CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effectsis just evaluates the current point

    :type U: float
    :type Degree: int
    :type CacheParameter: float
    :type SpanLenght: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Vec1: OCC.wrapper.gp.gp_Vec2d
    :type Vec2: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__CacheD2(*args)

def BSplCLib__CoefsD2(*args):
    """
    CoefsD2(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2)
    BSplCLib__CoefsD2(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2)

    Calls CacheD1 for Bezier  Curves Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for Beziercurves ONLY!!!

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Vec1: OCC.wrapper.gp.gp_Vec2d
    :type Vec2: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__CoefsD2(*args)

def BSplCLib__CacheD3(*args):
    """
    CacheD3(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2, gp_Vec Vec3)
    BSplCLib__CacheD3(Standard_Real const U, Standard_Integer const Degree, Standard_Real const CacheParameter, Standard_Real const SpanLenght, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2, gp_Vec2d Vec3)

    Perform the evaluation of the Bspline Basis
    and then multiplies by the weights
    this just evaluates the current point
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    ththe CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effectsis just evaluates the current point

    :type U: float
    :type Degree: int
    :type CacheParameter: float
    :type SpanLenght: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Vec1: OCC.wrapper.gp.gp_Vec2d
    :type Vec2: OCC.wrapper.gp.gp_Vec2d
    :type Vec3: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__CacheD3(*args)

def BSplCLib__CoefsD3(*args):
    """
    CoefsD3(Standard_Real const U, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt Point, gp_Vec Vec1, gp_Vec Vec2, gp_Vec Vec3)
    BSplCLib__CoefsD3(Standard_Real const U, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, gp_Pnt2d Point, gp_Vec2d Vec1, gp_Vec2d Vec2, gp_Vec2d Vec3)

    Calls CacheD1 for Bezier  Curves Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for Beziercurves ONLY!!!

    :type U: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt2d
    :type Vec1: OCC.wrapper.gp.gp_Vec2d
    :type Vec2: OCC.wrapper.gp.gp_Vec2d
    :type Vec3: OCC.wrapper.gp.gp_Vec2d

    """
    return _BSplCLib.BSplCLib__CoefsD3(*args)

def BSplCLib__BuildCache(*args):
    """
    BuildCache(Standard_Real const U, Standard_Real const InverseOfSpanDomain, Standard_Boolean const PeriodicFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt CachePoles, NCollection_Array1_Standard_Real CacheWeights)
    BuildCache(Standard_Real const U, Standard_Real const InverseOfSpanDomain, Standard_Boolean const PeriodicFlag, Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt2d CachePoles, NCollection_Array1_Standard_Real CacheWeights)
    BuildCache(Standard_Real const theParameter, Standard_Real const theSpanDomain, Standard_Boolean const thePeriodicFlag, Standard_Integer const theDegree, Standard_Integer const theSpanIndex, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt thePoles, NCollection_Array1_Standard_Real theWeights, NCollection_Array2_Standard_Real theCacheArray)
    BSplCLib__BuildCache(Standard_Real const theParameter, Standard_Real const theSpanDomain, Standard_Boolean const thePeriodicFlag, Standard_Integer const theDegree, Standard_Integer const theSpanIndex, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt2d thePoles, NCollection_Array1_Standard_Real theWeights, NCollection_Array2_Standard_Real theCacheArray)

    Perform the evaluation of the Taylor expansion
    of the Bspline normalized between 0 and 1.
    Structure of result optimized for BSplCLib_Cache.

    :type theParameter: float
    :type theSpanDomain: float
    :type thePeriodicFlag: bool
    :type theDegree: int
    :type theSpanIndex: int
    :type theFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type theWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type theCacheArray: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _BSplCLib.BSplCLib__BuildCache(*args)

def BSplCLib__PolesCoefficients(*args):
    """
    PolesCoefficients(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_gp_Pnt2d CachePoles)
    PolesCoefficients(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt2d CachePoles, NCollection_Array1_Standard_Real CacheWeights)
    PolesCoefficients(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt CachePoles)
    BSplCLib__PolesCoefficients(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_gp_Pnt CachePoles, NCollection_Array1_Standard_Real CacheWeights)

    Encapsulation   of  BuildCache    to   perform   the
    evaluation  of the Taylor expansion for beziercurves
    at parameter 0.
    Warning: To be used for Beziercurves ONLY!!!

    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type CachePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type CacheWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__PolesCoefficients(*args)

def BSplCLib__FlatBezierKnots(*args):
    """
    BSplCLib__FlatBezierKnots(Standard_Integer const Degree) -> Standard_Real const &

    Returns pointer to statically allocated array representing
    flat knots for bezier curve of the specified degree.
    Raises OutOfRange if Degree > MaxDegree()

    :type Degree: int
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BSplCLib.BSplCLib__FlatBezierKnots(*args)

def BSplCLib__BuildSchoenbergPoints(*args):
    """
    BSplCLib__BuildSchoenbergPoints(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters)

    builds the Schoenberg points from the flat knot
    used to interpolate a BSpline since the
    BSpline matrix is invertible.

    :type Degree: int
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplCLib.BSplCLib__BuildSchoenbergPoints(*args)

def BSplCLib__Interpolate(*args):
    """
    Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt Poles)
    Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt2d Poles)
    Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
    Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights)
    Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, Standard_Integer const ArrayDimension)
    BSplCLib__Interpolate(Standard_Integer const Degree, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_Standard_Real Parameters, NCollection_Array1_Standard_Integer ContactOrderArray, Standard_Integer const ArrayDimension)

    :type Degree: int
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type ContactOrderArray: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type ArrayDimension: int
    :type Poles: float
    :type Weights: float
    :type InversionProblem: int

    """
    return _BSplCLib.BSplCLib__Interpolate(*args)

def BSplCLib__MovePoint(*args):
    """
    MovePoint(Standard_Real const U, gp_Vec2d Displ, Standard_Integer const Index1, Standard_Integer const Index2, Standard_Integer const Degree, Standard_Boolean const Rational, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d NewPoles)
    BSplCLib__MovePoint(Standard_Real const U, gp_Vec Displ, Standard_Integer const Index1, Standard_Integer const Index2, Standard_Integer const Degree, Standard_Boolean const Rational, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt NewPoles)

    Find the new poles which allows  an old point (with a
    given  u as parameter) to reach a new position
    Index1 and Index2 indicate the range of poles we can move
    (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side
    don't enter (1,NbPoles) -> error: rigid move
    (2, NbPoles-1) -> the ends are enforced
    (3, NbPoles-2) -> the ends and the tangency are enforced
    if Problem in BSplineBasis calculation, no change for the curve
    and FirstIndex, LastIndex = 0

    :type U: float
    :type Displ: OCC.wrapper.gp.gp_Vec
    :type Index1: int
    :type Index2: int
    :type Degree: int
    :type Rational: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type FirstIndex: int
    :type LastIndex: int
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

    """
    return _BSplCLib.BSplCLib__MovePoint(*args)

def BSplCLib__MovePointAndTangent(*args):
    """
    MovePointAndTangent(Standard_Real const U, Standard_Integer const ArrayDimension, Standard_Real const Tolerance, Standard_Integer const Degree, Standard_Boolean const Rational, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots)
    MovePointAndTangent(Standard_Real const U, gp_Vec Delta, gp_Vec DeltaDerivative, Standard_Real const Tolerance, Standard_Integer const Degree, Standard_Boolean const Rational, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt NewPoles)
    BSplCLib__MovePointAndTangent(Standard_Real const U, gp_Vec2d Delta, gp_Vec2d DeltaDerivative, Standard_Real const Tolerance, Standard_Integer const Degree, Standard_Boolean const Rational, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition, NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, NCollection_Array1_gp_Pnt2d NewPoles)

    This is the dimension free version of the utility
    U is the parameter  must be within the  first FlatKnots and the
    last FlatKnots  Delta is the amount the  curve has  to be moved
    DeltaDerivative is the  amount the derivative  has to be moved.
    Delta  and   DeltaDerivative   must be    array   of  dimension
    ArrayDimension  Degree  is the degree  of   the BSpline and the
    FlatKnots are the knots of the BSpline  Starting Condition if =
    -1 means the starting point of the curve can move
    = 0 means the
    starting  point  of the cuve  cannot  move but  tangen  starting
    point of the curve cannot move
    = 1 means the starting point and tangents cannot move
    = 2 means the starting point tangent and curvature cannot move
    = ...
    Same holds for EndingCondition
    Poles are the poles of the curve
    Weights are the weights of the curve if Rational = Standard_True
    NewPoles are the poles of the deformed curve
    ErrorStatus will be 0 if no error happened
    1 if there are not enough knots/poles
    the imposed conditions
    The way to solve this problem is to add knots to the BSpline
    If StartCondition = 1 and EndCondition = 1 then you need at least
    4 + 2 = 6 poles so for example to have a C1 cubic you will need
    have at least 2 internal knots.

    :type U: float
    :type Delta: OCC.wrapper.gp.gp_Vec2d
    :type DeltaDerivative: OCC.wrapper.gp.gp_Vec2d
    :type Tolerance: float
    :type Degree: int
    :type Rational: bool
    :type StartingCondition: int
    :type EndingCondition: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type ErrorStatus: int

    """
    return _BSplCLib.BSplCLib__MovePointAndTangent(*args)

def BSplCLib__Resolution(*args):
    """
    Resolution(Standard_Integer const ArrayDimension, Standard_Integer const NumPoles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, Standard_Real const Tolerance3D)
    Resolution(NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, Standard_Integer const NumPoles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, Standard_Real const Tolerance3D)
    BSplCLib__Resolution(NCollection_Array1_gp_Pnt2d Poles, NCollection_Array1_Standard_Real Weights, Standard_Integer const NumPoles, NCollection_Array1_Standard_Real FlatKnots, Standard_Integer const Degree, Standard_Real const Tolerance3D)

    given a tolerance in 3D space returns a
    tolerance    in U parameter space such that
    all u1 and u0 in the domain of the curve f(u)
    | u1 - u0 | < UTolerance and
    we have |f (u1) - f (u0)| < Tolerance3D

    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NumPoles: int
    :type FlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Degree: int
    :type Tolerance3D: float
    :type UTolerance: float

    """
    return _BSplCLib.BSplCLib__Resolution(*args)

class BSplCLib_EvaluatorFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Evaluate(self, *args):
        """
        Evaluate(BSplCLib_EvaluatorFunction self, Standard_Integer const theDerivativeRequest, Standard_Real const * theStartEnd, Standard_Real const theParameter)

        Function evaluation method to be defined by descendant

        :type theDerivativeRequest: int
        :type theStartEnd: float
        :type theParameter: float
        :type theResult: float
        :type theErrorCode: int

        """
        return _BSplCLib.BSplCLib_EvaluatorFunction_Evaluate(self, *args)


    def __call__(self, *args):
        """
        __call__(BSplCLib_EvaluatorFunction self, Standard_Integer const theDerivativeRequest, Standard_Real const * theStartEnd, Standard_Real const theParameter)

        Shortcut for function-call style usage

        :type theDerivativeRequest: int
        :type theStartEnd: float
        :type theParameter: float
        :type theResult: float
        :type theErrorCode: int

        """
        return _BSplCLib.BSplCLib_EvaluatorFunction___call__(self, *args)

    __swig_destroy__ = _BSplCLib.delete_BSplCLib_EvaluatorFunction
BSplCLib_EvaluatorFunction_swigregister = _BSplCLib.BSplCLib_EvaluatorFunction_swigregister
BSplCLib_EvaluatorFunction_swigregister(BSplCLib_EvaluatorFunction)

class BSplCLib_Cache(Standard.Standard_Transient):
    """
    rief A cache class for Bezier and B-spline curves.

    Defines all data, that can be cached on a span of a curve.
    The data should be recalculated in going from span to span.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BSplCLib_Cache
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BSplCLib_Cache(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BSplCLib_Cache self) -> BSplCLib_Cache
        __init__(BSplCLib_Cache self, Standard_Integer const & theDegree, Standard_Boolean const & thePeriodic, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt2d thePoles2d, NCollection_Array1_Standard_Real theWeights=None) -> BSplCLib_Cache
        __init__(BSplCLib_Cache self, Standard_Integer const & theDegree, Standard_Boolean const & thePeriodic, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt thePoles, NCollection_Array1_Standard_Real theWeights=None) -> BSplCLib_Cache

        Constructor for caching of 3D curves
        \param theDegree     degree of the curve
        \param thePeriodic   identify the curve is periodic
        \param theFlatKnots  knots of Bezier/B-spline curve (with repetitions)
        \param thePoles      array of poles of 3D curve
        \param theWeights    array of weights of corresponding poles

        :type theDegree: int
        :type thePeriodic: bool
        :type theFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _BSplCLib.new_BSplCLib_Cache(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsCacheValid(self, *args):
        """
        IsCacheValid(BSplCLib_Cache self, Standard_Real theParameter) -> Standard_Boolean

        Verifies validity of the cache using flat parameter of the point
        \param theParameter parameter of the point placed in the span

        :type theParameter: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.BSplCLib_Cache_IsCacheValid(self, *args)


    def BuildCache(self, *args):
        """
        BuildCache(BSplCLib_Cache self, Standard_Real const & theParameter, Standard_Integer const & theDegree, Standard_Boolean const & thePeriodic, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt2d thePoles2d, NCollection_Array1_Standard_Real theWeights=None)
        BuildCache(BSplCLib_Cache self, Standard_Real const & theParameter, Standard_Integer const & theDegree, Standard_Boolean const & thePeriodic, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt thePoles, NCollection_Array1_Standard_Real theWeights=None)

        Recomputes the cache data for 3D curves. Does not verify validity of the cache
        \param theParameter  the value on the knot's axis to identify the span
        \param theDegree     degree of the curve
        \param thePeriodic   identify the curve is periodic
        \param theFlatKnots  knots of Bezier/B-spline curve (with repetitions)
        \param thePoles      array of poles of 3D curve
        \param theWeights    array of weights of corresponding poles

        :type theParameter: float
        :type theDegree: int
        :type thePeriodic: bool
        :type theFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.BSplCLib_Cache_BuildCache(self, *args)


    def D0(self, *args):
        """
        D0(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint)
        D0(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplCLib.BSplCLib_Cache_D0(self, *args)


    def D1(self, *args):
        """
        D1(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint, gp_Vec2d theTangent)
        D1(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint, gp_Vec theTangent)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangent: OCC.wrapper.gp.gp_Vec

        """
        return _BSplCLib.BSplCLib_Cache_D1(self, *args)


    def D2(self, *args):
        """
        D2(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint, gp_Vec2d theTangent, gp_Vec2d theCurvature)
        D2(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint, gp_Vec theTangent, gp_Vec theCurvature)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangent: OCC.wrapper.gp.gp_Vec
        :type theCurvature: OCC.wrapper.gp.gp_Vec

        """
        return _BSplCLib.BSplCLib_Cache_D2(self, *args)


    def D3(self, *args):
        """
        D3(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint, gp_Vec2d theTangent, gp_Vec2d theCurvature, gp_Vec2d theTorsion)
        D3(BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint, gp_Vec theTangent, gp_Vec theCurvature, gp_Vec theTorsion)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangent: OCC.wrapper.gp.gp_Vec
        :type theCurvature: OCC.wrapper.gp.gp_Vec
        :type theTorsion: OCC.wrapper.gp.gp_Vec

        """
        return _BSplCLib.BSplCLib_Cache_D3(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BSplCLib.BSplCLib_Cache_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BSplCLib.BSplCLib_Cache_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BSplCLib.BSplCLib_Cache_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BSplCLib.delete_BSplCLib_Cache
BSplCLib_Cache_swigregister = _BSplCLib.BSplCLib_Cache_swigregister
BSplCLib_Cache_swigregister(BSplCLib_Cache)

def BSplCLib_Cache_get_type_name(*args):
    """
    BSplCLib_Cache_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BSplCLib.BSplCLib_Cache_get_type_name(*args)

def BSplCLib_Cache_get_type_descriptor(*args):
    """
    BSplCLib_Cache_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BSplCLib.BSplCLib_Cache_get_type_descriptor(*args)

class Handle_BSplCLib_Cache(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BSplCLib_Cache self)

        Nullify the handle


        """
        return _BSplCLib.Handle_BSplCLib_Cache_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BSplCLib_Cache self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BSplCLib.Handle_BSplCLib_Cache_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BSplCLib_Cache self, BSplCLib_Cache thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BSplCLib.Handle_BSplCLib_Cache_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BSplCLib_Cache self, Handle_BSplCLib_Cache theHandle) -> Handle_BSplCLib_Cache
        assign(Handle_BSplCLib_Cache self, BSplCLib_Cache thePtr) -> Handle_BSplCLib_Cache
        assign(Handle_BSplCLib_Cache self, Handle_BSplCLib_Cache theHandle) -> Handle_BSplCLib_Cache

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BSplCLib.Handle_BSplCLib_Cache_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BSplCLib_Cache self) -> BSplCLib_Cache

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BSplCLib.Handle_BSplCLib_Cache_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BSplCLib_Cache self) -> BSplCLib_Cache

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BSplCLib.Handle_BSplCLib_Cache___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BSplCLib_Cache self) -> BSplCLib_Cache

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BSplCLib.Handle_BSplCLib_Cache___ref__(self, *args)


    def __hash__(self):
        return _BSplCLib.Handle_BSplCLib_Cache___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BSplCLib.Handle_BSplCLib_Cache___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BSplCLib.new_Handle_BSplCLib_Cache(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BSplCLib.Handle_BSplCLib_Cache_DownCast)
    __swig_destroy__ = _BSplCLib.delete_Handle_BSplCLib_Cache

    def IsCacheValid(self, *args):
        """
        IsCacheValid(Handle_BSplCLib_Cache self, Standard_Real theParameter) -> Standard_Boolean

        Verifies validity of the cache using flat parameter of the point
        \param theParameter parameter of the point placed in the span

        :type theParameter: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.Handle_BSplCLib_Cache_IsCacheValid(self, *args)


    def BuildCache(self, *args):
        """
        BuildCache(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, Standard_Integer const & theDegree, Standard_Boolean const & thePeriodic, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt2d thePoles2d, NCollection_Array1_Standard_Real theWeights=None)
        BuildCache(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, Standard_Integer const & theDegree, Standard_Boolean const & thePeriodic, NCollection_Array1_Standard_Real theFlatKnots, NCollection_Array1_gp_Pnt thePoles, NCollection_Array1_Standard_Real theWeights=None)

        Recomputes the cache data for 3D curves. Does not verify validity of the cache
        \param theParameter  the value on the knot's axis to identify the span
        \param theDegree     degree of the curve
        \param thePeriodic   identify the curve is periodic
        \param theFlatKnots  knots of Bezier/B-spline curve (with repetitions)
        \param thePoles      array of poles of 3D curve
        \param theWeights    array of weights of corresponding poles

        :type theParameter: float
        :type theDegree: int
        :type thePeriodic: bool
        :type theFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplCLib.Handle_BSplCLib_Cache_BuildCache(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint)
        D0(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplCLib.Handle_BSplCLib_Cache_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint, gp_Vec2d theTangent)
        D1(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint, gp_Vec theTangent)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangent: OCC.wrapper.gp.gp_Vec

        """
        return _BSplCLib.Handle_BSplCLib_Cache_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint, gp_Vec2d theTangent, gp_Vec2d theCurvature)
        D2(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint, gp_Vec theTangent, gp_Vec theCurvature)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangent: OCC.wrapper.gp.gp_Vec
        :type theCurvature: OCC.wrapper.gp.gp_Vec

        """
        return _BSplCLib.Handle_BSplCLib_Cache_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt2d thePoint, gp_Vec2d theTangent, gp_Vec2d theCurvature, gp_Vec2d theTorsion)
        D3(Handle_BSplCLib_Cache self, Standard_Real const & theParameter, gp_Pnt thePoint, gp_Vec theTangent, gp_Vec theCurvature, gp_Vec theTorsion)

        :type theParameter: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangent: OCC.wrapper.gp.gp_Vec
        :type theCurvature: OCC.wrapper.gp.gp_Vec
        :type theTorsion: OCC.wrapper.gp.gp_Vec

        """
        return _BSplCLib.Handle_BSplCLib_Cache_D3(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BSplCLib_Cache self) -> char const *

        :rtype: const char *

        """
        return _BSplCLib.Handle_BSplCLib_Cache_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BSplCLib.Handle_BSplCLib_Cache_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BSplCLib.Handle_BSplCLib_Cache_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BSplCLib_Cache self)

        Memory deallocator for transient classes


        """
        return _BSplCLib.Handle_BSplCLib_Cache_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BSplCLib_Cache self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BSplCLib_Cache self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.Handle_BSplCLib_Cache_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BSplCLib_Cache self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BSplCLib_Cache self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplCLib.Handle_BSplCLib_Cache_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BSplCLib_Cache self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BSplCLib.Handle_BSplCLib_Cache_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BSplCLib_Cache self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.Handle_BSplCLib_Cache_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BSplCLib_Cache self)

        Increments the reference counter of this object


        """
        return _BSplCLib.Handle_BSplCLib_Cache_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BSplCLib_Cache self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplCLib.Handle_BSplCLib_Cache_DecrementRefCounter(self, *args)

Handle_BSplCLib_Cache_swigregister = _BSplCLib.Handle_BSplCLib_Cache_swigregister
Handle_BSplCLib_Cache_swigregister(Handle_BSplCLib_Cache)

def Handle_BSplCLib_Cache_DownCast(thing):
    return _BSplCLib.Handle_BSplCLib_Cache_DownCast(thing)
Handle_BSplCLib_Cache_DownCast = _BSplCLib.Handle_BSplCLib_Cache_DownCast




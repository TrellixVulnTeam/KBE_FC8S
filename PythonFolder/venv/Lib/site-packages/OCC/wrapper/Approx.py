# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Approx')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Approx')
    _Approx = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Approx', [dirname(__file__)])
        except ImportError:
            import _Approx
            return _Approx
        try:
            _mod = imp.load_module('_Approx', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Approx = swig_import_helper()
    del swig_import_helper
else:
    import _Approx
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Approx.delete_SwigPyIterator

    def value(self):
        return _Approx.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Approx.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Approx.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Approx.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Approx.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Approx.SwigPyIterator_copy(self)

    def next(self):
        return _Approx.SwigPyIterator_next(self)

    def __next__(self):
        return _Approx.SwigPyIterator___next__(self)

    def previous(self):
        return _Approx.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Approx.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Approx.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Approx.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Approx.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Approx.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Approx.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Approx.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Approx.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Approx.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Approx.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Approx.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Approx.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Approx.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Approx.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Approx.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Approx.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Approx.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Approx.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Approx.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Approx.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Approx.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Approx.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Approx.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Approx.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Approx.ptr_to_number(item)
ptr_to_number = _Approx.ptr_to_number

def HashCode(*args):
    return _Approx.HashCode(*args)
HashCode = _Approx.HashCode

def ptr_equal(a, b):
    return _Approx.ptr_equal(a, b)
ptr_equal = _Approx.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
Approx_ChordLength = _Approx.Approx_ChordLength
Approx_Centripetal = _Approx.Approx_Centripetal
Approx_IsoParametric = _Approx.Approx_IsoParametric
Approx_PointsAdded = _Approx.Approx_PointsAdded
Approx_NoPointsAdded = _Approx.Approx_NoPointsAdded
Approx_NoApproximation = _Approx.Approx_NoApproximation
class Approx_HArray1OfGTrsf2d(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Approx_HArray1OfGTrsf2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Approx_HArray1OfGTrsf2d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Approx_HArray1OfGTrsf2d self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Approx_HArray1OfGTrsf2d
        __init__(Approx_HArray1OfGTrsf2d self, Standard_Integer const theLower, Standard_Integer const theUpper, gp_GTrsf2d theValue) -> Approx_HArray1OfGTrsf2d
        __init__(Approx_HArray1OfGTrsf2d self, NCollection_Array1_gp_GTrsf2d theOther) -> Approx_HArray1OfGTrsf2d

        :type theOther: OCC.wrapper.Approx.Approx_Array1OfGTrsf2d

        """
        this = _Approx.new_Approx_HArray1OfGTrsf2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Approx.Approx_Array1OfGTrsf2d

        """
        res = _Approx.Approx_HArray1OfGTrsf2d_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Approx_HArray1OfGTrsf2d self) -> NCollection_Array1_gp_GTrsf2d

        :rtype: OCC.wrapper.Approx.Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Approx.Approx_HArray1OfGTrsf2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Approx.Approx_HArray1OfGTrsf2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Approx_HArray1OfGTrsf2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Approx.delete_Approx_HArray1OfGTrsf2d
Approx_HArray1OfGTrsf2d_swigregister = _Approx.Approx_HArray1OfGTrsf2d_swigregister
Approx_HArray1OfGTrsf2d_swigregister(Approx_HArray1OfGTrsf2d)

def Approx_HArray1OfGTrsf2d_get_type_name(*args):
    """
    Approx_HArray1OfGTrsf2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Approx.Approx_HArray1OfGTrsf2d_get_type_name(*args)

def Approx_HArray1OfGTrsf2d_get_type_descriptor(*args):
    """
    Approx_HArray1OfGTrsf2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Approx.Approx_HArray1OfGTrsf2d_get_type_descriptor(*args)

class Approx_CurvlinFunc(Standard.Standard_Transient):
    """
    defines an abstract curve with
    curvilinear parametrization
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Approx_CurvlinFunc
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Approx_CurvlinFunc(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Approx_CurvlinFunc self, Handle_Adaptor3d_HCurve C, Standard_Real const Tol) -> Approx_CurvlinFunc
        __init__(Approx_CurvlinFunc self, Handle_Adaptor2d_HCurve2d C2D, Handle_Adaptor3d_HSurface S, Standard_Real const Tol) -> Approx_CurvlinFunc
        __init__(Approx_CurvlinFunc self, Handle_Adaptor2d_HCurve2d C2D1, Handle_Adaptor2d_HCurve2d C2D2, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Standard_Real const Tol) -> Approx_CurvlinFunc

        :type C2D1: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type C2D2: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Tol: float

        """
        this = _Approx.new_Approx_CurvlinFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetTol(self, *args):
        """
        SetTol(Approx_CurvlinFunc self, Standard_Real const Tol)

        ---Purpose Update the tolerance to used

        :type Tol: float

        """
        return _Approx.Approx_CurvlinFunc_SetTol(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Approx_CurvlinFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvlinFunc_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Approx_CurvlinFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvlinFunc_LastParameter(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Approx_CurvlinFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_CurvlinFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Approx_CurvlinFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Approx.Approx_CurvlinFunc_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Approx_CurvlinFunc self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol)

        if First < 0 or Last > 1

        :type First: float
        :type Last: float
        :type Tol: float

        """
        return _Approx.Approx_CurvlinFunc_Trim(self, *args)


    def Length(self, *args):
        """
        Length(Approx_CurvlinFunc self)
        Length(Approx_CurvlinFunc self, Adaptor3d_Curve C, Standard_Real const FirstU, Standard_Real const LasrU) -> Standard_Real

        Computes length of the curve segment.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type FirstU: float
        :type LasrU: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvlinFunc_Length(self, *args)


    def GetLength(self, *args):
        """
        GetLength(Approx_CurvlinFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvlinFunc_GetLength(self, *args)


    def GetUParameter(self, *args):
        """
        GetUParameter(Approx_CurvlinFunc self, Adaptor3d_Curve C, Standard_Real const S, Standard_Integer const NumberOfCurve) -> Standard_Real

        returns  original parameter correponding S.  if
        Case == 1 computation is performed on myC2D1 and mySurf1,
        otherwise it is done on myC2D2 and mySurf2.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: float
        :type NumberOfCurve: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvlinFunc_GetUParameter(self, *args)


    def GetSParameter(self, *args):
        """
        GetSParameter(Approx_CurvlinFunc self, Standard_Real const U) -> Standard_Real

        returns original parameter correponding S.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvlinFunc_GetSParameter(self, *args)


    def EvalCase1(self, *args):
        """
        EvalCase1(Approx_CurvlinFunc self, Standard_Real const S, Standard_Integer const Order, NCollection_Array1_Standard_Real Result) -> Standard_Boolean

        if myCase != 1

        :type S: float
        :type Order: int
        :type Result: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurvlinFunc_EvalCase1(self, *args)


    def EvalCase2(self, *args):
        """
        EvalCase2(Approx_CurvlinFunc self, Standard_Real const S, Standard_Integer const Order, NCollection_Array1_Standard_Real Result) -> Standard_Boolean

        if myCase != 2

        :type S: float
        :type Order: int
        :type Result: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurvlinFunc_EvalCase2(self, *args)


    def EvalCase3(self, *args):
        """
        EvalCase3(Approx_CurvlinFunc self, Standard_Real const S, Standard_Integer const Order, NCollection_Array1_Standard_Real Result) -> Standard_Boolean

        if myCase != 3

        :type S: float
        :type Order: int
        :type Result: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurvlinFunc_EvalCase3(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Approx.Approx_CurvlinFunc_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Approx.Approx_CurvlinFunc_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Approx_CurvlinFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Approx.delete_Approx_CurvlinFunc
Approx_CurvlinFunc_swigregister = _Approx.Approx_CurvlinFunc_swigregister
Approx_CurvlinFunc_swigregister(Approx_CurvlinFunc)

def Approx_CurvlinFunc_get_type_name(*args):
    """
    Approx_CurvlinFunc_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Approx.Approx_CurvlinFunc_get_type_name(*args)

def Approx_CurvlinFunc_get_type_descriptor(*args):
    """
    Approx_CurvlinFunc_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Approx.Approx_CurvlinFunc_get_type_descriptor(*args)

class Approx_HArray1OfAdHSurface(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Approx_HArray1OfAdHSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Approx_HArray1OfAdHSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Approx_HArray1OfAdHSurface self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Approx_HArray1OfAdHSurface
        __init__(Approx_HArray1OfAdHSurface self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_Adaptor3d_HSurface theValue) -> Approx_HArray1OfAdHSurface
        __init__(Approx_HArray1OfAdHSurface self, NCollection_Array1_Handle_Adaptor3d_HSurface theOther) -> Approx_HArray1OfAdHSurface

        :type theOther: OCC.wrapper.Approx.Approx_Array1OfAdHSurface

        """
        this = _Approx.new_Approx_HArray1OfAdHSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Approx.Approx_Array1OfAdHSurface

        """
        res = _Approx.Approx_HArray1OfAdHSurface_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Approx_HArray1OfAdHSurface self) -> NCollection_Array1_Handle_Adaptor3d_HSurface

        :rtype: OCC.wrapper.Approx.Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Approx.Approx_HArray1OfAdHSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Approx.Approx_HArray1OfAdHSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Approx_HArray1OfAdHSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Approx.delete_Approx_HArray1OfAdHSurface
Approx_HArray1OfAdHSurface_swigregister = _Approx.Approx_HArray1OfAdHSurface_swigregister
Approx_HArray1OfAdHSurface_swigregister(Approx_HArray1OfAdHSurface)

def Approx_HArray1OfAdHSurface_get_type_name(*args):
    """
    Approx_HArray1OfAdHSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Approx.Approx_HArray1OfAdHSurface_get_type_name(*args)

def Approx_HArray1OfAdHSurface_get_type_descriptor(*args):
    """
    Approx_HArray1OfAdHSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Approx.Approx_HArray1OfAdHSurface_get_type_descriptor(*args)

class Approx_SweepFunction(Standard.Standard_Transient):
    """
    defined the function used by SweepApproximation to
    perform sweeping application.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Approx_SweepFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Approx_SweepFunction(self) 
            return h


    def D0(self, *args):
        """
        D0(Approx_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SweepFunction_D0(self, *args)


    def D1(self, *args):
        """
        D1(Approx_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SweepFunction_D1(self, *args)


    def D2(self, *args):
        """
        D2(Approx_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SweepFunction_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Approx_SweepFunction self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepFunction_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Approx_SweepFunction self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _Approx.Approx_SweepFunction_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Approx_SweepFunction self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Approx_SweepFunction self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepFunction_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Approx_SweepFunction self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SweepFunction_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Approx_SweepFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Approx_SweepFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Approx.Approx_SweepFunction_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Approx_SweepFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Approx.Approx_SweepFunction_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Approx_SweepFunction self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _Approx.Approx_SweepFunction_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Approx_SweepFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to satisfy.
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepFunction_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Approx_SweepFunction self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _Approx.Approx_SweepFunction_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Approx_SweepFunction self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Approx.Approx_SweepFunction_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Approx_SweepFunction self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SweepFunction_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Approx_SweepFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepFunction_GetMinimalWeight(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Approx.Approx_SweepFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Approx.Approx_SweepFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Approx_SweepFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Approx.delete_Approx_SweepFunction
Approx_SweepFunction_swigregister = _Approx.Approx_SweepFunction_swigregister
Approx_SweepFunction_swigregister(Approx_SweepFunction)

def Approx_SweepFunction_get_type_name(*args):
    """
    Approx_SweepFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Approx.Approx_SweepFunction_get_type_name(*args)

def Approx_SweepFunction_get_type_descriptor(*args):
    """
    Approx_SweepFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Approx.Approx_SweepFunction_get_type_descriptor(*args)

class Approx_CurveOnSurface(object):
    """Approximation of   curve on surface"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_CurveOnSurface self, Handle_Adaptor2d_HCurve2d C2D, Handle_Adaptor3d_HSurface Surf, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol, GeomAbs_Shape const Continuity, Standard_Integer const MaxDegree, Standard_Integer const MaxSegments, Standard_Boolean const Only3d, Standard_Boolean const Only2d) -> Approx_CurveOnSurface

        :type C2D: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type First: float
        :type Last: float
        :type Tol: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSegments: int
        :type Only3d: bool
        :type Only2d: bool

        """
        this = _Approx.new_Approx_CurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Approx_CurveOnSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurveOnSurface_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Approx_CurveOnSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurveOnSurface_HasResult(self, *args)


    def Curve3d(self, *args):
        """
        Curve3d(Approx_CurveOnSurface self) -> Handle_Geom_BSplineCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_CurveOnSurface_Curve3d(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(Approx_CurveOnSurface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurveOnSurface_MaxError3d(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(Approx_CurveOnSurface self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurveOnSurface_Curve2d(self, *args)


    def MaxError2dU(self, *args):
        """
        MaxError2dU(Approx_CurveOnSurface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurveOnSurface_MaxError2dU(self, *args)


    def MaxError2dV(self, *args):
        """
        MaxError2dV(Approx_CurveOnSurface self) -> Standard_Real

        returns the maximum errors relativly to the  U component or the V component of the
        2d Curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurveOnSurface_MaxError2dV(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_CurveOnSurface
Approx_CurveOnSurface_swigregister = _Approx.Approx_CurveOnSurface_swigregister
Approx_CurveOnSurface_swigregister(Approx_CurveOnSurface)

class Handle_Approx_HArray1OfGTrsf2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Approx_HArray1OfGTrsf2d self)

        Nullify the handle


        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Approx_HArray1OfGTrsf2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Approx_HArray1OfGTrsf2d self, Approx_HArray1OfGTrsf2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Approx_HArray1OfGTrsf2d self, Handle_Approx_HArray1OfGTrsf2d theHandle) -> Handle_Approx_HArray1OfGTrsf2d
        assign(Handle_Approx_HArray1OfGTrsf2d self, Approx_HArray1OfGTrsf2d thePtr) -> Handle_Approx_HArray1OfGTrsf2d
        assign(Handle_Approx_HArray1OfGTrsf2d self, Handle_Approx_HArray1OfGTrsf2d theHandle) -> Handle_Approx_HArray1OfGTrsf2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Approx_HArray1OfGTrsf2d self) -> Approx_HArray1OfGTrsf2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Approx_HArray1OfGTrsf2d self) -> Approx_HArray1OfGTrsf2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Approx_HArray1OfGTrsf2d self) -> Approx_HArray1OfGTrsf2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d___ref__(self, *args)


    def __hash__(self):
        return _Approx.Handle_Approx_HArray1OfGTrsf2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Approx.Handle_Approx_HArray1OfGTrsf2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Approx.new_Handle_Approx_HArray1OfGTrsf2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_HArray1OfGTrsf2d

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Approx.Approx_Array1OfGTrsf2d

        """
        res = _Approx.Handle_Approx_HArray1OfGTrsf2d_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Approx_HArray1OfGTrsf2d self) -> NCollection_Array1_gp_GTrsf2d

        :rtype: OCC.wrapper.Approx.Approx_Array1OfGTrsf2d

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Approx_HArray1OfGTrsf2d self) -> char const *

        :rtype: const char *

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_HArray1OfGTrsf2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_HArray1OfGTrsf2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Approx_HArray1OfGTrsf2d self)

        Memory deallocator for transient classes


        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Approx_HArray1OfGTrsf2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Approx_HArray1OfGTrsf2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Approx_HArray1OfGTrsf2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Approx_HArray1OfGTrsf2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Approx_HArray1OfGTrsf2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Approx_HArray1OfGTrsf2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Approx_HArray1OfGTrsf2d self)

        Increments the reference counter of this object


        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Approx_HArray1OfGTrsf2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_HArray1OfGTrsf2d_DecrementRefCounter(self, *args)

Handle_Approx_HArray1OfGTrsf2d_swigregister = _Approx.Handle_Approx_HArray1OfGTrsf2d_swigregister
Handle_Approx_HArray1OfGTrsf2d_swigregister(Handle_Approx_HArray1OfGTrsf2d)

def Handle_Approx_HArray1OfGTrsf2d_DownCast(thing):
    return _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast(thing)
Handle_Approx_HArray1OfGTrsf2d_DownCast = _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast

class Approx_SameParameter(object):
    """
    Approximation of a  PCurve  on a surface to  make  its
    parameter be the same that the parameter of a given 3d
    reference curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_SameParameter self, Handle_Geom_Curve C3D, Handle_Geom2d_Curve C2D, Handle_Geom_Surface S, Standard_Real const Tol) -> Approx_SameParameter
        __init__(Approx_SameParameter self, Handle_Adaptor3d_HCurve C3D, Handle_Geom2d_Curve C2D, Handle_Adaptor3d_HSurface S, Standard_Real const Tol) -> Approx_SameParameter
        __init__(Approx_SameParameter self, Handle_Adaptor3d_HCurve C3D, Handle_Adaptor2d_HCurve2d C2D, Handle_Adaptor3d_HSurface S, Standard_Real const Tol) -> Approx_SameParameter

        Warning: the C3D and C2D must have the same parametric domain.

        :type C3D: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type C2D: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Tol: float

        """
        this = _Approx.new_Approx_SameParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Approx_SameParameter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SameParameter_IsDone(self, *args)


    def TolReached(self, *args):
        """
        TolReached(Approx_SameParameter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SameParameter_TolReached(self, *args)


    def IsSameParameter(self, *args):
        """
        IsSameParameter(Approx_SameParameter self) -> Standard_Boolean

        Tells whether the original data  had already the  same
        parameter up to  the tolerance :  in that case nothing
        is done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SameParameter_IsSameParameter(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(Approx_SameParameter self) -> Handle_Geom2d_BSplineCurve

        Returns the 2D  curve that has  the same parameter  as
        the  3D curve once evaluated on  the surface up to the
        specified tolerance

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_SameParameter_Curve2d(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_SameParameter
Approx_SameParameter_swigregister = _Approx.Approx_SameParameter_swigregister
Approx_SameParameter_swigregister(Approx_SameParameter)

class Handle_Approx_CurvlinFunc(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Approx_CurvlinFunc self)

        Nullify the handle


        """
        return _Approx.Handle_Approx_CurvlinFunc_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Approx_CurvlinFunc self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Approx.Handle_Approx_CurvlinFunc_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Approx_CurvlinFunc self, Approx_CurvlinFunc thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Approx.Handle_Approx_CurvlinFunc_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Approx_CurvlinFunc self, Handle_Approx_CurvlinFunc theHandle) -> Handle_Approx_CurvlinFunc
        assign(Handle_Approx_CurvlinFunc self, Approx_CurvlinFunc thePtr) -> Handle_Approx_CurvlinFunc
        assign(Handle_Approx_CurvlinFunc self, Handle_Approx_CurvlinFunc theHandle) -> Handle_Approx_CurvlinFunc

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Approx.Handle_Approx_CurvlinFunc_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Approx_CurvlinFunc self) -> Approx_CurvlinFunc

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Approx.Handle_Approx_CurvlinFunc_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Approx_CurvlinFunc self) -> Approx_CurvlinFunc

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Approx.Handle_Approx_CurvlinFunc___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Approx_CurvlinFunc self) -> Approx_CurvlinFunc

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Approx.Handle_Approx_CurvlinFunc___ref__(self, *args)


    def __hash__(self):
        return _Approx.Handle_Approx_CurvlinFunc___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Approx.Handle_Approx_CurvlinFunc___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Approx.new_Handle_Approx_CurvlinFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Approx.Handle_Approx_CurvlinFunc_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_CurvlinFunc

    def SetTol(self, *args):
        """
        SetTol(Handle_Approx_CurvlinFunc self, Standard_Real const Tol)

        ---Purpose Update the tolerance to used

        :type Tol: float

        """
        return _Approx.Handle_Approx_CurvlinFunc_SetTol(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Approx_CurvlinFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_CurvlinFunc_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Approx_CurvlinFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_CurvlinFunc_LastParameter(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Approx_CurvlinFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_CurvlinFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Approx_CurvlinFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Approx.Handle_Approx_CurvlinFunc_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Approx_CurvlinFunc self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol)

        if First < 0 or Last > 1

        :type First: float
        :type Last: float
        :type Tol: float

        """
        return _Approx.Handle_Approx_CurvlinFunc_Trim(self, *args)


    def Length(self, *args):
        """
        Length(Handle_Approx_CurvlinFunc self)
        Length(Handle_Approx_CurvlinFunc self, Adaptor3d_Curve C, Standard_Real const FirstU, Standard_Real const LasrU) -> Standard_Real

        Computes length of the curve segment.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type FirstU: float
        :type LasrU: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_CurvlinFunc_Length(self, *args)


    def GetLength(self, *args):
        """
        GetLength(Handle_Approx_CurvlinFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_CurvlinFunc_GetLength(self, *args)


    def GetUParameter(self, *args):
        """
        GetUParameter(Handle_Approx_CurvlinFunc self, Adaptor3d_Curve C, Standard_Real const S, Standard_Integer const NumberOfCurve) -> Standard_Real

        returns  original parameter correponding S.  if
        Case == 1 computation is performed on myC2D1 and mySurf1,
        otherwise it is done on myC2D2 and mySurf2.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type S: float
        :type NumberOfCurve: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_CurvlinFunc_GetUParameter(self, *args)


    def GetSParameter(self, *args):
        """
        GetSParameter(Handle_Approx_CurvlinFunc self, Standard_Real const U) -> Standard_Real

        returns original parameter correponding S.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_CurvlinFunc_GetSParameter(self, *args)


    def EvalCase1(self, *args):
        """
        EvalCase1(Handle_Approx_CurvlinFunc self, Standard_Real const S, Standard_Integer const Order, NCollection_Array1_Standard_Real Result) -> Standard_Boolean

        if myCase != 1

        :type S: float
        :type Order: int
        :type Result: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_CurvlinFunc_EvalCase1(self, *args)


    def EvalCase2(self, *args):
        """
        EvalCase2(Handle_Approx_CurvlinFunc self, Standard_Real const S, Standard_Integer const Order, NCollection_Array1_Standard_Real Result) -> Standard_Boolean

        if myCase != 2

        :type S: float
        :type Order: int
        :type Result: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_CurvlinFunc_EvalCase2(self, *args)


    def EvalCase3(self, *args):
        """
        EvalCase3(Handle_Approx_CurvlinFunc self, Standard_Real const S, Standard_Integer const Order, NCollection_Array1_Standard_Real Result) -> Standard_Boolean

        if myCase != 3

        :type S: float
        :type Order: int
        :type Result: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_CurvlinFunc_EvalCase3(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Approx_CurvlinFunc self) -> char const *

        :rtype: const char *

        """
        return _Approx.Handle_Approx_CurvlinFunc_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_CurvlinFunc_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_CurvlinFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Approx_CurvlinFunc self)

        Memory deallocator for transient classes


        """
        return _Approx.Handle_Approx_CurvlinFunc_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Approx_CurvlinFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Approx_CurvlinFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_CurvlinFunc_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Approx_CurvlinFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Approx_CurvlinFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_CurvlinFunc_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Approx_CurvlinFunc self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Approx.Handle_Approx_CurvlinFunc_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Approx_CurvlinFunc self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_CurvlinFunc_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Approx_CurvlinFunc self)

        Increments the reference counter of this object


        """
        return _Approx.Handle_Approx_CurvlinFunc_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Approx_CurvlinFunc self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_CurvlinFunc_DecrementRefCounter(self, *args)

Handle_Approx_CurvlinFunc_swigregister = _Approx.Handle_Approx_CurvlinFunc_swigregister
Handle_Approx_CurvlinFunc_swigregister(Handle_Approx_CurvlinFunc)

def Handle_Approx_CurvlinFunc_DownCast(thing):
    return _Approx.Handle_Approx_CurvlinFunc_DownCast(thing)
Handle_Approx_CurvlinFunc_DownCast = _Approx.Handle_Approx_CurvlinFunc_DownCast

class Handle_Approx_HArray1OfAdHSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Approx_HArray1OfAdHSurface self)

        Nullify the handle


        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Approx_HArray1OfAdHSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Approx_HArray1OfAdHSurface self, Approx_HArray1OfAdHSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Approx_HArray1OfAdHSurface self, Handle_Approx_HArray1OfAdHSurface theHandle) -> Handle_Approx_HArray1OfAdHSurface
        assign(Handle_Approx_HArray1OfAdHSurface self, Approx_HArray1OfAdHSurface thePtr) -> Handle_Approx_HArray1OfAdHSurface
        assign(Handle_Approx_HArray1OfAdHSurface self, Handle_Approx_HArray1OfAdHSurface theHandle) -> Handle_Approx_HArray1OfAdHSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Approx_HArray1OfAdHSurface self) -> Approx_HArray1OfAdHSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Approx_HArray1OfAdHSurface self) -> Approx_HArray1OfAdHSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Approx_HArray1OfAdHSurface self) -> Approx_HArray1OfAdHSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface___ref__(self, *args)


    def __hash__(self):
        return _Approx.Handle_Approx_HArray1OfAdHSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Approx.Handle_Approx_HArray1OfAdHSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Approx.new_Handle_Approx_HArray1OfAdHSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Approx.Handle_Approx_HArray1OfAdHSurface_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_HArray1OfAdHSurface

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Approx.Approx_Array1OfAdHSurface

        """
        res = _Approx.Handle_Approx_HArray1OfAdHSurface_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Approx_HArray1OfAdHSurface self) -> NCollection_Array1_Handle_Adaptor3d_HSurface

        :rtype: OCC.wrapper.Approx.Approx_Array1OfAdHSurface

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Approx_HArray1OfAdHSurface self) -> char const *

        :rtype: const char *

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_HArray1OfAdHSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_HArray1OfAdHSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Approx_HArray1OfAdHSurface self)

        Memory deallocator for transient classes


        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Approx_HArray1OfAdHSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Approx_HArray1OfAdHSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Approx_HArray1OfAdHSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Approx_HArray1OfAdHSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Approx_HArray1OfAdHSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Approx_HArray1OfAdHSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Approx_HArray1OfAdHSurface self)

        Increments the reference counter of this object


        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Approx_HArray1OfAdHSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_HArray1OfAdHSurface_DecrementRefCounter(self, *args)

Handle_Approx_HArray1OfAdHSurface_swigregister = _Approx.Handle_Approx_HArray1OfAdHSurface_swigregister
Handle_Approx_HArray1OfAdHSurface_swigregister(Handle_Approx_HArray1OfAdHSurface)

def Handle_Approx_HArray1OfAdHSurface_DownCast(thing):
    return _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast(thing)
Handle_Approx_HArray1OfAdHSurface_DownCast = _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast

class Approx_Curve3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_Curve3d self, Handle_Adaptor3d_HCurve Curve, Standard_Real const Tol3d, GeomAbs_Shape const Order, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Approx_Curve3d

        Approximation  of  a  curve  with respect of the
        requiered tolerance Tol3D.

        :type Curve: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Tol3d: float
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxSegments: int
        :type MaxDegree: int

        """
        this = _Approx.new_Approx_Curve3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curve(self, *args):
        """
        Curve(Approx_Curve3d self) -> Handle_Geom_BSplineCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_Curve3d_Curve(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Approx_Curve3d self) -> Standard_Boolean

        returns  Standard_True  if  the  approximation  has
        been  done  within  requiered tolerance

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_Curve3d_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Approx_Curve3d self) -> Standard_Boolean

        returns  Standard_True if the approximation did come out
        with a result that  is not NECESSARELY within the required
        tolerance

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_Curve3d_HasResult(self, *args)


    def MaxError(self, *args):
        """
        MaxError(Approx_Curve3d self) -> Standard_Real

        returns  the  Maximum  Error  (>0 when an approximation
        has  been  done, 0  if  no  approximation)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_Curve3d_MaxError(self, *args)


    def Dump(self, *args):
        """
        Dump(Approx_Curve3d self, Standard_OStream & o)

        Print on the stream  o  information about the object

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _Approx.Approx_Curve3d_Dump(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_Curve3d
Approx_Curve3d_swigregister = _Approx.Approx_Curve3d_swigregister
Approx_Curve3d_swigregister(Approx_Curve3d)

class Approx_CurvilinearParameter(object):
    """
    Approximation of a Curve to make its parameter be its
    curvilinear  abscissa
    If the curve is a curve on a surface S, C2D is the corresponding Pcurve,
    we considere the curve is given by its representation S(C2D(u))
    If the curve is a curve on 2 surfaces S1 and S2 and C2D1 C2D2 are
    the two corresponding Pcurve, we considere the curve is given
    by its representation  1/2(S1(C2D1(u) + S2 (C2D2(u)))
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_CurvilinearParameter self, Handle_Adaptor3d_HCurve C3D, Standard_Real const Tol, GeomAbs_Shape const Order, Standard_Integer const MaxDegree, Standard_Integer const MaxSegments) -> Approx_CurvilinearParameter
        __init__(Approx_CurvilinearParameter self, Handle_Adaptor2d_HCurve2d C2D, Handle_Adaptor3d_HSurface Surf, Standard_Real const Tol, GeomAbs_Shape const Order, Standard_Integer const MaxDegree, Standard_Integer const MaxSegments) -> Approx_CurvilinearParameter
        __init__(Approx_CurvilinearParameter self, Handle_Adaptor2d_HCurve2d C2D1, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor2d_HCurve2d C2D2, Handle_Adaptor3d_HSurface Surf2, Standard_Real const Tol, GeomAbs_Shape const Order, Standard_Integer const MaxDegree, Standard_Integer const MaxSegments) -> Approx_CurvilinearParameter

        case of a curve on two surfaces

        :type C2D1: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C2D2: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Tol: float
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSegments: int

        """
        this = _Approx.new_Approx_CurvilinearParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Approx_CurvilinearParameter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurvilinearParameter_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Approx_CurvilinearParameter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_CurvilinearParameter_HasResult(self, *args)


    def Curve3d(self, *args):
        """
        Curve3d(Approx_CurvilinearParameter self) -> Handle_Geom_BSplineCurve

        returns the Bspline curve corresponding to the reparametrized 3D curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve3d(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(Approx_CurvilinearParameter self) -> Standard_Real

        returns the maximum error on the reparametrized 3D curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvilinearParameter_MaxError3d(self, *args)


    def Curve2d1(self, *args):
        """
        Curve2d1(Approx_CurvilinearParameter self) -> Handle_Geom2d_BSplineCurve

        returns the BsplineCurve representing the reparametrized 2D curve on the
        first surface (case of a curve on one or two surfaces)

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve2d1(self, *args)


    def MaxError2d1(self, *args):
        """
        MaxError2d1(Approx_CurvilinearParameter self) -> Standard_Real

        returns the maximum error on the first reparametrized 2D curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d1(self, *args)


    def Curve2d2(self, *args):
        """
        Curve2d2(Approx_CurvilinearParameter self) -> Handle_Geom2d_BSplineCurve

        returns the BsplineCurve representing the reparametrized 2D curve on the
        second surface (case of a curve on two surfaces)

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve2d2(self, *args)


    def MaxError2d2(self, *args):
        """
        MaxError2d2(Approx_CurvilinearParameter self) -> Standard_Real

        returns the maximum error on the second reparametrized 2D curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d2(self, *args)


    def Dump(self, *args):
        """
        Dump(Approx_CurvilinearParameter self, Standard_OStream & o)

        print the maximum errors(s)

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _Approx.Approx_CurvilinearParameter_Dump(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_CurvilinearParameter
Approx_CurvilinearParameter_swigregister = _Approx.Approx_CurvilinearParameter_swigregister
Approx_CurvilinearParameter_swigregister(Approx_CurvilinearParameter)

class Approx_Curve2d(object):
    """Makes  an  approximation  for  HCurve2d  from  Adaptor3d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_Curve2d self, Handle_Adaptor2d_HCurve2d C2D, Standard_Real const First, Standard_Real const Last, Standard_Real const TolU, Standard_Real const TolV, GeomAbs_Shape const Continuity, Standard_Integer const MaxDegree, Standard_Integer const MaxSegments) -> Approx_Curve2d

        :type C2D: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type First: float
        :type Last: float
        :type TolU: float
        :type TolV: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSegments: int

        """
        this = _Approx.new_Approx_Curve2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Approx_Curve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_Curve2d_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Approx_Curve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_Curve2d_HasResult(self, *args)


    def Curve(self, *args):
        """
        Curve(Approx_Curve2d self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_Curve2d_Curve(self, *args)


    def MaxError2dU(self, *args):
        """
        MaxError2dU(Approx_Curve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_Curve2d_MaxError2dU(self, *args)


    def MaxError2dV(self, *args):
        """
        MaxError2dV(Approx_Curve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_Curve2d_MaxError2dV(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_Curve2d
Approx_Curve2d_swigregister = _Approx.Approx_Curve2d_swigregister
Approx_Curve2d_swigregister(Approx_Curve2d)

class NCollection_Array1_gp_GTrsf2d(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_gp_GTrsf2d self) -> NCollection_Array1< gp_GTrsf2d >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_gp_GTrsf2d self) -> NCollection_Array1< gp_GTrsf2d >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_gp_GTrsf2d self) -> NCollection_Array1< gp_GTrsf2d >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_gp_GTrsf2d self) -> NCollection_Array1< gp_GTrsf2d >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Approx.new_NCollection_Array1_gp_GTrsf2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_gp_GTrsf2d self, gp_GTrsf2d theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_gp_GTrsf2d self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_gp_GTrsf2d self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_gp_GTrsf2d self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_gp_GTrsf2d self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_gp_GTrsf2d self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_gp_GTrsf2d self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_gp_GTrsf2d self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_gp_GTrsf2d self, NCollection_Array1_gp_GTrsf2d theOther) -> NCollection_Array1_gp_GTrsf2d

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_gp_GTrsf2d self, NCollection_Array1_gp_GTrsf2d theOther) -> NCollection_Array1_gp_GTrsf2d

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_gp_GTrsf2d self, NCollection_Array1_gp_GTrsf2d theOther) -> NCollection_Array1_gp_GTrsf2d
        assign(NCollection_Array1_gp_GTrsf2d self, NCollection_Array1_gp_GTrsf2d theOther) -> NCollection_Array1_gp_GTrsf2d

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_gp_GTrsf2d_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_gp_GTrsf2d self) -> gp_GTrsf2d

        @return first element

        :rtype: TheItemType &

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_gp_GTrsf2d_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_gp_GTrsf2d self) -> gp_GTrsf2d

        @return last element

        :rtype: TheItemType &

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_gp_GTrsf2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_gp_GTrsf2d self, Standard_Integer const theIndex) -> gp_GTrsf2d

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_gp_GTrsf2d___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_gp_GTrsf2d_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_gp_GTrsf2d self, Standard_Integer const theIndex, gp_GTrsf2d theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_gp_GTrsf2d self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Approx.NCollection_Array1_gp_GTrsf2d_Resize(self, *args)

    __swig_destroy__ = _Approx.delete_NCollection_Array1_gp_GTrsf2d
NCollection_Array1_gp_GTrsf2d_swigregister = _Approx.NCollection_Array1_gp_GTrsf2d_swigregister
NCollection_Array1_gp_GTrsf2d_swigregister(NCollection_Array1_gp_GTrsf2d)


try:
	Approx_Array1OfGTrsf2d = NCollection_Array1_gp_GTrsf2d
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_Adaptor3d_HSurface(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> NCollection_Array1< opencascade::handle< Adaptor3d_HSurface > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> NCollection_Array1< opencascade::handle< Adaptor3d_HSurface > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> NCollection_Array1< opencascade::handle< Adaptor3d_HSurface > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> NCollection_Array1< opencascade::handle< Adaptor3d_HSurface > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Approx.new_NCollection_Array1_Handle_Adaptor3d_HSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Adaptor3d_HSurface self, Handle_Adaptor3d_HSurface theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Adaptor3d_HSurface self, NCollection_Array1_Handle_Adaptor3d_HSurface theOther) -> NCollection_Array1_Handle_Adaptor3d_HSurface

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Adaptor3d_HSurface self, NCollection_Array1_Handle_Adaptor3d_HSurface theOther) -> NCollection_Array1_Handle_Adaptor3d_HSurface

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Adaptor3d_HSurface self, NCollection_Array1_Handle_Adaptor3d_HSurface theOther) -> NCollection_Array1_Handle_Adaptor3d_HSurface
        assign(NCollection_Array1_Handle_Adaptor3d_HSurface self, NCollection_Array1_Handle_Adaptor3d_HSurface theOther) -> NCollection_Array1_Handle_Adaptor3d_HSurface

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Handle_Adaptor3d_HSurface

        @return first element

        :rtype: TheItemType &

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Adaptor3d_HSurface self) -> Handle_Adaptor3d_HSurface

        @return last element

        :rtype: TheItemType &

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Adaptor3d_HSurface self, Standard_Integer const theIndex) -> Handle_Adaptor3d_HSurface

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Adaptor3d_HSurface self, Standard_Integer const theIndex, Handle_Adaptor3d_HSurface theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Adaptor3d_HSurface self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_Resize(self, *args)

    __swig_destroy__ = _Approx.delete_NCollection_Array1_Handle_Adaptor3d_HSurface
NCollection_Array1_Handle_Adaptor3d_HSurface_swigregister = _Approx.NCollection_Array1_Handle_Adaptor3d_HSurface_swigregister
NCollection_Array1_Handle_Adaptor3d_HSurface_swigregister(NCollection_Array1_Handle_Adaptor3d_HSurface)


try:
	Approx_Array1OfAdHSurface = NCollection_Array1_Handle_Adaptor3d_HSurface
except NameError:
	pass # does not exist, probably ignored

class Approx_SweepApproximation(object):
    """
    Approximation  of  an  Surface   S(u,v)
    (and eventually associate  2d Curves) defined
    by section's law.

    This surface is defined by a function F(u, v)
    where Ft(u) = F(u, t) is a bspline curve.
    To use this algorithme, you  have to implement Ft(u)
    as a derivative class  of Approx_SweepFunction.
    This algorithm can be used by blending, sweeping...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_SweepApproximation self, Handle_Approx_SweepFunction Func) -> Approx_SweepApproximation

        :type Func: OCC.wrapper.Approx.Handle_Approx_SweepFunction

        """
        this = _Approx.new_Approx_SweepApproximation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Approx_SweepApproximation self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol3d, Standard_Real const BoundTol, Standard_Real const Tol2d, Standard_Real const TolAngular, GeomAbs_Shape const Continuity=GeomAbs_C0, Standard_Integer const Degmax=11, Standard_Integer const Segmax=50)

        Perform the Approximation
        [First, Last] : Approx_SweepApproximation.cdl
        Tol3d : Tolerance to surface approximation
        Tol2d : Tolerance used to perform curve approximation
        Normaly the 2d curve are approximated with a
        tolerance given by the resolution on support surfaces,
        but if this tolerance is too large Tol2d is used.
        TolAngular : Tolerance (in radian) to control the angle
        beetween tangents on the section law and
        tangent of iso-v on approximed surface
        Continuity : The continuity in v waiting on the surface
        Degmax     : The maximum degree in v requiered on the surface
        Segmax     : The maximum number of span in v requiered on
        the surface
        Warning : The continuity ci can be obtained only if Ft is Ci

        :type First: float
        :type Last: float
        :type Tol3d: float
        :type BoundTol: float
        :type Tol2d: float
        :type TolAngular: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Degmax: int
        :type Segmax: int

        """
        return _Approx.Approx_SweepApproximation_Perform(self, *args)


    def Eval(self, *args):
        """
        Eval(Approx_SweepApproximation self, Standard_Real const Parameter, Standard_Integer const DerivativeRequest, Standard_Real const First, Standard_Real const Last) -> Standard_Integer

        The EvaluatorFunction from AdvApprox;

        :type Parameter: float
        :type DerivativeRequest: int
        :type First: float
        :type Last: float
        :type Result: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepApproximation_Eval(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Approx_SweepApproximation self) -> Standard_Boolean

        returns if we have an result

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_SweepApproximation_IsDone(self, *args)


    def SurfShape(self, *args):
        """
        SurfShape(Approx_SweepApproximation self)

        :type UDegree: int
        :type VDegree: int
        :type NbUPoles: int
        :type NbVPoles: int
        :type NbUKnots: int
        :type NbVKnots: int

        """
        return _Approx.Approx_SweepApproximation_SurfShape(self, *args)


    def Surface(self, *args):
        """
        Surface(Approx_SweepApproximation self, NCollection_Array2_gp_Pnt TPoles, NCollection_Array2_Standard_Real TWeights, NCollection_Array1_Standard_Real TUKnots, NCollection_Array1_Standard_Real TVKnots, NCollection_Array1_Standard_Integer TUMults, NCollection_Array1_Standard_Integer TVMults)

        :type TPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type TWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type TUKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TVKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TUMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type TVMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_Surface(self, *args)


    def UDegree(self, *args):
        """
        UDegree(Approx_SweepApproximation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepApproximation_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(Approx_SweepApproximation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepApproximation_VDegree(self, *args)


    def SurfPoles(self, *args):
        """
        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _Approx.Approx_SweepApproximation_SurfPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfWeights(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _Approx.Approx_SweepApproximation_SurfWeights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Approx.Approx_SweepApproximation_SurfUKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Approx.Approx_SweepApproximation_SurfVKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Approx.Approx_SweepApproximation_SurfUMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Approx.Approx_SweepApproximation_SurfVMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MaxErrorOnSurf(self, *args):
        """
        MaxErrorOnSurf(Approx_SweepApproximation self) -> Standard_Real

        returns the maximum error in the suface approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SweepApproximation_MaxErrorOnSurf(self, *args)


    def AverageErrorOnSurf(self, *args):
        """
        AverageErrorOnSurf(Approx_SweepApproximation self) -> Standard_Real

        returns the average error in the suface approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SweepApproximation_AverageErrorOnSurf(self, *args)


    def NbCurves2d(self, *args):
        """
        NbCurves2d(Approx_SweepApproximation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepApproximation_NbCurves2d(self, *args)


    def Curves2dShape(self, *args):
        """
        Curves2dShape(Approx_SweepApproximation self)

        :type Degree: int
        :type NbPoles: int
        :type NbKnots: int

        """
        return _Approx.Approx_SweepApproximation_Curves2dShape(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(Approx_SweepApproximation self, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d TPoles, NCollection_Array1_Standard_Real TKnots, NCollection_Array1_Standard_Integer TMults)

        :type Index: int
        :type TPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_Curve2d(self, *args)


    def Curves2dDegree(self, *args):
        """
        Curves2dDegree(Approx_SweepApproximation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_SweepApproximation_Curves2dDegree(self, *args)


    def Curve2dPoles(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Approx.Approx_SweepApproximation_Curve2dPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Approx.Approx_SweepApproximation_Curves2dKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Approx.Approx_SweepApproximation_Curves2dMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Max2dError(self, *args):
        """
        Max2dError(Approx_SweepApproximation self, Standard_Integer const Index) -> Standard_Real

        returns the maximum error of the <Index>
        2d curve approximation.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SweepApproximation_Max2dError(self, *args)


    def Average2dError(self, *args):
        """
        Average2dError(Approx_SweepApproximation self, Standard_Integer const Index) -> Standard_Real

        returns the average error of the <Index>
        2d curve approximation.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SweepApproximation_Average2dError(self, *args)


    def TolCurveOnSurf(self, *args):
        """
        TolCurveOnSurf(Approx_SweepApproximation self, Standard_Integer const Index) -> Standard_Real

        returns the  maximum 3d  error  of the  <Index>
        2d curve approximation on the Surface.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Approx_SweepApproximation_TolCurveOnSurf(self, *args)


    def Dump(self, *args):
        """
        Dump(Approx_SweepApproximation self, Standard_OStream & o)

        display information on approximation.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _Approx.Approx_SweepApproximation_Dump(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_SweepApproximation
Approx_SweepApproximation_swigregister = _Approx.Approx_SweepApproximation_swigregister
Approx_SweepApproximation_swigregister(Approx_SweepApproximation)

class NCollection_Sequence_Handle_TColStd_HArray1OfReal(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> NCollection_Sequence< opencascade::handle< TColStd_HArray1OfReal > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> NCollection_Sequence< opencascade::handle< TColStd_HArray1OfReal > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> NCollection_Sequence< opencascade::handle< TColStd_HArray1OfReal > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> NCollection_Sequence< opencascade::handle< TColStd_HArray1OfReal > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Approx.new_NCollection_Sequence_Handle_TColStd_HArray1OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TColStd_HArray1OfReal self)

        Reverse sequence


        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, NCollection_Sequence_Handle_TColStd_HArray1OfReal theOther) -> NCollection_Sequence_Handle_TColStd_HArray1OfReal

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, NCollection_Sequence_Handle_TColStd_HArray1OfReal theOther) -> NCollection_Sequence_Handle_TColStd_HArray1OfReal

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, NCollection_Sequence< opencascade::handle< TColStd_HArray1OfReal > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Handle_TColStd_HArray1OfReal theItem)
        Append(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, NCollection_Sequence_Handle_TColStd_HArray1OfReal theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Handle_TColStd_HArray1OfReal theItem)
        Prepend(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, NCollection_Sequence_Handle_TColStd_HArray1OfReal theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex, Handle_TColStd_HArray1OfReal theItem)
        InsertBefore(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TColStd_HArray1OfReal theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, NCollection_Sequence< opencascade::handle< TColStd_HArray1OfReal > >::Iterator & thePosition, Handle_TColStd_HArray1OfReal theItem)
        InsertAfter(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TColStd_HArray1OfReal theSeq)
        InsertAfter(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex, Handle_TColStd_HArray1OfReal theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TColStd_HArray1OfReal theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Handle_TColStd_HArray1OfReal

        First item access

        :rtype: TheItemType &

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TColStd_HArray1OfReal self) -> Handle_TColStd_HArray1OfReal

        Last item access

        :rtype: TheItemType &

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex) -> Handle_TColStd_HArray1OfReal

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TColStd_HArray1OfReal self, Standard_Integer const theIndex, Handle_TColStd_HArray1OfReal theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_SetValue(self, *args)


    def __iter__(self):
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal___iter__(self)
    __swig_destroy__ = _Approx.delete_NCollection_Sequence_Handle_TColStd_HArray1OfReal
NCollection_Sequence_Handle_TColStd_HArray1OfReal_swigregister = _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_swigregister
NCollection_Sequence_Handle_TColStd_HArray1OfReal_swigregister(NCollection_Sequence_Handle_TColStd_HArray1OfReal)

def NCollection_Sequence_Handle_TColStd_HArray1OfReal_delNode(*args):
    """
    NCollection_Sequence_Handle_TColStd_HArray1OfReal_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_delNode(*args)

class NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Approx.new_NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Approx.delete_NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper

    def __next__(self):
        return _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper_swigregister = _Approx.NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper_swigregister
NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper_swigregister(NCollection_Sequence_Handle_TColStd_HArray1OfReal_IteratorHelper)


try:
	Approx_SequenceOfHArray1OfReal = NCollection_Sequence_Handle_TColStd_HArray1OfReal
except NameError:
	pass # does not exist, probably ignored

class Handle_Approx_SweepFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Approx_SweepFunction self)

        Nullify the handle


        """
        return _Approx.Handle_Approx_SweepFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Approx_SweepFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Approx.Handle_Approx_SweepFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Approx_SweepFunction self, Approx_SweepFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Approx.Handle_Approx_SweepFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Approx_SweepFunction self, Handle_Approx_SweepFunction theHandle) -> Handle_Approx_SweepFunction
        assign(Handle_Approx_SweepFunction self, Approx_SweepFunction thePtr) -> Handle_Approx_SweepFunction
        assign(Handle_Approx_SweepFunction self, Handle_Approx_SweepFunction theHandle) -> Handle_Approx_SweepFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Approx.Handle_Approx_SweepFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Approx_SweepFunction self) -> Approx_SweepFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Approx.Handle_Approx_SweepFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Approx_SweepFunction self) -> Approx_SweepFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Approx.Handle_Approx_SweepFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Approx_SweepFunction self) -> Approx_SweepFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Approx.Handle_Approx_SweepFunction___ref__(self, *args)


    def __hash__(self):
        return _Approx.Handle_Approx_SweepFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Approx.Handle_Approx_SweepFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Approx.new_Handle_Approx_SweepFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Approx.Handle_Approx_SweepFunction_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_SweepFunction

    def D0(self, *args):
        """
        D0(Handle_Approx_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_SweepFunction_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Approx_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_SweepFunction_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Approx_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_SweepFunction_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_Approx_SweepFunction self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_SweepFunction_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_Approx_SweepFunction self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _Approx.Handle_Approx_SweepFunction_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_Approx_SweepFunction self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Approx.Handle_Approx_SweepFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_Approx_SweepFunction self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Approx.Handle_Approx_SweepFunction_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Approx_SweepFunction self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_SweepFunction_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Approx_SweepFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_SweepFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Approx_SweepFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Approx.Handle_Approx_SweepFunction_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_Approx_SweepFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _Approx.Handle_Approx_SweepFunction_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Approx_SweepFunction self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _Approx.Handle_Approx_SweepFunction_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_Approx_SweepFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to satisfy.
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Approx.Handle_Approx_SweepFunction_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_Approx_SweepFunction self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _Approx.Handle_Approx_SweepFunction_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_Approx_SweepFunction self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Approx.Handle_Approx_SweepFunction_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_Approx_SweepFunction self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Approx.Handle_Approx_SweepFunction_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_Approx_SweepFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Approx.Handle_Approx_SweepFunction_GetMinimalWeight(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Approx_SweepFunction self) -> char const *

        :rtype: const char *

        """
        return _Approx.Handle_Approx_SweepFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_SweepFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Approx.Handle_Approx_SweepFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Approx_SweepFunction self)

        Memory deallocator for transient classes


        """
        return _Approx.Handle_Approx_SweepFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Approx_SweepFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Approx_SweepFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_SweepFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Approx_SweepFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Approx_SweepFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Handle_Approx_SweepFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Approx_SweepFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Approx.Handle_Approx_SweepFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Approx_SweepFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_SweepFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Approx_SweepFunction self)

        Increments the reference counter of this object


        """
        return _Approx.Handle_Approx_SweepFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Approx_SweepFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Handle_Approx_SweepFunction_DecrementRefCounter(self, *args)

Handle_Approx_SweepFunction_swigregister = _Approx.Handle_Approx_SweepFunction_swigregister
Handle_Approx_SweepFunction_swigregister(Handle_Approx_SweepFunction)

def Handle_Approx_SweepFunction_DownCast(thing):
    return _Approx.Handle_Approx_SweepFunction_DownCast(thing)
Handle_Approx_SweepFunction_DownCast = _Approx.Handle_Approx_SweepFunction_DownCast

class Approx_FitAndDivide(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_FitAndDivide self, AppCont_Function Line, Standard_Integer const degreemin=3, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-5, Standard_Real const Tolerance2d=1.0e-5, Standard_Boolean const cutting, AppParCurves_Constraint const FirstC=AppParCurves_TangencyPoint, AppParCurves_Constraint const LastC=AppParCurves_TangencyPoint) -> Approx_FitAndDivide
        __init__(Approx_FitAndDivide self, Standard_Integer const degreemin=3, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-05, Standard_Real const Tolerance2d=1.0e-05, Standard_Boolean const cutting, AppParCurves_Constraint const FirstC=AppParCurves_TangencyPoint, AppParCurves_Constraint const LastC=AppParCurves_TangencyPoint) -> Approx_FitAndDivide

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type cutting: bool
        :type FirstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        this = _Approx.new_Approx_FitAndDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Approx_FitAndDivide self, AppCont_Function Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.AppCont.AppCont_Function

        """
        return _Approx.Approx_FitAndDivide_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(Approx_FitAndDivide self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _Approx.Approx_FitAndDivide_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(Approx_FitAndDivide self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _Approx.Approx_FitAndDivide_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(Approx_FitAndDivide self, AppParCurves_Constraint const FirstC, AppParCurves_Constraint const LastC)

        Changes the constraints of the approximation.

        :type FirstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _Approx.Approx_FitAndDivide_SetConstraints(self, *args)


    def SetMaxSegments(self, *args):
        """
        SetMaxSegments(Approx_FitAndDivide self, Standard_Integer const theMaxSegments)

        Changes the max number of segments, which is allowed for cutting.

        :type theMaxSegments: int

        """
        return _Approx.Approx_FitAndDivide_SetMaxSegments(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(Approx_FitAndDivide self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_FitAndDivide_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(Approx_FitAndDivide self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_FitAndDivide_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(Approx_FitAndDivide self, Standard_Integer const Index)

        returns the tolerances 2d and 3d of the <Index> MultiCurve.

        :type Index: int
        :type tol3d: float
        :type tol2d: float

        """
        return _Approx.Approx_FitAndDivide_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(Approx_FitAndDivide self) -> Standard_Integer

        Returns the number of MultiCurve doing the approximation
        of the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_FitAndDivide_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        Value(Approx_FitAndDivide self, Standard_Integer const Index=1) -> AppParCurves_MultiCurve

        returns the approximation MultiCurve of range <Index>.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _Approx.Approx_FitAndDivide_Value(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Approx_FitAndDivide self, Standard_Integer const Index)

        :type Index: int
        :type firstp: float
        :type lastp: float

        """
        return _Approx.Approx_FitAndDivide_Parameters(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_FitAndDivide
Approx_FitAndDivide_swigregister = _Approx.Approx_FitAndDivide_swigregister
Approx_FitAndDivide_swigregister(Approx_FitAndDivide)

class Approx_FitAndDivide2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Approx_FitAndDivide2d self, AppCont_Function Line, Standard_Integer const degreemin=3, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-5, Standard_Real const Tolerance2d=1.0e-5, Standard_Boolean const cutting, AppParCurves_Constraint const FirstC=AppParCurves_TangencyPoint, AppParCurves_Constraint const LastC=AppParCurves_TangencyPoint) -> Approx_FitAndDivide2d
        __init__(Approx_FitAndDivide2d self, Standard_Integer const degreemin=3, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-05, Standard_Real const Tolerance2d=1.0e-05, Standard_Boolean const cutting, AppParCurves_Constraint const FirstC=AppParCurves_TangencyPoint, AppParCurves_Constraint const LastC=AppParCurves_TangencyPoint) -> Approx_FitAndDivide2d

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type cutting: bool
        :type FirstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        this = _Approx.new_Approx_FitAndDivide2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Approx_FitAndDivide2d self, AppCont_Function Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.AppCont.AppCont_Function

        """
        return _Approx.Approx_FitAndDivide2d_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(Approx_FitAndDivide2d self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _Approx.Approx_FitAndDivide2d_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(Approx_FitAndDivide2d self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _Approx.Approx_FitAndDivide2d_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(Approx_FitAndDivide2d self, AppParCurves_Constraint const FirstC, AppParCurves_Constraint const LastC)

        Changes the constraints of the approximation.

        :type FirstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _Approx.Approx_FitAndDivide2d_SetConstraints(self, *args)


    def SetMaxSegments(self, *args):
        """
        SetMaxSegments(Approx_FitAndDivide2d self, Standard_Integer const theMaxSegments)

        Changes the max number of segments, which is allowed for cutting.

        :type theMaxSegments: int

        """
        return _Approx.Approx_FitAndDivide2d_SetMaxSegments(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(Approx_FitAndDivide2d self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_FitAndDivide2d_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(Approx_FitAndDivide2d self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Approx.Approx_FitAndDivide2d_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(Approx_FitAndDivide2d self, Standard_Integer const Index)

        returns the tolerances 2d and 3d of the <Index> MultiCurve.

        :type Index: int
        :type tol3d: float
        :type tol2d: float

        """
        return _Approx.Approx_FitAndDivide2d_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(Approx_FitAndDivide2d self) -> Standard_Integer

        Returns the number of MultiCurve doing the approximation
        of the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Approx.Approx_FitAndDivide2d_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        Value(Approx_FitAndDivide2d self, Standard_Integer const Index=1) -> AppParCurves_MultiCurve

        returns the approximation MultiCurve of range <Index>.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _Approx.Approx_FitAndDivide2d_Value(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Approx_FitAndDivide2d self, Standard_Integer const Index)

        :type Index: int
        :type firstp: float
        :type lastp: float

        """
        return _Approx.Approx_FitAndDivide2d_Parameters(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_FitAndDivide2d
Approx_FitAndDivide2d_swigregister = _Approx.Approx_FitAndDivide2d_swigregister
Approx_FitAndDivide2d_swigregister(Approx_FitAndDivide2d)

class Approx_MCurvesToBSpCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(Approx_MCurvesToBSpCurve self) -> Approx_MCurvesToBSpCurve"""
        this = _Approx.new_Approx_MCurvesToBSpCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """Reset(Approx_MCurvesToBSpCurve self)"""
        return _Approx.Approx_MCurvesToBSpCurve_Reset(self, *args)


    def Append(self, *args):
        """
        Append(Approx_MCurvesToBSpCurve self, AppParCurves_MultiCurve MC)

        :type MC: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _Approx.Approx_MCurvesToBSpCurve_Append(self, *args)


    def Perform(self, *args):
        """
        Perform(Approx_MCurvesToBSpCurve self)
        Perform(Approx_MCurvesToBSpCurve self, NCollection_Sequence_AppParCurves_MultiCurve TheSeq)

        :type TheSeq: OCC.wrapper.AppParCurves.AppParCurves_SequenceOfMultiCurve

        """
        return _Approx.Approx_MCurvesToBSpCurve_Perform(self, *args)


    def Value(self, *args):
        """
        return the composite MultiCurves as a MultiBSpCurve.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _Approx.Approx_MCurvesToBSpCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        return the composite MultiCurves as a MultiBSpCurve.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _Approx.Approx_MCurvesToBSpCurve_ChangeValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Approx.delete_Approx_MCurvesToBSpCurve
Approx_MCurvesToBSpCurve_swigregister = _Approx.Approx_MCurvesToBSpCurve_swigregister
Approx_MCurvesToBSpCurve_swigregister(Approx_MCurvesToBSpCurve)



